Sys.ns("Core");
Core.StateHandler = {
	constructor: function() {
		var a = this;
		Core.StateHandler.superclass.constructor.apply(a, arguments);
		a.useLogging = false;
		a.states = window.GenericStates || {};
		a.stateStack = [];
		a.runningStateMachine = false
	},
	registerEvents: function(c) {
		var d = this,
			b = c.length,
			a;
		if (Sys.isArray(c)) {
			for (a = -1; ++a < b;) {
				d.addListener(c[a], d.onDefaultEventHandler.bind(d, c[a]))
			}
		} else {
			if (Sys.isString(c)) {
				d.addListener(c, d.onDefaultEventHandler.bind(d, c))
			}
		}
	},
	onDefaultEventHandler: function(a) {
		this.dispatchEvent(a);
		this.activateStateMachine()
	},
	initStateHandler: function() {
		var b = this,
			a;
		Sys.iterate(window.GenericStates || {}, function(c, d) {
			b._registerTrigger(d)
		});
		EventHandler.sortEventListeners(this);
		a = Resources.readData("gameServerInitResponse");
		if (a.restore !== true) {
			this.pushState(this.states.idle)
		}
		this.pushState(this.states.beforeLoaderClose);
		this.pushState(this.states.setupGame);
		this.activateStateMachine()
	},
	activateStateMachine: function() {
		var a = this,
			b;
		if (a.runningStateMachine) {
			return
		}
		a.runningStateMachine = true;
		while (a.hasStatesInStack()) {
			if (!Sys.isEmpty(a.currentState)) {
				for (b in a.currentState.waitEvents) {
					if (a.currentState.waitEvents.hasOwnProperty(b) && !a.currentState.waitEvents[b]) {
						a.runningStateMachine = false;
						return
					}
				}
				setTimeout(a.leaveCurrentState.bind(a), 1);
				return
			}
			a.currentState = a.stateStack.pop();
			a.currentState.execute({
				stateHandler: a,
				states: a.states
			});
			a.processModuleQueue();
			if (Sys.isDefined(a.currentState.executeLast)) {
				a.currentState.executeLast({
					stateHandler: a,
					states: a.states
				})
			}
			a.fireEvent("notify:stateHandler.entering" + a.currentState.name + "State")
		}
		a.runningStateMachine = false
	},
	leaveCurrentState: function() {
		var a = this;
		a.fireEvent("notify:stateHandler.leaving" + a.currentState.name + "State");
		a.currentState = undefined;
		a.runningStateMachine = false;
		a.activateStateMachine()
	},
	processModuleQueue: function() {
		var c = this,
			a = Game.moduleLoader.getModuleQueueForState(c.currentState.name),
			d = a.length,
			b;
		for (b = 0; b < d; b++) {
			a[b]({
				stateHandler: c,
				states: c.states
			})
		}
	},
	addState: function(a, b) {
		if (!Sys.isDefined(this.states[a])) {
			this.states[a] = b;
			this._registerTrigger(b)
		}
	},
	_registerTrigger: function(a) {
		if (Sys.isDefined(Services.trigger)) {
			Services.trigger.registerTrigger("notify:stateHandler.entering" + a.name + "State", this, "When entering the state " + a.name);
			Services.trigger.registerTrigger("notify:stateHandler.leaving" + a.name + "State", this, "When leaving the state " + a.name)
		}
	},
	pushState: function(a) {
		var b;
		if (this.stateStack.indexOf(a) > -1) {
			return
		}
		for (b in a.waitEvents) {
			if (a.waitEvents.hasOwnProperty(b)) {
				a.waitEvents[b] = false
			}
		}
		this.stateStack.push(a)
	},
	dispatchEvent: function(b) {
		var a = this;
		if (!Sys.isEmpty(a.currentState) && !Sys.isEmpty(a.currentState.waitEvents[b])) {
			a.currentState.waitEvents[b] = true
		}
		Sys.each(a.stateStack, function(c) {
			if (!Sys.isEmpty(c.waitEvents[b])) {
				c.waitEvents[b] = true
			}
		})
	},
	dumpStack: function(d) {
		var c = this,
			f = "",
			e, a, b;
		if (c.useLogging) {
			if (!this.currentState) {} else {
				e = d;
				Sys.each(Object.getOwnPropertyNames(this.currentState.waitEvents), function(g) {
					a = c.currentState.waitEvents[g] ? "*" : " ";
					f += "\n\t\t(" + a + ") " + g.replace(/\s/g, "")
				});
				e += "\nCurrent state:\t" + this.currentState.name + f;
				for (b = this.stateStack.length - 1; b >= 0; b--) {
					e += "\n\t" + this.stateStack[b].name
				}
			}
		}
	},
	hasStates: function() {
		return Object.keys(this.states).length > 0
	},
	hasStatesInStack: function() {
		return this.stateStack.length > 0
	},
	isRunning: function() {
		return this.runningStateMachine
	}
};
Core.StateHandler = Sys.extend(Sys.Observable, Core.StateHandler, "Core.StateHandler");
window.GenericStates = {
	beforeLoaderClose: {
		name: "BeforeLoaderClose",
		execute: function() {},
		waitEvents: {}
	},
	setupGame: {
		name: "SetupGame",
		execute: function() {},
		waitEvents: {}
	},
	idle: {
		name: "Idle",
		execute: function(a) {},
		waitEvents: {}
	}
};
Sys.ns("Core");
Core.ModuleLoader = {
	constructor: function(a) {
		Core.ModuleLoader.superclass.constructor.apply(this, arguments);
		this.init(a)
	},
	getModuleQueueForState: function(b) {
		var a = this.stateOrder[b];
		if (Sys.isDefined(a)) {
			return a
		}
		return []
	},
	init: function(a) {
		var c = this,
			b = Resources.readData("modules");
		c.stateHandler = a.stateHandler;
		c.stateOrder = c.getCommonStateOrder();
		c.addGameSpecificStateOrder();
		c.loadModules(b);
		c.updateStates();
		c.cleanStateQueue();
		c.fireEvent("notify:moduleLoader.finishedLoadingModules")
	},
	loadModules: function(d) {
		var c = this,
			e = Environment.getCurrentPlatform(),
			b, a;
		c.modules = {};
		Sys.iterate(d, function(g, f) {
			b = (Sys.isArray(f.platforms) && f.platforms.indexOf(e) === -1);
			if (!Sys.isDefined(c.modules[g]) && !b) {
				a = c.getClassFromString(f.module);
				if (!Sys.isDefined(a) && f.optional === true) {
					return
				}
				c.modules[g] = new a({
					name: g,
					model: c.getPlatformSpecificClass(f.model),
					view: c.getPlatformSpecificClass(f.view),
					controller: c.getClassFromString(f.controller)
				});
				if (Sys.isString(f.global)) {
					if (!Sys.isDefined(window[f.global])) {
						window[f.global] = {}
					}
					window[f.global][g] = c.modules[g].controller
				}
				c.applyMixins(c.modules[g], c.combineMixins(c.modules[g].getMixinDependencies(), f.mixins))
			}
		})
	},
	combineMixins: function(b, g) {
		var f = {},
			j, a, h, d, e, c, k = Environment.getCurrentPlatform();
		if (Sys.isArray(b)) {
			e = b;
			c = b.length
		} else {
			e = (b.hasOwnProperty(k)) ? b[k] : b.fallback;
			c = e.length
		}
		for (d = -1; ++d < c;) {
			j = e[d];
			if (Sys.isObj(j)) {
				h = Object.keys(j)[0];
				a = j[h];
				f[h] = a
			} else {
				if (Sys.isString(j)) {
					f[j] = undefined
				}
			}
		}
		if (Sys.isArray(g)) {
			c = g.length;
			for (d = -1; ++d < c;) {
				j = g[d];
				if (!Sys.isDefined(f[j])) {
					f[j] = undefined
				}
			}
		}
		return f
	},
	applyMixins: function(a, h) {
		var d = ["controller", "model", "view"],
			n = Object.keys(h),
			g = n.length,
			c = d.length,
			m, k, b, l, f, e;
		for (f = -1; ++f < g;) {
			l = n[f];
			b = h[l] || {};
			m = Mixins[l];
			if (Sys.isDefined(m)) {
				for (e = -1; ++e < c;) {
					k = d[e];
					if (Sys.isDefined(m[k]) && Sys.isDefined(a[k]) && Sys.isDefined(m[k].methods)) {
						this.applyMixinProperties(a[k], m[k].methods)
					}
				}
				for (e = -1; ++e < c;) {
					k = d[e];
					if (Sys.isDefined(m[k]) && Sys.isDefined(a[k]) && Sys.isDefined(m[k].executeOnInstantiation)) {
						this.executeMixinProperties(a[k], m[k].executeOnInstantiation, b)
					}
				}
			}
		}
	},
	applyMixinProperties: function(f, a) {
		var d = Object.keys(a),
			e = d.length,
			c, b = 0;
		while (b < e) {
			c = d[b];
			if (!Sys.isDefined(f[c])) {
				f[c] = a[c]
			}++b
		}
	},
	executeMixinProperties: function(f, c, d) {
		var b = Object.keys(c),
			a = b.length,
			e = 0;
		while (e < a) {
			c[b[e]].call(f, d);
			++e
		}
	},
	updateStates: function() {
		var b = this,
			a = b.modules,
			c = b.stateHandler.states;
		b.moduleQueues = {};
		Sys.iterate(a, function(d, f) {
			var e = f.getStateChanges();
			Sys.iterate(e, function(j, h) {
				var g = [];
				if (Sys.isDefined(h.state)) {
					b.stateHandler.addState(j, h.state);
					Sys.iterate(h.state.waitEvents, function(k) {
						g.push(k)
					});
					if (g.length > 0) {
						b.registerListenersOnStateHandler(f.controller, g)
					}
				}
			})
		});
		Sys.iterate(a, function(d, f) {
			var e = f.getStateChanges();
			Sys.iterate(e, function(h, g) {
				if (!Sys.isDefined(g.state) && Sys.isDefined(c[h])) {
					if (Sys.isArray(g.waitEvents)) {
						Sys.each(g.waitEvents, function(j) {
							c[h].waitEvents[j] = false
						});
						b.registerListenersOnStateHandler(f.controller, g.waitEvents)
					}
					if (Sys.isArray(g.queue)) {
						b.updateModuleQueue(d, c[h].name, g.queue)
					}
				}
			})
		})
	},
	registerListenersOnStateHandler: function(d, c) {
		var b = c.length,
			a;
		for (a = -1; ++a < b;) {
			if (!this.stateHandler.hasListener(c[a])) {
				this.stateHandler.registerEvents(c[a])
			}
		}
	},
	updateModuleQueue: function(c, e, a) {
		var d = this.stateOrder[e],
			b;
		if (Sys.isDefined(d)) {
			b = d.indexOf(c);
			if (b >= 0) {
				d.splice.apply(d, [b, 1].concat(a));
				this.stateOrder[e] = d
			} else {}
		} else {}
	},
	cleanStateQueue: function() {
		var a = this;
		Sys.iterate(a.stateOrder, function(d, b) {
			var c;
			for (c = 0; c < b.length; c++) {
				if (Sys.isString(b[c]) || !Sys.isDefined(b[c])) {
					b.splice(c, 1);
					c--
				}
			}
		})
	},
	addGameSpecificStateOrder: function() {
		var d = this,
			c = d.stateOrder,
			b = Resources.readData("config"),
			a = b.stateOrder;
		if (Sys.isDefined(a)) {
			Sys.iterate(a, function(f, e) {
				Sys.each(e, function(h) {
					var g;
					if (!Sys.isDefined(c[f])) {
						c[f] = h.modules
					} else {
						if (Sys.isDefined(h.insertBefore)) {
							g = c[f].indexOf(h.insertBefore) + 1;
							if (g < 0) {
								c[f] = h.modules.concat(c[f])
							} else {
								c[f].splice.apply(c[f], [g, 0].concat(h.modules))
							}
						} else {
							c[f].push.apply(c[f], h.modules)
						}
					}
				})
			})
		}
	},
	getClassFromString: function(c) {
		var d, b, a, e;
		if (Sys.isString(c)) {
			d = c.split(".");
			b = window;
			e = d.length;
			for (a = 0; a < e; a++) {
				if (Sys.isDefined(b)) {
					b = b[d[a]]
				}
			}
			return b
		}
		return undefined
	},
	getPlatformSpecificClass: function(c) {
		var b = this,
			a = c;
		if (Sys.isObj(a)) {
			if (b.isMVCSupported(a)) {
				a = b.getPlatformView(a)
			} else {}
		}
		return b.getClassFromString(a)
	},
	isMVCSupported: function(b) {
		var c = Environment.getSupportedPlatforms(),
			a = true;
		Sys.iterate(b, function(e, d) {
			if (c.indexOf(e) < 0) {
				a = false
			}
		});
		return a
	},
	getPlatformView: function(a) {
		var b = Environment.getCurrentPlatform();
		if (b === "desktop" && !Sys.isDefined(a[b])) {
			b = "tablet"
		}
		if (b === "tablet" && !Sys.isDefined(a[b])) {
			b = "mobile"
		}
		if (b === "tabletLow" && !Sys.isDefined(a[b])) {
			b = "mobileLow"
		}
		if (b === "mobileLow" && !Sys.isDefined(a[b])) {
			b = "mobile"
		}
		return a[b]
	},
	getCommonStateOrder: function() {
		return {
			BeforeLoaderClose: ["stage"],
			Idle: ["playForRealPromo"]
		}
	}
};
Core.ModuleLoader = Sys.extend(Sys.Observable, Core.ModuleLoader, "Core.ModuleLoader");
Sys.ns("Core.Slots");
Core.Slots.ModuleLoader = {
	constructor: function(a) {
		Core.Slots.ModuleLoader.superclass.constructor.apply(this, arguments)
	},
	getCommonStateOrder: function() {
		return {
			SetupGame: ["blurredSymbols"],
			BeforeLoaderClose: ["freeSpinOutro", "spinTypeFreespin", "spinTypeRespin", "countDownFreespins", "freeSpinIntro", "freeRounds", "introMovie", "stage"],
			Idle: ["spin", "playForRealPromo", "customMessages"],
			Spinning: ["serverManager"],
			ProcessServerResponse: [],
			BeforeStopping: ["customMessages"],
			Stopping: ["spin"],
			Stopped: ["spinTypeRespin", "spinTypeBasic", "realityCheck", "autoPlayer", "freeSpinOutro", "spinTypeFreespin", "g4", "freeSpinIntro", "freeSpinIntroMovie", "countDownFreespins", "additionalFreespins", "standardWin", "bigWin", "freeSpinSymbolAttentionAnimation", "stickySymbols", "spreadingWild"],
			FreeSpinIntro: ["freeRounds"],
			spinTypeRespinRestore: ["freeRounds"],
			NoWinPresentation: ["customMessages"]
		}
	}
};
Core.Slots.ModuleLoader = Sys.extend(Core.ModuleLoader, Core.Slots.ModuleLoader, "Core.Slots.ModuleLoader");
Sys.ns("Core");
Core.Heart = {
	constructor: function(a) {
		var b = this;
		Core.Heart.superclass.constructor.apply(b, arguments);
		b.pulse = 5000;
		b.pulseDelay = 1000;
		b.timeOutDelay = 2000;
		if (Sys.isDefined(a)) {
			b.pulse = a.pulse || b.pulse;
			b.pulseDelay = a.pulseDelay || b.pulseDelay
		}
		b.lastBeat = 0;
		b.flatlined = false;
		b.on({
			scope: b,
			"notify:loader.closed": b.init
		})
	},
	init: function() {
		this.revive()
	},
	flatline: function() {
		this.flatlined = true;
		clearTimeout(this.currentBeatTimeout)
	},
	revive: function() {
		this.flatlined = false;
		this.lastBeat = Date.now();
		this.beat()
	},
	beat: function() {
		var b = this,
			a = Date.now();
		if ((a - b.lastBeat) >= (b.pulse + b.pulseDelay)) {
			b.fireEvent("request:errorManager.handleGameInactive");
			this.flatline()
		}
		b.lastBeat = a;
		if (!b.flatlined) {
			clearTimeout(b.currentBeatTimeout);
			b.currentBeatTimeout = setTimeout(function() {
				b.beat()
			}, b.timeOutDelay)
		}
	}
};
Core.Heart = Sys.extend(Sys.Observable, Core.Heart, "Core.Heart");
Sys.ns("Mixins");
Mixins.animation = {
	controller: {
		methods: {
			initAnimations: function() {
				this.view.initAnimations()
			}
		},
		executeOnInstantiation: {
			setupEvents: function() {
				this.on({
					"notify:animationManager.allImagesLoaded": this.initAnimations
				})
			}
		}
	},
	view: {
		methods: {
			initAnimations: function() {}
		}
	}
};
Sys.ns("Mixins");
Mixins.orientation = {
	controller: {
		methods: {
			onPortrait: function() {
				this.view.onPortrait()
			},
			onLandscape: function() {
				this.view.onLandscape()
			}
		},
		executeOnInstantiation: {
			setupEvents: function() {
				this.on({
					"notify:viewport.PORTRAIT": this.onPortrait,
					"notify:viewport.LANDSCAPE": this.onLandscape
				})
			}
		}
	},
	view: {
		methods: {
			onPortrait: function() {
				this.adaptToOrientation("PORTRAIT");
				this.currentOrientation = "PORTRAIT"
			},
			onLandscape: function() {
				this.adaptToOrientation("LANDSCAPE");
				this.currentOrientation = "LANDSCAPE"
			},
			adaptToOrientation: function(a) {
				this.setSize(a);
				this.setPosition(a);
				this.setStyle(a)
			},
			setSize: function(c) {
				var f = this,
					a = f.container,
					g = Sys.isDefined(a) ? a.el.style : undefined,
					k = f[c + "_SIZE"],
					d, h, l = 0,
					e = 0,
					j, b;
				if (!Sys.isDefined(k) || !Sys.isDefined(a)) {
					return
				}
				d = k.RELATIVE_SCREEN ? Environment.getInnerScreenSize() : Environment.getResolution();
				h = k.RELATIVE_SCREEN ? 1 / Environment.getScale() : 1;
				if (Sys.isDefined(k.HEIGHT)) {
					j = Math.round(d.height * k.HEIGHT * h);
					b = Sys.isDefined(k.WIDTH) ? Math.round(d.width * k.WIDTH * h) : Math.round(j * k.ASPECT_RATIO)
				} else {
					b = Math.round(d.width * k.WIDTH * h);
					j = Math.round(b / k.ASPECT_RATIO)
				}
				if (k.VERTICAL_OFFSET === "bottom") {
					l = "-" + j + "px"
				} else {
					if (k.VERTICAL_OFFSET === "center") {
						l = "-" + Math.round(j / 2) + "px"
					}
				}
				if (k.HORIZONTAL_OFFSET === "right") {
					e = "-" + b + "px"
				} else {
					if (k.HORIZONTAL_OFFSET === "center") {
						e = "-" + Math.round(b / 2) + "px"
					}
				}
				g.width = b + "px";
				g.height = j + "px";
				g.backgroundSize = b + "px " + j + "px";
				g.margin = l + " 0 0 " + e
			},
			setPosition: function(c) {
				var h = this,
					e = h[c + "_POSITION"],
					k, j, f, b, g, d, a;
				if (!Sys.isDefined(e) || !Sys.isDefined(h.container)) {
					return
				}
				k = h.container.el.style;
				if (Sys.isDefined(e.BOTTOM)) {
					f = "BOTTOM";
					b = "top";
					a = "getBottom"
				} else {
					f = "TOP";
					b = "bottom";
					a = "getTop"
				}
				if (Sys.isDefined(e.RIGHT)) {
					g = "RIGHT";
					d = "left"
				} else {
					g = "LEFT";
					d = "right"
				}
				if (e.BELOW_GAME) {
					j = Environment[a + "BelowGame"](e[f])
				} else {
					if (e.ABOVE_GAME) {
						j = Environment[a + "AboveGame"](e[f])
					} else {
						j = Environment[a + "InGame"](e[f])
					}
				}
				if (e["MIN_" + f]) {
					j = Math.max(e["MIN_" + f], j)
				}
				k[f.toLowerCase()] = j + "px";
				k[b] = "auto";
				k[g.toLowerCase()] = (100 * e[g]) + "%";
				k[d] = "auto"
			},
			setStyle: function(a) {
				var c = this,
					d = a + "_CSS",
					b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
				if (Sys.isDefined(c[d])) {
					c.container.removeCls(c[b]);
					c.container.addCls(c[d])
				}
			}
		}
	}
};
Sys.applyProperties(Mixins.orientation.view.methods, {
	setStyle: function(a) {
		var c = this,
			d = a + "_CSS",
			b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
		if (Sys.isDefined(c.container) && Sys.isDefined(c[d])) {
			c.container.removeCls(c[b]);
			c.container.addCls(c[d])
		}
	}
});
Sys.ns("Mixins");
Mixins.userInput = {
	controller: {
		methods: {
			startListeningToUserInput: function() {
				this.on(this.USED_INPUT_HANDLERS);
				this.isListeningToUserInput = true
			},
			stopListeningToUserInput: function() {
				var a = this;
				Sys.iterate(a.USED_INPUT_HANDLERS, a.removeListener.bind(a));
				a.isListeningToUserInput = false
			},
			onUserInputStart: function() {},
			onUserInputEnd: function() {},
			onUserInputMove: function() {},
			onUserInputHover: function() {},
			onUserInputCanceled: function() {},
			onUserInputScroll: function() {},
			onUserInputKeyUp: function() {},
			onUserInputKeyDown: function() {},
			isUserInputInSegment: function(b, a) {
				Sys.UserInputUtils.isUserInputInSegment(b, a)
			}
		},
		executeOnInstantiation: {
			init: function(c) {
				var d = this,
					e = Sys.isDefined(c.inputEvents) ? c.inputEvents : ["start", "end", "cancel", "move"],
					a = {},
					b;
				for (b = 0; b < e.length; b++) {
					switch (e[b]) {
						case "start":
							a["notify:userInputManager.userInputStarted"] = d.onUserInputStart;
							break;
						case "end":
							a["notify:userInputManager.userInputEnded"] = d.onUserInputEnd;
							break;
						case "move":
							a["notify:userInputManager.userInputMove"] = d.onUserInputMove;
							break;
						case "hover":
							a["notify:userInputManager.userInputHover"] = d.onUserInputHover;
							break;
						case "cancel":
							a["notify:userInputManager.userInputCanceled"] = d.onUserInputCanceled;
							break;
						case "scroll":
							a["notify:userInputManager.userInputScroll"] = d.onUserInputScroll;
							break;
						case "keyUp":
							a["notify:userInputManager.userInputKeyUp"] = d.onUserInputKeyUp;
							break;
						case "keyDown":
							a["notify:userInputManager.userInputKeyDown"] = d.onUserInputKeyDown;
							break;
						default:
					}
				}
				d.USED_INPUT_HANDLERS = a;
				if (c.listenToUserInput) {
					d.startListeningToUserInput()
				}
			}
		}
	}
};
Sys.ns("Mixins");
Mixins.serverResponse = {
	controller: {
		methods: {
			onServerResponse: function(a) {
				this.model.processServerResponse(a)
			}
		},
		executeOnInstantiation: {
			setupEvents: function() {
				this.on({
					"notify:responseParser.responseParsed": this.onServerResponse
				})
			}
		}
	},
	model: {
		methods: {
			processServerResponse: function(a) {}
		}
	}
};
Sys.ns("Mixins");
Mixins.waitSequence = {
	controller: {
		methods: {
			initializeWaitSequence: function(c, a) {
				var b = this;
				b.clearWaitSequence();
				b.waiting = true;
				if (Sys.isDefined(c)) {
					b.fireEvent(c, a);
					b.checkForCompletion()
				}
			},
			clearWaitSequence: function() {
				var a = this;
				Sys.each(a.eventsToWaitFor, a.removeWaitEventListener.bind(a));
				a.eventsToWaitFor.length = 0;
				a.waiting = false
			},
			removeWaitEventListener: function(a) {
				if (Sys.isDefined(this.customListeners[a])) {
					this.removeListener(a);
					delete this.customListeners[a]
				}
			},
			checkForCompletion: function() {
				if (this.eventsToWaitFor.length === 0) {
					this.onWaitIsComplete();
					this.waiting = false
				}
			},
			onWaitRequested: function(a) {
				var b = this,
					c;
				if (b.waiting && !b.eventsToWaitFor.contains(a)) {
					if (!Sys.isDefined(b.events[a]) && !Sys.isDefined(b.handlers[a])) {
						c = b.onWaitEventReceived.bind(b, a);
						b.addListener(a, c, b);
						b.customListeners[a] = c
					}
					b.eventsToWaitFor.push(a)
				}
			},
			onWaitEventReceived: function(a) {
				var c = this,
					b = c.eventsToWaitFor.indexOf(a);
				if (b >= 0) {
					c.eventsToWaitFor.splice(b, 1);
					c.removeWaitEventListener(a)
				}
				c.checkForCompletion()
			},
			onWaitIsComplete: function() {}
		},
		executeOnInstantiation: {
			initialize: function() {
				var a = this;
				a.eventsToWaitFor = [];
				a.waiting = false;
				a.customListeners = {};
				if (!Sys.isDefined(a.events)) {
					a.events = {}
				}
			}
		}
	}
};
Sys.ns("Mixins");
Mixins.properties = {
	model: {
		methods: {
			hasProperty: function(b) {
				var a = this.readData("properties")[b];
				return Sys.isDefined(a) && a.length > 0
			},
			addProperty: function(c, b) {
				var a = this.readData("properties");
				if (!Sys.isDefined(a[c])) {
					a[c] = [b]
				} else {
					if (!a[c].contains(b)) {
						a[c].push(b)
					}
				}
				this.storeData("properties", a)
			},
			removeProperty: function(c, b) {
				var a = this.readData("properties")[c];
				if (Sys.isDefined(a) && a.contains(b)) {
					a.splice(a.indexOf(b), 1)
				}
			}
		}
	},
	controller: {
		executeOnInstantiation: {
			setupEvents: function(a) {
				var c = this,
					b = this.model.PROPERTIES || {},
					d = {
						"view:addProperty": c.addProperty,
						"view:removeProperty": c.removeProperty
					};
				c.model.storeData("properties", b);
				d["request:" + c.MODULE_NAME + ".addProperty"] = c.addProperty;
				d["request:" + c.MODULE_NAME + ".removeProperty"] = c.removeProperty;
				c.on(d);
				if (Sys.isDefined(a) && a.updateOnStartup === true) {
					c.updateAppearance()
				}
			}
		},
		methods: {
			addProperty: function(c, b) {
				var a = !this.model.hasProperty(c);
				this.model.addProperty(c, b);
				if (a) {
					this.updateAppearance()
				}
			},
			updateAppearance: function() {},
			removeProperty: function(c, b) {
				var a = this;
				if (a.model.hasProperty(c)) {
					a.model.removeProperty(c, b);
					if (!a.model.hasProperty(c)) {
						a.updateAppearance()
					}
				}
			}
		}
	}
};
Sys.ns("Mixins");
Mixins.trigger = {
	controller: {
		methods: {
			registerTriggers: function(a) {
				throw new Error("Abstract method! Must be implemented!")
			},
			onTriggerReady: function() {
				this.registerTriggers(Services.trigger)
			}
		},
		executeOnInstantiation: {
			setupEvents: function() {
				this.on({
					"notify:trigger.ready": this.onTriggerReady
				})
			}
		}
	}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseGetter = {
	platforms: ["desktop", "mobile"],
	isAvailable: function() {
		return true
	},
	validateNumArguments: function() {
		return arguments.length === 3
	},
	validateArguments: function() {
		return true
	},
	func: function() {}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseSetter = {
	platforms: ["desktop", "mobile"],
	isAvailable: function(a) {
		return this.model.readData("inIdleState") && Services.settingsManager.isSettable(a)
	},
	validateNumArguments: function() {
		return arguments.length === 4
	},
	validateArguments: function() {
		return true
	},
	func: function() {}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseCall = {
	platforms: ["desktop", "mobile"],
	isAvailable: function() {
		return this.model.readData("inIdleState") && !Services.storage.readData("dialog.showing")
	},
	validateNumArguments: function() {
		return arguments.length === 3
	},
	validateArguments: function() {
		return true
	},
	func: function() {}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Getters = {
	balanceInCurrency: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				b = Services.moneyManager,
				a = b.getBalanceCents(),
				e = b.formatMoneyCurrencySign(a),
				c = Array.prototype.slice.call(arguments),
				f = d.addParamsToArgument(c, e);
			d.success.apply(d, f)
		}
	}, NetEntExtend.API.BaseGetter),
	betInCurrency: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				a = Services.moneyManager,
				c = a.getBetCents(),
				e = a.formatMoneyCurrencySign(c),
				b = Array.prototype.slice.call(arguments),
				f = d.addParamsToArgument(b, e);
			d.success.apply(d, f)
		}
	}, NetEntExtend.API.BaseGetter),
	winInCurrency: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				a = Services.storage.readData("cashField.winInCents"),
				b = Services.moneyManager.formatMoneyCurrencySign(a),
				c = Array.prototype.slice.call(arguments),
				e = d.addParamsToArgument(c, b);
			d.success.apply(d, e)
		}
	}, NetEntExtend.API.BaseGetter),
	audio: Sys.applyPropertiesIf({
		func: function() {
			var b = this,
				d = Services.settingsManager.getSetting("volume") > 0,
				a = Array.prototype.slice.call(arguments),
				c = b.addParamsToArgument(a, d);
			b.success.apply(b, c)
		}
	}, NetEntExtend.API.BaseGetter),
	currentPlayMode: Sys.applyPropertiesIf({
		func: function() {
			var b = Services.storage.readData("playModeManager.modes"),
				a = Array.prototype.slice.call(arguments),
				c = this.addParamsToArgument(a, b);
			this.success.apply(this, c)
		}
	}, NetEntExtend.API.BaseGetter),
	autoplayNumberOfRoundsAvailable: Sys.applyPropertiesIf({
		func: function() {
			var c = this,
				a = c.autoplayNumberOfRoundsAvailable(),
				b = Array.prototype.slice.call(arguments),
				d = c.addParamsToArgument(b, a);
			c.success.apply(c, d)
		}
	}, NetEntExtend.API.BaseGetter),
	autoplayCurrentRoundsLeft: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				b = Services.storage.readData("autoPlayer.roundsLeft"),
				a = Sys.isDefined(b) && b > 0 ? b : null,
				c = Array.prototype.slice.call(arguments),
				e = d.addParamsToArgument(c, a);
			d.success.apply(d, e)
		}
	}, NetEntExtend.API.BaseGetter),
	paytableCount: Sys.applyPropertiesIf({
		func: function() {
			var a = Services.storage.readData("paytable.numberOfPages"),
				b = Array.prototype.slice.call(arguments),
				c = this.addParamsToArgument(b, a);
			this.success.apply(this, c)
		}
	}, NetEntExtend.API.BaseGetter),
	paytablePage: Sys.applyPropertiesIf({
		func: function() {
			var b = null,
				a = Array.prototype.slice.call(arguments);
			if (Services.storage.readData("paytable.showing")) {
				b = Services.storage.readData("paytable.currentPage")
			}
			this.success.apply(this, this.addParamsToArgument(a, b))
		}
	}, NetEntExtend.API.BaseGetter),
	volumeLevel: Sys.applyPropertiesIf({
		func: function() {
			var c = this,
				b = Sys.utils.toInt(Services.settingsManager.getSetting("volume") * 100),
				a = Array.prototype.slice.call(arguments),
				d = c.addParamsToArgument(a, b);
			c.success.apply(c, d)
		}
	}, NetEntExtend.API.BaseGetter),
	debugMode: Sys.applyPropertiesIf({
		func: function() {
			var c = this,
				a = false,
				b = Array.prototype.slice.call(arguments),
				d;
			d = c.addParamsToArgument(b, a);
			c.success.apply(c, d)
		}
	}, NetEntExtend.API.BaseGetter)
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Setters = {
	volumeLevel: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return true
		},
		validateArguments: function() {
			return Sys.isNumber(arguments[3]) && 0 <= arguments[3] && arguments[3] <= 100
		},
		func: function() {
			var b = this,
				c = arguments[3] / 100,
				a = Array.prototype.slice.call(arguments);
			b.updateSetting("volume", c, a)
		}
	}, NetEntExtend.API.BaseSetter),
	audio: Sys.applyPropertiesIf({
		isAvailable: function() {
			return true
		},
		validateArguments: function() {
			return typeof arguments[3] === "boolean"
		},
		func: function() {
			var c = this,
				a = arguments[3] ? 1 : 0,
				b = Array.prototype.slice.call(arguments);
			c.updateSetting("volume", a, b)
		}
	}, NetEntExtend.API.BaseSetter),
	inGameMessage: Sys.applyPropertiesIf({
		platforms: ["mobile"],
		isAvailable: function() {
			return true
		},
		validateArguments: function() {
			var a = arguments[3],
				b;
			if (Sys.isArray(a) && a.length > 0) {
				b = Sys.find(a, function(c) {
					if (Sys.isObj(c) && Sys.isString(c.text)) {
						if (Sys.isDefined(c.type)) {
							if (c.type !== "link" && c.type !== "text") {
								return true
							}
							if (c.type === "link" && Sys.isDefined(c.url) && !Sys.isString(c.url)) {
								return true
							}
						}
						return false
					}
					return true
				});
				return !Sys.isDefined(b)
			}
			return false
		},
		func: function() {
			var f = this,
				g = arguments[3],
				e = [],
				c = 60,
				d, h = "",
				a = 0,
				b = Array.prototype.slice.call(arguments);
			g.forEach(function(j) {
				a++;
				h += j.text;
				if (h.length > c) {
					j.text = j.text.substring(0, j.text.length - h.length + c)
				}
				if (j.text.length > 0) {
					if (Sys.isDefined(j.type) && j.type === "link") {
						d = new Interface.utils.Button({
							id: "ticker_lnk_" + a,
							label: j.text,
							clickCallback: function() {
								Sys.utils.openURL(j.url)
							}
						});
						d.enable();
						window.linkContainer = d.getContainer();
						window.linkContainer.addCSSClass("netEntExtend_button");
						e.push(window.linkContainer)
					} else {
						e.push(new Sys.Element({
							tag: "span",
							textContent: j.text
						}))
					}
				}
			});
			f.fireEvent("request:ticker.enable", "netEntExtend");
			f.fireEvent("request:ticker.setText", e);
			f.success.apply(f, b)
		}
	}, NetEntExtend.API.BaseSetter)
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Calls = {
	stopAutoplay: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			var b = Services.storage.readData("dialog.showing"),
				a = Services.storage.readData("autoPlayer.roundsLeft");
			return !b && a > 0
		},
		func: function() {
			var b = this,
				a = Array.prototype.slice.call(arguments);
			b.fireEvent("request:autoPlayer.stop");
			b.success.apply(b, a)
		}
	}, NetEntExtend.API.BaseCall),
	reloadBalance: Sys.applyPropertiesIf({
		func: function() {
			var b = this,
				a = Array.prototype.slice.call(arguments);
			b.fireEvent("request:serverManager.sendAction", "reloadbalance", "notify:responseParser.reloadBalanceResponseParsed", "notify:serverManager.reloadBalanceFailed");
			b.model.storeData("reloadBalanceArguments", a);
			b.model.storeData("reloadBalanceSpin", false)
		}
	}, NetEntExtend.API.BaseCall),
	createDialogbox: Sys.applyPropertiesIf({
		platforms: ["mobile"],
		isAvailable: function() {
			return true
		},
		validateNumArguments: function() {
			return arguments.length === 7
		},
		validateArguments: function() {
			var d = arguments[3],
				c = arguments[4],
				b = arguments[5],
				a = arguments[6];
			return Sys.isString(d) && Sys.isString(c) && Sys.isString(b) && Sys.isArray(a) && a.length > 0 && a.length <= 2 && typeof Sys.find(a, function(e) {
				return !(Sys.isString(e.buttonid) && Sys.isString(e.buttontext))
			}) === "undefined"
		},
		func: function() {
			var d = this,
				g = arguments[3],
				f = arguments[4].substring(0, 20),
				e = arguments[5],
				c = arguments[6],
				b = {
					id: "netEntExtend_" + g,
					title: f,
					text: e,
					buttons: [],
					stopAutoplay: true
				},
				a = Array.prototype.slice.call(arguments);
			Sys.each(c, function(h) {
				var j = {};
				j.action = function() {
					var k = Sys.isDefined(this.buttontype) ? this.buttontype.toLowerCase() : "";
					d.fireEvent("request:postman.sendMessage", ["event", "dialogBoxClosed", this.dialogid, this.buttonid]);
					switch (k) {
						case "gotolobby":
							Environment.goToLobby(this.reason);
							break;
						case "reload":
							Environment.reload();
							break;
						default:
							break
					}
				};
				j.scope = {
					dialogid: g,
					buttonid: h.buttonid,
					buttontype: h.action,
					reason: h.reason
				};
				j.text = h.buttontext;
				j.buttonid = h.buttonid;
				b.buttons.push(j)
			});
			d.fireEvent("request:customMessages.showDialog", b);
			d.success.apply(d, a)
		}
	}, NetEntExtend.API.BaseCall),
	removeDialogbox: Sys.applyPropertiesIf({
		platforms: ["mobile"],
		isAvailable: function() {
			return true
		},
		validateNumArguments: function() {
			return arguments.length === 4
		},
		validateArguments: function() {
			return Sys.isString(arguments[3])
		},
		func: function() {
			var b = this,
				a = Array.prototype.slice.call(arguments);
			b.fireEvent("request:customMessages.removeDialog", "netEntExtend_" + arguments[3]);
			b.success.apply(b, a)
		}
	}, NetEntExtend.API.BaseCall),
	pluginError: Sys.applyPropertiesIf({
		platforms: ["mobile"],
		isAvailable: function() {
			return true
		},
		func: function() {
			var a = Array.prototype.slice.call(arguments);
			this.fireEvent("request:errorManager.handleError");
			this.success.apply(this, a)
		}
	}, NetEntExtend.API.BaseCall),
	deactivatePluginMenu: Sys.applyPropertiesIf({
		platforms: ["mobile"],
		isAvailable: function() {
			return true
		},
		func: function() {
			var a = Array.prototype.slice.call(arguments);
			this.fireEvent("request:pluginMenu.deactivate");
			this.success.apply(this, a)
		}
	}, NetEntExtend.API.BaseCall),
	pluginNotification: Sys.applyPropertiesIf({
		platforms: ["mobile"],
		isAvailable: function() {
			return true
		},
		validateNumArguments: function() {
			return arguments.length === 4
		},
		validateArguments: function() {
			return Sys.isString(arguments[3])
		},
		func: function() {
			var a = Array.prototype.slice.call(arguments);
			this.fireEvent("request:pluginMenu.notification", arguments[3]);
			this.success.apply(this, a)
		}
	}, NetEntExtend.API.BaseCall),
	showSystemClock: Sys.applyPropertiesIf({
		platforms: ["desktop", "mobile"],
		isAvailable: function() {
			return true
		},
		func: function() {
			var a = Array.prototype.slice.call(arguments);
			this.fireEvent("request:systemClock.show");
			this.success.apply(this, a)
		}
	}, NetEntExtend.API.BaseCall)
};
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Getters, {
	balanceInCoins: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				b = Services.moneyManager,
				a = b.getBalanceCoins(),
				c = d.addParamsToArgument(arguments, a);
			d.success.apply(d, c)
		}
	}, NetEntExtend.API.BaseGetter),
	betInCoins: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				a = Services.moneyManager,
				c = a.getBetCoins(),
				b = d.addParamsToArgument(arguments, c);
			d.success.apply(d, b)
		}
	}, NetEntExtend.API.BaseGetter),
	availableCoins: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				c = Resources.readData("gameServerInitResponse"),
				a = c["denomination.all"],
				b = d.addParamsToArgument(arguments, a);
			d.success.apply(d, b)
		}
	}, NetEntExtend.API.BaseGetter),
	selectedCoinValue: Sys.applyPropertiesIf({
		func: function() {
			var c = this,
				a = Services.moneyManager,
				d = a.model.readData("denomination"),
				b = c.addParamsToArgument(arguments, d);
			c.success.apply(c, b)
		}
	}, NetEntExtend.API.BaseGetter),
	winInCoins: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				b = Services.storage.readData("cashField.winInCents"),
				e = Services.moneyManager.model.readData("denomination"),
				a = Math.floor(b / e),
				c = d.addParamsToArgument(arguments, a);
			d.success.apply(d, c)
		}
	}, NetEntExtend.API.BaseGetter),
	freeRoundsLeft: Sys.applyPropertiesIf({
		func: function() {
			var d = this,
				c = Services.storage.readData("freeRounds.roundsLeft"),
				a = Sys.isDefined(c) && c > 0 ? c : null,
				b = d.addParamsToArgument(arguments, a);
			d.success.apply(d, b)
		}
	}, NetEntExtend.API.BaseGetter),
	freeSpinsLeft: Sys.applyPropertiesIf({
		func: function() {
			var c = this,
				b = Services.storage.readData("freespin.freespinsLeft"),
				a = Sys.isDefined(b) && b >= 0 && ["FREESPIN", "SUPERSPIN"].contains(c.model.readData("gameMode")) ? b : null;
			c.success.apply(c, c.addParamsToArgument(arguments, a))
		}
	}, NetEntExtend.API.BaseGetter)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Setters, {});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Calls, {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Getters = Sys.apply(Sys.clone(NetEntExtend.API.Getters), {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Setters = Sys.apply(Sys.clone(NetEntExtend.API.Setters), {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Calls = Sys.apply(Sys.clone(NetEntExtend.API.Calls), {
	startAutoplay: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		validateNumArguments: function() {
			return arguments.length === 4
		},
		validateArguments: function() {
			var c = this,
				b = c.autoplayNumberOfRoundsAvailable(),
				d = b === null ? [] : b.split(","),
				a = arguments[3];
			return Sys.isString(a) && d.contains(a)
		},
		func: function() {
			var b = this,
				a = arguments[3];
			Services.settingsManager.storeSetting("autoPlayNrSpins", Number(a), false);
			b.fireEvent("request:autoPlayer.start");
			b.success.apply(b, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	showAutoplay: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			var d = Services.storage.readData("autoplaySettings.showing"),
				c = Services.storage.readData("spinSettings.showing"),
				e = Services.storage.readData("dialog.showing"),
				b = Services.storage.readData("IntroMovie.showing"),
				a = this.model.readData("featureSplash.showing");
			return !(d || c || e || b || a)
		},
		func: function() {
			var a = this;
			a.fireEvent("request:autoplaySettings.show");
			a.fireEvent("request:spinSettings.show");
			if (!(Services.storage.readData("autoplaySettings.showing") || Services.storage.readData("spinSettings.showing"))) {
				a.error(arguments, a.model.ERROR_CODES.UNKNOWN_ERROR)
			} else {
				a.success.apply(a, arguments)
			}
		}
	}, NetEntExtend.API.BaseCall),
	hideAutoplay: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing") && (Services.storage.readData("autoplaySettings.showing") || Services.storage.readData("spinSettings.showing"))
		},
		func: function() {
			var a = this;
			a.fireEvent("request:autoplaySettings.hide");
			a.fireEvent("request:spinSettings.hide");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	showPaytable: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing")
		},
		validateNumArguments: function() {
			return arguments.length === 4
		},
		validateArguments: function() {
			var b = arguments[3],
				a = Services.storage.readData("paytable.numberOfPages");
			return Sys.isNumber(b) && (1 <= b && b <= a)
		},
		func: function() {
			var a = this,
				b = arguments[3];
			a.fireEvent("request:paytable.show", b);
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	hidePaytable: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:paytable.hide");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	paytableForward: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:paytable.forward");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	paytableBackward: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:paytable.backward");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	closeSplash: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			var a = this;
			return !Services.storage.readData("dialog.showing") && a.model.readData("featureSplash.showing")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:featureSplash.close");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	startFreespins: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing") && Services.storage.readData("freeSpins.canStart")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:freeSpins.start");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	openHelp: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			var a = this;
			return !Services.storage.readData("dialog.showing") && a.model.readData("inIdleState") && !Services.storage.readData("gameRules.showing")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:gameRules.show");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	skipIntro: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return !Services.storage.readData("dialog.showing") && Services.storage.readData("IntroMovie.showing")
		},
		func: function() {
			var a = this;
			a.fireEvent("request:introMovie.close");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Restricted.Setters, {
	betLevel: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return NetEntExtend.API.BaseSetter.isAvailable.call(this, "betLevel")
		},
		validateArguments: function() {
			var c = arguments[3],
				a = Resources.readData("gameServerInitResponse"),
				b = a["betlevel.all"].split(",");
			return Sys.isNumber(c) && b.contains(String(c))
		},
		func: function() {
			var a = this;
			a.updateSetting("betLevel", arguments[3], arguments)
		}
	}, NetEntExtend.API.BaseSetter),
	coinValue: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return NetEntExtend.API.BaseSetter.isAvailable.call(this, "denomination")
		},
		validateArguments: function() {
			var b = arguments[3],
				c = Resources.readData("gameServerInitResponse"),
				a = c["denomination.all"].split(",");
			return Sys.isNumber(b) && a.contains(String(b))
		},
		func: function() {
			var a = this;
			a.updateSetting("denomination", arguments[3], arguments)
		}
	}, NetEntExtend.API.BaseSetter)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Restricted.Calls, {
	startSpin: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return NetEntExtend.API.BaseCall.isAvailable.call(this) && Services.moneyManager.canPlaceAnotherBet()
		},
		func: function() {
			var a = this;
			a.fireEvent("request:spin.startNewRound");
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	startQuickSpin: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		isAvailable: function() {
			return NetEntExtend.API.BaseCall.isAvailable.call(this) && Services.settingsManager.isSettable("quickSpin") && Services.moneyManager.canPlaceAnotherBet()
		},
		func: function() {
			var b = this,
				a = Services.settingsManager.getSetting("quickSpin");
			b.fireEvent("request:settingsManager.storeData", "quickSpin", true);
			b.fireEvent("request:spin.startNewRound");
			b.onEnteringIdleState.push(function() {
				b.fireEvent("request:settingsManager.storeData", "quickSpin", a)
			});
			b.success.apply(b, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	maxBetSpin: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		func: function() {
			var b = this,
				c = Resources.readData("gameServerInitResponseObject").betlevel.all,
				a = Math.max.apply(null, c);
			b.fireEvent("request:settingsManager.storeData", "betLevel", a);
			b.startRound();
			b.success.apply(b, arguments)
		}
	}, NetEntExtend.API.BaseCall),
	featurePreview: Sys.applyPropertiesIf({
		platforms: ["desktop"],
		func: function() {
			var a = this;
			a.success.apply(a, arguments)
		}
	}, NetEntExtend.API.BaseCall)
});
Sys.ns("Core.NetEntExtend");
Core.NetEntExtend = {
	constructor: function() {
		Core.NetEntExtend.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.NetEntExtendModel,
			controller: Core.NetEntExtendController
		}
	}
};
Core.NetEntExtend = Sys.extend(Core.Module, Core.NetEntExtend, "Core.NetEntExtend");
Sys.ns("Core");
Core.NetEntExtendController = {
	USE_LOGGING: false,
	ROUND_START_EVENT: "request:spin.startNewRound",
	constructor: function() {
		Core.NetEntExtendController.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Core.NetEntExtendController.superclass.init.apply(a, arguments);
		a.onEnteringIdleState = [];
		a.setupAPI()
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringIdleState": a.enteringIdleState,
			"notify:stateHandler.leavingIdleState": a.leavingIdleState,
			"notify:netEntExtendEvents.eventTriggered": a.sendMessage,
			"notify:responseParser.reloadBalanceResponseParsed": a.onReloadBalanceResponse,
			"notify:serverManager.reloadBalanceFailed": a.onReloadBalanceFailed,
			"notify:featureSplash.showing": a.onFeatureSplashShowing,
			"notify:featureSplash.closed": a.onFeatureSplashClosed,
			"notify:gameModeChanged": a.onGameModeChanged,
			"request:NetEntExtend.newMessage": a.handleIncomingMessage
		})
	},
	setupAPI: function() {
		var b = this,
			c = b.model.readData("useRestricted"),
			a = (c === true) ? NetEntExtend.API.Restricted : NetEntExtend.API;
		b.API = {
			get: a.Getters,
			set: a.Setters,
			call: a.Calls
		}
	},
	enteringIdleState: function() {
		var a = this;
		a.onEnteringIdleState.forEach(function(b) {
			b.apply(a, arguments)
		});
		a.onEnteringIdleState = [];
		a.model.storeData("inIdleState", true)
	},
	leavingIdleState: function() {
		var a = this;
		a.model.storeData("inIdleState", false);
		a.model.storeData("reloadBalanceSpin", true)
	},
	handleIncomingMessage: function() {
		var d = this,
			b = arguments[0],
			c = arguments[1],
			a = arguments[2],
			f;
		if (arguments.length < 3 || !Sys.isString(b) || !Sys.isNumber(c) || !Sys.isString(a)) {
			d.error(arguments, d.model.ERROR_CODES.WRONG_NUMBER_OF_ARGUMENTS)
		} else {
			if (!Sys.isDefined(d.API[b]) || !Sys.isDefined(d.API[b][a])) {
				d.error(arguments, d.model.ERROR_CODES.FUNCTIONALITY_NOT_AVAILABLE)
			} else {
				f = d.API[b][a];
				if ((Platform.isDesktopDevice && f.platforms.indexOf("desktop") === -1) || ((Platform.isMobileDevice || Platform.isTabletDevice) && f.platforms.indexOf("mobile") === -1)) {
					d.error(arguments, d.model.ERROR_CODES.FUNCTIONALITY_NOT_AVAILABLE)
				} else {
					if (!f.isAvailable.apply(d, arguments)) {
						d.error(arguments, d.model.ERROR_CODES.NOT_AVAILABLE_IN_CURRENT_STATE)
					} else {
						if (!f.validateNumArguments.apply(d, arguments)) {
							d.error(arguments, d.model.ERROR_CODES.WRONG_NUMBER_OF_ARGUMENTS)
						} else {
							if (!f.validateArguments.apply(d, arguments)) {
								d.error(arguments, d.model.ERROR_CODES.ILLEGAL_ARGUMENT)
							} else {
								try {
									f.func.apply(d, arguments)
								} catch (g) {
									d.error(arguments, d.model.ERROR_CODES.UNKNOWN_ERROR)
								}
							}
						}
					}
				}
			}
		}
	},
	success: function() {
		var b = this,
			a = b.getResponseArguments.apply(b, arguments);
		b.sendMessage(["success", a.callId].concat(a.rest))
	},
	error: function(c, a, e) {
		var d = this,
			b = d.getResponseArguments.apply(d, c);
		d.sendMessage(["error", b.callId, a, e])
	},
	sendMessage: function(a) {
		var b = "";
		this.fireEvent("request:postman.sendMessage", a)
	},
	getResponseArguments: function() {
		var a = Array.prototype.slice.call(arguments),
			c = a[1],
			b = a.splice(3);
		return {
			callId: c,
			rest: b
		}
	},
	addParamsToArgument: function(c, b) {
		var a = Array.prototype.slice.call(c);
		if (Sys.isArray(b)) {
			b.forEach(function(d) {
				a.push(d)
			})
		} else {
			a.push(b)
		}
		return a
	},
	updateSetting: function(c, f, b) {
		var e = this,
			a = Services.settingsManager,
			d = this.model.ERROR_CODES;
		a.storeSetting(c, f, false);
		if (a.getSetting(c) === f) {
			e.success.apply(e, b)
		} else {
			e.error(b, d.UNKNOWN_ERROR)
		}
	},
	autoplayNumberOfRoundsAvailable: function() {
		var a = Services.storage.readData("spinSettings.autoplayRoundsAvailable");
		return Sys.isDefined(a) ? a.toString() : null
	},
	onReloadBalanceResponse: function(a) {
		var c = this,
			b = c.model.readData("reloadBalanceArguments"),
			d = c.model.readData("reloadBalanceSpin"),
			e = a.credit;
		if (d) {
			c.success.apply(c, c.addParamsToArgument(b, "busy"))
		} else {
			if (Sys.isNumber(e)) {
				Services.moneyManager.setBalance(e);
				c.success.apply(c, c.addParamsToArgument(b, e))
			}
		}
	},
	onReloadBalanceFailed: function() {
		var b = this,
			a = b.model.readData("reloadBalanceArguments");
		b.error(a, b.model.UNKNOWN_ERROR)
	},
	onFeatureSplashShowing: function() {
		this.model.storeData("featureSplash.showing", true)
	},
	onFeatureSplashClosed: function() {
		this.model.storeData("featureSplash.showing", false)
	},
	startRound: function() {
		var a = this;
		a.fireEvent(a.ROUND_START_EVENT)
	},
	onGameModeChanged: function(a) {
		this.model.storeData("gameMode", a)
	}
};
Core.NetEntExtendController = Sys.extend(Core.Controller, Core.NetEntExtendController, "Core.NetEntExtendController");
Sys.ns("Core");
Core.NetEntExtendModel = {
	ERROR_CODES: {
		UNKNOWN_ERROR: 0,
		ILLEGAL_ARGUMENT: 1,
		EVENTS_NOT_AVAILABLE_IN_GAME: 7,
		CALLBACK_NOT_PROVIDED: 8,
		FUNCTIONALITY_NOT_AVAILABLE: 9,
		WRONG_NUMBER_OF_ARGUMENTS: 10,
		NO_RESPONSE_FROM_GAME: 11,
		NOT_AVAILABLE_IN_CURRENT_STATE: 12,
		HTML_GAME_LAUNCH_FAILED: 18
	},
	constructor: function() {
		Core.NetEntExtendModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var d = this,
			c = Resources.readData("gameServerInitResponse"),
			b = (Sys.isDefined(c)) ? c["gameEventSetters.enabled"] : false,
			a = false;
		if (Sys.isDefined(b) && b === true) {
			a = true
		}
		d.storeData("useRestricted", a);
		d.storeData("locked", true);
		d.storeData("inIdleState", false);
		d.storeData("featureSplash.showing", false)
	}
};
Core.NetEntExtendModel = Sys.extend(Core.Model, Core.NetEntExtendModel, "Core.NetEntExtendModel");
Sys.ns("Core.NetEntExtendEvents");
Core.NetEntExtendEvents = {
	constructor: function() {
		Core.NetEntExtendEvents.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.NetEntExtendEventsModel,
			controller: Core.NetEntExtendEventsController
		}
	}
};
Core.NetEntExtendEvents = Sys.extend(Core.Module, Core.NetEntExtendEvents, "Core.NetEntExtendEvents");
Sys.ns("Core");
Core.NetEntExtendEventsController = {
	USE_LOGGING: false,
	constructor: function() {
		Core.NetEntExtendEventsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var b = this,
			a = {
				"notify:autoPlayer.starting": b.onAutoplayStarting,
				"notify:autoPlayer.startRound": b.onAutoplayStartRound,
				"notify:settingsManager.settingChanged": b.onSettingsChanged,
				"notify:spin.spinAnimationStarted": b.onSpinStart,
				"notify:spin.spinAnimationComplete": b.onSpinEnded,
				"notify:stateHandler.enteringStandardWinPresentationState": b.onWinPresentationStarted,
				"notify:responseParser.responseParsed": b.onServerResponseParsed,
				"notify:standardWin.presentationComplete": b.onWinPresentationComplete,
				"notify:paytable.shown": b.sendEvent.bind(b, "paytableToggle", true),
				"notify:paytable.hidden": b.sendEvent.bind(b, "paytableToggle", false),
				"notify:bonusGameIntro.bonusGameStarted": b.onBonusGameStarted,
				"notify:bonusGameOutro.bonusGameEnded": b.onBonusGameEnded,
				"notify:gameModeChanged": b.onGameModeChanged,
				"notify:stateHandler.enteringIdleState": b.onEnteringIdleState,
				"notify:stateHandler.leavingIdleState": b.onLeavingIdleState,
				"notify:cashField.update": b.onCashFieldUpdate,
				"notify:freeRounds.started": b.onFreeRoundsStarted,
				"notify:freeRounds.ended": b.onFreeRoundsEnded,
				"notify:freeRounds.nextRound": b.onFreeRoundsNextRound,
				"notify:pluginMenu.activated": b.onPluginMenuActivated,
				"notify:pluginMenu.deactivated": b.onPluginMenuDeactivated,
				"notify:viewport.PORTRAIT": b.onPortrait,
				"notify:viewport.LANDSCAPE": b.onLandscape,
				"notify:loader.closed": b.onLoaderClosed,
				"notify:customMessages.fatalMessageShowing": b.onFatalCustomMessage
			};
		Sys.iterate(b.model.EVENT_MAP, function(c, d) {
			a[c] = b.sendEvent.bind(b, d)
		});
		b.on(a)
	},
	onLoaderClosed: function() {
		if (this.model.readData("isRestore") === true) {
			this.sendEvent("gameRoundStarted")
		}
	},
	onFatalCustomMessage: function(b, a) {
		if (b === 990 || b === 992) {
			this.sendEvent("gameError", 18, a)
		}
	},
	onFreeRoundsStarted: function(a) {
		this.sendEvent("freeRoundsStarted", a)
	},
	onFreeRoundsEnded: function() {
		this.sendEvent("freeRoundsEnded")
	},
	onFreeRoundsNextRound: function(a, b) {
		this.sendEvent("freeRoundsNextRound", a, b)
	},
	sendEvent: function() {
		var a = Array.prototype.slice.call(arguments),
			b = "";
		this.fireEvent("notify:netEntExtendEvents.eventTriggered", ["event"].concat(a))
	},
	onSpinStart: function() {
		var a = Services.storage.readData("playModeManager.modes");
		this.model.storeData("spinStarted", true);
		this.sendEvent("spinStarted", a)
	},
	onSpinEnded: function() {
		this.model.storeData("spinStarted", false);
		this.sendEvent("spinEnded")
	},
	onWinPresentationStarted: function() {
		this.sendEvent("spinProgress", "initialWinPresentationStarted")
	},
	onServerResponseParsed: function(c) {
		var a = this,
			b;
		if (a.model.readData("spinStarted")) {
			b = Sys.isDefined(c.gameroundid) ? c.gameroundid : 0;
			a.sendEvent("spinProgress", "outcomeReceived", b)
		}
		if ((c.restore === true)) {
			a.model.storeData("isRestore", true)
		}
	},
	onWinPresentationComplete: function(b) {
		var a;
		if (Sys.isDefined(b)) {
			a = (b === true) ? "initialWinPresentationAborted" : "initialWinPresentationEnded"
		}
		if (a) {
			this.sendEvent("spinProgress", a)
		}
	},
	onSettingsChanged: function(a, c) {
		var b = this;
		if (a === "volume") {
			b.volumeChange(c)
		}
	},
	onAutoplayStarting: function() {
		var a = this,
			b = Services.settingsManager.getSetting("autoPlayNrSpins");
		a.model.storeData("autoplayRoundsSelected", b);
		a.sendEvent("autoplayStarted", b)
	},
	onAutoplayStartRound: function(a) {
		var c = this,
			b = c.model.readData("autoplayRoundsSelected");
		c.sendEvent("autoplayNextRound", b, a)
	},
	volumeChange: function(d) {
		var c = this,
			b = Math.floor(d * 100),
			e = d > 0,
			a = c.model.readData("lastVolume") > 0;
		c.model.storeData("lastVolume", d);
		c.sendEvent("volumeChange", b);
		if (e !== a) {
			c.sendEvent("audioToggle", e)
		}
	},
	onCashFieldUpdate: function(d) {
		var b = this,
			a = b.model,
			c = a.readData("balance");
		if (Sys.isDefined(c)) {
			if (d !== c) {
				b.sendEvent("balanceChanged");
				a.storeData("balance", d)
			}
		} else {
			a.storeData("balance", d)
		}
	},
	onGameModeChanged: function(a) {
		this.model.storeData("gameMode", a.toLowerCase())
	},
	onBonusGameStarted: function(a) {
		this.sendEvent("bonusGameStarted", a)
	},
	onBonusGameEnded: function(a) {
		this.sendEvent("bonusGameEnded", a)
	},
	onEnteringIdleState: function() {
		var b = this,
			a = b.model.readData("leftIdleState"),
			c = b.model.readData("isRestore");
		if (a || c) {
			b.sendEvent("gameRoundEnded");
			b.model.storeData("isRestore", false)
		}
		b.model.storeData("leftIdleState", false)
	},
	onLeavingIdleState: function() {
		var a = this;
		a.sendEvent("gameRoundStarted");
		a.model.storeData("leftIdleState", true)
	},
	onPluginMenuActivated: function() {
		this.sendEvent("pluginMenuActivated")
	},
	onPluginMenuDeactivated: function() {
		this.sendEvent("pluginMenuDeactivated")
	},
	onPortrait: function() {
		this.sendEvent("rotate", {
			orientation: "portrait"
		})
	},
	onLandscape: function() {
		this.sendEvent("rotate", {
			orientation: "landscape"
		})
	}
};
Core.NetEntExtendEventsController = Sys.extend(Core.Controller, Core.NetEntExtendEventsController, "Core.NetEntExtendEventsController");
Sys.ns("Core");
Core.NetEntExtendEventsModel = {
	EVENT_MAP: {
		"notify:stateHandler.leavingBeforeLoaderCloseState": "gameReady",
		"notify:errorManager.error": "gameError",
		"notify:errorManager.errorDialogClosed": "gameErrorClose",
		"notify:paytable.pageSwitched": "paytablePageSwitch",
		"notify:autoPlayer.stopped": "autoplayStopped"
	},
	constructor: function() {
		Core.NetEntExtendEventsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.storeData("autoplay", false);
		this.storeData("gameMode", "basic")
	},
	getCurrentGameMode: function() {
		var b = this,
			a = b.readData("gameMode");
		if (b.readData("autoplay")) {
			a += ", autoplay"
		}
		return a
	}
};
Core.NetEntExtendEventsModel = Sys.extend(Core.Model, Core.NetEntExtendEventsModel, "Core.NetEntExtendEventsModel");
Sys.ns("Core.Slots");
Core.Slots.NetEntExtendEventsModel = {
	SLOTS_EVENT_MAP: {
		"notify:stateHandler.enteringBigWinState": "bigWinStarted",
		"notify:stateHandler.leavingBigWinState": "bigWinEnded",
		"notify:freeSpinIntro.closed": "freeSpinStarted",
		"notify:freeSpinOutro.closed": "freeSpinEnded"
	},
	constructor: function() {
		Core.Slots.NetEntExtendEventsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		Core.Slots.NetEntExtendEventsModel.superclass.setupData.apply(this, arguments);
		Sys.apply(this.EVENT_MAP, this.SLOTS_EVENT_MAP)
	}
};
Core.Slots.NetEntExtendEventsModel = Sys.extend(Core.NetEntExtendEventsModel, Core.Slots.NetEntExtendEventsModel, "Core.Slots.NetEntExtendEventsModel");
Sys.ns("Core");
Core.Postman = {
	constructor: function() {
		Core.Postman.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			setupGame: {
				waitEvents: ["notify:postman.ready"]
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Core.PostmanController
		}
	}
};
Core.Postman = Sys.extend(Core.Module, Core.Postman, "Core.Postman");
Sys.ns("Core");
Core.PostmanController = {
	IS_READY: false,
	PLUGIN_TIMEOUT: 30000,
	constructor: function() {
		Core.PostmanController.superclass.constructor.apply(this, arguments)
	},
	setupPlugin: function() {
		var c = this,
			b = Resources.readData("pluginURL"),
			a;
		c.iframe = undefined;
		if (c.isStandalone) {
			c.iframe = document.createElement("iframe");
			c.iframe.setAttribute("id", "netEntExtendPlugin");
			c.iframe.setAttribute("frameborder", 0);
			c.iframe.setAttribute("width", "100%");
			c.iframe.setAttribute("height", 0);
			c.iframe.src = b;
			a = document.getElementById("viewport");
			a.insertBefore(c.iframe, a.firstChild);
			c.timeout = setTimeout(function() {
				c.fireEvent("request:loaderErrorHandler.handlePluginTimeoutError")
			}, c.PLUGIN_TIMEOUT)
		} else {
			c.fireEvent("notify:postman.ready");
			c.IS_READY = true
		}
	},
	setupEvents: function() {
		var b = this,
			a = Resources.readData("pluginURL");
		b.isInIframe = window !== window.parent;
		b.isStandalone = Sys.isDefined(a);
		b.on({
			"request:postman.sendMessage": b.sendMessage,
			"notify:stateHandler.enteringSetupGameState": b.setupPlugin
		});
		window.addEventListener("message", function(c) {
			b.handleIncomingMessage.apply(b, c.data)
		})
	},
	handlePluginReadyCall: function(b) {
		var c = this,
			a = b[3],
			d = b[4];
		if (b[0] === "call" && b[2] === "pluginReady") {
			if (Sys.isDefined(c.timeout)) {
				clearTimeout(c.timeout)
			}
			c.IS_READY = true;
			c.fireEvent("notify:postman.ready");
			if (Sys.isDefined(a) && Sys.isDefined(d)) {
				c.fireEvent("request:pluginMenu.init", a, d)
			}
			c.sendMessage(["success", b[1]])
		}
	},
	handleIncomingMessage: function() {
		var c = this,
			b = Array.prototype.slice.call(arguments),
			a = ["request:NetEntExtend.newMessage"].concat(b);
		if (c.isStandalone && !c.IS_READY) {
			c.handlePluginReadyCall(b)
		} else {
			c.fireEvent.apply(c, a)
		}
	},
	sendMessage: function(b) {
		var a = this;
		if (a.isInIframe) {
			window.parent.postMessage(b, "*")
		}
		if (Sys.isDefined(a.iframe) && a.isStandalone) {
			a.iframe.contentWindow.postMessage(b, "*")
		}
	}
};
Core.PostmanController = Sys.extend(Core.Controller, Core.PostmanController, "Core.PostmanController");
Sys.ns("Core");
Core.CustomMessages = {
	constructor: function() {
		Core.CustomMessages.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model;
		return {
			showingCustomMessages: {
				state: {
					name: "ShowingCustomMessages",
					execute: function() {},
					waitEvents: {
						"notify:customMessages.messagesClosed": false
					}
				}
			},
			delayBeforeShowingMessages: {
				state: {
					name: "DelayBeforeShowingMessages",
					execute: function() {},
					waitEvents: {
						"notify:customMessages.delayComplete": false
					}
				}
			},
			idle: {
				waitEvents: ["notify:customMessages.messagesClosed"]
			},
			beforeStopping: {
				queue: [function(b) {
					if (a.hasImmediate() || !a.readData("shouldShowDialogs")) {
						b.stateHandler.pushState(b.states.showingCustomMessages)
					}
				}]
			},
			setupGame: {
				waitEvents: ["notify:customMessages.ready"]
			},
			noWinPresentation: {
				queue: [function(b) {
					if (a.hasDialogs() || !a.readData("shouldShowDialogs")) {
						b.stateHandler.pushState(b.states.delayBeforeShowingMessages)
					}
				}]
			}
		}
	},
	getMixinDependencies: function() {
		return ["userInput"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Core.CustomMessagesController,
			model: Core.CustomMessagesModel
		}
	}
};
Core.CustomMessages = Sys.extend(Core.Module, Core.CustomMessages, "Core.CustomMessages");
Sys.ns("Core");
Core.CustomMessagesController = {
	DIALOG_DELAY: 3000,
	ERRORS: {
		DISPLAY_IMMEDIATELY_CLOSE: 990,
		DISPLAY_IMMEDIATELY_CONTINUE: 991,
		DISPLAY_ON_IDLE_CLOSE: 992,
		DISPLAY_ON_IDLE_CONTINUE: 993
	},
	constructor: function() {
		Core.CustomMessagesController.superclass.constructor.apply(this, arguments);
		this.model.storeData("showingLoader", true)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:customMessages.showDialog": a.onShowDialogRequest,
			"request:customMessages.removeDialog": a.onRemoveDialogRequest,
			"notify:serverManager.serverResponseReceived": a.onServerResponseReceived,
			"notify:serverManager.serverErrorReceived": a.onServerErrorReceived,
			"notify:stateHandler.enteringSetupGameState": a.onEnteringSetupGameState,
			"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
			"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
			"notify:stateHandler.enteringShowingCustomMessagesState": a.onEnteringShowingCustomMessagesState,
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
			"notify:stateHandler.enteringDelayBeforeShowingMessagesState": a.onEnteringDelayBeforeShowingMessagesState,
			"notify:stateHandler.leavingDelayBeforeShowingMessagesState": a.onLeavingDelayBeforeShowingMessagesState,
			"notify:dialogWindow.dialogShown": a.onDialogShown
		})
	},
	onLoaderClose: function() {
		this.model.storeData("showingLoader", false);
		this.model.storeData("shouldShowDialogs", true)
	},
	onShowDialogRequest: function(b) {
		var c = this,
			a;
		try {
			a = c.prepareDialogConfig(b)
		} catch (d) {
			c.showTechnicalError();
			c.model.storeData("shouldShowDialogs", false);
			return
		}
		delete a.immediate;
		if (c.model.readData("isIdle")) {
			if (c.model.hasDialogsToWaitFor()) {
				c.model.addDialogToWaitFor(a.id)
			}
			c.fireEvent("request:dialogWindow.showDialog", a)
		} else {
			c.model.addDialog(a)
		}
	},
	onRemoveDialogRequest: function(a) {
		this.model.removeDialogToWaitFor(a);
		this.model.removeDialog(a);
		this.fireEvent("request:dialogWindow.removeDialog", a)
	},
	onServerResponseReceived: function(a) {
		var b = Sys.utils.queryStringToObject(a.responseText, true),
			c = Object.keys(b).length;
		if (Sys.isDefined(b.messages)) {
			this.handleMessagesFromServerRequest(b.messages, c === 1)
		}
	},
	onServerErrorReceived: function(a) {
		var b = Sys.utils.qsToObj(a.responseText, true);
		if (Sys.isDefined(b.messages)) {
			this.handleMessagesFromServerRequest(b.messages, true)
		}
	},
	handleMessagesFromServerRequest: function(f, c) {
		var h = this,
			g, b, d, a;
		try {
			g = JSON.parse(f);
			if (Sys.isArray(g)) {
				b = g.pop();
				if (Sys.isDefined(b)) {
					d = h.createConfigFromMessage(b);
					a = h.prepareDialogConfig(d);
					h.model.addDialog(a)
				}
				if (c) {
					h.showImmediateMessages()
				}
				return
			}
		} catch (j) {}
		h.showTechnicalError();
		h.model.storeData("shouldShowDialogs", false)
	},
	onEnteringSetupGameState: function() {
		if (!this.model.readData("showingError")) {
			this.fireEvent("notify:customMessages.ready")
		}
	},
	onEnteringIdleState: function() {
		this.model.storeData("isIdle", true);
		if (!this.model.readData("shouldShowDialogs")) {
			return
		}
		this.showDialogs(this.model.popAll())
	},
	onLeavingIdleState: function() {
		this.model.storeData("isIdle", false)
	},
	onEnteringShowingCustomMessagesState: function() {
		this.showImmediateMessages()
	},
	onEnteringDelayBeforeShowingMessagesState: function() {
		var a = this;
		clearTimeout(a.delayTimeout);
		a.startListeningToUserInput();
		a.delayTimeout = setTimeout(a.fireEvent.bind(a, "notify:customMessages.delayComplete"), a.DIALOG_DELAY)
	},
	onLeavingDelayBeforeShowingMessagesState: function() {
		this.stopListeningToUserInput()
	},
	onUserInputEnd: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			clearTimeout(a.delayTimeout);
			a.fireEvent("notify:customMessages.delayComplete")
		}
	},
	showImmediateMessages: function() {
		if (!this.model.readData("shouldShowDialogs")) {
			return
		}
		this.showDialogs(this.model.popAllImmediate())
	},
	onDialogShown: function(b) {
		var a = this;
		if (!Sys.isDefined(b)) {
			return
		}
		a.model.removeDialogToWaitFor(b);
		if (!a.model.hasDialogsToWaitFor()) {
			a.fireEvent("notify:customMessages.messagesClosed")
		}
	},
	showDialogs: function(d) {
		var c = this,
			a, b;
		if (d.length > 0) {
			for (b = 0; b < d.length; b++) {
				a = d[b];
				c.model.addDialogToWaitFor(a.id);
				if (Services.settingsManager.getSetting("autoPlayNrSpins") > 0 && (a.messageCode === c.ERRORS.DISPLAY_IMMEDIATELY_CONTINUE || a.messageCode === c.ERRORS.DISPLAY_ON_IDLE_CONTINUE || a.stopAutoplay)) {
					c.fireEvent("request:autoPlayer.stop")
				}
				c.fireEvent("request:dialogWindow.showDialog", a);
				if (a.messageCode === c.ERRORS.DISPLAY_IMMEDIATELY_CLOSE || a.messageCode === c.ERRORS.DISPLAY_ON_IDLE_CLOSE) {
					c.fireEvent("notify:customMessages.fatalMessageShowing", a.messageCode, a.text)
				}
			}
		} else {
			c.fireEvent("notify:customMessages.messagesClosed")
		}
	},
	createConfigFromMessage: function(e) {
		var d = this,
			b = d.model,
			f = d.ERRORS,
			a = {
				title: Services.languageManager.getText(Language.Keys.messageCaption),
				text: e.message,
				buttons: [],
				immediate: true,
				id: e.code,
				messageCode: e.code
			},
			c;
		switch (e.code) {
			case f.DISPLAY_IMMEDIATELY_CLOSE:
				c = b.getCloseButtonConfig(d);
				a.hideGame = true;
				break;
			case f.DISPLAY_IMMEDIATELY_CONTINUE:
				c = b.getContinueButtonConfig(d, true);
				break;
			case f.DISPLAY_ON_IDLE_CLOSE:
				c = b.getCloseButtonConfig(d);
				a.hideGame = true;
				a.immediate = false;
				break;
			case f.DISPLAY_ON_IDLE_CONTINUE:
				c = b.getContinueButtonConfig(d);
				a.immediate = false;
				break;
			default:
				throw new Error("Technical Error")
		}
		if (Sys.isDefined(c)) {
			a.buttons.push(c)
		}
		return a
	},
	prepareDialogConfig: function(a) {
		a.text = this.scrubMessageString(a.text);
		return a
	},
	scrubMessageString: function(c) {
		var a = (c.match(/(<|>)/g) || []).length > 0,
			b = document.createElement("div");
		if (a) {
			throw new Error("Technical Error")
		}
		try {
			b.innerHTML = c
		} catch (d) {
			throw new Error("Technical Error")
		}
		return c
	},
	showTechnicalError: function() {
		var a = this;
		a.model.storeData("showingError", true);
		if (a.model.readData("showingLoader")) {
			a.fireEvent("request:loaderErrorHandler.showTechnicalError")
		} else {
			a.fireEvent("request:errorManager.handleError")
		}
	},
	revertSpin: function() {
		this.fireEvent("request:moneyManager.revertBet");
		this.fireEvent("request:spin.cancelSpin")
	}
};
Core.CustomMessagesController = Sys.extend(Core.Controller, Core.CustomMessagesController, "Core.CustomMessagesController");
Sys.ns("Core");
Core.CustomMessagesModel = {
	constructor: function() {
		Core.CustomMessagesModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.roundEndQueue = [];
		a.immediateQueue = [];
		a.dialogsToWaitFor = [];
		a.storeData("isIdle", false)
	},
	addDialogToWaitFor: function(a) {
		this.dialogsToWaitFor.push(a)
	},
	removeDialogToWaitFor: function(b) {
		var a = this.dialogsToWaitFor.indexOf(b);
		if (a !== -1) {
			this.dialogsToWaitFor.splice(a, 1)
		}
	},
	hasDialogsToWaitFor: function() {
		return this.dialogsToWaitFor.length > 0
	},
	addDialog: function(a) {
		if (a.immediate) {
			this.immediateQueue.push(a)
		} else {
			this.roundEndQueue.push(a)
		}
	},
	removeDialog: function(b) {
		var a = this;
		a.spliceDialogFromQueue(a.roundEndQueue, b);
		a.spliceDialogFromQueue(a.immediateQueue, b)
	},
	spliceDialogFromQueue: function(b, d) {
		var a = b.length,
			c;
		for (c = 0; c < a; c++) {
			if (b[c].id === d) {
				return b.splice(c, 1)
			}
		}
		return undefined
	},
	popAllImmediate: function() {
		return this.immediateQueue.splice(0, this.immediateQueue.length)
	},
	popAllRoundEnd: function() {
		return this.roundEndQueue.splice(0, this.roundEndQueue.length)
	},
	popAll: function() {
		return this.popAllImmediate().concat(this.popAllRoundEnd())
	},
	hasImmediate: function() {
		return this.immediateQueue.length > 0
	},
	hasDialogs: function() {
		return (this.immediateQueue.length > 0 || this.roundEndQueue.length > 0)
	},
	getCloseButtonConfig: function(a) {
		return {
			scope: a,
			text: Services.languageManager.getText(Language.Keys.btn_casino),
			action: function() {
				Environment.goToLobby()
			}
		}
	},
	getContinueButtonConfig: function(b, a) {
		return {
			scope: b,
			text: Services.languageManager.getText(Language.Keys.btn_continue),
			action: function() {
				if (a) {
					b.revertSpin()
				}
			}
		}
	}
};
Core.CustomMessagesModel = Sys.extend(Core.Model, Core.CustomMessagesModel, "Core.CustomMessagesModel");
Sys.ns("Core");
Core.CustomMessagesDesktopModel = {
	constructor: function() {
		Core.CustomMessagesDesktopModel.superclass.constructor.apply(this, arguments)
	},
	getCloseButtonConfig: function() {}
};
Core.CustomMessagesDesktopModel = Sys.extend(Core.CustomMessagesModel, Core.CustomMessagesDesktopModel, "Core.CustomMessagesDesktopModel");
Sys.ns("Core");
Core.ServerManager = {
	constructor: function() {
		Core.ServerManager.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.ServerManagerModel,
			controller: Core.ServerManagerController
		}
	}
};
Core.ServerManager = Sys.extend(Core.Module, Core.ServerManager, "Core.ServerManager");
Sys.ns("Core");
Core.ServerManagerController = {
	constructor: function() {
		Core.ServerManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:serverManager.sendAction": a.sendAction,
			"request:serverManager.storeParameter": a.storeParameter,
			"notify:moduleLoader.finishedLoadingModules": a.initResponse
		})
	},
	initResponse: function() {
		this.fireEvent("notify:serverManager.serverResponseReceived", {
			responseText: Resources.readData("unParsedGameServerInitResponse")
		})
	},
	sendAction: function(f, b, g) {
		var e = this,
			d = e.model.getRequestURL(f),
			c, a;
		c = Sys.utils.httpGet({
			url: d
		});
		e.fireEvent("notify:serverManager.actionRequestSent", f);
		a = setTimeout(function() {
			e.fireEvent("notify:serverManager.slowRequest", c)
		}, e.model.readData("slowServerRequestTimeLimit"));
		c.done(function(h) {
			e.fireEvent("notify:serverManager.serverResponseReceived", h, b)
		}).fail(function(h) {
			e.fireEvent("notify:serverManager.serverErrorReceived", h);
			e.fireEvent("request:errorManager.handleRequestError", h);
			e.fireEvent("notify:serverManager.actionRequestError", f);
			if (Sys.isDefined(g)) {
				e.fireEvent(g, h)
			}
		}).always(function() {
			clearTimeout(a)
		})
	},
	storeParameter: function(a, b) {
		this.model.storeData("parameter:" + a, b)
	}
};
Core.ServerManagerController = Sys.extend(Core.Controller, Core.ServerManagerController, "Core.ServerManagerController");
Sys.ns("Core");
Core.ServerManagerModel = {
	constructor: function() {
		Core.ServerManagerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("queryData");
		b.storeData("queryData", a);
		b.storeData("serverURL", a.server);
		b.storeData("parameter:sessionID", Resources.readData("sessionID"));
		b.storeData("parameter:gameID", a.gameId);
		b.storeData("slowServerRequestTimeLimit", 5000)
	},
	getRequestURL: function(b) {
		var a = this.readData("serverURL") + "servlet/CasinoGameServlet;jsession=" + this.readData("parameter:sessionID") + "?" + this.getActionParameters(b) + "&no-cache=" + Sys.utils.pseudoGUID();
		a = this.doIntegrationSpecificRequestUrlUpdates(a);
		return a
	},
	doIntegrationSpecificRequestUrlUpdates: function(a) {
		return a
	},
	getActionParameters: function(a) {
		if (a === "init") {
			return this.getInitParameters(a)
		}
		return ""
	},
	getInitParameters: function(a) {
		return "action=" + a + "&sessid=" + this.readData("parameter:sessionID") + "&gameId=" + this.readData("parameter:gameID")
	}
};
Core.ServerManagerModel = Sys.extend(Core.Model, Core.ServerManagerModel, "Core.ServerManagerModel");
Sys.ns("Core");
Core.MoneyManager = {
	constructor: function() {
		Core.MoneyManager.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.MoneyManagerModel,
			controller: Core.MoneyManagerController
		}
	}
};
Core.MoneyManager = Sys.extend(Core.Module, Core.MoneyManager, "Core.MoneyManager");
Sys.ns("Core");
Core.MoneyManagerController = {
	constructor: function() {
		Core.MoneyManagerController.superclass.constructor.apply(this, arguments)
	},
	formatMoney: function(a, c, b) {
		return this.model.formatMoney(a, c, b)
	},
	formatMoneyCurrencySign: function(a, c, b) {
		return this.model.formatMoneyCurrencySign(a, c, b)
	},
	getBalanceCents: function() {
		return this.model.getBalanceCents()
	},
	getBalanceCoins: function() {
		return this.model.getBalanceCoins()
	},
	getBetCents: function() {
		return this.model.getBetCents()
	},
	getBetCoins: function() {
		return this.model.getBetCoins()
	},
	canPlaceAnotherBet: function() {
		return (this.getBetCents() <= this.getBalanceCents() || this.model.readData("inFreeRounds"))
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"notify:responseParser.responseParsed": a.onServerResponse,
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"request:moneyManager.revertBet": a.revertBet
		})
	},
	onBeforeLoaderClose: function() {
		this.notifyBalanceChange()
	},
	onSettingChanged: function(b, d) {
		var c = this,
			a = c.model;
		if (b === "betLevel") {
			if (a.setBetLevel(d)) {
				c.notifyBetChange()
			}
		} else {
			if (b === "denomination") {
				if (a.setDenomination(d)) {
					c.notifyBetChange()
				}
			}
		}
	},
	placeBet: function() {
		var a = this;
		if (!a.model.readData("inFreeRounds")) {
			a.setBalance(a.getBalanceCents() - a.getBetCents())
		}
	},
	revertBet: function() {
		var a = this;
		a.setBalance(a.getBalanceCents() + a.getBetCents());
		a.reloadBalance()
	},
	setBalance: function(a) {
		var c = this,
			b = this.model;
		if (b.setBalance(a)) {
			c.notifyBetChange();
			c.notifyBalanceChange()
		}
	},
	reloadBalance: function() {
		var b = this,
			a = new Sys.Deferred();
		b.addListener("notify:responseParser.reloadBalanceParsed", function(c) {
			b.setBalance(parseInt(c.credit, 10));
			a.resolve(c);
			b.removeListener("notify:responseParser.reloadBalanceParsed");
			b.removeListener("notify:serverManager.reloadBalanceRequestFailed");
			b.fireEvent("notify:moneyManager.balanceReloaded")
		});
		b.addListener("notify:serverManager.reloadBalanceRequestFailed", function(c) {
			a.reject(c);
			b.removeListener("notify:responseParser.reloadBalanceParsed");
			b.removeListener("notify:serverManager.reloadBalanceRequestFailed")
		});
		b.fireEvent("request:serverManager.sendAction", "reloadbalance", "notify:responseParser.reloadBalanceParsed", "notify:serverManager.reloadBalanceRequestFailed");
		return a
	},
	notifyBalanceChange: function() {
		var b = this,
			a = this.model;
		b.fireEvent("notify:moneyManager.balanceChanged", {
			denomination: a.readData("denomination"),
			playerBetCents: a.readData("playerBetCents"),
			playerBalanceCoins: a.readData("playerBalanceCoins"),
			playerBalanceCents: a.readData("playerBalanceCents"),
			playerBalanceFormatted: b.formatMoneyCurrencySign(a.readData("playerBalanceCents"))
		})
	},
	notifyBetChange: function() {
		var b = this,
			a = this.model;
		b.fireEvent("notify:moneyManager.betChanged", {
			playerBetCoins: a.readData("playerBetCoins"),
			playerBetCents: a.readData("playerBetCents"),
			playerBetFormatted: b.formatMoneyCurrencySign(a.readData("playerBetCents"))
		})
	},
	getMinimumBetCents: function() {
		return this.model.getMinimumBetInCents()
	},
	getCurrencyIsoName: function(a) {
		return this.model.getMoneyFormat(a).iso
	}
};
Core.MoneyManagerController = Sys.extend(Core.Controller, Core.MoneyManagerController, "Core.MoneyManagerController");
Sys.ns("Core");
Core.MoneyManagerModel = {
	constructor: function() {
		Core.MoneyManagerModel.superclass.constructor.apply(this, arguments)
	},
	formatMoney: function(g, j, d) {
		var a = this.getMoneyFormat(j),
			h = "",
			f, b, k, c, e;
		e = Sys.isDefined(d) ? d : 2;
		f = (Math.floor(g) / 100).toFixed(e).split(".");
		b = f[0];
		for (c = 0; c < b.length; c++) {
			if (c > 0 && c % 3 === 0) {
				h = a.thousandsDivider + h
			}
			h = b[b.length - c - 1] + h
		}
		k = f[1];
		if (k) {
			h += a.decimalDivider + k
		}
		return h
	},
	formatMoneyCurrencySign: function(a, f, b) {
		var c = this.getMoneyFormat(f),
			e, d;
		d = this.formatMoney(a, f, b);
		e = c.currencyChar;
		if (c.isCurrCharAfter) {
			return d + (e.length > 1 ? " " : "") + e
		}
		return e + (e.length > 1 ? " " : "") + d
	},
	getCurrency: function(a) {
		return this.getMoneyFormat(a).currencyChar
	},
	processServerResponse: function(a) {
		if (Sys.isDefined(a.credit)) {
			this.setBalance(a.credit)
		}
	},
	setBalance: function(b) {
		var a = parseInt(b, 10);
		if (!isNaN(a) && a >= 0) {
			this.storeData("playerBalanceCents", a);
			this.storeData("playerBalanceCoins", Math.floor(a / this.readData("denomination")));
			return true
		}
		return false
	},
	setBetLevel: function(c) {
		var b = this,
			a;
		if (c > 0 && Math.floor(c) === c) {
			b.storeData("betLevel", c);
			a = c * b.readData("betlineCoins");
			b.storeData("playerBetCoins", a);
			b.storeData("playerBetCents", a * b.readData("denomination"));
			return true
		}
		return false
	},
	setDenomination: function(b) {
		var a = this;
		if (b > 0) {
			a.storeData("denomination", b);
			a.storeData("playerBetCents", a.readData("playerBetCoins") * b);
			a.storeData("playerBalanceCoins", Math.floor(a.readData("playerBalanceCents") / b));
			return true
		}
		return false
	},
	getBalanceCents: function() {
		return this.readData("playerBalanceCents")
	},
	getBalanceCoins: function() {
		return this.readData("playerBalanceCoins")
	},
	getBetCents: function() {
		return this.readData("playerBetCents")
	},
	getBetCoins: function() {
		return this.readData("playerBetCoins")
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponse");
		b.setupMoneyHandling();
		b.setBalance(Number(a.credit));
		b.storeData("betlineCoins", b.getBetlineCoinValue(a));
		b.storeData("inFreeRounds", parseInt(a.freeRoundsLeft, 10) > 0);
		b.calculateMinimumBetInCents()
	},
	getBetlineCoinValue: function(d) {
		var b = d["bl.standard"].split(","),
			e = b.length,
			a = 0,
			c;
		for (c = -1; ++c < e;) {
			a += Sys.utils.toInt(d["bl.i" + c + ".coins"])
		}
		return a
	},
	calculateMinimumBetInCents: function() {
		var c = this,
			b = Resources.readData("gameServerInitResponseObject"),
			d = b.betlevel.all,
			h = b.denomination.all,
			g = c.validateArray(d),
			f = c.validateArray(h),
			a = c.readData("betlineCoins"),
			e = g[0] * a * f[0];
		c.setMinimumBetInCents(e)
	},
	validateArray: function(a) {
		if (!Sys.isArray(a)) {
			return [a]
		}
		return a.slice(0).sort(function(d, c) {
			return d - c
		})
	},
	setMinimumBetInCents: function(a) {
		this.storeData("minimumBetInCents", a)
	},
	getMinimumBetInCents: function() {
		return this.readData("minimumBetInCents")
	},
	setupMoneyHandling: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponse");
		b.language = a.language;
		b.availableFormats = ["player", "jackpot"];
		b.moneyFormats = {
			player: Sys.utils.XMLHelper.getMoneyFormatFromXML(Resources.readData("moneyformat_player"), a.playercurrencyiso),
			jackpot: Sys.utils.XMLHelper.getMoneyFormatFromXML(Resources.readData("moneyformat_jackpot"), a.jackpotcurrencyiso)
		};
		if (!Sys.isDefined(b.moneyFormats.player)) {
			throw new Error("The player currency format is missing!")
		}
		if (!Sys.isDefined(b.moneyFormats.jackpot)) {
			throw new Error("The jackpot currency format is missing!")
		}
	},
	getMoneyFormat: function(a) {
		var b = a;
		if (!this.availableFormats.contains(b)) {
			b = "player"
		}
		return this.moneyFormats[b]
	}
};
Core.MoneyManagerModel = Sys.extend(Core.Model, Core.MoneyManagerModel, "Core.MoneyManagerModel");
Sys.ns("Core");
Core.SettingsManager = {
	constructor: function() {
		Core.SettingsManager.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.SettingsManagerModel,
			controller: Core.SettingsManagerController
		}
	}
};
Core.SettingsManager = Sys.extend(Core.Module, Core.SettingsManager, "Core.SettingsManager");
Sys.ns("Core");
Core.SettingsManagerController = {
	constructor: function() {
		Core.SettingsManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:settingsManager.storeData": a.storeSetting,
			"request:settingsManager.lockSetting": a.lockSetting,
			"request:settingsManager.unlockSetting": a.unlockSetting,
			"request:settingsManager.disableSetting": a.disableSetting,
			"request:settingsManager.enableSetting": a.enableSetting
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:settingsManager.settingChanged", this, "When the settings are changed")
	},
	isSettable: function(a) {
		var b = this;
		return !b.model.isLocked(a) && !b.model.isDisabled(a)
	},
	storeSetting: function(c, e, f, a) {
		var d = this,
			b;
		if (!d.model.isLocked(c) && !d.model.isDisabled(c)) {
			b = d.model.readData("settings");
			if (b[c] !== e) {
				b[c] = e;
				d.model.storeData("settings", b);
				if (f) {
					Services.localStorageManager.storeData(c, Sys.isString(e) ? e : JSON.stringify(e))
				}
				if (!a) {
					d.fireEvent("notify:settingsManager.settingChanged", c, e)
				}
			}
		}
	},
	getSetting: function(a) {
		return this.model.readData("settings")[a]
	},
	lockSetting: function(b, a) {
		var c = this.model.readData("lockedSettings");
		if (!Sys.isArray(c[b])) {
			c[b] = []
		}
		if (!c[b].contains(a)) {
			c[b].push(a);
			this.model.storeData("lockedSettings", c);
			if (c[b].length === 1) {
				this.fireEvent("notify:settingsManager.settingLocked", b)
			}
		}
	},
	unlockSetting: function(b, a) {
		var c = this.model.readData("lockedSettings");
		if (Sys.isArray(c[b]) && c[b].contains(a)) {
			c[b].splice(c[b].indexOf(a), 1);
			this.model.storeData("lockedSettings", c);
			if (c[b].length === 0) {
				this.fireEvent("notify:settingsManager.settingUnlocked", b)
			}
		}
	},
	disableSetting: function(a) {
		var b = this;
		b.model.readData("disabledSettings")[a] = true;
		b.fireEvent("notify:settingsManager.settingDisabled", a)
	},
	enableSetting: function(a) {
		var b = this;
		b.model.readData("disabledSettings")[a] = false;
		b.fireEvent("notify:settingsManager.settingEnabled", a)
	}
};
Core.SettingsManagerController = Sys.extend(Core.Controller, Core.SettingsManagerController, "Core.SettingsManagerController");
Sys.ns("Core");
Core.SettingsManagerModel = {
	constructor: function() {
		Core.SettingsManagerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.data = {
			settings: {},
			lockedSettings: {},
			disabledSettings: {}
		}
	},
	isLocked: function(b) {
		var a = this.readData("lockedSettings")[b];
		return Sys.isArray(a) && a.length > 0
	},
	isDisabled: function(a) {
		return this.readData("disabledSettings")[a]
	}
};
Core.SettingsManagerModel = Sys.extend(Core.Model, Core.SettingsManagerModel, "Core.SettingsManagerModel");
Sys.ns("Core");
Core.StopGame = {
	constructor: function() {
		Core.StopGame.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Core.StopGameController,
			view: Core.StopGameView
		}
	}
};
Core.StopGame = Sys.extend(Core.Module, Core.StopGame, "Core.StopGame");
Sys.ns("Core");
Core.StopGameController = {
	constructor: function() {
		Core.StopGameController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:stopGame.disable": a.disable,
			"request:stopGame.pause": a.pause
		})
	},
	disable: function() {
		this.pause();
		this.view.displayOverlay()
	},
	disableAnimations: function() {
		this.fireEvent("request:stage.pauseAnimation")
	},
	disableAudio: function() {
		this.fireEvent("request:audioPlayer.stopAll");
		Services.settingsManager.storeSetting("volume", 0)
	},
	disableInterface: function() {
		var a = this;
		a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
		a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME)
	},
	pause: function() {
		this.disableInterface();
		this.disableAnimations();
		this.disableAudio()
	}
};
Core.StopGameController = Sys.extend(Core.Controller, Core.StopGameController, "Core.StopGameController");
Sys.ns("Core");
Core.StopGameView = {
	constructor: function() {
		Core.StopGameView.superclass.constructor.apply(this, arguments)
	},
	displayOverlay: function() {
		this.overlay.el.style.display = "block"
	},
	initAnimations: function() {
		this.overlay = new Sys.Element({
			tag: "div",
			id: "stopGameOverlay",
			cls: "stopGameOverlay",
			style: "display:none",
			renderTo: "gameWrapper"
		})
	}
};
Core.StopGameView = Sys.extend(Core.View, Core.StopGameView, "Core.StopGameView");
Sys.ns("Core");
Core.RealityCheck = {
	CONTROL_STATE: "idle",
	constructor: function() {
		Core.RealityCheck.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse"]
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				realityCheck: {
					state: {
						name: "RealityCheck",
						execute: function(c) {},
						waitEvents: {
							"notify:realityCheck:completed": false
						}
					}
				}
			};
		b[this.CONTROL_STATE] = {
			queue: [function(c) {
				if (a.isTimeToDoRealityCheck()) {
					c.stateHandler.pushState(c.states.realityCheck)
				}
			}]
		};
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.RealityCheckModel,
			view: Core.View,
			controller: Core.RealityCheckController
		}
	}
};
Core.RealityCheck = Sys.extend(Core.Module, Core.RealityCheck, "Core.RealityCheck");
Sys.ns("Core");
Core.RealityCheckController = {
	constructor: function() {
		Core.RealityCheckController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringRealityCheckState": a.doRealityCheck,
			"notify:responseParser.rcInfoParsed": a.handleInfoResponse,
			"notify:responseParser.rcInfoReset": a.handleResetResponse,
			"notify:responseParser.responseParsed": a.handleGenericResponse
		})
	},
	sendServerAction: function(a, b) {
		this.model.setState("requestPending");
		this.fireEvent("request:serverManager.sendAction", a, b)
	},
	handleResetResponse: function(a) {
		var b = this;
		b.model.storeData("msUntilTimeout", a.rc.msuntiltimeout);
		b.model.storeData("lastCheckTime", Date.now())
	},
	handleInfoResponse: function(b) {
		var d = this,
			a = b.rc,
			c, f, e;
		if (Sys.isDefined(a) && a.msuntiltimeout <= 0) {
			e = Math.round(a.duration / 60 / 60 / 10) / 100;
			if (a.totalwin >= 0) {
				f = a.totalwin;
				c = Language.Keys.rc_checkPlayingWon
			} else {
				f = Sys.utils.toInt(-a.totalwin);
				c = Language.Keys.rc_checkPlayingLost
			}
			d.requestDialog(Services.languageManager.getText(c, [e, Services.moneyManager.formatMoneyCurrencySign(f)]));
			d.model.setState("dialogOpen")
		} else {
			d.handleResetResponse(b);
			d.complete()
		}
	},
	requestDialog: function(a) {
		this.fireEvent("request:dialogWindow.showDialog", this.model.getDialog(a, this))
	},
	complete: function() {
		this.fireEvent("notify:realityCheck:completed")
	},
	doRealityCheck: function() {
		this.sendServerAction("rcinfo", "notify:responseParser.rcInfoParsed")
	}
};
Core.RealityCheckController = Sys.extend(Core.Controller, Core.RealityCheckController, "Core.RealityCheckController");
Sys.ns("Core");
Core.RealityCheckModel = {
	constructor: function() {
		Core.RealityCheckModel.superclass.constructor.apply(this, arguments)
	},
	getDialog: function(b, a) {
		return {
			title: Services.languageManager.getText(Language.Keys.rc_checkReminder),
			text: b,
			buttons: [{
				scope: a,
				text: Services.languageManager.getText(Language.Keys.btn_casino),
				action: function() {
					Environment.goToLobby("0")
				}
			}, {
				scope: a,
				text: Services.languageManager.getText(Language.Keys.btn_continue),
				action: function() {
					a.sendServerAction("rcreset", "notify:responseParser.rcInfoReset");
					a.complete()
				}
			}]
		}
	},
	setupData: function() {
		var c = this,
			a = Resources.readData("gameServerInitResponse"),
			b = (Sys.isDefined(a["rc.enabled"]) && Sys.utils.strIsTrue(a["rc.enabled"]));
		if (Sys.isDefined(a.freeRoundsLeft) && Number(a.freeRoundsLeft) > 0) {
			b = false
		}
		c.storeData("rcEnabled", b);
		if (b) {
			if (Sys.isDefined(a["rc.msuntiltimeout"])) {
				c.storeData("msUntilTimeout", Sys.utils.toInt(a["rc.msuntiltimeout"]));
				c.storeData("lastCheckTime", Date.now())
			} else {
				c.storeData("rcEnabled", false)
			}
		}
	},
	processServerResponse: function(a) {
		this.storeData("nextAction", a.nextaction)
	},
	isTimeToDoRealityCheck: function() {
		var a = this,
			b;
		if (a.readData("rcEnabled")) {
			b = a.readData("lastCheckTime") + a.readData("msUntilTimeout") <= Date.now();
			if (a.readData("nextAction") === "spin" && b) {
				return true
			}
		}
		return false
	}
};
Core.RealityCheckModel = Sys.extend(Core.Model, Core.RealityCheckModel, "Core.RealityCheckModel");
Sys.ns("Core");
Core.RealityCheckDesktopModel = {
	constructor: function() {
		Core.RealityCheckDesktopModel.superclass.constructor.apply(this, arguments)
	},
	getDialog: function(b, a) {
		return {
			title: Services.languageManager.getText(Language.Keys.rc_checkReminder),
			text: b,
			buttons: [{
				scope: a,
				text: Services.languageManager.getText(Language.Keys.btn_checkEnd),
				action: function() {
					a.fireEvent("request:stopGame.disable")
				}
			}, {
				scope: a,
				text: Services.languageManager.getText(Language.Keys.btn_continue),
				action: function() {
					a.sendServerAction("rcreset", "notify:responseParser.rcInfoReset");
					a.complete()
				}
			}]
		}
	}
};
Core.RealityCheckDesktopModel = Sys.extend(Core.RealityCheckModel, Core.RealityCheckDesktopModel, "Core.RealityCheckDesktopModel");
Sys.ns("Core.Slots");
Core.Slots.RealityCheck = {
	CONTROL_STATE: "stopped",
	constructor: function() {
		Core.Slots.RealityCheck.superclass.constructor.apply(this, arguments)
	}
};
Core.Slots.RealityCheck = Sys.extend(Core.RealityCheck, Core.Slots.RealityCheck, "Core.Slots.RealityCheck");
Sys.ns("Core");
Core.KeepAlive = {
	constructor: function() {
		Core.KeepAlive.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.KeepAliveModel,
			view: Core.View,
			controller: Core.KeepAliveController
		}
	}
};
Core.KeepAlive = Sys.extend(Core.Module, Core.KeepAlive, "Core.KeepAlive");
Sys.ns("Core");
Core.KeepAliveController = {
	constructor: function() {
		Core.KeepAliveController.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Core.KeepAliveController.superclass.init.apply(a, arguments);
		if (a.model.readData("url")) {
			a.keepAlive()
		}
	},
	keepAlive: function() {
		var c = this,
			a = c.model.readData("interval"),
			b = Sys.utils.httpGet({
				url: c.model.readData("url"),
				handleError: false,
				showTimeoutDialog: false
			});
		b.always(function() {
			setTimeout(function() {
				c.keepAlive()
			}, a)
		})
	}
};
Core.KeepAliveController = Sys.extend(Core.Controller, Core.KeepAliveController, "Core.KeepAliveController");
Sys.ns("Core");
Core.KeepAliveModel = {
	constructor: function() {
		Core.KeepAliveModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var d = this,
			b = Resources.readData("queryData"),
			c = b.keepAliveURL,
			e = Resources.readData("sessionID"),
			a = b.keepAliveInterval;
		if (Sys.isDefined(c) && Sys.isDefined(a) && Sys.isDefined(e) && Sys.utils.isUrl(c) && Sys.utils.toInt(a) >= 5) {
			d.storeData("url", c + "?sessId=" + e);
			d.storeData("interval", a * 1000)
		}
	}
};
Core.KeepAliveModel = Sys.extend(Core.Model, Core.KeepAliveModel, "Core.KeepAliveModel");
Sys.ns("Core");
Core.PlayForRealPromo = {
	constructor: function() {
		Core.PlayForRealPromo.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			idle: {
				waitEvents: ["notify:playForRealPromo:completed"]
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.PlayForRealPromoModel,
			view: Core.View,
			controller: Core.PlayForRealPromoController
		}
	}
};
Core.PlayForRealPromo = Sys.extend(Core.Module, Core.PlayForRealPromo, "Core.PlayForRealPromo");
Sys.ns("Core");
Core.PlayForRealPromoController = {
	constructor: function() {
		Core.PlayForRealPromoController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
			"request:playForRealPromo:enable": a.onEnable,
			"request:playForRealPromo:disable": a.onDisable
		})
	},
	onEnteringIdleState: function() {
		var b = this,
			a = b.model.readData("roundsLeft");
		if (a === 0 && !b.isDisabled) {
			b.requestDialog()
		} else {
			b.complete()
		}
		if (Sys.isDefined(a)) {
			b.model.handleRounds()
		}
	},
	requestDialog: function() {
		this.fireEvent("request:dialogWindow.showDialog", this.model.getDialog(this))
	},
	complete: function() {
		this.fireEvent("notify:playForRealPromo:completed")
	},
	onEnable: function() {
		this.isDisabled = false
	},
	onDisable: function() {
		this.isDisabled = true
	}
};
Core.PlayForRealPromoController = Sys.extend(Core.Controller, Core.PlayForRealPromoController, "Core.PlayForRealPromoController");
Sys.ns("Core");
Core.PlayForRealPromoModel = {
	constructor: function() {
		Core.PlayForRealPromoModel.superclass.constructor.apply(this, arguments)
	},
	getDialog: function(a) {
		return {
			title: Services.languageManager.getText(Language.Keys.youPlayingForFun),
			buttons: [{
				text: Services.languageManager.getText(Language.Keys.btn_login),
				scope: a,
				action: function() {
					Environment.goToLobby("4")
				}
			}, {
				text: Services.languageManager.getText(Language.Keys.btn_continue),
				scope: a,
				action: function() {
					a.complete()
				}
			}]
		}
	},
	setupData: function() {
		var c = this,
			b = Resources.readData("gameServerInitResponse"),
			a;
		if (b.playforfun && Sys.isDefined(b["playforrealpromo.rounds"])) {
			a = Sys.utils.toInt(b["playforrealpromo.rounds"]);
			c.storeData("roundsLeft", a);
			c.storeData("rounds", a)
		}
	},
	handleRounds: function() {
		var a = this.readData("roundsLeft"),
			b;
		if (a === 0) {
			b = this.readData("rounds")
		} else {
			b = --a
		}
		this.storeData("roundsLeft", b)
	}
};
Core.PlayForRealPromoModel = Sys.extend(Core.Model, Core.PlayForRealPromoModel, "Core.PlayForRealPromoModel");
Sys.ns("Core");
Core.PlayForRealPromoDesktopModel = {
	constructor: function() {
		Core.PlayForRealPromoDesktopModel.superclass.constructor.apply(this, arguments)
	},
	getDialog: function(a) {
		return {
			title: Services.languageManager.getText(Language.Keys.youPlayingForFun),
			buttons: [{
				text: Services.languageManager.getText(Language.Keys.btn_continue),
				scope: a,
				action: function() {
					a.complete()
				}
			}]
		}
	}
};
Core.PlayForRealPromoDesktopModel = Sys.extend(Core.PlayForRealPromoModel, Core.PlayForRealPromoDesktopModel, "Core.PlayForRealPromoDesktopModel");
Sys.ns("Core");
Core.CountUp = {
	constructor: function() {
		Core.CountUp.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.CountUpModel,
			view: Core.CountUpView,
			controller: Core.CountUpController
		}
	}
};
Core.CountUp = Sys.extend(Core.Module, Core.CountUp, "Core.CountUp");
Sys.ns("Core");
Core.CountUpModel = {
	constructor: function() {
		Core.CountUpModel.superclass.constructor.apply(this, arguments);
		this.setState("stopped")
	},
	setupData: function() {
		this.defineEasingMethods()
	},
	defineEasingMethods: function() {
		var a = {
			"ease-in": 0,
			"ease-out": 1,
			linear: 0.5
		};
		this.storeData("easingMethods", a)
	}
};
Core.CountUpModel = Sys.extend(Core.Model, Core.CountUpModel, "Core.CountUpModel");
Sys.ns("Core");
Core.CountUpView = {
	NUMBER_IMAGE: undefined,
	NUMBER_WIDTH: 80,
	NUMBER_HEIGHT: 100,
	NUMBER_FONT: "bold 100px Verdana",
	NUMBER_OFFSET: 0,
	NUMBER_TEXT_OPERATIONS: [{
		fillStyle: "#FFFFFF"
	}, {
		lineWidth: 5,
		strokeStyle: "#00000",
		drawType: "stroke"
	}],
	COUNT_UP_LEFT: undefined,
	COUNT_UP_TOP: 250,
	COUNT_UP_DEPTH: 100,
	COUNT_UP_EASING_TYPE: "ease-out",
	SHOW_TOTAL_DURATION: 3000,
	constructor: function() {
		var a = {
			COUNT_UP_LEFT: this.COUNT_UP_LEFT,
			COUNT_UP_TOP: this.COUNT_UP_TOP
		};
		Core.CountUpView.superclass.constructor.apply(this, arguments);
		this.CONFIG = this.CONFIG || {};
		this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
		Sys.applyProperties(this.CONFIG.DEFAULT, a)
	},
	configureStartAnimation: function(a) {},
	configureEndAnimation: function() {},
	createItems: function() {
		var a = this;
		a.countUpItem = a.createCountUpItem();
		a.list.add(a.countUpItem)
	},
	initAnimations: function() {
		this.scaleFactor = this.getScaleFactor();
		this.createList();
		this.createItems();
		Game.stage.view.addToRenderLoop(this.list);
		this.list.stop()
	},
	getScaleFactor: function() {
		return Resources.readData("config").mobileResourceToVirtualScale || 1
	},
	refresh: function() {
		var b = this.scaleFactor,
			a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
		if (Animation.utils.isAnimationItem(this.countUpItem)) {
			this.countUpItem.setLeft(Math.round(a.COUNT_UP_LEFT * b) || Environment.getStageResolution().width / 2);
			this.countUpItem.setTop(Math.round(a.COUNT_UP_TOP * b))
		}
	},
	createList: function() {
		this.list = new Animation.CanvasAnimationList({})
	},
	createCountUpItem: function() {
		var b = this,
			a = Environment.getOrientationSpecificConfig(this.CONFIG, true),
			c = Animation.utils.text.createNumberDrawingProperties(b);
		return new Animation.CanvasAnimationItem({
			left: Math.round(a.COUNT_UP_LEFT * b.scaleFactor) || Environment.getStageResolution().width / 2,
			top: Math.round(a.COUNT_UP_TOP * b.scaleFactor),
			width: 0,
			height: 0,
			depth: b.COUNT_UP_DEPTH,
			executeBefore: function(d) {
				var f, g, h = this.value.toString(),
					e;
				Animation.utils.text.drawTextFromImage(h, b.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, c.image, c.charMap, c.width, c.height, d);
				if (Sys.isDefined(this.fireOnValue)) {
					f = this.fireOnValue.length;
					for (e = -1; ++e < f;) {
						g = this.fireOnValue[e];
						if (!g.fired && this.value >= g.value) {
							g.scope.fireEvent(g.event, g.argument);
							g.fired = true
						}
					}
				}
			},
			operations: {}
		})
	},
	setCountUpValues: function(a) {
		var b = this,
			c = b.countUpItem.prop;
		c.fireOnValue = a.fireEventsOnValue;
		c.operations = {
			value: [{
				time: 0,
				value: a.from,
				support: b.model.readData("easingMethods")[b.COUNT_UP_EASING_TYPE] * a.to,
				numDecimals: 0
			}, {
				time: a.duration,
				value: a.to,
				fireEvent: {
					event: "view:countUpComplete",
					scope: b
				}
			}, {
				time: a.duration + 1,
				value: a.to
			}, {
				time: a.duration + 2,
				value: a.to,
				goTo: 2
			}]
		};
		b.configureStartAnimation(a.duration)
	},
	start: function(a) {
		this.list.restore();
		this.setCountUpValues(a);
		this.list.play()
	},
	stop: function() {
		this.list.stop()
	},
	pause: function() {
		this.list.pause()
	},
	resume: function() {
		this.list.play()
	},
	showTotal: function(e) {
		var c = this,
			b, d = [],
			a;
		e = e || {};
		c.list.stop();
		b = c.countUpItem.prop.operations.value[1].value;
		c.countUpItem.prop.fireOnValue.length = 0;
		c.list.restore();
		d.push({
			value: b,
			time: 0
		});
		if (e.showUntilStopped) {
			d.push({
				value: b,
				time: 1,
				goTo: 0
			})
		} else {
			a = Sys.isDefined(e.showDuration) ? e.showDuration : c.SHOW_TOTAL_DURATION;
			d.push({
				value: b,
				time: a,
				fireEvent: {
					event: "view:showTotalDurationPassed",
					scope: c
				}
			})
		}
		c.countUpItem.value(d);
		c.configureEndAnimation(a);
		c.list.play()
	}
};
Core.CountUpView = Sys.extend(Core.View, Core.CountUpView, "Core.CountUpView");
Sys.ns("Core");
Core.CountUpController = {
	constructor: function() {
		Core.CountUpController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this,
			b = {
				"view:countUpComplete": a.onCountUpComplete,
				"view:showTotalDurationPassed": a.stop,
				"notify:scaling.gameSizeChanged": a.onGameSizeChanged
			};
		b["request:" + a.MODULE_NAME + ".start"] = a.start;
		b["request:" + a.MODULE_NAME + ".pause"] = a.pause;
		b["request:" + a.MODULE_NAME + ".resume"] = a.resume;
		b["request:" + a.MODULE_NAME + ".stop"] = a.stop;
		b["request:" + a.MODULE_NAME + ".showTotal"] = a.showTotal;
		a.on(b)
	},
	start: function(a) {
		this.view.start(a);
		this.model.setState("countingUp")
	},
	stop: function() {
		var a = this;
		if (!a.model.isState("stopped")) {
			a.model.setState("stopped");
			a.view.stop();
			a.fireEvent("notify:" + this.MODULE_NAME + ".hidden")
		}
	},
	pause: function() {
		this.view.pause()
	},
	resume: function() {
		if (!this.model.isState("stopped")) {
			this.view.resume()
		}
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	showTotal: function(a) {
		if (!this.model.isState("showingTotal")) {
			this.view.showTotal(a);
			this.model.setState("showingTotal")
		}
	},
	onCountUpComplete: function() {
		this.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
	}
};
Core.CountUpController = Sys.extend(Core.Controller, Core.CountUpController, "Core.CountUpController");
Sys.ns("Core");
Core.DialogWindow = {
	constructor: function() {
		Core.DialogWindow.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.DialogWindowModel,
			view: Core.DialogWindowBaseView,
			controller: Core.DialogWindowController
		}
	},
	getMixinDependencies: function() {
		return [{
			userInput: {
				inputEvents: ["start", "end", "move", "scroll"]
			}
		}, "orientation"]
	}
};
Core.DialogWindow = Sys.extend(Core.Module, Core.DialogWindow, "Core.DialogWindow");
Sys.ns("Core");
Core.DialogWindowController = {
	constructor: function() {
		Core.DialogWindowController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var b = this,
			a = {
				"request:dialogWindow.showDialog": b.onShowDialogRequest,
				"request:dialogWindow.removeDialog": b.onRemoveDialogRequest,
				"request:dialogWindow.closeCurrentDialog": b.onCloseDialogRequest,
				"view:dialogShown": b.onDialogShown,
				"view:showingDialog": b.onShowingDialog,
				"view:pauseGame": b.pauseGame,
				"notify:scaling.gameSizeChanged": b.onGameSizeChanged,
				"notify:viewport.scaled": b.onGameSizeChanged
			};
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveStart"] = b.onUserInputStart;
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveEnd"] = b.onUserInputEnd;
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveMove"] = b.onUserInputMove;
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveScroll"] = b.onUserInputScroll;
		b.on(a)
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	onShowDialogRequest: function(a) {
		var b = this;
		if (!b.model.isState("showing")) {
			b.view.showDialog(a);
			if (Sys.isFunc(this.view.refresh)) {
				this.view.refresh()
			}
		} else {
			if (a.fatal && !b.model.readData("currentDialogConfig").fatal) {
				b.model.addAsFirst(a);
				b.view.closeCurrentDialog()
			} else {
				b.model.queue(a)
			}
		}
	},
	onRemoveDialogRequest: function(d) {
		var c = this,
			a = c.model.isState("showing"),
			b = c.model.readData("currentDialogConfig");
		if (a && Sys.isDefined(b) && Sys.isDefined(b.id) && b.id === d) {
			c.view.closeCurrentDialog();
			c.fireEvent("request:userInputManager.deactivateExclusivity", c.MODULE_NAME)
		} else {
			this.model.remove(d)
		}
	},
	onCloseDialogRequest: function() {
		var a = this;
		if (Sys.isDefined(a.model.readData("currentDialogConfig")) && !a.model.readData("currentDialogConfig").fatal) {
			a.view.closeCurrentDialog();
			a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME)
		}
	},
	onDialogShown: function(a) {
		var b = this;
		if (b.model.hasQueuedDialog()) {
			b.view.showNextDialog()
		} else {
			b.fireEvent("request:quickSettingsMenu.externalActivate", b.MODULE_NAME);
			b.fireEvent("request:enableBasicGamePanel", b.MODULE_NAME);
			b.fireEvent("notify:dialogWindow.allDialogsClosed")
		}
		b.fireEvent("notify:dialogWindow.dialogShown", a.id)
	},
	onShowingDialog: function() {
		var a = this;
		a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
		a.fireEvent("request:quickSettingsMenu.externalDeactivate", a.MODULE_NAME);
		a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
		a.fireEvent("notify.dialogWindow.showingDialog")
	},
	pauseGame: function() {
		this.fireEvent("request:stopGame.pause")
	},
	onUserInputStart: function(c) {
		var b = this,
			a = b.view.getButtonFromCoordinate(c);
		b.view.handleScrolling("start", c);
		if (a) {
			b.model.storeData("activeButton", a)
		}
	},
	onUserInputEnd: function(d) {
		var c = this,
			a = Sys.UserInputUtils.getDOMElementFromCoordinates(d),
			b = c.model.readData("activeButton");
		c.view.handleScrolling("end", d);
		if (Sys.isDefined(b) && Sys.UserInputUtils.isParentAndChildElements(b.element, a)) {
			b.action();
			c.fireEvent("request:userInputManager.deactivateExclusivity", c.MODULE_NAME)
		}
		c.model.removeData("activeButton")
	},
	onUserInputMove: function(a) {
		this.view.handleScrolling("move", a)
	},
	onUserInputScroll: function(b, a) {
		this.view.handleScrolling("scroll", b, a)
	},
	onPortrait: function() {
		this.view.handleScrolling("orientation")
	},
	onLandscape: function() {
		this.view.handleScrolling("orientation")
	}
};
Core.DialogWindowController = Sys.extend(Core.Controller, Core.DialogWindowController, "Core.DialogWindowController");
Sys.ns("Core");
Core.DialogWindowModel = {
	constructor: function() {
		Core.DialogWindowModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.requestQueue = [];
		Services.storage.storeData("dialog.showing", false)
	},
	queue: function(a) {
		this.requestQueue.push(a)
	},
	addAsFirst: function(a) {
		this.requestQueue.unshift(a)
	},
	getNextDialogConfig: function() {
		if (this.requestQueue.length > 0) {
			return this.requestQueue.shift()
		}
		return undefined
	},
	remove: function(b) {
		var a;
		for (a = 0; a < this.requestQueue.length; a++) {
			if (this.requestQueue[a].id === b) {
				this.requestQueue.splice(a, 1);
				break
			}
		}
	},
	hasQueuedDialog: function() {
		return this.requestQueue.length > 0
	}
};
Core.DialogWindowModel = Sys.extend(Core.Model, Core.DialogWindowModel, "Core.DialogWindowModel");
Sys.ns("Core");
Core.DialogWindowView = {
	constructor: function() {
		Core.DialogWindowView.superclass.constructor.apply(this, arguments);
		this.dialogDOMElement = new Core.DialogWindowDOMElement()
	},
	button1Clicked: function() {
		var a = this.model.readData("currentDialogConfig");
		this.handleButtonClick(a.buttons[0], !a.fatal)
	},
	button2Clicked: function() {
		var a = this.model.readData("currentDialogConfig");
		this.handleButtonClick(a.buttons[1], !a.fatal)
	},
	handleButtonClick: function(b, a) {
		if (b && b.action) {
			b.action.call(b.scope || window)
		}
		if (a) {
			this.closeCurrentDialog()
		}
	},
	hideGame: function() {
		document.getElementById("gameWrapper").classList.add("hideGame");
		this.fireEvent("view:pauseGame")
	},
	showDialog: function(a) {
		var c = this,
			b = c.dialogDOMElement;
		b.setTitle(a.title);
		b.setMessage(a.text);
		b.setScrollable(b.text.el.textContent.length > 150);
		b.hideButtons();
		if (a.buttons.length === 2) {
			b.showDualButtons(a.buttons[0].text, a.buttons[1].text)
		} else {
			if (a.buttons.length === 1) {
				b.showSingleButton(a.buttons[0].text)
			}
		}
		c.model.storeData("currentDialogConfig", a);
		c.model.setState("showing");
		c.fireEvent("view:showingDialog");
		b.show();
		Services.storage.storeData("dialog.showing", true);
		c.dialogDOMElement.scroll.show();
		c.dialogDOMElement.scroll.scrollTo(0, 0, false);
		if (Sys.isDefined(a.hideGame) && a.hideGame) {
			c.hideGame()
		}
	},
	getButtonFromCoordinate: function(h) {
		var e = this,
			c = Sys.UserInputUtils.getDOMElementFromCoordinates(h),
			a = e.dialogDOMElement.singleButton.getContainer().el,
			b = e.dialogDOMElement.leftDualButton.getContainer().el,
			f = e.dialogDOMElement.rightDualButton.getContainer().el,
			g, d;
		if (Sys.UserInputUtils.isParentAndChildElements(a, c)) {
			g = a
		}
		if (!Sys.isDefined(g) && Sys.UserInputUtils.isParentAndChildElements(b, c)) {
			g = b
		}
		if (!Sys.isDefined(g) && Sys.UserInputUtils.isParentAndChildElements(f, c)) {
			g = f
		}
		switch (g) {
			case a:
			case b:
				d = e.button1Clicked.bind(e);
				break;
			case f:
				d = e.button2Clicked.bind(e);
				break;
			default:
				return undefined
		}
		return {
			element: g,
			action: d
		}
	},
	showNextDialog: function() {
		var a = this.model.getNextDialogConfig();
		if (a) {
			this.showDialog(a)
		}
	},
	closeCurrentDialog: function() {
		this.dialogDOMElement.close();
		this.model.setState("idle");
		this.fireEvent("view:dialogShown", this.model.readData("currentDialogConfig"));
		Services.storage.storeData("dialog.showing", false)
	},
	handleScrolling: function(a, d, c) {
		var b = this;
		if (b.dialogDOMElement.scroll) {
			switch (a) {
				case "start":
					b.dialogDOMElement.scroll.onUserInputStart(d);
					break;
				case "end":
					b.dialogDOMElement.scroll.onUserInputEnd(d);
					break;
				case "move":
					b.dialogDOMElement.scroll.onUserInputMove(d);
					break;
				case "scroll":
					b.dialogDOMElement.scroll.onUserInputScroll(d, c);
					break;
				case "orientation":
					b.dialogDOMElement.scroll.show();
					break;
				default:
			}
		}
	}
};
Core.DialogWindowView = Sys.extend(Core.View, Core.DialogWindowView, "Core.DialogWindowView");
Sys.ns("Gui");
Core.DialogWindowDOMElement = {
	constructor: function() {
		var a = this;
		a.initParentAsWrapper();
		a.initContainer();
		a.initTitle();
		a.initText();
		a.initButtonContainer();
		a.initSingleButton();
		a.initDualButtons()
	},
	initParentAsWrapper: function() {
		Core.DialogWindowDOMElement.superclass.constructor.call(this, {
			tag: "div",
			id: "dialogWindowWrapper",
			cls: "dialogWindowWrapper hidden"
		});
		document.body.appendChild(this.getEl())
	},
	initContainer: function() {
		this.container = new Sys.Element({
			tag: "div",
			id: "dialogWindowContainer",
			cls: "dialogWindowContainer"
		});
		this.add(this.container)
	},
	initTitle: function() {
		this.title = this.container.add(new Sys.Element({
			tag: "div",
			id: "dialogWindowTitle",
			cls: "dialogWindowTitle"
		}))
	},
	initText: function() {
		var a = this;
		a.text = new Sys.Element({
			tag: "div",
			id: "dialogWindowText",
			cls: "dialogWindowText"
		});
		a.scroll = new Interface.utils.DOMScrollableContent({
			content: a.text,
			id: "dialogWindowScroll",
			CSS: {
				base: "dialogWindowScrollWrapper"
			}
		});
		a.container.add(a.scroll.container);
		a.scroll.addScrollBar();
		a.scroll.enable()
	},
	initButtonContainer: function() {
		this.buttonContainer = new Sys.Element({
			tag: "div",
			id: "dialogWindowButtonContainer",
			cls: "dialogWindowButtonContainer"
		});
		this.container.add(this.buttonContainer)
	},
	initSingleButton: function() {
		this.singleButton = new Interface.utils.Button({
			id: "dialogWindowSingleButton",
			CSS: {
				base: "button dialogWindowSingleButton"
			},
			hidden: true
		});
		this.buttonContainer.add(this.singleButton.getContainer())
	},
	initDualButtons: function() {
		var a = this;
		a.leftDualButton = new Interface.utils.Button({
			id: "dialogWindowLeftDualButton",
			CSS: {
				base: "button dialogWindowDualButton dialogWindowRightButton"
			},
			hidden: true
		});
		a.buttonContainer.add(a.leftDualButton.getContainer());
		a.rightDualButton = new Interface.utils.Button({
			id: "dialogWindowRightDualButton",
			CSS: {
				base: "button dialogWindowDualButton dialogWindowLeftButton"
			},
			hidden: true
		});
		a.buttonContainer.add(a.rightDualButton.getContainer())
	},
	show: function() {
		this.removeCSSClass("hidden")
	},
	close: function() {
		this.addCSSClass("hidden")
	},
	setTitle: function(a) {
		this.title.el.textContent = a
	},
	setMessage: function(d) {
		var b = this,
			a, c;
		if (Sys.isDefined(d)) {
			a = b.parseHyperlink(d);
			c = new Sys.Element({
				tag: "p"
			});
			c.addChildren(a);
			b.text.removeAll();
			b.text.addChildren([c.el])
		} else {
			b.text.el.textContent = ""
		}
	},
	parseHyperlink: function(d) {
		var a = /\[([^\]]+)\]\(([^)]+)\)/,
			c = {
				started: "notify:userInputManager.dialogWindowExclusiveStart",
				ended: "notify:userInputManager.dialogWindowExclusiveEnd",
				move: "notify:userInputManager.dialogWindowExclusiveMove",
				hover: "notify:userInputManager.dialogWindowExclusiveHover"
			},
			f = 0,
			e, b;
		d = d || "";
		e = d.split(/(\[[^\]]+\]\([^)]+\))/);
		e.forEach(function(j, g) {
			var h;
			if (g % 2 === 1) {
				h = a.exec(j);
				b = new Interface.utils.Button({
					id: "dialogWindow_link_" + (f++),
					label: h[1],
					CSS: {
						base: "dialogWindow_link"
					},
					clickCallback: function() {
						Sys.utils.openURL(h[2])
					},
					userInputEvents: c
				});
				b.enable();
				e[g] = b.getContainer().getEl()
			} else {
				e[g] = document.createTextNode(e[g])
			}
		});
		return e
	},
	showSingleButton: function(b) {
		var a = this;
		a.singleButton.setText(b);
		a.singleButton.enable();
		a.singleButton.show("inline-block");
		a.leftDualButton.disable();
		a.leftDualButton.hide();
		a.rightDualButton.disable();
		a.rightDualButton.hide()
	},
	showDualButtons: function(b, a) {
		var c = this;
		c.singleButton.disable();
		c.singleButton.hide();
		c.leftDualButton.setText(b);
		c.leftDualButton.enable();
		c.leftDualButton.show("inline-block");
		c.rightDualButton.setText(a);
		c.rightDualButton.enable();
		c.rightDualButton.show("inline-block")
	},
	hideButtons: function() {
		var a = this;
		a.singleButton.disable();
		a.singleButton.hide();
		a.leftDualButton.disable();
		a.leftDualButton.hide();
		a.rightDualButton.disable();
		a.rightDualButton.hide()
	},
	hideGame: function() {
		this.addCls("hideGame")
	},
	setScrollable: function(b) {
		var a = "scrollable";
		if (b) {
			this.addCSSClass(a)
		} else {
			this.removeCSSClass(a)
		}
	}
};
Core.DialogWindowDOMElement = Sys.extend(Sys.Element, Core.DialogWindowDOMElement, "Core.DialogWindowDOMElement");
Sys.ns("Core");
Core.DialogWindowBaseView = {
	BASE_CSS: "interface-dialogWindow_base",
	PORTRAIT_CSS: "interface-dialogWindow_portrait",
	LANDSCAPE_CSS: "interface-dialogWindow_landscape",
	constructor: function() {
		var a = this;
		Core.DialogWindowBaseView.superclass.constructor.apply(a, arguments);
		a.container = a.dialogDOMElement
	},
	onPortrait: function() {
		var a = this;
		Mixins.orientation.view.methods.onPortrait.call(a)
	},
	onLandscape: function() {
		var a = this;
		Mixins.orientation.view.methods.onLandscape.call(a)
	},
	adaptToOrientation: function(a) {
		Mixins.orientation.view.methods.setStyle.call(this, a)
	}
};
Core.DialogWindowBaseView = Sys.extend(Core.DialogWindowView, Core.DialogWindowBaseView, "Core.DialogWindowBaseView");
Sys.ns("Core");
Core.DialogWindowMobileView = {
	PORTRAIT_CSS: "interface-dialogWindow-mobile_portrait",
	LANDSCAPE_CSS: "interface-dialogWindow-mobile_landscape",
	constructor: function() {
		Core.DialogWindowMobileView.superclass.constructor.apply(this, arguments);
		this.setScale()
	},
	refresh: function() {
		this.setScale()
	},
	setScale: function() {
		var d = Environment.getCurrentResolutionPixelFactor(),
			e = this.dialogDOMElement.el,
			a = this.dialogDOMElement.container.el,
			b = Sys.utils.getPrefixedCSSProperty("transform"),
			c;
		if (Sys.isNumber(d)) {
			a.style[b] = "";
			a.style.height = "";
			a.style.width = "";
			c = 1 / (a.offsetWidth / Environment.getInnerScreenSize().width);
			if (Environment.getOrientation() === "PORTRAIT") {
				c = (isFinite(c) ? c : 1) * 0.95;
				a.style[b] = "scale(" + c.toFixed(1) + ")"
			} else {
				a.style[b] = "none"
			}
			if (e.classList.contains("scrollable")) {
				a.style[b] = "scale(" + 1 / d + ")";
				a.style.height = "calc(100% / " + 1 / d + ")";
				a.style.width = "calc(100% / " + 1 / d + ")"
			} else {
				a.style.height = "";
				a.style.width = ""
			}
		}
	}
};
Core.DialogWindowMobileView = Sys.extend(Core.DialogWindowBaseView, Core.DialogWindowMobileView, "Core.DialogWindowMobileView");
Sys.ns("Core");
Core.ResponseParser = {
	constructor: function() {
		Core.ResponseParser.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Core.ResponseParserController
		}
	}
};
Core.ResponseParser = Sys.extend(Core.Module, Core.ResponseParser, "Core.ResponseParser");
Sys.ns("Core");
Core.ResponseParserController = {
	constructor: function() {
		Core.ResponseParserController.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		Core.ResponseParserController.superclass.init.apply(this, arguments);
		this.doIntegrationSpecificResponseHandling(this.parseServerResponse(Resources.readData("unParsedGameServerInitResponse")))
	},
	setupEvents: function() {
		this.on({
			"notify:serverManager.serverResponseReceived": this.parseAndBroadcastServerResponse
		})
	},
	parseAndBroadcastServerResponse: function(e, c) {
		var f = this,
			a = (Sys.isDefined(c)) ? c : "notify:responseParser.responseParsed",
			b = f.parseServerResponse(e.responseText),
			d = Object.keys(b).length;
		b = f.doIntegrationSpecificResponseHandling(b);
		if (e.responseText.trim().length === 0) {
			f.fireEvent("request:errorManager.handleError")
		} else {
			if (d > 1) {
				f.fireEvent(a, b)
			}
		}
	},
	parseServerResponse: function(a) {
		return Sys.utils.parseQueryStringToNestedObject(a)
	},
	doIntegrationSpecificResponseHandling: function(a) {
		return a
	}
};
Core.ResponseParserController = Sys.extend(Core.Controller, Core.ResponseParserController, "Core.ResponseParserController");
Sys.ns("Core");
Core.ErrorManager = {
	constructor: function() {
		Core.ErrorManager.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Core.ErrorManagerController,
			model: Core.ErrorManagerModel
		}
	}
};
Core.ErrorManager = Sys.extend(Core.Module, Core.ErrorManager, "Core.ErrorManager");
Sys.ns("Core");
Core.ErrorManagerModel = {
	constructor: function() {
		Core.ErrorManagerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Resources.readData("queryData"),
			b = Sys.isDefined(a.depositAvailable) && a.depositAvailable === true;
		this.storeData("depositAvailable", b);
		this.storeData("dialogConfig", this.setupDialogConfig(b))
	},
	setupDialogConfig: function(b) {
		var a = {};
		a.http = {
			title: Services.languageManager.getText(Language.Keys.connectionLost),
			text: Services.languageManager.getText(Language.Keys.reload),
			buttons: [{
				type: "casino",
				reason: "9"
			}, {
				type: "reload"
			}],
			fatal: true
		};
		a[11] = {
			title: Services.languageManager.getText(Language.Keys.playLimit),
			text: Services.languageManager.getText("11"),
			buttons: [{
				type: "casino",
				reason: "11"
			}]
		};
		a[12] = {
			title: Services.languageManager.getText(Language.Keys.freeRounds_expired),
			buttons: [{
				type: "casino"
			}],
			fatal: true
		};
		a[13] = {
			title: Services.languageManager.getText(Language.Keys.playLimit),
			text: Services.languageManager.getText("13"),
			buttons: [{
				type: "reduceBetAndRevertSpin"
			}, {
				type: "closeAndRevertSpin"
			}]
		};
		a[20] = {
			title: Services.languageManager.getText(Language.Keys.sessionTimeOut),
			text: Services.languageManager.getText(Language.Keys.returnToLobby),
			buttons: [{
				type: "casino",
				reason: "3"
			}],
			fatal: true
		};
		Sys.each([10, 15, 51, 100, 101, 102], function(c) {
			a[c] = {
				title: Services.languageManager.getText(Language.Keys.outOfMoney),
				text: Services.languageManager.getText(Language.Keys.deposit),
				buttons: b ? [{
					type: "deposit"
				}, {
					type: "reduceBetAndRevertSpin"
				}] : [{
					type: "casino"
				}, {
					type: "reduceBetAndRevertSpin"
				}]
			}
		});
		Sys.each([0, 53, 56, 58], function(c) {
			a[c] = {
				title: Services.languageManager.getText(Language.Keys.gameUnavailable) + " (" + c + ")",
				buttons: [{
					type: "casino",
					reason: "9"
				}, {
					type: "reload"
				}],
				fatal: true
			}
		});
		a[70] = {
			title: Services.languageManager.getText(Language.Keys.accountUnavailable),
			buttons: [{
				type: "casino"
			}, {
				type: "reload"
			}],
			fatal: true
		};
		a.generic = {
			title: Services.languageManager.getText(Language.Keys.error),
			text: Services.languageManager.getText(Language.Keys.returnToLobby),
			buttons: [{
				type: "casino",
				reason: "9"
			}],
			fatal: true,
			hideGame: true
		};
		a.gameInactive = {
			title: Services.languageManager.getText(Language.Keys.gameUnavailable),
			text: Services.languageManager.getText(Language.Keys.lostConnectInactivity),
			buttons: [{
				type: "casino",
				reason: "9"
			}, {
				type: "reload"
			}],
			fatal: true,
			hideGame: true
		};
		return a
	},
	getDialogConfig: function(a) {
		var c = this.readData("dialogConfig"),
			b;
		if (Sys.isDefined(c[a])) {
			b = c[a]
		} else {
			b = c.generic
		}
		b.errorCode = a;
		return b
	},
	setUpOutOfMoneyErrorConfig: function() {
		var f = Services.languageManager.getText(Language.Keys.outOfMoney),
			c = this.readData("depositAvailable"),
			b = Services.moneyManager.getBalanceCents(),
			e = Services.moneyManager.getMinimumBetCents(),
			d, a;
		if (b >= e) {
			if (c) {
				d = Services.languageManager.getText(Language.Keys.deposit);
				a = [{
					type: "deposit"
				}, {
					type: "reduceBet"
				}]
			} else {
				d = Services.languageManager.getText(Language.Keys.reduce);
				a = [{
					type: "reduceBet"
				}, {
					type: "close"
				}]
			}
		} else {
			d = Services.languageManager.getText(Language.Keys.depositPlay);
			if (c) {
				a = [{
					type: "deposit"
				}, {
					type: "close"
				}]
			} else {
				a = [{
					type: "close"
				}]
			}
		}
		return {
			title: f,
			text: d,
			buttons: a,
			errorCode: 100
		}
	}
};
Core.ErrorManagerModel = Sys.extend(Core.Model, Core.ErrorManagerModel, "Core.ErrorManagerModel");
Sys.ns("Core");
Core.ErrorManagerController = {
	constructor: function() {
		Core.ErrorManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		this.on({
			"request:errorManager.handleError": this.showDialogForErrorCode,
			"request:errorManager.handleRequestError": this.handleRequestError,
			"request:errorManager.handleGameInactive": this.handleGameInactive,
			"request:errorManager.handleClientOutOfMoneyError": this.handleClientOutOfMoneyError
		})
	},
	showDialog: function(a) {
		var b = (a.errorCode === "http") ? 0 : a.errorCode;
		this.fireEvent("notify:errorManager.error", b, Services.languageManager.getText(b));
		this.fireEvent("request:dialogWindow.showDialog", a)
	},
	showDialogForErrorCode: function(a) {
		this.showDialog(this.getDialogConfig(a))
	},
	handleRequestError: function(b) {
		var c = this,
			a = c.handleHttpErrors(b);
		if (!a) {
			a = c.handleIntegrationSpecificErrors(b)
		}
		if (!a) {
			a = c.handleGameSpecificErrors(b)
		}
		if (!a) {
			a = c.handleServerErrors(b)
		}
		if (!a) {
			c.fireEvent("notify:errorManager.noErrorDetected")
		} else {
			if (a.fatal) {
				c.fireEvent("request:audioPlayer.stopAll")
			}
			c.showDialog(a)
		}
	},
	handleHttpErrors: function(a) {
		if (Sys.utils.httpRequestIsOK(a)) {
			return undefined
		}
		return this.getDialogConfig("http")
	},
	handleIntegrationSpecificErrors: function(a) {},
	handleGameSpecificErrors: function(a) {},
	handleServerErrors: function(a) {
		var b = Sys.utils.getErrorCode(a);
		if (!Sys.isDefined(b)) {
			return undefined
		}
		return this.getDialogConfig(b)
	},
	handleGameInactive: function() {},
	handleClientOutOfMoneyError: function() {
		var b = this,
			a = b.model.setUpOutOfMoneyErrorConfig();
		a.buttons = b.getButtons(a.buttons);
		b.showDialog(a)
	},
	getDialogConfig: function(b) {
		var a = this.model.getDialogConfig(b);
		return {
			title: a.title,
			text: a.text,
			buttons: this.getButtons(a.buttons),
			fatal: a.fatal,
			hideGame: Boolean(Sys.isDefined(a.hideGame) && a.hideGame),
			errorCode: b
		}
	},
	getButtons: function(c) {
		var b = [],
			a;
		for (a = 0; a < c.length; a++) {
			b.push(this.getButton(c[a]))
		}
		return b
	},
	getButton: function(a) {
		var b = this;
		switch (a.type) {
			case "casino":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_casino),
					action: function() {
						b.onButtonInteraction();
						Environment.goToLobby(a.reason)
					}
				};
			case "reload":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_reload),
					action: function() {
						b.onButtonInteraction();
						Environment.reload()
					}
				};
			case "close":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_close),
					action: function() {
						b.onButtonInteraction()
					}
				};
			case "closeAndRevertSpin":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_close),
					action: function() {
						b.onButtonInteraction();
						b.revertSpin()
					}
				};
			case "reduceBetAndRevertSpin":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_reduceBet),
					action: function() {
						b.onButtonInteraction();
						b.revertSpin();
						b.openBetSettings()
					}
				};
			case "reduceBet":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_reduceBet),
					action: function() {
						b.onButtonInteraction();
						b.openBetSettings()
					}
				};
			case "deposit":
				return {
					text: Services.languageManager.getText(Language.Keys.btn_deposit),
					action: function() {
						b.onButtonInteraction();
						Services.moneyManager.reloadBalance();
						Environment.goToCashier()
					}
				};
			default:
				return {
					text: "[ERROR]",
					action: console.error.bind(console, "this button was not correctly configured in the error manager")
				}
		}
	},
	openBetSettings: function() {
		this.fireEvent("request:betSettings.show")
	},
	revertSpin: function() {
		this.fireEvent("request:moneyManager.revertBet");
		this.fireEvent("request:spin.activateDefaultOutcome", "basic")
	},
	onButtonInteraction: function() {
		this.fireEvent("notify:errorManager.errorDialogClosed")
	}
};
Core.ErrorManagerController = Sys.extend(Core.Controller, Core.ErrorManagerController, "Core.ErrorManagerController");
Sys.ns("Core");
Core.ErrorManagerDesktopModel = {
	constructor: function() {
		Core.ErrorManagerDesktopModel.superclass.constructor.apply(this, arguments)
	},
	setUpOutOfMoneyErrorConfig: function() {
		var e = Services.languageManager.getText(Language.Keys.outOfMoney),
			b = Services.moneyManager.getBalanceCents(),
			d = Services.moneyManager.getMinimumBetCents(),
			c, a = [{
				type: "close"
			}];
		if (b >= d) {
			c = Services.languageManager.getText(Language.Keys.reduce)
		} else {
			c = Services.languageManager.getText(Language.Keys.depositPlay)
		}
		return {
			title: e,
			text: c,
			buttons: a,
			errorCode: 100
		}
	},
	setupDialogConfig: function(b) {
		var a = Core.ErrorManagerDesktopModel.superclass.setupDialogConfig.apply(this, arguments);
		a.http.buttons = [{
			type: "reload"
		}];
		a[11].buttons = [{
			type: "reload"
		}];
		a[12].buttons = [{
			type: "reload"
		}];
		a[13].buttons = [{
			type: "closeAndRevertSpin"
		}];
		a[20].buttons = [];
		a[20].text = Services.languageManager.getText("20");
		Sys.each([10, 15, 51, 100, 101, 102], function(c) {
			a[c].buttons = [{
				type: "closeAndRevertSpin"
			}]
		});
		Sys.each([0, 53, 56, 58], function(c) {
			a[c].buttons = [{
				type: "reload"
			}]
		});
		a[70].buttons = [{
			type: "reload"
		}];
		a.generic.buttons = [{
			type: "reload"
		}];
		a.generic.text = Services.languageManager.getText(Language.Keys.reload);
		a.gameInactive.buttons = [{
			type: "reload"
		}];
		return a
	}
};
Core.ErrorManagerDesktopModel = Sys.extend(Core.ErrorManagerModel, Core.ErrorManagerDesktopModel, "Core.ErrorManagerDesktopModel");
Sys.ns("Core");
Core.LocalStorageManager = {
	constructor: function() {
		Core.LocalStorageManager.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.LocalStorageManagerModel,
			controller: Core.LocalStorageManagerController
		}
	}
};
Core.LocalStorageManager = Sys.extend(Core.Module, Core.LocalStorageManager, "Core.LocalStorageManager");
Sys.ns("Core");
Core.LocalStorageManagerController = {
	constructor: function() {
		Core.LocalStorageManagerController.superclass.constructor.apply(this, arguments)
	},
	storeData: function(a, b) {
		this.model.writeToStorage(a, b)
	},
	readData: function(a) {
		return this.model.readFromStorage(a)
	},
	removeData: function(a) {
		this.model.removeFromStorage(a)
	},
	hasData: function(a) {
		return this.model.hasData(a)
	}
};
Core.LocalStorageManagerController = Sys.extend(Core.Controller, Core.LocalStorageManagerController, "Core.LocalStorageManagerController");
Sys.ns("Core");
Core.LocalStorageManagerModel = {
	constructor: function() {
		Core.LocalStorageManagerModel.superclass.constructor.apply(this, arguments)
	},
	writeToStorage: function(a, b) {
		if (this.readData("storageActive")) {
			if (Sys.isString(a) && Sys.isString(b)) {
				this._setItemInStorage(this.accessKey + a, b)
			}
		}
	},
	readFromStorage: function(a) {
		var b = this;
		if (b.readData("storageActive")) {
			if (!Sys.isDefined(a)) {
				return b.getAllData()
			}
			if (Sys.isString(a)) {
				return b._getItemFromStorage(b.accessKey + a)
			}
		}
		return false
	},
	removeFromStorage: function(a) {
		if (this.readData("storageActive")) {
			if (Sys.isString(a)) {
				this._removeItemFromStorage(this.accessKey + a)
			}
		}
	},
	hasData: function(a) {
		if (Sys.isDefined(a)) {
			if (Sys.isString(this.readFromStorage(a))) {
				return true
			}
		}
		return false
	},
	setupData: function() {
		var a = this,
			b = Resources.readData("queryData");
		a.accessKey = a.createAccessKey(b.operatorId, b.gameId, Resources.readData("sessionID"));
		a.storeData("storageActive", a.isLocalStorageSupported() && Sys.isDefined(a.accessKey))
	},
	createAccessKey: function(a, b, c) {
		if (Sys.isDefined(a) && Sys.isDefined(b) && Sys.isDefined(c)) {
			return this.hashValue(a + "." + b + "." + c) + "."
		}
		return undefined
	},
	activate: function() {
		this.storeData("storageActive", true)
	},
	deactivate: function() {
		this.storeData("storageActive", false)
	},
	getAllData: function() {
		var c = this,
			d = {},
			b = 0,
			a = c._getKeyFromStorage(b);
		while (a) {
			if (a.indexOf(c.accessKey) === 0) {
				d[a.replace(c.accessKey, "")] = c._getItemFromStorage(a)
			}++b;
			a = c._getKeyFromStorage(b)
		}
		return d
	},
	hashValue: function(c) {
		var d = 2285455121,
			b, a;
		if (!Sys.isString(c)) {
			return null
		}
		for (a = 0, b = c.length; a < b; a++) {
			d += c.charCodeAt(a) * (a + 1)
		}
		return d
	},
	isLocalStorageSupported: function() {
		if ((typeof window.localStorage === "object")) {
			try {
				this._setItemInStorage("availabilityCheck", "true");
				this._removeItemFromStorage("availabilityCheck");
				return true
			} catch (a) {
				return false
			}
		}
		return false
	},
	_setItemInStorage: function(a, b) {
		localStorage.setItem(a, b)
	},
	_removeItemFromStorage: function(a) {
		localStorage.removeItem(a)
	},
	_getItemFromStorage: function(a) {
		return localStorage.getItem(a)
	},
	_getKeyFromStorage: function(a) {
		return localStorage.key(a)
	}
};
Core.LocalStorageManagerModel = Sys.extend(Core.Model, Core.LocalStorageManagerModel, "Core.LocalStorageManagerModel");
Sys.ns("Core");
Core.AutoPlayer = {
	constructor: function() {
		Core.AutoPlayer.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.AutoPlayerModel,
			controller: Core.AutoPlayerController
		}
	},
	getMixinDependencies: function() {
		return ["serverResponse"]
	}
};
Core.AutoPlayer = Sys.extend(Core.Module, Core.AutoPlayer, "Core.AutoPlayer");
Sys.ns("Core");
Core.AutoPlayerController = {
	constructor: function() {
		Core.AutoPlayerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:autoPlayer.stop": a.stop,
			"request:autoPlayer.pause": a.pause,
			"request:autoPlayer.start": a.start,
			"request:autoPlayer.resume": a.resume,
			"notify:serverManager.serverErrorReceived": a.stop,
			"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
			"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
			"notify:stateHandler.enteringStandardWinPresentationState": a.onEnteringWinPresentationState,
			"notify:stateHandler.enteringBigWinState": a.onEnteringWinPresentationState,
			"notify:spinButton.clicked": a.onSpinButtonClicked,
			"notify.dialogWindow.showingDialog": a.onShowingDialog,
			"notify:dialogWindow.allDialogsClosed": a.onAllDialogsClosed,
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"notify:errorManager.error": a.stop
		})
	},
	playRound: function() {
		if (this.model.readData("nrRounds") > 0) {
			this.reduceNumberOfRounds();
			this.requestRoundStart()
		}
	},
	start: function() {
		var a = this;
		if (!a.model.readData("spinning") && a.model.isState("WAITING")) {
			a.play();
			a.requestRoundStart()
		}
	},
	stop: function() {
		var c = this,
			b = c.fireEvent.bind(c),
			a = c.model;
		if (!a.isState("STOPPED")) {
			b("request:spinButton.removeProperty", "visibleDuringRound", c.MODULE_NAME);
			b("request:spinButton.hideCounter");
			b("request:spinButton.removeDisplayType", "autoPlay");
			b("request:spinButton.removeDisplayType", "autoPlayStop");
			b("request:quickStopper.enableInMode", "autoPlay");
			b("request:playModeManager.removeMode", "autoplay");
			a.setState("STOPPED");
			a.storeData("nrRounds", 0);
			b("request:settingsManager.storeData", "autoPlayNrSpins", 0);
			b("request:spinButton.enable", c.MODULE_NAME);
			b("request:settingsButton.enable", c.MODULE_NAME);
			b("request:betSettings.enable", c.MODULE_NAME);
			b("request:maxBetButton.enable", c.MODULE_NAME);
			c.signalStopped()
		}
	},
	pause: function() {
		if (this.model.isState("PLAYING")) {
			this.model.setState("PAUSED")
		}
	},
	resume: function() {
		var a = this;
		if (this.model.isState("PAUSED")) {
			this.model.setState("PLAYING");
			if (!a.model.readData("spinning")) {
				a.playRound()
			}
		}
	},
	play: function() {
		var a = this;
		if (!a.model.isState("PLAYING") && a.model.readData("nrRounds") > 0) {
			a.model.setState("PLAYING");
			a.fireEvent("request:spinButton.removeDisplayType", "autoPlay");
			a.fireEvent("request:spinButton.addDisplayType", "autoPlayStop");
			a.fireEvent("request:quickStopper.disableInMode", "autoPlay");
			a.fireEvent("request:spinButton.disable", a.MODULE_NAME);
			a.fireEvent("request:betSettings.disable", a.MODULE_NAME);
			a.fireEvent("request:maxBetButton.disable", a.MODULE_NAME);
			a.fireEvent("request:settingsButton.disable", a.MODULE_NAME);
			a.fireEvent("notify:autoPlayer.starting");
			a.fireEvent("request:playModeManager.addMode", "autoplay");
			a.reduceNumberOfRounds()
		}
	},
	onSpinButtonClicked: function(b) {
		var c = this,
			a = c.model;
		if (Sys.isDefined(b) && b.hasOwnProperty("skip") && b.skip === true) {
			return false
		}
		if (a.isState("PLAYING") || a.isState("PAUSED") || a.isState("STOPPING")) {
			c.stop()
		}
		return true
	},
	onEnteringIdleState: function() {
		var b = this,
			a = b.model;
		a.storeData("spinning", false);
		if (a.isState("PLAYING")) {
			b.playRound()
		}
		if (a.isState("STOPPING")) {
			b.stop()
		}
		if (a.isState("WAITING")) {
			b.fireEvent("request:playModeManager.addMode", "autoplay");
			b.play();
			b.requestRoundStart()
		}
	},
	onLeavingIdleState: function() {
		var a = this;
		a.model.storeData("spinning", true);
		if (a.model.isState("WAITING")) {
			a.fireEvent("request:playModeManager.addMode", "autoplay");
			a.play()
		}
		if (a.model.isState("PLAYING")) {
			a.fireEvent("request:spinButton.updateCounter", a.model.readData("nrRounds"))
		}
	},
	onEnteringWinPresentationState: function() {
		var b = this,
			a = b.model;
		if (a.isState("STOPPING") && Services.settingsManager.getSetting("autoPlayNrSpins") > 0) {
			b.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0)
		}
	},
	onShowingDialog: function() {
		if (this.model.readData("nrRounds") > 0) {
			this.pause()
		}
	},
	onAllDialogsClosed: function() {
		if (this.model.readData("nrRounds") > 0) {
			this.resume()
		}
	},
	signalStopped: function() {
		this.fireEvent("notify:autoPlayer.stopped")
	},
	reduceNumberOfRounds: function() {
		this.model.playRound();
		this.fireEvent("request:spinButton.updateCounter", this.model.readData("nrRounds"));
		this.fireEvent("notify:autoPlayer.reduceCounter", this.model.readData("nrRounds"))
	},
	onSettingChanged: function(a, c) {
		var b = this;
		if (a === "autoPlayNrSpins" && c !== b.model.readData("nrRounds")) {
			b.model.storeData("nrRounds", c);
			if (c === 0) {
				b.stop()
			} else {
				b.fireEvent("notify:autoPlayer.enabled", c);
				b.fireEvent("request:spinButton.showCounter", c);
				b.fireEvent("request:spinButton.addDisplayType", "autoPlay");
				b.fireEvent("request:spinButton.addProperty", "visibleDuringRound", b.MODULE_NAME);
				b.model.setState("WAITING");
				b.model.storeData("startingBalance", Services.moneyManager.getBalanceCents())
			}
		} else {
			if (["stopAutoplayIfBalanceIncreasedBy", "stopAutoplayIfBalanceDecreasedBy", "stopAutoplayOnAnyWin", "stopAutoplayIfWinExceeds"].contains(a)) {
				b.model.storeData(a, c)
			}
		}
	},
	requestRoundStart: function() {
		var a = this;
		a.fireEvent("notify:autoPlayer.startRound", a.model.readData("nrRounds"));
		a.fireEvent("request:spinButton.startRound")
	}
};
Core.AutoPlayerController = Sys.extend(Core.Controller, Core.AutoPlayerController, "Core.AutoPlayerController");
Sys.ns("Core");
Core.AutoPlayerModel = {
	constructor: function() {
		Core.AutoPlayerModel.superclass.constructor.apply(this, arguments)
	},
	playRound: function() {
		var a = this.readData("nrRounds") - 1;
		if (a <= 0) {
			a = 0;
			this.setState("STOPPING")
		}
		this.storeData("nrRounds", a)
	},
	storeData: function(a, b) {
		Core.AutoPlayerModel.superclass.storeData.apply(this, arguments);
		if (a === "nrRounds") {
			Services.storage.storeData("autoPlayer.roundsLeft", b)
		}
	},
	shouldPlayAnotherRound: function() {
		return this.isState("PLAYING")
	},
	processServerResponse: function(g) {
		var k = this,
			d = g.credit,
			h, l, f = k.readData("startingBalance"),
			m = k.readData("stopAutoplayIfBalanceIncreasedBy"),
			a = k.readData("stopAutoplayIfBalanceDecreasedBy"),
			e = k.readData("stopAutoplayOnAnyWin"),
			j = k.readData("stopAutoplayIfWinExceeds"),
			c = false,
			b = Services.moneyManager.getBetCents();
		if (!k.isState("STOPPED")) {
			if (Sys.isDefined(g.wins)) {
				h = g.wins.cents;
				l = g.wins.centsTotal
			}
			if ((m !== false && m !== 0) && (d >= f + m)) {
				c = true
			}
			if ((a !== false && a !== 0) && (d - b < f - a)) {
				c = true
			}
			if (e === true) {
				if ((Sys.isDefined(h) && h > 0) || (Sys.isDefined(l) && l > 0)) {
					c = true
				}
			}
			if (j !== false && j !== 0) {
				if ((Sys.isDefined(h) && h >= j) || (Sys.isDefined(l) && l >= j)) {
					c = true
				}
			}
			if (c) {
				k.setState("STOPPING")
			}
		}
	},
	setupData: function() {
		var a = this,
			b = a.storeData.bind(a);
		b("nrRounds", 0);
		a.setState("STOPPED");
		b("spinning", true);
		b("startingBalance", 0);
		b("stopAutoplayIfBalanceIncreasedBy", false);
		b("stopAutoplayIfBalanceDecreasedBy", false);
		b("stopAutoplayOnAnyWin", false);
		b("stopAutoplayIfWinExceeds", false)
	}
};
Core.AutoPlayerModel = Sys.extend(Core.Model, Core.AutoPlayerModel, "Core.AutoPlayerModel");
Sys.ns("Core");
Core.G4 = {
	constructor: function() {
		Core.G4.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.G4Model,
			view: Core.View,
			controller: Core.G4Controller
		}
	},
	getStateChanges: function() {
		var a = this.model;
		return {
			minimumRoundTimeEnforcement: {
				state: {
					name: "MinimumRoundTimeEnforcement",
					execute: function(b) {},
					waitEvents: {
						"notify:g4.minimumRoundTimePassed": false
					}
				}
			},
			stopped: {
				queue: [function(b) {
					if (a.isG4() && a.isNewRound()) {
						b.stateHandler.pushState(b.states.minimumRoundTimeEnforcement)
					}
				}]
			}
		}
	}
};
Core.G4 = Sys.extend(Core.Module, Core.G4, "Core.G4");
Sys.ns("Core");
Core.G4Model = {
	constructor: function() {
		Core.G4Model.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponse");
		b.storeData("isG4", a.g4mode);
		b.storeData("G4Config", b.setupG4Config());
		b.storeData("isNewRound", false);
		b.storeData("roundTimeLimit", 3000);
		b.storeData("disabledDuringRound", false)
	},
	isG4: function() {
		return this.readData("isG4")
	},
	setupG4Config: function() {
		return {
			settings: [{
				name: "quickSpin",
				enabled: false,
				offValue: false
			}],
			modules: [{
				name: "systemClock",
				enabled: true
			}, {
				name: "quickStopper",
				enabled: false
			}]
		}
	},
	getMinimumTimeLeft: function() {
		var b = this,
			a = b.getRoundStartTime() + b.readData("roundTimeLimit"),
			c = a - Date.now();
		return c > 0 ? c : 0
	},
	isNewRound: function() {
		return this.readData("isNewRound")
	},
	setRoundStartTime: function() {
		var a = Date.now();
		this.storeData("roundStartTime", a)
	},
	getRoundStartTime: function() {
		return this.readData("roundStartTime")
	},
	getG4Config: function(b) {
		var a = this.readData("G4Config");
		if (a.hasOwnProperty(b)) {
			return a[b]
		}
		return undefined
	}
};
Core.G4Model = Sys.extend(Core.Model, Core.G4Model, "Core.G4Model");
Sys.ns("Core");
Core.G4DesktopModel = {
	constructor: function() {
		Core.G4DesktopModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		Core.G4DesktopModel.superclass.setupData.apply(this, arguments);
		this.storeData("disabledDuringRound", true)
	}
};
Core.G4DesktopModel = Sys.extend(Core.G4Model, Core.G4DesktopModel, "Core.G4DesktopModel");
Sys.ns("Core");
Core.G4Controller = {
	constructor: function() {
		Core.G4Controller.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringBeforeLoaderCloseState": a.initG4IfActive,
			"notify:stateHandler.enteringMinimumRoundTimeEnforcementState": a.minimumRoundTimeEnforcement,
			"notify:stateHandler.enteringSpinningState": a.onStartSpin
		})
	},
	initG4IfActive: function() {
		var b = this,
			a;
		if (b.model.readData("isG4")) {
			a = b.model.readData("G4Config");
			b.requestModuleChanges(a.modules);
			b.requestSettingChanges(a.settings);
			if (b.model.readData("disabledDuringRound")) {
				b.fireEvent("request:spinButton.addProperty", "disabledDuringRound", b.MODULE_NAME)
			}
		}
	},
	minimumRoundTimeEnforcement: function() {
		var c = this,
			d, a, b;
		if (c.model.isNewRound()) {
			b = c.model.getMinimumTimeLeft();
			a = c.model.readData("roundExtensionTimer");
			if (b > 0) {
				if (Sys.isDefined(a)) {
					clearTimeout(a)
				}
				d = setTimeout(function() {
					c.fireEvent("notify:g4.minimumRoundTimePassed")
				}, b);
				c.model.storeData("roundExtensionTimer", d)
			} else {
				c.fireEvent("notify:g4.minimumRoundTimePassed")
			}
		}
	},
	onStartSpin: function() {
		this.model.storeData("isNewRound", true);
		this.model.setRoundStartTime()
	},
	requestSettingChanges: function(a) {
		var b = this;
		Sys.each(a, function(c) {
			if (c.enabled) {
				b.dispatchRequestEnableSettingEvent(c.name)
			} else {
				if (!c.enabled) {
					b.dispatchRequestDisableSettingEvent(c.name, c.offValue)
				}
			}
		})
	},
	requestModuleChanges: function(a) {
		var b = this;
		Sys.each(a, function(c) {
			if (c.enabled) {
				b.dispatchRequestEnableModuleEvent(c.name)
			} else {
				if (!c.enabled) {
					b.dispatchRequestDisableModuleEvent(c.name)
				}
			}
		})
	},
	dispatchRequestDisableSettingEvent: function(a, b) {
		var c = this;
		if (Sys.isDefined(b)) {
			c.fireEvent("request:settingsManager.storeValue", a, b)
		}
		c.fireEvent("request:settingsManager.disableSetting", a);
		c.fireEvent("request:settingsManager.lockSetting", a, c.MODULE_NAME)
	},
	dispatchRequestEnableSettingEvent: function(a) {
		this.fireEvent("request:settingsManager.enableSetting", a)
	},
	dispatchRequestDisableModuleEvent: function(a) {
		this.fireEvent("request:" + a + ".disableInMode", "g4")
	},
	dispatchRequestEnableModuleEvent: function(a) {
		this.fireEvent("request:" + a + ".enableInMode", "g4")
	}
};
Core.G4Controller = Sys.extend(Core.Controller, Core.G4Controller, "Core.G4Controller");
Sys.ns("Core");
Core.PlayModeManager = {
	constructor: function() {
		Core.PlayModeManager.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.PlayModeManagerModel,
			controller: Core.PlayModeManagerController
		}
	}
};
Core.PlayModeManager = Sys.extend(Core.Module, Core.PlayModeManager, "Core.PlayModeManager");
Sys.ns("Core");
Core.PlayModeManagerController = {
	USE_LOGGING: false,
	constructor: function() {
		Core.PlayModeManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:playModeManager.addMode": a.addMode,
			"request:playModeManager.removeMode": a.removeMode
		})
	},
	addMode: function(a) {
		this.model.addMode(a)
	},
	removeMode: function(a) {
		this.model.removeMode(a)
	}
};
Core.PlayModeManagerController = Sys.extend(Core.Controller, Core.PlayModeManagerController, "Core.PlayModeManagerController");
Sys.ns("Core");
Core.PlayModeManagerModel = {
	constructor: function() {
		Core.PlayModeManagerModel.superclass.constructor.apply(this, arguments)
	},
	addMode: function(b) {
		var a = this.readData("modes");
		if (a.indexOf(b) === -1) {
			a.push(b);
			this.storeModeString()
		}
	},
	removeMode: function(c) {
		var b = this.readData("modes"),
			a = b.indexOf(c);
		if (a >= 0) {
			b.splice(a, 1);
			this.storeModeString()
		}
	},
	getModeString: function() {
		var b = this.readData("modes"),
			d = b.length,
			c = "",
			a;
		for (a = -1; ++a < d;) {
			c += ((a > 0) ? "," : "") + b[a]
		}
		return c
	},
	setupData: function() {
		this.storeData("modes", []);
		this.storeModeString()
	},
	storeModeString: function() {
		Services.storage.storeData(this.MODULE_NAME + ".modes", this.getModeString())
	}
};
Core.PlayModeManagerModel = Sys.extend(Core.Model, Core.PlayModeManagerModel, "Core.PlayModeManagerModel");
Sys.ns("Core.Slots");
Core.Slots.FreeRounds = {
	constructor: function() {
		Core.Slots.FreeRounds.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model;
		return {
			beforeLoaderClose: {
				queue: [function(b) {
					if (a.hasFreeRounds() && !a.readData("hasShownSplash")) {
						b.stateHandler.pushState(b.states.freeRoundsDialog)
					}
				}]
			},
			freeRoundsDialog: {
				state: {
					name: "FreeRoundsDialog",
					execute: function() {},
					waitEvents: {}
				}
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.FreeRoundsModel,
			controller: Core.Slots.FreeRoundsController
		}
	}
};
Core.Slots.FreeRounds = Sys.extend(Core.Module, Core.Slots.FreeRounds, "Core.Slots.FreeRounds");
Sys.ns("Core.Slots");
Core.Slots.FreeRoundsController = {
	constructor: function() {
		Core.Slots.FreeRoundsController.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		Core.Slots.FreeRoundsController.superclass.init.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringFreeRoundsDialogState": a.startFreeRounds,
			"notify:responseParser.responseParsed": a.model.handleFreeRounds.bind(a.model)
		})
	},
	startFreeRounds: function() {
		var a = this;
		a.addListener("notify:stateHandler.enteringIdleState", a.endFreeRoundsIfSpent);
		a.addListener("notify:stateHandler.leavingIdleState", a.onFreeRoundStart);
		a.requestUpdateCounter();
		a.fireEvent("request:maxBetButton.disable", a.MODULE_NAME);
		a.fireEvent("request:betSettings.hideCashDisplay");
		a.fireEvent("notify:freeRounds.started", a.model.readData("freeRoundsLeft"));
		a.setFreeroundModeParameter(true);
		a.requestDialog({
			title: Services.languageManager.getText(Language.Keys.roundsLeft),
			text: Services.languageManager.getText(Language.Keys.haveFreeRounds, [a.model.readData("freeRoundsLeft")]),
			buttonText: Language.Keys["continue"],
			action: a.fireEvent.bind(a, "notify:freeRounds.dialogClosed")
		});
		a.model.storeData("hasShownSplash", true);
		a.model.storeData("totalFreeRounds", a.model.readData("freeRoundsLeft"))
	},
	setFreeroundModeParameter: function(b) {
		var a = b || false,
			c = Resources.readData("extraParams");
		if (Sys.isDefined(c) && typeof(b) === "boolean") {
			c.freeroundmode = a;
			Resources.storeData("extraParams", c)
		}
	},
	onFreeRoundStart: function() {
		var c = this,
			b = c.model.readData("totalFreeRounds"),
			a = c.model.readData("freeRoundsLeft");
		c.fireEvent("notify:freeRounds.nextRound", b, a)
	},
	endFreeRoundsIfSpent: function() {
		var a = this;
		a.requestUpdateCounter();
		if (a.model.readData("freeRoundsLeft") <= 0) {
			a.fireEvent("notify:freeRounds.ended");
			a.setFreeroundModeParameter(false);
			a.fireEvent("request:autoPlayer.stop");
			a.requestDialog({
				title: Services.languageManager.getText(Language.Keys.freeRoundsFinished),
				text: Services.languageManager.getText(Language.Keys.roundsUseAcctMoney) + " " + Services.languageManager.getText(Language.Keys.reload),
				buttonText: Language.Keys.btn_reload,
				action: function() {
					Environment.reload()
				}
			})
		}
	},
	requestUpdateCounter: function() {
		var b = this,
			a = b.model.readData("freeRoundsLeft");
		Services.storage.storeData("freeRounds.roundsLeft", a)
	},
	requestDialog: function(a) {
		var b = this;
		b.fireEvent("request:dialogWindow.showDialog", {
			title: a.title,
			text: a.text,
			buttons: [{
				scope: b,
				text: Services.languageManager.getText(a.buttonText),
				action: a.action
			}]
		})
	}
};
Core.Slots.FreeRoundsController = Sys.extend(Core.Controller, Core.Slots.FreeRoundsController, "Core.Slots.FreeRoundsController");
Sys.ns("Core.Slots");
Core.Slots.FreeRoundsModel = {
	constructor: function() {
		Core.Slots.FreeRoundsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponseObject");
		b.storeData("hasShownSplash", false);
		b.handleFreeRounds(a)
	},
	hasFreeRounds: function() {
		var a = this.readData("freeRoundsLeft");
		return Sys.isDefined(a) && a > 0
	},
	handleFreeRounds: function(a) {
		if (Sys.isDefined(a.freeRoundsLeft)) {
			this.storeData("freeRoundsLeft", a.freeRoundsLeft)
		}
	}
};
Core.Slots.FreeRoundsModel = Sys.extend(Core.Model, Core.Slots.FreeRoundsModel, "Core.Slots.FreeRoundsModel");
Sys.ns("Core.Slots");
Core.Slots.ServerManager = {
	constructor: function() {
		Core.Slots.ServerManager.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			spinning: {
				queue: [function(a) {
					a.stateHandler.pushState(a.states.processServerResponse)
				}]
			},
			processServerResponse: {
				state: {
					name: "ProcessServerResponse",
					execute: function(a) {},
					waitEvents: {}
				}
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.ServerManagerModel,
			view: Core.View,
			controller: Core.Slots.ServerManagerController
		}
	}
};
Core.Slots.ServerManager = Sys.extend(Core.Module, Core.Slots.ServerManager, "Core.Slots.ServerManager");
Sys.ns("Core.Slots");
Core.Slots.ServerManagerController = {
	constructor: function() {
		Core.Slots.ServerManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Core.Slots.ServerManagerController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"notify:responseParser.responseParsed": a.storeNextAction,
			"notify:settingsManager.settingChanged": a.onSettingsChanged
		})
	},
	onSettingsChanged: function(a, b) {
		if (a === "betLevel" || a === "denomination" || a === "betLines") {
			this.model.storeData("parameters:" + a, b)
		}
	},
	sendAction: function(b, a) {
		b = (b === "nextAction") ? this.model.readData("nextAction") : b;
		Core.Slots.ServerManagerController.superclass.sendAction.call(this, b, a)
	},
	storeNextAction: function(a) {
		this.model.storeData("nextAction", a.nextaction)
	}
};
Core.Slots.ServerManagerController = Sys.extend(Core.ServerManagerController, Core.Slots.ServerManagerController, "Core.Slots.ServerManagerController");
Sys.ns("Core.Slots");
Core.Slots.ServerManagerModel = {
	constructor: function() {
		Core.Slots.ServerManagerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var d = this,
			c, a, b;
		Core.Slots.ServerManagerModel.superclass.setupData.apply(d, arguments);
		c = Resources.readData("gameServerInitResponse");
		a = c["bl.standard"].split(",").length;
		b = "0-" + (a - 1).toString();
		d.storeData("parameters:betLines", b);
		d.storeData("nextAction", c.nextaction)
	},
	getActionParameters: function(a) {
		var b = this.getBaseParameters(a);
		b = b + this.getFreeroundsParameters();
		switch (a) {
			case "init":
				return b + this.getInitParameters();
			case "jmxinit":
				return b + this.getJMXInitParameters();
			case "paytable":
				return b + this.getPaytableParameters();
			case "spin":
				return b + this.getSpinParameters();
			case "initfreespin":
				return b + this.getInitFreespinParameters();
			case "respin":
			case "freespin":
				return b + this.getFreespinParameters();
			default:
				return b
		}
	},
	getBaseParameters: function(a) {
		return "action=" + a + "&sessid=" + this.readData("parameter:sessionID") + "&gameId=" + this.readData("parameter:gameID") + "&wantsreels=true"
	},
	getFreeroundsParameters: function() {
		var a = Resources.readData("extraParams");
		return "&wantsfreerounds=" + a.wantsfreerounds + "&freeroundmode=" + a.freeroundmode
	},
	getInitParameters: function() {
		return ""
	},
	getJMXInitParameters: function() {
		return this.getInitParameters()
	},
	getPaytableParameters: function() {
		return ""
	},
	getSpinParameters: function() {
		var c = this,
			b = "&bet.betlevel=" + c.readData("parameters:betLevel") + "&bet.denomination=" + c.readData("parameters:denomination") + "&bet.betlines=" + c.readData("parameters:betLines"),
			a = c.readData("parameter:jmx");
		if (a) {
			b += "&" + a
		}
		return b
	},
	getInitFreespinParameters: function() {
		return this.getInitParameters()
	},
	getFreespinParameters: function() {
		var b = this.getInitParameters(),
			a = this.readData("parameter:jmx");
		if (a) {
			b += "&" + a
		}
		return b
	}
};
Core.Slots.ServerManagerModel = Sys.extend(Core.ServerManagerModel, Core.Slots.ServerManagerModel, "Core.Slots.ServerManagerModel");
Sys.ns("Core.Slots");
Core.Slots.ResponseParser = {
	constructor: function() {
		Core.Slots.ResponseParser.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Model,
			view: Core.View,
			controller: Core.Slots.ResponseParserController
		}
	}
};
Core.Slots.ResponseParser = Sys.extend(Core.ResponseParser, Core.Slots.ResponseParser, "Core.Slots.ResponseParser");
Sys.ns("Core.Slots");
Core.Slots.ResponseParserController = {
	constructor: function() {
		Core.Slots.ResponseParserController.superclass.constructor.apply(this, arguments)
	},
	parseServerResponse: function(d) {
		var b = this,
			c = Core.Slots.ResponseParserController.superclass.parseServerResponse.call(b, d),
			a;
		if (c.gamestate) {
			c.currentGameState = b.getCurrentGameState(c)
		}
		if (c.rs) {
			a = this.parseReelInfo(c);
			c.reelInfo = a;
			c.nearWinList = this.parseNearWin(c);
			if (c.ws) {
				c.wins = b.parseWinSituations(c, a);
				c.wins.winType = b.setWinType(c.wins.coins, Services.moneyManager.getBetCoins());
				c.wins.centsTotal = c.totalwin.cents;
				c.wins.coinsTotal = c.totalwin.coins
			} else {
				if (Sys.isDefined(c.totalwin)) {
					c.wins = {
						centsTotal: c.totalwin.cents,
						coinsTotal: c.totalwin.coins
					}
				}
			}
		} else {
			if (Sys.isDefined(c.totalwin)) {
				c.wins = {
					centsTotal: c.totalwin.cents,
					coinsTotal: c.totalwin.coins
				}
			}
		}
		return c
	},
	getCurrentGameState: function(c) {
		var b = this,
			a = b.model.readData("currentServerGameState");
		if (c.gamestate.current) {
			b.model.storeData("currentServerGameState", c.gamestate.current)
		} else {
			b.model.storeData("currentServerGameState", c.gamestate)
		}
		if (!a) {
			a = b.model.readData("currentServerGameState");
			if (a === "basic") {
				b.fireEvent("request:playModeManager.addMode", "basic")
			}
		}
		return a
	},
	parseNearWin: function(b) {
		var a;
		if (Sys.isDefined(b.rs.i0)) {
			a = b.rs.i0.nearwin;
			if (Sys.isArray(a)) {
				return a
			} else {
				if (Sys.isNumber(a)) {
					return [a]
				}
			}
		}
		return undefined
	},
	setWinType: function(e, a) {
		var b = Resources.readData("config"),
			d = b.winTypes,
			c = "";
		if (e > 0) {
			if ((e >= a * d.smallWin.from) && (e < a * d.smallWin.to)) {
				c = "smallWin"
			} else {
				if ((e >= a * d.mediumWin.from) && (e < a * d.mediumWin.to)) {
					c = "mediumWin"
				} else {
					if ((e >= a * d.largeWin.from) && (e < a * d.largeWin.to)) {
						c = "largeWin"
					} else {
						if (e >= a * d.bigWin.from) {
							c = "bigWin"
						}
					}
				}
			}
		}
		return c
	},
	parseReelInfo: function(a) {
		return Sys.utils.parseReelInfo(a)
	},
	parseWinSituations: function(b, c) {
		var d = 0,
			a = [],
			e;
		if (b.ws) {
			while (b.ws["i" + d]) {
				a.push(b.ws["i" + d]);
				d++
			}
		}
		e = this.parseWinLayouts(a, c);
		this.doGameSpecificWinSituationParsing(e, a);
		return e
	},
	parseWinLayouts: function(a, f) {
		var b, g, c, d = [],
			j, k = 0,
			h = 0,
			e = 0;
		for (b = 0; b < a.length; b++) {
			d.push({
				betline: Sys.isNumber(a[b].betline) ? a[b].betline + 1 : undefined,
				positions: [],
				reelset: a[b].reelset,
				wins: {}
			});
			if (Sys.isDefined(a[b].pos)) {
				for (g = 0; Sys.isDefined(a[b].pos["i" + g]); g++) {
					j = {};
					j.reelIndex = a[b].pos["i" + g][0];
					j.symbolIndex = a[b].pos["i" + g][1];
					j = Sys.apply(j, f[j.reelIndex].symbols[j.symbolIndex]);
					d[b].positions.push(j)
				}
				d[b].positions.sort(this.sortSymbols)
			}
			for (c = 0; Sys.isDefined(a[b].types["i" + c]) && Sys.isDefined(a[b].types["i" + c].wintype); c++) {
				d[b].wins.type = a[b].types["i" + c].wintype;
				if (a[b].types["i" + c].wintype === "coins") {
					d[b].wins.coins = a[b].types["i" + c].coins;
					d[b].wins.cents = a[b].types["i" + c].cents;
					k += a[b].types["i" + c].coins;
					h += a[b].types["i" + c].cents
				} else {
					if (a[b].types["i" + c].wintype === "freespins") {
						d[b].wins.freespins = a[b].types["i" + c].freespins;
						e += a[b].types["i" + c].freespins
					} else {}
				}
			}
		}
		d.sort(this.sortWinSituations);
		return {
			winSituations: d,
			coins: k,
			cents: h,
			freespins: e
		}
	},
	sortSymbols: function(b, a) {
		return b.reelIndex - a.reelIndex
	},
	sortWinSituations: function(b, a) {
		if (b.wins.coins) {
			if (a.wins.coins) {
				return a.wins.coins - b.wins.coins
			}
			return -1
		} else {
			if (a.wins.coins) {
				return 1
			}
		}
		return a.wins.freespins - b.wins.freespins
	},
	doGameSpecificWinSituationParsing: function(b, a) {}
};
Core.Slots.ResponseParserController = Sys.extend(Core.ResponseParserController, Core.Slots.ResponseParserController, "Core.Slots.ResponseParserController");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayer = {
	ENGINE: false,
	constructor: function() {
		var a = Resources.readData("config") || {};
		this.ENGINE = a.enableWADE || this.ENGINE;
		Core.Audio.AudioPlayer.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			setupGame: {
				waitEvents: ["notify:audioPlayer.ready"]
			}
		}
	},
	getMixinDependencies: function() {
		return ["trigger"]
	},
	getDefaultMVCClasses: function() {
		if (Platform.hasWebAudioContext) {
			return {
				model: Core.Audio.AudioPlayerModel,
				view: this.ENGINE ? Core.Audio.AudioPlayerEngineView : Core.Audio.AudioPlayerView,
				controller: Core.Audio.AudioPlayerController
			}
		}
		return {
			model: Core.Audio.AudioPlayerModel,
			view: Core.Audio.Legacy.LegacyAudioPlayerView,
			controller: Core.Audio.AudioPlayerController
		}
	}
};
Core.Audio.AudioPlayer = Sys.extend(Core.Module, Core.Audio.AudioPlayer, "Core.Audio.AudioPlayer");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerController = {
	constructor: function() {
		Core.Audio.AudioPlayerController.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Core.Audio.AudioPlayerController.superclass.init.apply(a, arguments);
		a.soundsToLoadOnEnable = ["main"];
		if (Sys.isDefined(Resources.readData("preloadedAudio"))) {
			a.model.storeData("hasPreloadedAudio", true);
			a.view.decodePreloadedAudio()
		} else {
			setTimeout(function() {
				a.fireEvent("notify:audioPlayer.ready")
			}, 0);
			a.model.storeData("hasPreloadedAudio", false)
		}
	},
	setupEvents: function() {
		var a = this;
		a.on({
			pageVisibilityChanged_event: a.onPageVisibilityChanged,
			"request:audioPlayer.play": a.play,
			"request:audioPlayer.stop": a.stop,
			"request:audioPlayer.stopAll": a.stopAll,
			"request:audioPlayer.stopNonLooping": a.stopNonLooping,
			"request:audioPlayer.loadSounds": a.loadSounds,
			"request:audioPlayer.disableEventInteractions": a.onDisableEventInteractions,
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"notify:resourceLoader.soundLoaded": a.view.onSoundResourceLoaded.bind(a.view),
			"notify:resourceLoader.soundLoadingFailed": a.handleLoadError,
			"notify:settingsManager.settingChanged": a.onSettingsChanged,
			"view:loadResource": a.fireEvent.bind(a, "request:resourceLoader.loadResource"),
			"view:soundLoaded": a.onSoundLoaded,
			"view:audioLoadError": a.handleLoadError
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:audioPlayer.soundLoaded", this, "When the sound is loaded")
	},
	onDisableEventInteractions: function() {
		var a = this;
		a.removeListener("request:audioPlayer.play");
		a.removeListener("request:audioPlayer.stop");
		a.removeListener("request:audioPlayer.stopAll");
		a.removeListener("request:audioPlayer.stopNonLooping")
	},
	onSoundLoaded: function() {
		this.fireEvent("notify:audioPlayer.soundPlayable");
		this.fireEvent("notify:audioPlayer.soundLoaded");
		this.fireEvent("notify:audioPlayer.ready")
	},
	onBeforeLoaderClose: function() {
		this.setAudioState(this.model.readData("hasPreloadedAudio"))
	},
	onSettingsChanged: function(a, b) {
		if (a === "volume") {
			this.adjustVolume(b)
		}
	},
	loadSounds: function(a) {
		var b = this;
		a = a || ["main"];
		if (!Sys.isArray(a)) {
			a = [a]
		}
		if (b.model.isState("audioEnabled")) {
			b.fireEvent("notify:audioPlayer.loadingSound");
			Sys.each(a, function(c) {
				b.view.loadSounds(c)
			})
		} else {
			Sys.each(a, function(c) {
				if (!b.soundsToLoadOnEnable.contains(c)) {
					b.soundsToLoadOnEnable.push(c)
				}
			})
		}
	},
	adjustVolume: function(a) {
		if (Sys.isNumber(a) && a >= 0 && a <= 1) {
			this.view.setVolume(a);
			if (a > 0) {
				this.setAudioState(true)
			}
		}
	},
	setAudioState: function(b) {
		var c = this,
			d = b ? "audioEnabled" : "audioDisabled",
			a = c.soundsToLoadOnEnable.slice(0);
		if (c.model.isState(d)) {
			return
		}
		c.model.setState(d);
		c.fireEvent("notify:audioPlayer.audioStateSet", d);
		if (b && a.length > 0 && !c.model.readData("hasPreloadedAudio")) {
			c.loadSounds(a);
			c.soundsToLoadOnEnable.length = 0
		}
	},
	onPageVisibilityChanged: function(c) {
		var b = this,
			a;
		if (c && b.model.isState("audioEnabled")) {
			b.model.setState("audioDisabled:hidden");
			b.adjustVolume(0)
		} else {
			if (!c && this.model.isState("audioDisabled:hidden")) {
				b.model.setState("audioEnabled");
				a = Services.settingsManager.getSetting("volume");
				b.adjustVolume(a)
			}
		}
	},
	play: function(b) {
		var a = this;
		if (!a.model.isState("audioEnabled") && Sys.isDefined(b) && Sys.isDefined(b.callback)) {
			b.callback();
			delete b.callback
		}
		a.view.play(b);
		a.fireEvent("notify:audioPlayer.playing", b)
	},
	stop: function(b, a) {
		this.view.stop(b, a);
		this.fireEvent("notify:audioPlayer.stop", b)
	},
	stopAll: function() {
		this.view.abort();
		this.fireEvent("notify:audioPlayer.stopAll")
	},
	stopNonLooping: function() {
		this.view.stopNonLooping();
		this.fireEvent("notify:audioPlayer.stopNonLooping")
	},
	handleLoadError: function(a) {
		throw new Error("Could not load audio.", a)
	}
};
Core.Audio.AudioPlayerController = Sys.extend(Core.Controller, Core.Audio.AudioPlayerController, "Core.Audio.AudioPlayerController");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerModel = {
	constructor: function() {
		Core.Audio.AudioPlayerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Resources.readData("audioConfig");
		this.storeData("clips", a.clips);
		this.storeData("files", a.files)
	}
};
Core.Audio.AudioPlayerModel = Sys.extend(Core.Model, Core.Audio.AudioPlayerModel, "Core.Audio.AudioPlayerModel");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerView = {
	constructor: function() {
		Core.Audio.AudioPlayerView.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var b = this,
			c = window.AudioContext;
		b.model = a.model;
		b.MODULE_NAME = a.name;
		b.audioPlaying = {};
		b.audioResources = {};
		b.audioBuffers = {};
		b.soundsToLoad = [];
		b.initializedAudio = false;
		b.context = new c();
		b.callbacks = {};
		b.duckingSounds = {};
		b.duckingRestore = {}
	},
	setVolume: function(b) {
		var a = this;
		if (a.initializedAudio && Sys.isNumber(b)) {
			a.nodes.mainVolume.gain.value = b
		}
	},
	play: function(e) {
		var d = this,
			c, g, b, f, a;
		if (!Sys.isDefined(e.source)) {
			c = d.setUpSource(e)
		} else {
			c = e
		}
		if (!Sys.isDefined(c)) {
			return
		}
		c.source.playbackRate.value = 1;
		b = d.audioPlaying[e.syncWithId];
		if (!Sys.isEmpty(b)) {
			f = d.context.currentTime - b[0].initTime;
			a = (f % c.duration);
			c.duration -= a;
			c.start = a + c.clipOffsetFromFileStart
		}
		g = d.getId(e);
		d.addToPlayingList(g, c);
		d.setupCallback(e.callback, c, g);
		if (!e.loop) {
			d.setupCallback(d.clipFinished.bind(d, c, g), c, g)
		}
		if (Sys.isDefined(c.ducking)) {
			d.duckSounds(c.ducking, c, g, e)
		}
		c.initTime = d.context.currentTime + c.delay - c.start + c.clipOffsetFromFileStart;
		if (e.loop === true && d.canPlayWithoutDuration) {
			if (c.start > 0) {
				c.source.start(d.context.currentTime + c.delay, c.start);
				c.source.onended = function() {
					if (!c.stopped) {
						d.play(e)
					}
				};
				c.stopped = false
			} else {
				c.source.start(d.context.currentTime + c.delay)
			}
		} else {
			c.source.start(d.context.currentTime + c.delay, c.start, c.duration)
		}
	},
	duckSounds: function(f, k, d, e) {
		var m = this,
			p = Object.keys(f),
			a = p.length,
			l, g, o, c, j, b, n, h;
		for (h = -1; ++h < a;) {
			b = p[h];
			n = f[b];
			g = m.duckingSounds[b];
			o = Sys.isDefined(n.duration) ? n.duration : k.duration;
			l = m.context.currentTime + k.delay + Math.min(k.duration, o);
			if (Sys.isObj(g)) {
				if (g.finishedAt > l) {
					continue
				}
				c = m.callbacks[g.duckedBy].funcs.indexOf(g.restoreUsing);
				if (c > -1) {
					m.callbacks[g.duckedBy].funcs.splice(c, 1)
				}
			}
			m.changePlayingSoundVolume(b, n, k, e);
			j = m.restoreDuckedSound.bind(m, b, n);
			m.setupCallback(j, k, d, e.loop);
			m.duckingSounds[b] = {
				duckedBy: d,
				restoreUsing: j,
				finishedAt: l
			}
		}
	},
	changePlayingSoundVolume: function(c, d, f, b) {
		var g = this,
			a = g.audioPlaying[c],
			j = g.context.currentTime + (f.delay || 0),
			h = j + (d.duration || f.duration || 0),
			k, e;
		Sys.each(a, function(l) {
			k = l.gainNode.gain;
			k.setTargetAtTime(d.value, j, d.attack);
			e = Math.max(k.value, g.duckingRestore[c] || 0);
			if (!b.loop) {
				k.setTargetAtTime(e, h, d.release)
			}
			g.duckingRestore[c] = e
		}, g)
	},
	restoreDuckedSound: function(b, a) {
		this.restoreGainValue(b, a);
		this.duckingSounds[b] = undefined
	},
	restoreGainValue: function(c, b) {
		var d = this,
			a = d.audioPlaying[c],
			e;
		if (!Sys.isDefined(d.duckingRestore[c])) {
			return
		}
		Sys.each(a, function(f) {
			e = f.gainNode.gain;
			e.cancelScheduledValues(d.context.currentTime);
			e.setTargetAtTime(d.duckingRestore[c], d.context.currentTime, b.release)
		}, d)
	},
	clipFinished: function(b, c) {
		var a = this.audioPlaying[c].indexOf(b);
		while (a >= 0) {
			this.audioPlaying[c].splice(a, 1);
			a = this.audioPlaying[c].indexOf(b)
		}
	},
	stop: function(e, b) {
		var d = this,
			c, a;
		if (!Sys.isDefined(d.audioPlaying[e])) {
			return
		}
		for (a = 0; a < d.audioPlaying[e].length; a++) {
			c = d.audioPlaying[e][a];
			if (Sys.isDefined(c)) {
				d.stopClip(c, b)
			}
		}
		d.removeFromPlayingList(e);
		if (Sys.isDefined(d.callbacks[e])) {
			clearTimeout(d.callbacks[e].timeout);
			d.callArrayOfCallbacks(e)
		}
	},
	stopClip: function(e, c) {
		var d = this,
			b = Sys.isDefined(c) ? c : e.fadeOut,
			f = d.context.currentTime,
			a = f;
		if (b) {
			e.gainNode.gain.exponentialRampToValueAtTime(b.from, f);
			e.gainNode.gain.exponentialRampToValueAtTime(b.to, f + b.time);
			a += b.time
		}
		e.stopped = true;
		e.source.stop(a)
	},
	stopNonLooping: function() {
		var b = this,
			a;
		Sys.iterate(b.audioPlaying, function(d, c) {
			a = [];
			Sys.each(c, function(e) {
				if (e.source.loop) {
					a.push(e)
				} else {
					b.stopClip(e)
				}
			});
			b.audioPlaying[d].length = 0;
			b.audioPlaying[d] = a
		})
	},
	abort: function() {
		var a = this;
		Sys.iterate(a.audioPlaying, function(b) {
			a.stop(b)
		})
	},
	getId: function(a) {
		return a.id || "audioPlayer.noID"
	},
	addToPlayingList: function(b, a) {
		if (!Sys.isDefined(this.audioPlaying[b])) {
			this.audioPlaying[b] = []
		}
		this.audioPlaying[b].push(a)
	},
	removeFromPlayingList: function(a) {
		this.audioPlaying[a].length = 0
	},
	setUpSource: function(g) {
		var j = this,
			d = j.setUpSourceParams(g),
			h, c = this.context.currentTime,
			a, e, b, f;
		if (!Sys.isDefined(d)) {
			return undefined
		}
		a = j.context.createBufferSource();
		a.buffer = d.sourceBuffer;
		e = j.context.createGain();
		a.connect(e);
		e.gain.value = d.gain;
		if (d.fadeIn) {
			h = d.fadeIn;
			e.gain.exponentialRampToValueAtTime(h.from, c);
			e.gain.exponentialRampToValueAtTime(h.to, c + h.time)
		}
		if (d.fadeOut && !d.loop) {
			h = d.fadeOut;
			f = c + d.start + (d.duration - h.time);
			e.gain.exponentialRampToValueAtTime(h.from, f);
			e.gain.exponentialRampToValueAtTime(h.to, f + h.time)
		}
		a.loop = d.loop;
		if (a.loop && Sys.isDefined(d.start)) {
			a.loopStart = d.start;
			a.loopEnd = d.start + d.duration
		}
		if (Sys.isDefined(d.filter)) {
			b = this.filter(d.filter);
			e.connect(b);
			b.connect(j.nodes.mainVolume)
		} else {
			e.connect(j.nodes.mainVolume)
		}
		d = Sys.apply(d, {
			source: a,
			gainNode: e,
			filterNode: b
		});
		return d
	},
	setUpSourceParams: function(f) {
		var j = this,
			a, e, h, k = 1,
			g, b, c, d;
		if (!Sys.isDefined(f.name)) {
			return undefined
		}
		a = Sys.isDefined(f.buffer) ? f.buffer : "main";
		e = j.model.readData("clips")[a][f.name];
		h = j.audioBuffers[a];
		if (!Sys.isDefined(e)) {
			return undefined
		}
		if (!Sys.isDefined(h)) {
			return undefined
		}
		if (!Sys.isAudioBuffer(h)) {
			if (Sys.isAudioBuffer(h[f.name])) {
				h = h[f.name]
			} else {
				return undefined
			}
		}
		if (Sys.isDefined(f.volume)) {
			k = f.volume
		} else {
			if (Sys.isDefined(e.volume)) {
				k = e.volume
			}
		}
		g = Sys.isDefined(e.start) ? e.start : 0;
		b = g;
		if (Sys.isDefined(f.offset)) {
			b += f.offset
		}
		c = h.duration - b;
		if (Sys.isDefined(f.duration)) {
			c = Math.min(c, f.duration)
		} else {
			if (Sys.isDefined(e.duration)) {
				c = Math.min(c, e.duration)
			}
		}
		d = {
			sourceBuffer: h,
			delay: Sys.isDefined(f.delay) ? f.delay : 0,
			start: b,
			duration: c,
			clipOffsetFromFileStart: g,
			gain: k,
			loop: f.loop === true,
			fadeIn: Sys.isDefined(f.fadeIn) ? f.fadeIn : false,
			fadeOut: Sys.isDefined(f.fadeOut) ? f.fadeOut : false,
			filter: f.filter,
			ducking: e.duck
		};
		return d
	},
	setupCallback: function(h, e, g, a) {
		var d = this,
			f = (e.delay + e.duration) * 1000,
			b, c;
		if (!Sys.isDefined(h)) {
			return
		}
		b = function() {
			d.callArrayOfCallbacks(g)
		};
		if (Sys.isObj(d.callbacks[g])) {
			if (Sys.isEmpty(d.callbacks[g].funcs) && !a) {
				d.callbacks[g].timeout = setTimeout(b, f)
			}
			d.callbacks[g].funcs.push(h)
		} else {
			if (!a) {
				c = setTimeout(b, f)
			}
			d.callbacks[g] = {
				timeout: c,
				funcs: [h]
			}
		}
	},
	filter: function(a) {
		var b = this.context.createBiquadFilter();
		a.type = a.type || "allpass";
		b.type = Sys.isString(b.type) ? a.type : b[a.type.toUpperCase()];
		if (Sys.isDefined(a.frequency)) {
			b.frequency.value = a.frequency
		}
		if (Sys.isDefined(a.q)) {
			b.Q.value = a.q
		}
		if (Sys.isDefined(a.gain)) {
			b.gain.value = a.q
		}
		return b
	},
	createMainNodes: function() {
		var c = this,
			a = c.context,
			b;
		b = a.createGain();
		b.gain.value = Services.settingsManager.getSetting("volume");
		c.nodes = {
			mainVolume: b
		}
	},
	connectMainNodes: function() {
		var b = this,
			a = b.nodes;
		a.mainVolume.connect(b.context.destination)
	},
	loadSounds: function(f) {
		var e = this,
			c, d, a, g, b;
		f = f || "main";
		c = e.model.readData("files")[f];
		if (Sys.isObj(c)) {
			a = Object.keys(c);
			g = a.length;
			for (b = -1; ++b < g;) {
				d = e.loadSoundResource(f + "/" + a[b], c[a[b]])
			}
		} else {
			d = e.loadSoundResource(f, c)
		}
		if (d && f === "main") {
			e.fakeSound()
		}
	},
	loadSoundResource: function(b, a) {
		var c = this;
		if (!c.soundsToLoad.contains(b) && Sys.isDefined(a)) {
			c.soundsToLoad.push(b);
			c.fireEvent("view:loadResource", {
				name: b,
				type: "audioFile",
				url: a,
				successEvent: "notify:resourceLoader.soundLoaded",
				failEvent: "notify:resourceLoader.soundLoadingFailed"
			});
			return true
		}
		c.fireEvent("view:audioLoadError", "No config entry for sound resource", b);
		return false
	},
	fakeSound: function() {
		var a = this.context.createOscillator(),
			b = this.context.createGain();
		a.frequency.value = 440;
		b.gain.value = 0;
		a.connect(b);
		b.connect(this.context.destination);
		a.start(0);
		a.stop(0);
		a.disconnect(0);
		b.disconnect(0)
	},
	checkAPICompability: function(c) {
		var g = this,
			b = g.model.readData("clips"),
			a = c,
			f, j = true,
			d;
		if (Sys.isDefined(b[c])) {
			d = Object.keys(b[c]);
			a = d[d.length - 1]
		}
		f = g.setUpSource({
			name: a,
			volume: 0
		});
		try {
			f.source.start(0, 0);
			f.source.stop(g.context.currentTime)
		} catch (h) {
			j = false
		}
		g.canPlayWithoutDuration = j
	},
	onSoundResourceLoaded: function(b, e) {
		var d = this,
			h = b.split("/"),
			c, a = b,
			g = d.audioResources,
			f = d.audioBuffers;
		if (h.length > 1) {
			c = h[0];
			a = h[1];
			g = g[c];
			f = f[c];
			if (!Sys.isDefined(g)) {
				g = {};
				d.audioResources[c] = g;
				f = {};
				d.audioBuffers[c] = f
			}
		}
		g[a] = e;
		d.context.decodeAudioData(e, function(j) {
			var k = d.soundsToLoad.indexOf(b);
			f[a] = j;
			if (!d.initializedAudio) {
				d.setupEvents();
				d.createMainNodes();
				d.connectMainNodes();
				d.checkAPICompability(a);
				d.initializedAudio = true
			}
			if (k >= 0) {
				d.soundsToLoad.splice(k, 1);
				if (d.soundsToLoad.length === 0) {
					d.fireEvent("view:soundLoaded")
				}
			}
		}, d.fireEvent.bind(d, "view:audioLoadError", "Failed to decode audio file", b))
	},
	decodePreloadedAudio: function() {
		var b = this,
			a = Resources.readData("preloadedAudio");
		Sys.iterate(a, function(c) {
			b.soundsToLoad.push(c)
		});
		Sys.iterate(a, function(c, d) {
			b.onSoundResourceLoaded(c, d)
		})
	},
	callArrayOfCallbacks: function(b) {
		var a = this;
		Sys.each(a.callbacks[b].funcs, function(c) {
			c.call(a)
		});
		a.callbacks[b].funcs = []
	}
};
Core.Audio.AudioPlayerView = Sys.extend(Core.View, Core.Audio.AudioPlayerView, "Core.Audio.AudioPlayerView");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerEngineView = {
	constructor: function() {
		Core.Audio.AudioPlayerEngineView.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var b = this;
		b.model = a.model;
		b.MODULE_NAME = a.name;
		b.initializedAudio = false;
		b.soundsToLoad = []
	},
	setVolume: function() {},
	play: function() {},
	stop: function() {},
	duckSounds: function() {},
	stopNonLooping: function() {},
	abort: function() {},
	loadSounds: function(f) {
		var e = this,
			c, d, a, g, b;
		f = f || "main";
		c = e.model.readData("files")[f];
		if (Sys.isObj(c)) {
			a = Object.keys(c);
			g = a.length;
			for (b = -1; ++b < g;) {
				d = e.loadSoundResource(f + "/" + a[b], c[a[b]])
			}
		} else {
			d = e.loadSoundResource(f, c)
		}
		if (d && f === "main") {
			e.fakeSound()
		}
	},
	loadSoundResource: function(b, a) {
		var c = this;
		if (!c.soundsToLoad.contains(b) && Sys.isDefined(a)) {
			c.soundsToLoad.push(b);
			c.fireEvent("view:loadResource", {
				name: b,
				type: "audioFile",
				url: a,
				successEvent: "notify:resourceLoader.soundLoaded",
				failEvent: "notify:resourceLoader.soundLoadingFailed"
			});
			return true
		}
		c.fireEvent("view:audioLoadError", "No config entry for sound resource", b);
		return false
	},
	onSoundResourceLoaded: function(h, e) {
		var j = this,
			d = j.model.readData("clips"),
			g = h.split("/"),
			c, k = h,
			l, a, b, f;
		if (g.length > 1) {
			c = g[0];
			k = g[1]
		}
		Audio.Engine.add(k, e, function() {
			var m = j.soundsToLoad.indexOf(h);
			if (!j.initializedAudio) {
				j.setupEvents();
				j.initializedAudio = true
			}
			if (m >= 0) {
				j.soundsToLoad.splice(m, 1);
				if (j.soundsToLoad.length === 0) {
					j.fireEvent("view:soundLoaded")
				}
			}
		}, j.fireEvent.bind(j, "view:audioLoadError", "Failed to decode audio file", h));
		if (!Sys.isDefined(c)) {
			c = k;
			l = d[c];
			a = Object.keys(l);
			b = a.length;
			for (f = -1; ++f < b;) {
				k = a[f];
				l[k].source = c;
				Audio.Engine.addClipConfig(k, l[k])
			}
		}
	},
	decodePreloadedAudio: function() {
		var b = this,
			a = Resources.readData("preloadedAudio");
		Sys.iterate(a, function(c) {
			b.soundsToLoad.push(c)
		});
		Sys.iterate(a, function(c, d) {
			b.onSoundResourceLoaded(c, d)
		})
	},
	fakeSound: function() {
		Audio.Engine.playSound("nosound", {
			volume: 0
		}).stop(0)
	}
};
Core.Audio.AudioPlayerEngineView = Sys.extend(Core.View, Core.Audio.AudioPlayerEngineView, "Core.Audio.AudioPlayerEngineView");
Sys.ns("Core.Audio.Legacy");
Core.Audio.Legacy.LegacyAudioPlayerView = {
	constructor: function() {
		Core.Audio.Legacy.LegacyAudioPlayerView.superclass.constructor.apply(this, arguments);
		this.audioElements = {};
		this.clipsToLoad = [];
		this.callbacks = {}
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:audioDisabled": a.abort,
			"model:audioDisabled:hidden": a.abort
		})
	},
	play: function(e) {
		var d = this,
			b, a = e.name,
			g, f;
		e.buffer = e.buffer || "main";
		b = d.audioElements[e.buffer];
		g = d.model.readData("clips")[e.buffer][a];
		if (Sys.isDefined(b) && d.model.isState("audioEnabled")) {
			f = b[e.name];
			if (Sys.isDefined(f)) {
				if (d.currentClip) {
					d.stopCurrentClip()
				}
				if (!Sys.isDefined(e.volume)) {
					e.volume = Sys.isDefined(g.volume) ? g.volume : 1
				}
				if (e.loop) {
					e.loopHandler = function() {
						f.play()
					};
					f.addEventListener("ended", e.loopHandler, false)
				}
				d.currentClip = e;
				f.volume = Services.settingsManager.getSetting("volume") * e.volume;
				d.setupCallback(e.callback, f.duration, e.id, e.loop);
				try {
					f.play()
				} catch (c) {}
			}
		}
	},
	stopCurrentClip: function() {
		var c = this.currentClip,
			b = this.audioElements[c.buffer][c.name];
		try {
			b.currentTime = 0
		} catch (a) {}
		b.pause();
		if (c.loop) {
			b.removeEventListener("ended", c.loopHandler, false)
		}
		this.currentClip = undefined;
		if (Sys.isDefined(this.callbacks[c.id])) {
			clearTimeout(this.callbacks[c.id].timeout);
			this.callArrayOfCallbacks(c.id)
		}
	},
	stop: function(a) {
		if (Sys.isDefined(this.currentClip) && this.currentClip.id === a) {
			this.stopCurrentClip()
		}
	},
	stopNonLooping: function() {
		if (Sys.isDefined(this.currentClip) && !this.currentClip.loop) {
			this.stopCurrentClip()
		}
	},
	abort: function() {
		if (Sys.isDefined(this.currentClip)) {
			this.stopCurrentClip()
		}
	},
	setVolume: function(a) {
		var b = this.currentClip;
		if (Sys.isDefined(b)) {
			this.audioElements[b.buffer][b.name].volume = a * b.volume
		}
	},
	loadSounds: function(c) {
		var b = this,
			a, d;
		c = c || "main";
		if (!Sys.isObj(b.audioElements[c])) {
			a = b.model.readData("files")[c];
			if (Sys.isDefined(a)) {
				b.audioElements[c] = {};
				Sys.iterate(a, function(e, f) {
					d = c + ":" + e;
					b.clipsToLoad.push(d);
					b.fireEvent("view:loadResource", {
						name: d,
						type: "audioElementSource",
						url: f,
						successEvent: "notify:resourceLoader.soundLoaded",
						failEvent: "notify:resourceLoader.soundLoadingFailed"
					})
				})
			} else {
				b.fireEvent("view:audioLoadError", "No config entry for sound resource", c)
			}
		} else {
			if (b.clipsToLoad.length === 0) {
				b.fireEvent("view:soundLoaded")
			}
		}
	},
	onSoundResourceLoaded: function(a, c) {
		var b = this,
			d = b.clipsToLoad.indexOf(a),
			e = a.split(":");
		b.audioElements[e[0]][e[1]] = c;
		if (d >= 0) {
			b.clipsToLoad.splice(d, 1);
			if (b.clipsToLoad.length === 0) {
				b.fireEvent("view:soundLoaded")
			}
		}
	},
	callArrayOfCallbacks: function(b) {
		var a = this;
		Sys.each(a.callbacks[b].funcs, function(c) {
			c.call(a)
		});
		a.callbacks[b].funcs = []
	},
	setupCallback: function(h, f, g, a) {
		var d = this,
			e = f * 1000,
			b, c;
		if (!Sys.isDefined(h)) {
			return
		}
		b = function() {
			d.callArrayOfCallbacks(g)
		};
		if (Sys.isObj(d.callbacks[g])) {
			if (Sys.isEmpty(d.callbacks[g].funcs) && !a) {
				d.callbacks[g].timeout = setTimeout(b, e)
			}
			d.callbacks[g].funcs.push(h)
		} else {
			if (!a) {
				c = setTimeout(b, e)
			}
			d.callbacks[g] = {
				timeout: c,
				funcs: [h]
			}
		}
	}
};
Core.Audio.Legacy.LegacyAudioPlayerView = Sys.extend(Core.View, Core.Audio.Legacy.LegacyAudioPlayerView, "Core.Audio.Legacy.LegacyAudioPlayerView");
Sys.ns("Core");
Core.ResourceLoader = {
	constructor: function() {
		Core.ResourceLoader.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.ResourceLoaderModel,
			view: Core.ResourceLoaderView,
			controller: Core.ResourceLoaderController
		}
	}
};
Core.ResourceLoader = Sys.extend(Core.Module, Core.ResourceLoader, "Core.ResourceLoader");
Sys.ns("Core");
Core.ResourceLoaderController = {
	constructor: function() {
		Core.ResourceLoaderController.superclass.constructor.apply(this, arguments);
		this.requestedResources = {}
	},
	setupEvents: function() {
		var a = this;
		Core.ResourceLoaderController.superclass.setupEvents.call(a);
		a.on({
			"request:resourceLoader.loadResource": a.loadResource,
			"request:resourceLoader.removeLoadAnimation": a.removeLoadAnimation
		})
	},
	removeLoadAnimation: function() {
		this.model.setState("clearAnimations")
	},
	loadResource: function(c) {
		var b = this,
			a = b.requestedResources[c.url];
		if (Sys.isObj(a)) {
			if (a.status === "fetched" && c.successEvent) {
				b.fireEvent(c.successEvent, c.name, a.data)
			} else {
				if (a.status === "fetching") {
					a.requesters.push(c)
				}
			}
		} else {
			if (c.showLoadAnimation) {
				b.model.setState("showLoadAnimation")
			}
			b.requestedResources[c.url] = {
				status: "fetching",
				requesters: [c]
			};
			switch (c.type) {
				case "audioFile":
					b.fetchAudioFile(c);
					break;
				case "audioElementSource":
					b.fetchAudioElementSource(c);
					break;
				case "JSON":
					b.fetchJSON(c);
					break;
				default:
					b.fetchGenericResource(c)
			}
		}
	},
	fetchAudioFile: function(c) {
		var b = this,
			a = Sys.utils.httpGet({
				url: c.url,
				responseType: "arraybuffer"
			});
		a.fail(b.failedToLoadResource.bind(b, c)).then(function(d) {
			b.fetchedResource(c, d.response)
		})
	},
	fetchAudioElementSource: function(c) {
		var b = this,
			d = document.createElement("audio"),
			a = Sys.utils.httpGet({
				url: c.url
			});
		a.fail(b.failedToLoadResource.bind(b, c)).then(function() {
			d.src = c.url;
			d.load();
			b.fetchedResource(c, d)
		})
	},
	fetchJSON: function(c) {
		var b = this,
			a = Sys.utils.httpGet({
				url: c.url
			});
		a.fail(b.failedToLoadResource.bind(b, c)).then(function(d) {
			b.fetchedResource(c, d.responseText)
		})
	},
	fetchGenericResource: function(c) {
		var b = this,
			a = Sys.utils.httpGet({
				url: c.url
			});
		a.fail(b.failedToLoadResource.bind(b, c)).then(function(d) {
			b.fetchedResource(c, d)
		})
	},
	failedToLoadResource: function(c) {
		var b = this,
			a = this.requestedResources[c.url].requesters;
		delete this.requestedResources[c.url];
		Sys.each(a, function(d) {
			if (Sys.isDefined(d.failEvent)) {
				b.fireEvent(d.failEvent, c.name)
			}
		})
	},
	fetchedResource: function(d, c) {
		var a = this,
			b = a.requestedResources[d.url];
		b.status = "fetched";
		b.data = c;
		Sys.each(b.requesters, function(e) {
			if (Sys.isDefined(e.successEvent)) {
				a.fireEvent(e.successEvent, d.name, c)
			}
		});
		b.requesters = []
	}
};
Core.ResourceLoaderController = Sys.extend(Core.Controller, Core.ResourceLoaderController, "Core.ResourceLoaderController");
Sys.ns("Core");
Core.ResourceLoaderModel = {
	constructor: function() {
		Core.ResourceLoaderModel.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var b = Resources.readData("gameServerInitResponse");
		Core.ResourceLoaderModel.superclass.init.call(this, a);
		this.storeData("isRestore", b.restore)
	}
};
Core.ResourceLoaderModel = Sys.extend(Core.Model, Core.ResourceLoaderModel, "Core.ResourceLoaderModel");
Sys.ns("Core");
Core.ResourceLoaderView = {
	SPINNER: {
		width: 132,
		height: 130,
		sprite: "loadingAnimation",
		frameWidth: 132,
		frameHeight: 130,
		totalSpriteWidth: 1188,
		duration: 1000,
		endFrame: 8
	},
	FADE: {
		RESTORE: {
			startOpacity: 1,
			endOpacity: 1,
			duration: 100
		},
		STANDARD: {
			startOpacity: 0,
			endOpacity: 0.2,
			duration: 100
		}
	},
	constructor: function() {
		Core.ResourceLoaderView.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var b = this;
		Core.ResourceLoaderView.superclass.init.call(b, a);
		b.loaderList = new Animation.CanvasAnimationList({});
		b.fadeList = new Animation.CanvasAnimationList({});
		b.bonusGameName = "";
		b.loading = Services.languageManager.getText(Language.Keys.loading);
		b.loaderItem = b.createLoadItem();
		b.fadeItem = b.createFadeItem();
		b.loaderList.add(b.loaderItem)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:showLoadAnimation": a.showLoadAnimation,
			"model:hideLoadAnimation": a.hideLoadAnimation,
			"model:clearAnimations": a.removeAnimations
		})
	},
	createFadeItem: function() {
		var b = this.getLayeringValues(),
			a = this.FADE.STANDARD;
		return new Animation.CanvasAnimationItem({
			fullScreen: true,
			depth: b.fade,
			opacity: 0,
			executeBefore: function(c) {
				var d = this;
				c.fillStyle = "rgb(0,0,0)";
				c.fillRect(d.pivot.x, d.pivot.y, d.width, d.height)
			},
			operations: {
				fade: [{
					time: 0,
					value: a.startOpacity
				}, {
					time: a.duration,
					value: a.endOpacity
				}, {
					time: a.duration + 1,
					value: a.endOpacity,
					goTo: 1
				}]
			}
		})
	},
	createLoadItem: function() {
		var a = this.SPINNER,
			c = this.getLayeringValues(),
			b = Environment.getStageResolution();
		return new Animation.CanvasAnimationItem({
			left: Math.round((b.width - a.width) / 2),
			top: Math.round((b.height - a.height) / 2),
			width: a.width,
			height: a.height,
			frameWidth: a.frameWidth,
			frameHeight: a.frameHeight,
			totalSpriteWidth: a.totalSpriteWidth,
			image: a.sprite,
			spriteArray: Game.stage.view.animationManager.getSpriteSequence(a.sprite),
			depth: c.spinner,
			operations: {
				sprite: [{
					time: 0,
					value: 0
				}, {
					time: a.duration,
					value: a.endFrame,
					goTo: 0
				}]
			}
		})
	},
	showLoadAnimation: function() {
		var c = this,
			d = c.model.readData("isRestore"),
			a = c.fadeItem.prop.operations.fade,
			b = (d) ? c.FADE.RESTORE : c.FADE.STANDARD;
		c.loaderItem.restore();
		c.fadeItem.restore();
		a[0].value = b.startOpacity;
		a[1].value = b.duration;
		a[1].value = b.endOpacity;
		a[2].value = b.duration + 1;
		a[2].value = b.endOpacity;
		c.bonusGameName = "";
		c.fadeList.add(c.fadeItem);
		Game.stage.view.addToRenderLoop(c.loaderList);
		Game.stage.view.addToRenderLoop(c.fadeList);
		c.isRestore = d
	},
	hideLoadAnimation: function() {
		Game.stage.view.removeFromRenderLoop(this.loaderList, "base");
		if (this.isRestore) {
			this.clearFade()
		}
	},
	clearFade: function() {
		this.fadeList.items = [];
		Game.stage.view.removeFromRenderLoop(this.fadeList, "base")
	},
	removeAnimations: function() {
		Game.stage.view.removeFromRenderLoop(this.loaderList, "base");
		this.clearFade()
	},
	getLayeringValues: function() {
		return Layering.Game.ResourceLoader
	}
};
Core.ResourceLoaderView = Sys.extend(Core.View, Core.ResourceLoaderView, "Core.ResourceLoaderView");
Sys.ns("Core");
Core.KeyboardManager = {
	constructor: function() {
		Core.KeyboardManager.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return [{
			userInput: {
				inputEvents: ["keyUp", "keyDown"],
				listenToUserInput: true
			}
		}, "properties"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.KeyboardManagerModel,
			controller: Core.KeyboardManagerController
		}
	}
};
Core.KeyboardManager = Sys.extend(Core.Module, Core.KeyboardManager, "Core.KeyboardManager");
Sys.ns("Core");
Core.KeyboardManagerController = {
	constructor: function() {
		Core.KeyboardManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringStoppedState": a.model.storeData.bind(a.model, "quickStopAvailable", false),
			"notify:stateHandler.enteringSpinningState": a.model.storeData.bind(a.model, "quickStopAvailable", true)
		})
	},
	onUserInputKeyDown: function(b, a) {
		this.handleUserInput(a.keyCode, "down");
		this.model.storeData("currentState", "down")
	},
	onUserInputKeyUp: function(b, a) {
		this.handleUserInput(a.keyCode, "up");
		this.model.storeData("currentKey", "");
		this.model.storeData("currentState", "up")
	},
	handleUserInput: function(f, e) {
		var d = this,
			b = d.model,
			c = b.getKey(f),
			a = (b.readData("currentKey") !== f || b.readData("currentState") !== e);
		if (!b.hasProperty("disabled") && a && Sys.isDefined(c) && c.triggerOnState.contains(e)) {
			b.storeData("currentKey", f);
			d[c.action](e)
		}
	},
	onSpaceBarPressed: function(b) {
		var a = this;
		if (Services.settingsManager.getSetting("spacebarToSpin")) {
			if (b === "down") {
				window.onkeydown = function(c) {
					return c.keyCode !== 32
				};
				this.fireEvent("request:spinButton.pressed")
			} else {
				if (b === "up") {
					a.fireEvent("request:spinButton.released");
					a.fireEvent("request:abortPresentation");
					if (a.model.readData("quickStopAvailable")) {
						a.fireEvent("request:quickStopper.quickStop")
					}
				}
			}
		}
	}
};
Core.KeyboardManagerController = Sys.extend(Core.Controller, Core.KeyboardManagerController, "Core.KeyboardManagerController");
Sys.ns("Core");
Core.KeyboardManagerModel = {
	KEY_MAP: {
		32: {
			action: "onSpaceBarPressed",
			triggerOnState: ["down", "up"]
		}
	},
	constructor: function() {
		Core.KeyboardManagerModel.superclass.constructor.apply(this, arguments)
	},
	getKey: function(a) {
		return this.KEY_MAP[a]
	}
};
Core.KeyboardManagerModel = Sys.extend(Core.Model, Core.KeyboardManagerModel, "Core.KeyboardManagerModel");
Sys.ns("Interface");
Interface.Keyboard = {
	constructor: function() {
		Interface.Keyboard.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation", {
			userInput: {
				listenToUserInput: true
			}
		}]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Model,
			controller: Interface.KeyboardController,
			view: Interface.KeyboardView
		}
	}
};
Interface.Keyboard = Sys.extend(Core.Module, Interface.Keyboard, "Interface.Keyboard");
Sys.ns("Interface");
Interface.KeyboardController = {
	MAX_LENGTH: 8,
	constructor: function() {
		Interface.KeyboardController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:keyboard.open": a.open,
			"request:keyboard.close": a.close,
			"request:keyboard.cancel": a.cancel,
			"view:ok": a.onOkClicked,
			"view:cancel": a.onCancelClicked,
			"view:back": a.onBackKeyClicked,
			"view:keyClicked": a.onKeyClicked
		})
	},
	open: function(a) {
		var b = this;
		if (b.model.readData("isOpen") === true) {
			return
		}
		b.fireEvent("request:userInputManager.activateExclusivity", b.MODULE_NAME);
		a = a || {};
		if (a.formatFunction && Sys.isFunc(a.formatFunction)) {
			b.formatFunc = a.formatFunction
		}
		b.model.storeData("info", Sys.isDefined(a.info) ? a.info : "");
		b.model.storeData("label", Sys.isDefined(a.label) ? a.label : "");
		b.model.storeData("isOpen", true);
		b.model.storeData("minValue", a.minValue);
		b.updateModel("0");
		b.okCallback = a.okCallback;
		b.cancelCallback = a.cancelCallback;
		b.view.show()
	},
	close: function() {
		var a = this;
		a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
		a.view.hide();
		a.model.storeData("isOpen", false)
	},
	cancel: function() {
		if (this.model.readData("isOpen")) {
			this.onCancelClicked()
		}
	},
	onOkClicked: function() {
		var a = this;
		if (Sys.isFunc(a.okCallback)) {
			a.okCallback({
				formattedInput: a.model.readData("formattedInputField"),
				input: a.model.readData("inputField"),
				value: parseInt(a.model.readData("inputField"), 10),
				cents: parseInt(a.model.readData("inputField"), 10) * 100
			})
		}
		a.close()
	},
	onCancelClicked: function() {
		var a = this;
		a.updateModel("0");
		if (Sys.isFunc(a.cancelCallback)) {
			a.cancelCallback({
				formattedInput: a.model.readData("formattedInputField"),
				input: a.model.readData("inputField"),
				value: parseInt(a.model.readData("inputField"), 10),
				cents: parseInt(a.model.readData("inputField"), 10) * 100
			})
		}
		a.close()
	},
	onKeyClicked: function(b) {
		var c = this,
			a = c.model.readData("inputField");
		if (a.length < c.MAX_LENGTH) {
			a = Sys.utils.toInt(a) + b
		}
		c.updateModel(a);
		c.view.update()
	},
	onBackKeyClicked: function() {
		var b = this,
			a = b.model.readData("inputField");
		a = a.substring(0, a.length - 1);
		a = a.length === 0 ? "0" : a;
		b.updateModel(a);
		b.view.update()
	},
	updateModel: function(a) {
		var c = this,
			b = c.model;
		b.storeData("formattedInputField", c.formatFunc(a));
		b.storeData("inputField", a);
		b.storeData("value", parseInt(a, 10));
		b.storeData("cents", parseInt(a, 10) * 100);
		b.storeData("isOkButtonEnabled", c.isInputValid())
	},
	formatFunc: function(a) {
		return Services.moneyManager.formatMoneyCurrencySign(Sys.utils.toInt(a) * 100, undefined, 0)
	},
	isInputValid: function() {
		var b = this,
			c = b.model.readData("minValue"),
			a = b.model.readData("cents");
		return !Sys.isDefined(c) || (c > 0 && c <= a)
	}
};
Interface.KeyboardController = Sys.extend(Core.Controller, Interface.KeyboardController, "Interface.KeyboardController");
Sys.ns("Interface");
Interface.KeyboardView = {
	RENDER_TARGET: "gameWrapper",
	KEYPAD: "keyboardKeypad",
	constructor: function() {
		Interface.KeyboardView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Interface.KeyboardView.superclass.init.apply(this, arguments);
		a.container = new Sys.Element({
			id: "keyboard",
			tag: "div",
			cls: "interface-keyboard_container",
			renderTo: a.RENDER_TARGET,
			style: "display:none;"
		});
		a.info = new Sys.Element({
			id: "keyboardInfo",
			tag: "div",
			cls: "info",
			renderTo: "keyboard",
			innerHTML: a.model.readData("info")
		});
		a.label = new Sys.Element({
			id: "keyboardFieldContainerLabel",
			tag: "div",
			cls: "label",
			renderTo: "keyboard",
			innerHTML: a.model.readData("label")
		});
		a.fieldContainer = new Sys.Element({
			id: "keyboardFieldContainer",
			tag: "div",
			cls: "fieldContainer",
			renderTo: "keyboard"
		});
		a.value = new Sys.Element({
			id: "",
			tag: "div",
			cls: "value",
			renderTo: "keyboardFieldContainer",
			innerHTML: a.model.readData("formattedInputField")
		});
		a.keypad = new Sys.Element({
			id: a.KEYPAD,
			tag: "div",
			cls: "keypad digits",
			renderTo: "keyboard"
		});
		a.initKeyboard()
	},
	initKeyboard: function() {
		var d = this,
			c, a = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
			b;
		d.keys = [];
		for (c = 0; c < a.length; c++) {
			b = new Interface.utils.DOMButton({
				id: "keypad_num_" + a[c],
				textContent: a[c],
				clickCallback: d.fireEvent.bind(d, "view:keyClicked", a[c]),
				renderTo: d.KEYPAD,
				baseCSS: "button num_" + a[c],
				exclusiveUserInput: d.MODULE_NAME
			});
			d.keys.push(b)
		}
		d.cancelButton = new Interface.utils.DOMButton({
			id: "keypad_cancel",
			textContent: "",
			clickCallback: d.fireEvent.bind(d, "view:cancel"),
			renderTo: d.KEYPAD,
			baseCSS: "button cancelButton ",
			exclusiveUserInput: d.MODULE_NAME
		});
		d.okButton = new Interface.utils.DOMButton({
			id: "keypad_ok",
			textContent: "",
			clickCallback: d.fireEvent.bind(d, "view:ok"),
			renderTo: d.KEYPAD,
			baseCSS: "button okButton",
			exclusiveUserInput: d.MODULE_NAME
		});
		d.backButton = new Interface.utils.DOMButton({
			textContent: "",
			clickCallback: d.fireEvent.bind(d, "view:back"),
			renderTo: "keyboardFieldContainer",
			baseCSS: "button removeDigit",
			exclusiveUserInput: d.MODULE_NAME
		})
	},
	show: function() {
		this.update();
		this.container.el.style.display = "block"
	},
	hide: function() {
		this.container.el.style.display = "none"
	},
	update: function() {
		var c = this,
			b = c.model,
			a = b.readData("isOkButtonEnabled");
		c.label.getEl().innerHTML = b.readData("label");
		c.info.getEl().innerHTML = b.readData("info");
		c.value.getEl().innerHTML = b.readData("formattedInputField");
		if (a) {
			c.okButton.enable()
		} else {
			c.okButton.disable()
		}
	}
};
Interface.KeyboardView = Sys.extend(Core.View, Interface.KeyboardView, "Interface.KeyboardView");
Sys.ns("Game");
Game.Stage = {
	constructor: function() {
		Game.Stage.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			setupGame: {
				waitEvents: ["notify:animationManager.allImagesLoaded"]
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.StageModel,
			view: Game.StageView,
			controller: Game.StageController
		}
	}
};
Game.Stage = Sys.extend(Core.Module, Game.Stage, "Game.Stage");
Sys.ns("Game");
Game.StageController = {
	constructor: function() {
		Game.StageController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringBeforeLoaderCloseState": a.startRenderLoop,
			"request:stage.setupImages": a.onSetupImages,
			"request:stage.elevate": a.view.elevate.bind(a.view),
			"request:stage.lower": a.view.lower.bind(a.view),
			"request:stage.pauseAnimation": a.view.pauseAnimation.bind(a.view),
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	startRenderLoop: function() {
		this.model.setState("playRenderLoop")
	},
	switchScenes: function(a) {
		this.model.switchScenes(a)
	},
	getGameContainer: function() {
		return this.view.getGameContainer()
	},
	onSetupImages: function(a) {
		this.view.setupImages(a)
	},
	onGameSizeChanged: function() {
		if (Environment.allowsCustomCanvasSize()) {
			this.view.updateActiveRenderContextSize()
		}
	},
	getOrientationSpecificImage: function(a) {
		return this.view.getOrientationSpecificImage(a)
	}
};
Game.StageController = Sys.extend(Core.Controller, Game.StageController, "Game.StageController");
Sys.ns("Game");
Game.StageModel = {
	constructor: function() {
		Game.StageModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("config");
		b.storeData("images", Resources.readData("images"));
		b.storeData("sprites", a.sprites);
		b.storeData("reelConfig", a.reel);
		b.storeData("reelGroups", a.reelGroups);
		b.storeData("scenes", a.scenes);
		b.switchScenes("base")
	},
	getSymbolConfiguration: function(c, a) {
		var b = this;
		if (Sys.isDefined(b.readData("reelGroups"))) {
			return b.getNewSymbolConfiguration(c, a)
		} else {
			if (Sys.isDefined(b.readData("reelConfig"))) {
				return b.getLegacySymbolConfiguration(c, a)
			}
		}
		return undefined
	},
	getCurrentReelGroupConfiguration: function() {
		var a = this;
		if (Sys.isDefined(a.readData("reelGroups"))) {
			return a.getCompatibleReelGroupConfiguration()
		} else {
			if (Sys.isDefined(a.readData("reelConfig"))) {
				return a.readData("reelConfig")
			}
		}
		return undefined
	},
	getCompatibleReelGroupConfiguration: function() {
		var b = this.readData("reelGroups")["default"],
			m = this.readData("reelConfig") || {},
			h = m.reelFrame || {},
			n = this.getReelLayout(b.reelLayouts) || b.reelLayout,
			l = n.config || n.standard,
			c = {},
			d = l.left || 0,
			o = l.top || 0,
			a = 0,
			f = l.numberOfOutcomeSymbols || 0,
			e = b.numberOfReels,
			g = l.symbolWidths.standard,
			p = l.symbolHeights.standard,
			j, k;
		c = Sys.applyProperties(c, l);
		c.symbolWidth = Sys.isNumber(m.symbolWidth) ? m.symbolWidth : g;
		c.symbolHeight = Sys.isNumber(m.symbolHeight) ? m.symbolHeight : p;
		c.symbolCols = Sys.isNumber(m.symbolCols) ? m.symbolCols : b.numberOfReels;
		for (k = -1; ++k < e;) {
			j = n[k];
			if (k > 0) {
				d = Math.min(d, Sys.isNumber(j.left) ? j.left : d);
				o = Math.min(o, Sys.isNumber(j.top) ? j.top : o);
				a = Math.max(a, Sys.isNumber(j.left) ? j.left : d)
			} else {
				d = Sys.isNumber(j.left) ? j.left : d;
				o = Sys.isNumber(j.top) ? j.top : o;
				a = d
			}
			f = Math.max(f, (j.numberOfOutcomeSymbols || 0))
		}
		a = a + g - d;
		c.symbolRows = Sys.isNumber(m.symbolRows) ? m.symbolRows : f;
		c.reelFrame = {
			left: Sys.isNumber(h.left) ? h.left : d,
			top: Sys.isNumber(h.top) ? h.top : o,
			width: Sys.isNumber(h.width) ? h.width : a,
			height: Sys.isNumber(h.height) ? h.height : f * p
		};
		c.reelAreaTop = Sys.isNumber(m.reelAreaTop) ? m.reelAreaTop : o;
		c.reelAreaLeft = Sys.isNumber(m.reelAreaLeft) ? m.reelAreaLeft : d;
		c.reelSpacing = Sys.isNumber(m.reelSpacing) ? m.reelSpacing : Math.round((a - (g * e)) / (e - 1));
		c.symbolSpacing = Sys.isNumber(m.symbolSpacing) ? m.symbolSpacing : Math.round(l.symbolCenterToCenter - p);
		return c
	},
	getReelLayout: function(a) {
		var b;
		if (!Sys.isDefined(a)) {
			return null
		}
		b = Environment.getConfigForCurrentDeviceState(a);
		if (b === null) {}
		return b
	},
	getLegacySymbolConfiguration: function(e, b) {
		var d = this.readData("reelConfig"),
			c = d.symbolWidth,
			a = d.symbolHeight;
		return {
			width: c,
			height: a,
			top: d.reelAreaTop + (b * (a + d.symbolSpacing)),
			left: d.reelAreaLeft + (e * (c + d.reelSpacing))
		}
	},
	getNewSymbolConfiguration: function(f, c) {
		var g = this.readData("reelGroups")["default"],
			d = this.getReelLayout(g.reelLayouts) || g.reelLayout,
			e = d[f.toString()],
			h = d.config || d.standard,
			b = e.top || h.top,
			a = h.outcomeOffset || 0;
		return {
			width: h.symbolWidths.standard,
			height: h.symbolHeights.standard,
			top: b + a + (c * h.symbolCenterToCenter),
			left: e.left
		}
	},
	switchScenes: function(a) {
		this.storeData("currentScene", a);
		this.setState("switchScene", a)
	}
};
Game.StageModel = Sys.extend(Core.Model, Game.StageModel, "Game.StageModel");
Sys.ns("Game");
Game.StageView = {
	constructor: function() {
		Game.StageView.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		this.model = a.model;
		this.setupAnimationManager();
		this.setupEvents()
	},
	setupAnimationManager: function() {
		var b = this,
			a = Environment.getResolution();
		b.animationManager = new Animation.CanvasAnimationManager({
			parent: document.getElementById("gameElements"),
			images: b.model.readData("images"),
			sprites: b.model.readData("sprites"),
			top: "0px",
			left: "0px",
			height: a.height,
			width: a.width,
			scenes: b.model.readData("scenes")
		})
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:switchScene": a.switchScenes,
			"model:playRenderLoop": a.playRenderLoop
		})
	},
	updateActiveRenderContextSize: function() {
		var b = Environment.getResolution(),
			a = {
				width: b.width,
				height: b.height
			};
		this.animationManager.updateActiveRenderContextSize(a)
	},
	getOrientationSpecificImage: function(c) {
		var b = Environment.getViewportOrientation(),
			a = c + "_" + b.toLowerCase(),
			d = this.animationManager.images[a];
		if (Environment.allowsCustomCanvasSize() && Sys.isDefined(d)) {
			return a
		}
		return c
	},
	pauseAnimation: function() {
		this.animationManager.pauseAnimation()
	},
	switchScenes: function(a) {
		this.animationManager.switchScenes(a)
	},
	clearScene: function(a) {
		this.animationManager.clearScene(a)
	},
	playRenderLoop: function() {
		var a = this.model.readData("currentScene");
		this.animationManager.start(a)
	},
	addToRenderLoop: function(a, b) {
		this.animationManager.addToRenderLoop(a, b)
	},
	removeFromRenderLoop: function(a, b) {
		this.animationManager.removeList(a, b)
	},
	addImages: function(a) {
		this.animationManager.addImages(a)
	},
	setupImages: function(a) {
		this.animationManager.setupImages(a[0], a[1])
	},
	getGameContainer: function() {
		return document.getElementById("gameElements")
	},
	elevate: function() {
		this.getGameContainer().classList.add("elevated")
	},
	lower: function() {
		this.getGameContainer().className = this.getGameContainer().className.replace(/\belevated\b/, "")
	}
};
Game.StageView = Sys.extend(Core.View, Game.StageView, "Game.StageView");
Sys.ns("Game.Slots");
Game.Slots.QuickStopper = {
	constructor: function() {
		Game.Slots.QuickStopper.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["userInput", "animation", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.QuickStopperModel,
			view: Game.Slots.QuickStopperView,
			controller: Game.Slots.QuickStopperController
		}
	}
};
Game.Slots.QuickStopper = Sys.extend(Core.Module, Game.Slots.QuickStopper, "Game.Slots.QuickStopper");
Sys.ns("Game.Slots.Slots");
Game.Slots.QuickStopperController = {
	constructor: function() {
		Game.Slots.QuickStopperController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:quickStopper.disableInMode": a.disableInMode,
			"request:quickStopper.enableInMode": a.enableInMode,
			"request:quickStopper.quickStop": a.performQuickStop,
			"notify:spin.spinAnimationStarted": a.spinStarted,
			"notify:spin.spinAnimationComplete": a.spinStopped,
			"notify:spinButton.clicked": a.performQuickStop,
			"notify:spinButton.clickedWhileHidden": a.performQuickStop,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:quickStopper.quickStop", this, "When a quick stop is performed.")
	},
	onUserInputStart: function(a) {
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
			this.performQuickStop()
		}
	},
	spinStarted: function() {
		this.startListeningToUserInput();
		this.model.setState("spinning")
	},
	spinStopped: function() {
		var a = this;
		a.stopListeningToUserInput();
		a.model.setState("stopped");
		a.fireEvent("request:spinButton.enable", a.MODULE_NAME)
	},
	disableInMode: function(a) {
		this.model.setDisabledMode(a)
	},
	enableInMode: function(a) {
		this.model.removeDisabledMode(a)
	},
	performQuickStop: function() {
		var a = this;
		if (a.model.canQuickStop()) {
			a.model.setState("quickStop");
			a.fireEvent("notify:quickStopper.quickStop");
			a.fireEvent("request:audioPlayer.play", {
				name: "quickStop"
			});
			a.fireEvent("request:spinButton.disable", a.MODULE_NAME)
		}
	}
};
Game.Slots.QuickStopperController = Sys.extend(Core.Controller, Game.Slots.QuickStopperController, "Game.Slots.QuickStopperController");
Sys.ns("Game.Slots.Slots");
Game.Slots.QuickStopperModel = {
	constructor: function() {
		Game.Slots.QuickStopperModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.storeLayout();
		this.storeData("disabledInModes", [])
	},
	canQuickStop: function() {
		return this.isState("spinning") && !this.isInDisabledMode()
	},
	storeLayout: function() {
		var b = Game.stage.model.getCurrentReelGroupConfiguration(),
			a = b.symbolWidth * b.symbolCols + b.reelSpacing * (b.symbolCols - 1);
		return this.storeData("layout", {
			width: a,
			height: b.visibleLength,
			top: b.reelAreaTop,
			left: b.reelAreaLeft,
			depth: Layering.Game.Slots.QuickStop.flash
		})
	},
	isInDisabledMode: function() {
		return this.readData("disabledInModes").length > 0
	},
	setDisabledMode: function(c) {
		var b = this,
			a = b.readData("disabledInModes");
		if (a.indexOf(c) === -1) {
			a.push(c);
			b.storeData("disabledInModes", a)
		} else {}
	},
	removeDisabledMode: function(d) {
		var c = this,
			b = c.readData("disabledInModes"),
			a = b.indexOf(d);
		if (a > -1) {
			b.splice(a, 1);
			c.storeData("disabledInModes", b)
		} else {}
	}
};
Game.Slots.QuickStopperModel = Sys.extend(Core.Model, Game.Slots.QuickStopperModel, "Game.Slots.QuickStopperModel");
Sys.ns("Game.Slots");
Game.Slots.QuickStopperView = {
	constructor: function() {
		Game.Slots.QuickStopperView.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		this.on({
			"model:quickStop": this.quickStop
		})
	},
	initAnimations: function() {
		var b = this,
			a = b.model.readData("layout");
		b.animationList = new Animation.CanvasAnimationList();
		b.item = new Animation.CanvasAnimationItem({
			top: a.top,
			left: a.left,
			width: a.width,
			height: a.height,
			depth: a.depth,
			executeBefore: function(c) {
				c.fillStyle = "#FFFFFF";
				c.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
			},
			operations: {
				fade: [{
					time: 0,
					value: 0
				}, {
					time: 100,
					value: 0.2
				}, {
					time: 200,
					value: 0
				}]
			}
		});
		b.animationList.add(b.item);
		Game.stage.view.addToRenderLoop(b.animationList);
		b.animationList.stop()
	},
	refresh: function() {
		var b, a = this.item;
		if (Animation.utils.isAnimationItem(a)) {
			b = this.model.storeLayout();
			a.setLeft(b.left);
			a.setTop(b.top);
			a.setWidth(b.width);
			a.setHeight(b.height)
		}
	},
	quickStop: function() {
		this.animationList.restore();
		this.animationList.play()
	}
};
Game.Slots.QuickStopperView = Sys.extend(Core.View, Game.Slots.QuickStopperView, "Game.Slots.QuickStopperView");
Sys.ns("Game");
Game.Background = {
	constructor: function() {
		Game.Background.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Game.BackgroundController,
			view: Game.BackgroundView
		}
	}
};
Game.Background = Sys.extend(Core.Module, Game.Background, "Game.Background");
Sys.ns("Game");
Game.BackgroundController = {
	constructor: function() {
		Game.BackgroundController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:background.changeImage": a.changeImage,
			"request:background.restoreImage": a.restoreImage,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	changeImage: function(a) {
		this.view.changeImage(a)
	},
	restoreImage: function() {
		this.view.restoreImage()
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	}
};
Game.BackgroundController = Sys.extend(Core.Controller, Game.BackgroundController, "Game.BackgroundController");
Sys.ns("Game");
Game.BackgroundView = {
	BACKGROUND_IMAGE: "background",
	constructor: function() {
		Game.BackgroundView.superclass.constructor.apply(this, arguments)
	},
	changeImage: function(b) {
		var a = Resources.readData("animationImages");
		if ((Sys.isString(b) && Sys.isDefined(a[b])) || Sys.isObj(b)) {
			this.currentImage = b;
			this.item.setImage(Game.stage.getOrientationSpecificImage(b))
		}
	},
	restoreImage: function() {
		this.currentImage = this.BACKGROUND_IMAGE;
		this.item.setImage(Game.stage.getOrientationSpecificImage(this.currentImage))
	},
	refresh: function() {
		var a = Environment.getStageResolution();
		if (Animation.utils.isAnimationItem(this.item)) {
			this.item.setImage(Game.stage.getOrientationSpecificImage(this.currentImage));
			this.item.setWidth(a.width);
			this.item.setHeight(a.height)
		}
	},
	initAnimations: function() {
		var b = this,
			c = new Animation.CanvasAnimationList({}),
			a = new Animation.CanvasAnimationItem({
				fullScreen: true,
				depth: Layering.Game.Background.image,
				image: Game.stage.getOrientationSpecificImage(b.BACKGROUND_IMAGE)
			});
		c.add(a);
		b.list = c;
		b.item = a;
		b.currentImage = b.BACKGROUND_IMAGE;
		Game.stage.view.addToRenderLoop(c)
	}
};
Game.BackgroundView = Sys.extend(Core.View, Game.BackgroundView, "Game.BackgroundView");
Sys.ns("Game");
Game.Movie = {
	constructor: function() {
		Game.Movie.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			view: Game.MovieView,
			controller: Game.MovieController
		}
	}
};
Game.Movie = Sys.extend(Core.Module, Game.Movie, "Game.Movie");
Sys.ns("Game");
Game.MovieController = {
	constructor: function() {
		Game.MovieController.superclass.constructor.apply(this, arguments)
	},
	onUserInputEnd: function(a) {
		if (this.view.inputTargetsButton(Sys.UserInputUtils.getCoordinatesRelativeToElement(a, Game.stage.getGameContainer()))) {
			this.close()
		}
	},
	setupEvents: function() {
		var b = this,
			a = {
				"view:animationComplete": b.close
			};
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveEnd"] = b.onUserInputEnd;
		b.on(a)
	},
	show: function() {
		var a = this;
		a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
		a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
		a.view.play()
	},
	close: function() {
		var a = this;
		a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
		a.fireEvent("request:enableBasicGamePanel", a.MODULE_NAME);
		Services.settingsManager.storeSetting("volume", a.previousVolume, true);
		a.view.stop()
	}
};
Game.MovieController = Sys.extend(Core.Controller, Game.MovieController, "Game.MovieController");
Sys.ns("Game");
Game.MovieView = {
	SRC: "movie",
	DURATION: 10000,
	MOVIE_BUTTON_CONTINUE: {
		fontSize: 30,
		fontFamily: "Arial",
		key: Language.Keys.skipIntro,
		uppercase: false,
		centerX: 640,
		centerY: 640,
		width: 400,
		height: 200,
		maxWidth: 400,
		operations: [{
			fillStyle: "#FFFFFF",
			drawType: "fill"
		}]
	},
	constructor: function() {
		Game.MovieView.superclass.constructor.apply(this, arguments);
		this.scale = Environment.getVirtualToWindowScale(3)
	},
	play: function() {
		this.movieList.restore();
		this.movieList.play()
	},
	stop: function() {
		this.movieList.stop()
	},
	inputTargetsButton: function(f) {
		var e = this,
			c = e.MOVIE_BUTTON_CONTINUE,
			b = e.scaleValue(c.width),
			d = e.scaleValue(c.height),
			a = e.scaleValue(c.centerX) - (b / 2),
			g = e.scaleValue(c.centerY) - (d / 2);
		return (f.x >= a && f.x <= a + b && f.y >= g && f.y <= g + d)
	},
	initAnimations: function() {
		var b = this,
			d = new Animation.List({}),
			a = b.MOVIE_BUTTON_CONTINUE,
			c = b.getLayeringValues();
		b.movieItem = b.getMovieAnimation(c.video);
		b.continueButtonItem = b.getContinueButtonItem(a, c.button, Services.languageManager.getText(a.key));
		b.blackScreenItem = new Animation.Item({
			fullScreen: true,
			depth: c.video - 1,
			executeBefore: function(e) {
				e.fillRect(0, 0, this.width, this.height)
			},
			operations: {
				fade: [{
					time: 0,
					value: 1
				}, {
					time: b.DURATION / 2,
					value: 1,
					goTo: 0
				}]
			}
		});
		d.add(b.blackScreenItem);
		d.add(b.movieItem);
		d.add(b.continueButtonItem);
		Game.stage.view.addToRenderLoop(d);
		d.stop();
		b.movieList = d
	},
	getMovieAnimation: function(b) {
		var a = this;
		return new Animation.VideoItem({
			src: a.SRC,
			fullScreen: true,
			depth: b,
			callbacks: {
				canPlayThrough: a.fireEvent("view:introMovieBuffered")
			},
			operations: {
				fade: [{
					time: 0,
					value: 1
				}, {
					time: a.DURATION,
					value: 1,
					fireEvent: {
						event: "view:animationComplete",
						scope: a
					}
				}]
			}
		})
	},
	getContinueButtonItem: function(d, f, h) {
		var e = this.DURATION,
			c = document.createElement("canvas"),
			b = c.getContext("2d"),
			a = d.width,
			j = d.height,
			g = new Animation.CanvasAnimationItem({
				width: a,
				height: j,
				top: d.centerY - Math.round(j / 2),
				left: d.centerX - Math.round(a / 2),
				depth: f,
				image: c,
				customProps: {
					context: b
				},
				operations: {
					fade: [{
						time: 0,
						value: 1
					}, {
						time: e,
						value: 1
					}]
				}
			});
		c.width = a;
		c.height = j;
		b.textAlign = "center";
		b.textBaseline = "middle";
		h = (d.uppercase === true) ? h.toUpperCase() : h;
		Animation.utils.text.performOperations(h, d.fontSize + "px " + d.fontFamily, Math.round(d.width / 2), Math.round(d.height / 2), d.operations, b);
		return g
	},
	getLayeringValues: function() {
		return Layering.Game.Movie
	},
	scaleValue: function(a) {
		return Math.round(this.scale * a)
	}
};
Game.MovieView = Sys.extend(Core.View, Game.MovieView, "Game.MovieView");
Sys.ns("Game");
Game.IntroMovie = {
	constructor: function() {
		Game.IntroMovie.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model;
		return {
			showingIntroMovie: {
				state: {
					name: "ShowingIntroMovie",
					execute: function() {},
					waitEvents: {
						"notify:introMovie.closed": false
					}
				}
			},
			beforeLoaderClose: {
				queue: [function(b) {
					if (a.shouldShowIntroMovie()) {
						b.stateHandler.pushState(b.states.showingIntroMovie)
					}
				}]
			},
			setupGame: {
				waitEvents: ["notify:introMovie.buffered"]
			}
		}
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.IntroMovieModel,
			controller: Game.IntroMovieController,
			view: Game.IntroMovieView
		}
	}
};
Game.IntroMovie = Sys.extend(Game.Movie, Game.IntroMovie, "Game.IntroMovie");
Sys.ns("Game");
Game.IntroMovieController = {
	constructor: function() {
		Game.IntroMovieController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Game.IntroMovieController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"notify:stateHandler.enteringShowingIntroMovieState": a.show,
			"view:introMovieBuffered": a.fireEvent.bind(a, "notify:introMovie.buffered"),
			"notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
			"notify:stateHandler.leavingShowingIntroMovieState": a.view.stopBlackScreen.bind(a.view),
			"request:introMovie.close": a.close.bind(a)
		})
	},
	close: function() {
		var a = this;
		Game.IntroMovieController.superclass.close.apply(a, arguments);
		a.fireEvent("request:ambienceManager.ambiencePauseSwitch", false);
		a.fireEvent("request:stage.lower");
		a.fireEvent("notify:introMovie.closed");
		Services.storage.storeData("IntroMovie.showing", false)
	},
	show: function() {
		Game.IntroMovieController.superclass.show.apply(this, arguments);
		this.fireEvent("request:ambienceManager.ambiencePauseSwitch", true);
		this.fireEvent("request:stage.elevate");
		Services.storage.storeData("IntroMovie.showing", true)
	},
	onModulesFinishedLoading: function() {
		var a = this;
		if (a.model.shouldShowIntroMovie()) {
			a.previousVolume = Services.settingsManager.getSetting("volume");
			Services.settingsManager.storeSetting("volume", 0, true)
		}
	}
};
Game.IntroMovieController = Sys.extend(Game.MovieController, Game.IntroMovieController, "Game.IntroMovieController");
Sys.ns("Game");
Game.IntroMovieModel = {
	constructor: function() {
		Game.IntroMovieModel.superclass.constructor.apply(this, arguments)
	},
	shouldShowIntroMovie: function() {
		return this.readData("initNotRestore") && Services.settingsManager.getSetting("showIntroMovie")
	},
	setupData: function() {
		var a = Resources.readData("gameServerInitResponse");
		this.storeData("initNotRestore", a.clientaction === "init" && a.restore !== true);
		Services.storage.storeData("IntroMovie.showing", false)
	}
};
Game.IntroMovieModel = Sys.extend(Core.Model, Game.IntroMovieModel, "Game.IntroMovieModel");
Sys.ns("Game");
Game.IntroMovieView = {
	SRC: "introMovie",
	constructor: function() {
		Game.IntroMovieView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var c = this,
			e = new Animation.List({}),
			b = new Animation.List({}),
			a = c.MOVIE_BUTTON_CONTINUE,
			d = c.getLayeringValues();
		c.movieItem = c.getMovieAnimation(d.video);
		c.continueButtonItem = c.getContinueButtonItem(a, d.button, Services.languageManager.getText(a.key));
		c.blackScreenItem = new Animation.Item({
			fullScreen: true,
			depth: d.video - 1,
			executeBefore: function(f) {
				f.fillRect(0, 0, this.width, this.height)
			},
			operations: {
				fade: [{
					time: 0,
					value: 1
				}, {
					time: c.DURATION / 2,
					value: 1,
					goTo: 0
				}]
			}
		});
		b.add(c.blackScreenItem);
		Game.stage.view.addToRenderLoop(b);
		if (!c.model.shouldShowIntroMovie()) {
			b.stop()
		}
		c.backdropList = b;
		e.add(c.movieItem);
		e.add(c.continueButtonItem);
		Game.stage.view.addToRenderLoop(e);
		e.stop();
		c.movieList = e
	},
	stop: function() {
		var a = this;
		a.movieItem.stop();
		a.continueButtonItem.stop()
	},
	stopBlackScreen: function() {
		this.blackScreenItem.stop()
	}
};
Game.IntroMovieView = Sys.extend(Game.MovieView, Game.IntroMovieView, "Game.IntroMovieView");
Sys.ns("Core");
Core.Slots.BufferedSpin = {
	constructor: function() {
		Core.Slots.BufferedSpin.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model;
		return {
			idle: {
				queue: [function(b) {
					b.stateHandler.pushState(b.states.validateSpin);
					b.stateHandler.pushState(b.states.spinning)
				}],
				waitEvents: ["notify:spin.roundStart"]
			},
			validateSpin: {
				state: {
					name: "ValidateSpin",
					execute: function(b) {
						if (a.readData("isValidServerResponse")) {
							b.stateHandler.pushState(b.states.stopped);
							b.stateHandler.pushState(b.states.stopping);
							b.stateHandler.pushState(b.states.beforeStopping)
						} else {
							b.stateHandler.pushState(b.states.idle)
						}
					},
					waitEvents: {
						"notify:spin:serverResponseReceived": false
					}
				}
			},
			spinning: {
				state: {
					name: "Spinning",
					execute: function(b) {},
					waitEvents: {
						"notify:spin:serverResponseReceived": false
					}
				}
			},
			beforeStopping: {
				state: {
					name: "BeforeStopping",
					execute: function() {},
					waitEvents: {}
				}
			},
			stopping: {
				state: {
					name: "Stopping",
					execute: function(b) {},
					waitEvents: {
						"notify:spin.AllIsStopped": false
					}
				}
			},
			stopped: {
				state: {
					name: "Stopped",
					execute: function(b) {},
					waitEvents: {}
				}
			}
		}
	},
	getMixinDependencies: function() {
		return ["animation", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.BufferedSpinModel,
			view: Core.Slots.BufferedSpinView,
			controller: Core.Slots.BufferedSpinController
		}
	}
};
Core.Slots.BufferedSpin = Sys.extend(Core.Module, Core.Slots.BufferedSpin, "Core.Slots.BufferedSpin");
Sys.ns("Core.Slots");
Core.Slots.BufferedSpinModel = {
	constructor: function() {
		Core.Slots.BufferedSpinModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponse");
		b.storeData("nearWinEnabled", a.nearwinallowed);
		b.storeData("isValidServerResponse", false);
		b.storeData("initialOutcomes", b.parseInitialOutcomes());
		Resources.storeData("symbolLayout", [])
	},
	parseInitialOutcomes: function() {
		var b = Resources.readData("gameServerInitResponseObject"),
			c = b.rs,
			a = {};
		Sys.iterate(c, function(e, d) {
			a[d.id] = Sys.utils.parseReelInfo(b, d.id)
		});
		return a
	},
	setInitialOutcomeInfo: function(b, a) {
		var c = this.readData("initialOutcomes");
		c[b] = a;
		this.storeData("initialOutcomes", c)
	},
	setDefaultOutcome: function(b) {
		var c = this,
			a = c.getDefaultOutcome(b);
		c.setInitialOutcomeInfo(b, a)
	}
};
Core.Slots.BufferedSpinModel = Sys.extend(Core.Model, Core.Slots.BufferedSpinModel, "Core.Slots.BufferedSpinModel");
Sys.ns("Core.Slots");
Core.Slots.BufferedSpinView = {
	SPIN_SOUNDS: {
		basic: {
			spinStart: {
				id: "spinStart",
				name: "spinStart"
			},
			reelSpin: {
				id: "reelSpin",
				name: "reelSpin",
				loop: true
			},
			reelBounce: {
				id: "reelBounce",
				name: "reelBounce"
			},
			reelStop: {
				id: "reelStop",
				name: "reelStop"
			}
		}
	},
	constructor: function() {
		Core.Slots.BufferedSpinView.superclass.constructor.apply(this, arguments)
	},
	pauseStopSequenceConfig: {},
	initAnimations: function() {
		var d = this,
			b = Resources.readData("config").reelGroups,
			e = d.model.readData("currentReelSet"),
			a, c = [],
			g = {},
			h = {},
			f = this.model.readData("spinType");
		Sys.iterate(b, function(k, j) {
			a = new Core.Slots.ReelGroup(k, j, {
				reelStartCompleteCallback: d.onReelStartComplete.bind(d, k),
				reelStartedStoppingCallback: d.onReelStartedStopping.bind(d, k),
				reelBounceStartCallback: d.onReelStartedBouncing.bind(d, k),
				reelStoppedCallback: d.onReelStopped.bind(d, k),
				fillerEventCallback: d.onFillerEvent.bind(d)
			}, {
				nearWinEnabled: d.model.readData("nearWinEnabled")
			});
			if (Sys.isDefined(f)) {
				a.setSpinType(f)
			}
			c.push(a);
			Sys.each(j.reelSets, function(l) {
				g[l] = a
			});
			h[k] = a
		});
		d.reelGroups = c;
		d.reelSetToGroupMapping = g;
		d.groupNameToGroupMapping = h;
		if (Sys.isDefined(e)) {
			d.activateReelSet(e, d.model.readData("startScene"))
		}
	},
	onReelStartComplete: function(a, c) {
		var b = this;
		b.fireEvent("view:startSpinComplete", c);
		if (!b.spinSoundStarted) {
			b.fireEvent("view:playAudio", b.getSoundConfig("reelSpin"));
			b.spinSoundStarted = true
		}
	},
	onReelStartedStopping: function(a, b) {
		this.fireEvent("view:reelStopStarted", b)
	},
	onReelStartedBouncing: function(a, b) {
		this.playReelSpecificSound("reelBounce", b);
		this.fireEvent("view:reelStopBouncingStarted", b)
	},
	onReelStopped: function(b, e) {
		var d = this,
			c = d.groupNameToGroupMapping[b].reelLists[e],
			a = d.currentReelGroup();
		d.playReelSpecificSound("reelStop", e);
		d.updateSymbolLayout(c, e);
		d.fireEvent("view:reelStoppedSpinning", e);
		if (e === d.lastReelToStop) {
			d.fireEvent("view:stopAudio", d.getSoundConfig("reelSpin").id);
			d.fireEvent("view:allReelsStoppedSpinning")
		}
		if (a.nearWinEnabled === true && Sys.isDefined(a.nearWinList) && a.nearWinList.length > 0) {
			if (a.nearWinList.indexOf(e + 1) === 0) {
				d.fireEvent("view:nearWinStarted", e + 1)
			}
		}
		c.correctMisalignedOutcomeOnDeviceRotate()
	},
	refresh: function() {
		var a = this.reelGroups,
			b = Resources.readData("config").reelGroups;
		a.forEach(function(c) {
			c.refresh(b)
		})
	},
	updateSymbolLayout: function(a, b) {
		Resources.readData("symbolLayout")[b] = a.getSymbolLayout()
	},
	changeCurrentReelStopDelays: function(a) {
		this.currentReelGroup().changeCurrentReelStopDelays(a)
	},
	resetCurrentReelStopDelays: function() {
		this.currentReelGroup().resetCurrentReelStopDelays()
	},
	getSoundConfig: function(a) {
		var c = this,
			b = c.model.readData("currentReelSet"),
			d = c.SPIN_SOUNDS,
			e = d.basic[a];
		if (Sys.isDefined(d[b]) && Sys.isDefined(d[b][a])) {
			e = d[b][a]
		}
		return e
	},
	playReelSpecificSound: function(a, c) {
		var b = this.getSoundConfig(a),
			d = Sys.applyProperties({}, b);
		d.id += c;
		this.fireEvent("view:playAudio", d)
	},
	startSpin: function(c) {
		var d = this,
			a = d.currentReelGroup(),
			b = a.getReelCount() - 1;
		d.fireEvent("view:playAudio", d.getSoundConfig("spinStart"));
		if (Sys.isDefined(c)) {
			for (; b >= 0; --b) {
				if (!c.contains(b)) {
					break
				}
			}
		}
		d.lastReelToStop = b;
		d.isStopSequenceResuming = false;
		d.spinSoundStarted = false;
		a.lastReelToStop = d.lastReelToStop;
		a.startSpin(c)
	},
	stopSpin: function(b, a, c) {
		this.currentReelGroup().stopSpin(b, a, c)
	},
	cancelSpin: function() {
		this.currentReelGroup().cancelSpin()
	},
	pauseStopSequence: function(a, b) {
		this.currentReelGroup().pauseStopSequence(a, b)
	},
	resumeStopSequence: function(a, b) {
		this.currentReelGroup().resumeStopSequence(a, b)
	},
	activateReelSet: function(b, e) {
		var c = this,
			a, d;
		if (Sys.isDefined(c.reelSetToGroupMapping)) {
			a = c.reelSetToGroupMapping[b];
			if (Sys.isDefined(a)) {
				a.activate(b, e);
				c.model.storeData("currentReelSet", b);
				d = c.model.readData("initialOutcomes")[b];
				if (Sys.isDefined(d)) {
					a.presentOutcome(d, c.model.readData("serverResponse"))
				}
				a.reelLists.forEach(function(g, f) {
					c.updateSymbolLayout(g, f)
				})
			}
		} else {
			c.model.storeData("currentReelSet", b);
			c.model.storeData("startScene", e)
		}
	},
	deactivateReelSet: function(b) {
		var c = this,
			a;
		if (!Sys.isDefined(b)) {
			b = c.model.readData("currentReelSet")
		}
		if (Sys.isDefined(c.reelSetToGroupMapping)) {
			a = c.reelSetToGroupMapping[b];
			if (Sys.isDefined(a)) {
				a.deactivate(b)
			}
		} else {
			if (b === c.model.readData("currentReelSet")) {
				c.model.removeData("currentReelSet");
				c.model.removeData("startScene")
			}
		}
	},
	setSymbols: function(a) {
		this.currentReelGroup().setSymbols(a)
	},
	hide: function() {
		this.currentReelGroup().hide()
	},
	show: function() {
		this.currentReelGroup().show()
	},
	currentReelGroup: function() {
		return this.reelSetToGroupMapping[this.model.readData("currentReelSet")]
	},
	setReelVisibility: function(a) {},
	handleSymbols: function(a, b) {},
	setSpinType: function(c) {
		var b = -1,
			a = this.reelGroups;
		if (Sys.isDefined(a)) {
			for (; ++b < a.length;) {
				a[b].setSpinType(c)
			}
		}
		this.model.storeData("spinType", c)
	},
	quickStop: function() {
		var c = this,
			b = c.model.readData("currentReelSet"),
			a;
		if (Sys.isDefined(c.reelSetToGroupMapping)) {
			a = c.reelSetToGroupMapping[b];
			if (Sys.isDefined(a)) {
				a.quickStop()
			}
		}
	},
	hideSymbols: function(b) {
		var c = this,
			a = c.currentReelGroup();
		a.hideSymbols(b)
	},
	showSymbols: function(b) {
		var c = this,
			a = c.currentReelGroup();
		a.showSymbols(b)
	},
	setTimeToMoveOneSlot: function(b) {
		var a = this.currentReelGroup();
		a.setTimeToMoveOneSlot(b)
	},
	onFillerEvent: function() {
		var a = ["view:fillerEvent"];
		a.push.apply(a, Array.prototype.slice.call(arguments, 0));
		this.fireEvent.apply(this, a)
	}
};
Core.Slots.BufferedSpinView = Sys.extend(Core.View, Core.Slots.BufferedSpinView, "Core.Slots.BufferedSpinView");
Sys.ns("Core.Slots");
Core.Slots.BufferedSpinController = {
	constructor: function() {
		Core.Slots.BufferedSpinController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:responseParser.responseParsed": a.serverResponse,
			"notify:stateHandler.enteringSpinningState": a.wantStartSpin,
			"notify:stateHandler.enteringStoppingState": a.wantStopSpin,
			"notify:quickStopper.quickStop": a.quickStop,
			"notify:settingsManager.settingChanged": a.onSettingsChanged,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged,
			"request:spin.startNewRound": a.startNewRound,
			"request:spin.activateReelset": a.activateReelSet,
			"request:spin.activateInitReelset": a.activateReelSet,
			"request:spin.deactivateReelset": a.deactivateReelSet,
			"request:spin.startSpin": a.startSpin,
			"request:spin.stopSpin": a.stopSpin,
			"request:spin.cancelSpin": a.cancelSpin,
			"request:spin.activateDefaultOutcome": a.cancelSpin,
			"request:spin.setSymbols": a.setSymbols,
			"request:spin.pauseStopSequence": a.pauseStopSequence,
			"request:spin.resumeStopSequence": a.resumeStopSequence,
			"request:spin.updateInitReelInfo": a.setInitialOutcomeInfo,
			"request:spin.hideSymbols": a.hideSymbols,
			"request:spin.showSymbols": a.showSymbols,
			"request:spin.setTimeToMoveOneSlot": a.setTimeToMoveOneSlot,
			"request:spin.changeCurrentReelStopDelays": a.changeCurrentReelStopDelays,
			"request:spin.resetCurrentReelStopDelays": a.resetCurrentReelStopDelays,
			"view:startSpinComplete": a.onStartSpinComplete,
			"view:reelStoppedSpinning": a.announceReelStopped,
			"view:reelStopBouncingStarted": a.announceReelStopBouncingStarted,
			"view:allReelsStoppedSpinning": a.announceSpinComplete,
			"view:stopSequencePaused": a.announceSpinStopSequencePaused,
			"view:stopSequenceResumed": a.announceSpinStopSequenceResumed,
			"view:resumeStopSequence": a.resumeStopSequence,
			"view:reelStopStarted": a.announceStopSpinStarted,
			"view:fillerEvent": a.announceFillerEvent,
			"view:nearWinStarted": a.announceNearWinStarted,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop")
		})
	},
	registerTriggers: function(a) {
		a.registerTrigger("notify:spin.reelStopStarted", this, "The stop spin has started on the given reel.");
		a.registerTrigger("notify:spin.reelStopBouncingStarted", this, "Reel stop bounce started.");
		a.registerTrigger("notify:spin.spinAnimationStarted", this, "When reel starts spinning.");
		a.registerTrigger("notify:quickStopper.quickStop", this, "When spin is quick stopped.");
		a.registerTrigger("notify:spin.nearWinStarted", this, "Near win started.");
		a.registerTrigger("notify:spin.spinAnimationComplete", this, "When spin animation complete.")
	},
	serverResponse: function(a) {
		this.fireEvent("request:spin.child.storeServerResponse", a);
		if (!a.clientaction.contains("init") && a.clientaction !== "endbonus") {
			this.model.storeData("isValidServerResponse", true);
			this.fireEvent("notify:spin:serverResponseReceived")
		}
		this.model.storeData("serverResponse", a)
	},
	wantStartSpin: function() {
		this.fireEvent("request:spin.child.wantStartSpin");
		this.fireEvent("request:serverManager.sendAction", "nextAction")
	},
	wantStopSpin: function() {
		this.fireEvent("request:spin.child.wantStopSpin")
	},
	quickStop: function() {
		this.view.quickStop()
	},
	onSettingsChanged: function(a, c) {
		var b = this;
		if (a === "quickSpin") {
			b.updateSpinType();
			if (c) {
				b.fireEvent("request:spinButton.addDisplayType", "quickSpin")
			} else {
				b.fireEvent("request:spinButton.removeDisplayType", "quickSpin")
			}
		}
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	changeCurrentReelStopDelays: function(a) {
		this.view.changeCurrentReelStopDelays(a)
	},
	resetCurrentReelStopDelays: function() {
		this.view.resetCurrentReelStopDelays()
	},
	updateSpinType: function() {
		var a = this;
		if (Services.settingsManager.getSetting("quickSpin")) {
			a.view.setSpinType("quickSpin")
		} else {
			a.view.setSpinType("standard")
		}
	},
	setInitialOutcomeInfo: function(b, a) {
		this.model.setInitialOutcomeInfo(b, a)
	},
	startNewRound: function() {
		var a = this;
		if (a.waitingToStart) {
			return
		}
		if (Services.moneyManager.canPlaceAnotherBet()) {
			a.performSpin()
		} else {
			a.waitingToStart = true;
			Services.moneyManager.reloadBalance().done(function() {
				if (Services.moneyManager.canPlaceAnotherBet()) {
					a.performSpin()
				} else {
					a.fireEvent("request:errorManager.handleClientOutOfMoneyError")
				}
			}).fail(function() {
				a.fireEvent("request:errorManager.handleClientOutOfMoneyError")
			}).always(function() {
				a.waitingToStart = false
			})
		}
	},
	performSpin: function() {
		this.updateSpinType();
		this.fireEvent("notify:spin.roundStart");
		Services.moneyManager.placeBet()
	},
	activateReelSet: function(a, b) {
		this.view.activateReelSet(a, b);
		this.fireEvent("notify:spin.reelSetActivated", a)
	},
	deactivateReelSet: function() {
		this.view.deactivateReelSet()
	},
	startSpin: function(b, d) {
		var c = this,
			a = c.getHeldReels();
		c.aborted = false;
		c.dialogClosed = false;
		c.allReelsHaveStopped = false;
		c.model.storeData("isValidServerResponse", false);
		c.announceSpinStarted(b);
		if (b !== "respin" && c.model.readData("currentReelSet") !== b) {
			c.activateReelSet(b, d)
		}
		c.view.startSpin(a)
	},
	stopSpin: function(b, a, c) {
		this.view.stopSpin(b, a, c);
		this.setInitialOutcomeInfo(this.model.readData("currentReelSet"), b)
	},
	setSymbols: function(a) {
		this.view.setSymbols(a)
	},
	pauseStopSequence: function(a, b) {
		this.view.pauseStopSequence(a, b)
	},
	resumeStopSequence: function(a, b) {
		this.view.resumeStopSequence(a, b)
	},
	cancelSpin: function() {
		var a = this;
		a.view.cancelSpin();
		a.fireEvent("notify:spin:serverResponseReceived");
		a.fireEvent("notify:spin.spinCanceled");
		a.fireEvent("notify:spin.spinAnimationComplete");
		a.fireEvent("request:spin.child.revertSpin")
	},
	hideSymbols: function(a) {
		this.view.hideSymbols(a)
	},
	showSymbols: function(a) {
		this.view.showSymbols(a)
	},
	setTimeToMoveOneSlot: function(a) {
		this.view.setTimeToMoveOneSlot(a)
	},
	announceSpinStarted: function(a) {
		this.fireEvent("notify:spin.spinAnimationStarted", a)
	},
	onStartSpinComplete: function(a) {
		this.fireEvent("notify:spin.startSpinComplete", a)
	},
	announceReelStopped: function(a) {
		this.fireEvent("notify:spin.reelStoppedSpinning", a)
	},
	announceReelStopBouncingStarted: function(a) {
		this.fireEvent("notify:spin.reelStopBouncingStarted", a)
	},
	announceSpinComplete: function() {
		var a = this;
		if (a.aborted) {
			if (a.dialogClosed) {
				a.view.show()
			}
		}
		a.allReelsHaveStopped = true;
		this.fireEvent("notify:spin.spinAnimationComplete");
		this.fireEvent("notify:spin.AllIsStopped")
	},
	announceSpinStopSequencePaused: function() {
		this.fireEvent("notify:spin.stopSequencePaused")
	},
	announceSpinStopSequenceResumed: function() {
		this.fireEvent("notify:spin.stopSequenceResumed")
	},
	announceStopSpinStarted: function(a) {
		this.fireEvent("notify:spin.reelStopStarted", a)
	},
	announceFillerEvent: function(b) {
		var a = [];
		a.push("notify:spin." + b);
		a.push.apply(a, Array.prototype.slice.call(arguments, 1));
		this.fireEvent.apply(this, a)
	},
	announceNearWinStarted: function(a) {
		this.fireEvent("notify:spin.nearWinStarted", a)
	},
	getHeldReels: function() {
		var a = [];
		this.model.readData("serverResponse").reelInfo.forEach(function(c, b) {
			if (c.hold) {
				a.push(b)
			}
		});
		return a
	}
};
Core.Slots.BufferedSpinController = Sys.extend(Core.Controller, Core.Slots.BufferedSpinController, "Core.Slots.BufferedSpinController");
Sys.ns("Core.Slots");
Core.Slots.ReelGroup = function(d, a, c, b) {
	this.constructor(d, a, c, b)
};
Core.Slots.ReelGroup.prototype = {
	constructor: function(f, a, d, b) {
		var c = this,
			e = this.getReelLayout(a.reelLayouts) || a.reelLayout;
		c.createSymbolBuffer(a.numberOfReels, a.fillers, d);
		c.createReelLists(f, a.numberOfReels, e, d);
		c.groupName = f;
		c.spinType = "standard";
		c.spinTimes = a.spinTimes;
		c.gameModeSpinTimes = a.spinTimes.gameModes || {};
		c.nearWinEnabled = b.nearWinEnabled;
		c.lastReelToStop = c.getReelCount() - 1
	},
	createSymbolBuffer: function(c, b, a) {
		this.symbolBuffer = new Core.Slots.SymbolBuffer(c, b, a)
	},
	createReelLists: function(m, c, g, j) {
		var l = this,
			f = 0,
			e, k = Layering.Game.Slots.Spin[m].symbols,
			d = l.symbolBuffer,
			h, a, b = [];
		l.reelLists = [];
		l.slotLengthGroups = {};
		for (; f < c; f++) {
			e = Sys.applyProperties({}, g.standard || g.config);
			if (Sys.isDefined(g[f])) {
				Sys.applyProperties(e, g[f])
			}
			e.id = m + "_" + f;
			e.baseDepth += k;
			e.symbolRetrievalFunction = d.getSymbols.bind(d, f);
			Sys.applyProperties(e, l.getReelSpecificCallbacks(f, j));
			h = new Animation.BufferedReelList(e);
			a = h.getSlotLength();
			if (!Sys.isDefined(l.slotLengthGroups[a])) {
				l.slotLengthGroups[a] = []
			}
			l.slotLengthGroups[a].push(h);
			b.push(h.getVisibleSymbolsCount());
			l.reelLists.push(h)
		}
		l.symbolBuffer.setVisibleSymbolsCounts(b)
	},
	getReelLayout: function(a) {
		var b;
		if (!Sys.isDefined(a)) {
			return null
		}
		b = Environment.getConfigForCurrentDeviceState(a);
		if (b === null) {}
		return b
	},
	refresh: function(a) {
		var c = this.getReelLayout(a["default"].reelLayouts) || a["default"].reelLayout,
			d = Sys.applyProperties({}, c.config || c.standard),
			b = this.reelLists;
		d.baseDepth = Layering.Game.Slots.Spin[this.groupName].symbols;
		Sys.each(b, function(f, e) {
			if (Sys.isDefined(c[e])) {
				Sys.applyProperties(d, c[e])
			}
			f.refresh(d)
		})
	},
	getReelSpecificCallbacks: function(d, c) {
		var b = this,
			a = {};
		a.reelStartCompleteCallback = function() {
			if (d === b.lastReelToStop) {
				b.startSpinCompleteTime = Date.now();
				b.tryToStartStopSequence()
			}
			c.reelStartCompleteCallback(d)
		};
		a.reelStartedStoppingCallback = function() {
			c.reelStartedStoppingCallback(d)
		};
		a.reelBounceStartCallback = function() {
			c.reelBounceStartCallback(d)
		};
		a.reelStoppedCallback = function() {
			c.reelStoppedCallback(d)
		};
		return a
	},
	startSpin: function(b) {
		var c = this,
			a = c.reelLists;
		b = Sys.isDefined(b) ? b : [];
		c.symbolBuffer.cleanUp();
		c.symbolBuffer.setHeldReels(b);
		c.syncReels();
		c.hasBeenToldToStop = false;
		c.isQuickStopped = false;
		c.startSpinCompleteTime = undefined;
		c.hasPassedMinimumSpinTime = false;
		c.stopStartTime = undefined;
		c.stopSequencePausers = Sys.utils.init2dMatrix(c.getReelCount(), 0);
		Sys.each(a, function(d, e) {
			if (!b.contains(e)) {
				d.startSpin()
			}
		})
	},
	syncReels: function() {
		var d = this,
			b, e, a, c = d.symbolBuffer.workspace.heldReels;
		Sys.iterate(this.slotLengthGroups, function(g, f) {
			b = 0;
			Sys.each(f, function(h) {
				b = Math.max(b, h.getBufferOffset())
			});
			Sys.each(f, function(h) {
				e = h.getBufferOffset();
				a = d.reelLists.indexOf(h);
				if (a > -1 && !c.contains(a) && e < b) {
					h.setBufferOffset(b)
				}
			})
		})
	},
	setSpinType: function(a) {
		this.spinType = a
	},
	stopSpin: function(b, a, d) {
		var c = this;
		c.symbolBuffer.setOutcome(b, d);
		c.nearWinList = a;
		c.hasBeenToldToStop = true;
		c.tryToStartStopSequence()
	},
	cancelSpin: function() {
		this.presentOutcome(Resources.readData("config").reelSets[this.activeReelSet].noWinOutcome)
	},
	presentOutcome: function(d, e) {
		var c = this,
			b = c.symbolBuffer,
			a = c.reelLists;
		c.hasBeenToldToStop = false;
		c.stopSequencePausers = Sys.utils.init2dMatrix(c.getReelCount(), 0);
		b.cleanUp();
		b.clearBuffer();
		a.forEach(function(f) {
			f.reset()
		});
		b.setOutcome(d, e);
		c.stopNow();
		a.forEach(function(f) {
			f.presentOutcome()
		})
	},
	setTimeToMoveOneSlot: function(b) {
		var a = this.reelLists;
		a.forEach(function(c) {
			c.setTimeToMoveOneSlot(b)
		})
	},
	stopNow: function() {
		var d = this,
			a = d.getReelCount(),
			c = [],
			b;
		for (b = -1; ++b < a;) {
			if (d.stopSequencePausers[b].length === 0) {
				c[b] = 0
			} else {
				c[b] = Infinity;
				break
			}
		}
		for (; ++b < a;) {
			c[b] = Infinity
		}
		d.symbolBuffer.setStopDistance(c)
	},
	calculateSymbolsBeforeOutcome: function() {
		var o = this,
			n = o.getReelCount(),
			h = o.spinTimes[o.spinType],
			q = o.gameModeSpinTimes[o.activeReelSet] || {},
			k = q[o.spinType] || {},
			b = h.minimumSpinTime,
			g = Sys.isNumber(h.nearWinDelay) ? h.nearWinDelay : 0,
			l = [],
			a, d = h.reelStopDelays,
			j, p = o.symbolBuffer.getIndexOfLastStoppingReel(),
			r = o.nearWinList,
			e, c, m = 0,
			f = o.getRuntimeReelStopDelayOverride();
		if (Sys.isNumber(k.minimumSpinTime)) {
			b = k.minimumSpinTime
		}
		if (Sys.isNumber(k.nearWinDelay)) {
			g = k.nearWinDelay
		}
		if (Sys.isArray(k.reelStopDelays)) {
			d = k.reelStopDelays
		}
		if (Sys.isArray(f)) {
			d = f
		}
		a = (b - (Date.now() - o.startSpinCompleteTime));
		for (j = -1; ++j <= p;) {
			l[j] = 0
		}
		for (j = p; ++j < n;) {
			if (o.stopSequencePausers[j].length === 0) {
				e = a + d[j];
				if (o.nearWinEnabled && Sys.isArray(r)) {
					e += g * (r.indexOf(j) + 1)
				}
				c = Math.round(e / o.reelLists[j].getTimeToMoveOneSlot()) + m;
				if (c < 0) {
					m = -c;
					c = 0
				}
				l[j] = c
			} else {
				l[j] = Infinity;
				break
			}
		}
		for (; ++j < n;) {
			l[j] = Infinity
		}
		return l
	},
	tryToStartStopSequence: function() {
		var a = this;
		if (a.canStop()) {
			if (a.isQuickStopped) {
				a.stopNow()
			} else {
				a.symbolBuffer.setStopDistance(a.calculateSymbolsBeforeOutcome())
			}
		}
	},
	canStop: function() {
		return this.hasBeenToldToStop && Sys.isDefined(this.startSpinCompleteTime)
	},
	pauseStopSequence: function(a, e) {
		var d = this,
			c, b = d.getReelCount();
		if (!Sys.isDefined(a) || !Sys.isDefined(e)) {
			return
		}
		d.stopSequencePausers[e].push(a);
		c = d.symbolBuffer.getStopDistance();
		for (; e < b; ++e) {
			c[e] = Infinity
		}
		d.symbolBuffer.setStopDistance(c)
	},
	resumeStopSequence: function(a, d) {
		var c = this,
			b;
		if (!Sys.isDefined(a) || !Sys.isDefined(d)) {
			return
		}
		b = c.stopSequencePausers[d].indexOf(a);
		if (b >= 0) {
			c.stopSequencePausers[d].splice(b, 1);
			if (c.stopSequencePausers[d].length === 0) {
				c.tryToStartStopSequence()
			}
		}
	},
	getReelCount: function() {
		return this.reelLists.length
	},
	setSymbols: function(b) {
		var c = -1,
			a = this.reelLists;
		for (; ++c < a.length;) {
			if (Sys.isDefined(b[c])) {
				a[c].setSymbols(b[c])
			}
		}
	},
	hide: function() {
		Sys.each(this.reelLists, function(a) {
			a.stop()
		})
	},
	show: function() {
		Sys.each(this.reelLists, function(a) {
			a.show()
		})
	},
	hideReel: function(b) {
		var a = this.reelLists[b];
		if (Sys.isDefined(a)) {
			a.stop()
		}
	},
	showReel: function(b) {
		var a = this.reelLists[b];
		if (Sys.isDefined(a)) {
			a.play()
		}
	},
	hideSymbolsOnReel: function(c, b) {
		var a = this.reelLists[c];
		if (Sys.isDefined(a)) {
			a.hideSymbols(b)
		}
	},
	hideSymbols: function(a) {
		var b = this;
		Sys.iterate(a, function(d, c) {
			b.hideSymbolsOnReel(d, c)
		})
	},
	showSymbolsOnReel: function(c, b) {
		var a = this.reelLists[c];
		if (Sys.isDefined(a)) {
			a.showSymbols(b)
		}
	},
	showSymbols: function(a) {
		var b = this;
		Sys.iterate(a, function(d, c) {
			b.showSymbolsOnReel(d, c)
		})
	},
	activate: function(a, c) {
		var b = this;
		if (Sys.isDefined(b.activeReelSet)) {
			b.deactivate(b.activeReelSet)
		}
		Sys.each(b.reelLists, function(d) {
			Game.stage.view.addToRenderLoop(d, c)
		});
		b.symbolBuffer.activateReelSet(a);
		b.activeReelSet = a;
		b.scene = c;
		b.updateSpinTimings(a)
	},
	deactivate: function(a) {
		var b = this;
		if (a === b.activeReelSet) {
			Sys.each(b.reelLists, function(c) {
				Game.stage.view.removeFromRenderLoop(c, b.scene)
			});
			b.activeReelSet = undefined
		}
	},
	quickStop: function() {
		var a = this;
		a.isQuickStopped = true;
		if (a.canStop()) {
			a.stopNow()
		}
	},
	updateSpinTimings: function(a) {
		var b = this.gameModeSpinTimes;
		if (b[a] && Sys.isNumber(b[a].timeToMoveOneSlot)) {
			this.setTimeToMoveOneSlot(b[a].timeToMoveOneSlot)
		}
	},
	getRuntimeReelStopDelayOverride: function() {
		var a = this;
		if (Sys.isDefined(a.runtimeReelStopDelaysOverride) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet]) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType])) {
			return a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType]
		}
		return null
	},
	changeCurrentReelStopDelays: function(a) {
		var b = this;
		if (b.isValidReelStopDelays(a)) {
			b.runtimeReelStopDelaysOverride = b.runtimeReelStopDelaysOverride || [];
			b.runtimeReelStopDelaysOverride[b.activeReelSet] = b.runtimeReelStopDelaysOverride[b.activeReelSet] || [];
			b.runtimeReelStopDelaysOverride[b.activeReelSet][b.spinType] = a
		}
	},
	resetCurrentReelStopDelays: function() {
		var a = this;
		if (Sys.isDefined(a.runtimeReelStopDelaysOverride) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet]) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType])) {
			delete a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType]
		}
	},
	isValidReelStopDelays: function(a) {
		var b;
		if (!Sys.isArray(a)) {
			return false
		}
		if (a.length !== this.getReelCount()) {
			return false
		}
		for (b = 0; b < a.length; b++) {
			if (!Sys.isNumber(a[b]) || a[b] < 0) {
				return false
			}
		}
		return true
	}
};
Sys.ns("Core.Slots");
Core.Slots.Filler = function() {};
Core.Slots.Filler.prototype = {
	fill: function() {
		return true
	},
	cleanUp: function() {},
	analyzePipeBuffer: function(g, a, d) {
		var f = [],
			h = -1,
			e, c, b;
		if (!Sys.isDefined(d)) {
			d = [this.workspace.symbols.any]
		}
		for (b = -1; ++b < g.length;) {
			e = d.contains(g[b]);
			c = h === -1;
			if (e && c) {
				h = b
			} else {
				if (!e && !c) {
					f.push({
						start: h,
						length: b - h
					});
					h = -1
				}
			}
		}
		if (h !== -1) {
			f.push({
				start: h,
				length: a ? g.length - h : Infinity
			})
		}
		return f
	},
	fillSlots: function(b, a, c) {
		if (c < 0 || c >= a.length) {
			return
		}
		a.splice.apply(a, [c, b.length].concat(b))
	},
	setReelSet: function() {},
	wrapSymbols: function(c) {
		var a = [],
			b;
		for (b = -1; ++b < c.length;) {
			a.push(this.wrapSymbol(c[b]))
		}
		return a
	},
	wrapSymbol: function(a) {
		return {
			symbol: a
		}
	},
	evenBuffer: function(b) {
		var e = this,
			d, c = e.workspace,
			a = 0,
			f = false;
		for (d = -1; ++d < b.length;) {
			a = Math.max(a, b[d].length)
		}
		for (d = -1; ++d < b.length;) {
			if (!c.outcomeInsertedOnReel[d]) {
				while (b[d].length < a) {
					b[d].push(c.symbolConstants.any)
				}
			}
			f = f || e.slotsLeftInPipe(b[d])
		}
		return f
	},
	slotsLeftInBuffer: function(a, c) {
		var b = -1;
		for (; ++b < a.length;) {
			if (this.slotsLeftInPipe(a[b], c)) {
				return true
			}
		}
		return false
	},
	slotsLeftInPipe: function(b, c) {
		var a = -1;
		for (; ++a < b.length;) {
			if (Sys.isObj(b[a])) {
				continue
			}
			if (!Sys.isDefined(c) || c.contains(b[a])) {
				return true
			}
		}
		return false
	},
	pipeBufferContainsOutcome: function(b) {
		var a = -1;
		for (; ++a < b.length;) {
			if (b[a].isOutcomeSymbol) {
				return true
			}
		}
		return false
	},
	processOutcome: function() {},
	updateStoppingDistances: function() {}
};
Sys.ns("Core.Slots");
Core.Slots.SimpleFakeReelFiller = {
	constructor: function(a) {
		var b = this;
		Core.Slots.SimpleFakeReelFiller.superclass.constructor.apply(b, arguments);
		b.workspace = a;
		b.setReelSet(a.currentReelSet);
		b.cleanUp()
	},
	fill: function(d) {
		var k = this,
			f, b, g, c = k.reelPositions,
			l = k.workspace.symbolConstants,
			e = [l.any, l.fakeReel],
			a, h;
		for (f = -1; ++f < d.length;) {
			g = d[f];
			if (!k.slotsLeftInPipe(g, e)) {
				continue
			}
			a = k.reelStrips[f];
			h = c[f];
			for (b = -1; ++b < g.length;) {
				if (e.contains(g[b])) {
					g[b] = k.wrapSymbol(a[h]);
					h = ++h % a.length
				}
			}
			c[f] = h
		}
		return false
	},
	setReelSet: function(d) {
		var c = this,
			a = Resources.readData("config").reelSets,
			b = Sys.isDefined(a[d]) ? a[d] : a.basic;
		if (Sys.isDefined(b)) {
			c.reelStrips = b.fakeReels;
			c.reelPositions = Sys.utils.initArray(c.reelStrips.length, 0)
		}
	}
};
Core.Slots.SimpleFakeReelFiller = Sys.extend(Core.Slots.Filler, Core.Slots.SimpleFakeReelFiller, "Core.Slots.SimpleFakeReelFiller");
Sys.ns("Interface");
Interface.Ticker = {
	constructor: function() {
		Interface.Ticker.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["properties"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.TickerController,
			view: Interface.TickerBaseView,
			model: Core.Model
		}
	}
};
Interface.Ticker = Sys.extend(Core.Module, Interface.Ticker, "Interface.Ticker");
Sys.ns("Interface");
Interface.TickerBaseView = {
	BASE_CSS: "interface-ticker_container",
	CONTENT_CSS: "interface-ticker_text",
	BACKGROUND_URI: "interface-ticker_uri",
	RENDER_TARGET: "gameWrapper",
	ANIMATION_SPEED: 20000,
	constructor: function() {
		Interface.TickerBaseView.superclass.constructor.apply(this, arguments)
	},
	enable: function() {},
	disable: function() {},
	update: function() {}
};
Interface.TickerBaseView = Sys.extend(Core.View, Interface.TickerBaseView, "Interface.TickerBaseView");
Sys.ns("Interface");
Interface.TickerMobileView = {
	constructor: function() {
		Interface.TickerMobileView.superclass.constructor.apply(this, arguments);
		this.constructDOMElement();
		this.setupAnimation()
	},
	enable: function() {
		var a = this;
		if (a.model.hasProperty("enabled")) {
			a.container.el.style.display = "block";
			a.update();
			a.fireEvent("view:enabled")
		}
	},
	disable: function() {
		var a = this;
		if (!a.model.hasProperty("enabled")) {
			a.container.el.style.display = "none";
			a.update();
			a.fireEvent("view:disabled")
		}
	},
	update: function() {
		var b = this,
			a = b.model.readData("content");
		b.textContainer.removeAll();
		if (Sys.isDefined(a)) {
			if (!Sys.isArray(a)) {
				b.textContainer.add(a)
			} else {
				a.forEach(function(c) {
					b.textContainer.add(c)
				})
			}
		}
		if (b.model.readData("animate") === true) {
			b.textContainer.el.style.paddingLeft = "100%";
			b.textContainer.el.style.width = "auto";
			b.animation.run(b.textContainer.el)
		} else {
			b.textContainer.el.style.paddingLeft = "0";
			b.textContainer.el.style.width = "100%";
			b.animation.removeAnimation(b.textContainer.el)
		}
	},
	constructDOMElement: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "ticker",
			tag: "div",
			cls: a.BASE_CSS + " " + a.BACKGROUND_URI,
			renderTo: a.RENDER_TARGET
		});
		a.textContainer = new Sys.Element({
			tag: "div",
			cls: a.CONTENT_CSS
		});
		a.container.add(a.textContainer)
	},
	setupAnimation: function() {
		var a = this;
		if (!Sys.isDefined(a.animation)) {
			a.animationConfig = {
				name: "scrollingAnimation",
				duration: a.ANIMATION_SPEED,
				timingFunction: "linear",
				iterationCount: "infinite",
				frames: {
					"0%": {
						"-webkit-transform": "translateX(0);",
						"-moz-transform": "translateX(0);",
						"-o-transform": "translateX(0);",
						"-MS-transform": "translateX(0);",
						transform: "translateX(0);"
					},
					"100%": {
						"-webkit-transform": "translateX(-100%);",
						"-moz-transform": "translateX(-100%);",
						"-o-transform": "translateX(-100%);",
						"-MS-transform": "translateX(-100%);",
						transform: "translateX(-100%);"
					}
				}
			};
			a.animation = new Interface.utils.CSSAnimation(a.animationConfig)
		}
	},
	onOrientationChange: function() {
		var a = this.container.el;
		if (Platform.isEdgeBrowser) {
			setTimeout(function() {
				a.style.visibility = "hidden";
				setTimeout(function() {
					a.style.visibility = ""
				}, 200)
			}, 150)
		}
	}
};
Interface.TickerMobileView = Sys.extend(Interface.TickerBaseView, Interface.TickerMobileView, "Interface.TickerMobileView");
Sys.ns("Interface");
Interface.TickerController = {
	constructor: function() {
		Interface.TickerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:ticker.enable": a.enable,
			"request:ticker.disable": a.disable,
			"request:ticker.setText": a.setText,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged,
			"view:enabled": a.viewEnabled,
			"view:disabled": a.viewDisabled
		})
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.onOrientationChange)) {
			this.view.onOrientationChange()
		}
	},
	enable: function(c, a) {
		var b = this;
		b.addProperty("enabled", c);
		b.model.storeData("animate", a === true);
		b.view.enable()
	},
	disable: function(b) {
		var a = this;
		a.removeProperty("enabled", b);
		a.model.storeData("animate", false);
		a.view.disable()
	},
	setText: function(b) {
		var a = this;
		a.model.storeData("content", b);
		a.view.update()
	},
	viewEnabled: function() {
		var c = this,
			b = c.model.readData("spinButtonAlignment") || false,
			a = {
				orientation: "portrait",
				vertical: 0.13
			};
		if (b === false) {
			c.model.storeData("spinButtonAlignment", true);
			c.fireEvent("request:spinButton.moveButton", a)
		}
		c.fireEvent("request:balanceDisplay.addClass", "ticker")
	},
	viewDisabled: function() {
		var c = this,
			b = c.model.readData("spinButtonAlignment") || false,
			a = {
				orientation: "portrait",
				vertical: -0.13
			};
		if (b === true) {
			c.model.storeData("spinButtonAlignment", false);
			c.fireEvent("request:spinButton.moveButton", a)
		}
		c.fireEvent("request:balanceDisplay.removeClass", "ticker")
	}
};
Interface.TickerController = Sys.extend(Core.Controller, Interface.TickerController, "Interface.TickerController");
Sys.ns("Interface");
Interface.RoundStartButton = {
	constructor: function() {
		Interface.RoundStartButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation", "userInput", "properties"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Interface.RoundStartButtonModel,
			view: Interface.RoundStartButtonBaseView,
			controller: Interface.RoundStartButtonController
		}
	}
};
Interface.RoundStartButton = Sys.extend(Core.Module, Interface.RoundStartButton, "Interface.RoundStartButton");
Sys.ns("Game.Slots");
Interface.RoundStartButtonController = {
	ROUND_START_EVENT: undefined,
	constructor: function() {
		Interface.RoundStartButtonController.superclass.constructor.apply(this, arguments);
		this.view.setUpDOMStructure();
		this.properties = {}
	},
	setupEvents: function() {
		var a = this,
			b = {
				"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
				"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
				"notify:stateHandler.leavingBeforeLoaderCloseState": a.onLeavingIdleState,
				"notify:gameModeChanged": a.onGameModeChanged,
				"view:clicked": a.onClick,
				"view:hidden": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".hidden"),
				"view:shown": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".shown"),
				"view:pressed": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".pressed"),
				"view:released": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".released"),
				"view:disable": a.disable.bind(a),
				"view:hide": a.hide.bind(a),
				"view:show": a.show.bind(a),
				"view:enable": a.enable.bind(a),
				"request:enableBasicGamePanel": a.enable,
				"request:disableBasicGamePanel": a.disable
			};
		b["request:" + a.MODULE_NAME + ".hide"] = a.hideRequested;
		b["request:" + a.MODULE_NAME + ".show"] = a.show;
		b["request:" + a.MODULE_NAME + ".enable"] = a.enable;
		b["request:" + a.MODULE_NAME + ".disable"] = a.disableRequested;
		b["request:" + a.MODULE_NAME + ".addDisplayType"] = a.addDisplayType;
		b["request:" + a.MODULE_NAME + ".removeDisplayType"] = a.removeDisplayType;
		b["request:" + a.MODULE_NAME + ".addProperty"] = a.addProperty;
		b["request:" + a.MODULE_NAME + ".removeProperty"] = a.removeProperty;
		a.on(b)
	},
	onUserInputStart: function(a) {
		this.view.userInputStart(a)
	},
	onUserInputMove: function(a) {
		this.view.userInputMove(a)
	},
	onUserInputHover: function(a) {
		this.view.userInputHover(a)
	},
	onUserInputEnd: function(a) {
		this.view.userInputEnd(a)
	},
	onClick: function() {
		this.fireEvent(this.ROUND_START_EVENT)
	},
	removeProperty: function(c, b) {
		var a = this;
		if (a.model.hasProperty(c)) {
			a.model.removeProperty(c, b);
			if (!a.model.hasProperty(c)) {
				a.updateAppearance()
			}
			if (!a.model.readData("inIdleState") && !a.model.hasProperty("visibleDuringRound")) {
				a.hide(a.MODULE_NAME)
			}
		}
	},
	addDisplayType: function(b) {
		var a = !this.model.hasDisplayType(b);
		this.model.addDisplayType(b);
		if (a) {
			this.updateAppearance()
		}
	},
	removeDisplayType: function(a) {
		var b = this;
		if (b.model.hasDisplayType(a)) {
			b.model.removeDisplayType(a);
			if (!b.model.hasDisplayType(a)) {
				b.updateAppearance()
			}
		}
	},
	updateAppearance: function() {},
	hide: function(a) {
		this.addProperty("hidden", a)
	},
	hideRequested: function(a) {
		this.view.hideRequested(a)
	},
	show: function(a) {
		this.removeProperty("hidden", a)
	},
	enable: function(a) {
		this.removeProperty("disabled", a)
	},
	disable: function(a) {
		this.addProperty("disabled", a)
	},
	disableRequested: function(a) {
		this.view.disableRequested(a)
	},
	onEnteringIdleState: function() {
		var a = this;
		a.model.storeData("inIdleState", true);
		a.show(a.MODULE_NAME)
	},
	onLeavingIdleState: function() {
		var a = this;
		a.model.storeData("inIdleState", false);
		if (!a.model.hasProperty("visibleDuringRound")) {
			a.hide(a.MODULE_NAME)
		}
	},
	onGameModeChanged: function(b) {
		var a = this;
		a.model.storeData("currentGameMode", b);
		if (b === "BASIC") {
			a.enable("notInBasicGame");
			a.show("globalRequest");
			a.view.show()
		} else {
			a.disable("notInBasicGame");
			a.hide("globalRequest");
			a.view.disableRequested("notInBasicGame");
			a.view.hideRequested("globalRequest");
			a.updateVisibility()
		}
	}
};
Interface.RoundStartButtonController = Sys.extend(Core.Controller, Interface.RoundStartButtonController, "Interface.RoundStartButtonController");
Sys.ns("Interface");
Interface.RoundStartButtonModel = {
	DISPLAY_TYPES: {},
	PROPERTIES: {
		hidden: [],
		visibleDuringRound: [],
		visibleOnInput: []
	},
	constructor: function() {
		Interface.RoundStartButtonModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = Resources.readData("gameServerInitResponseObject"),
			a = b.gamestate ? b.gamestate : undefined,
			c = a ? a.current : undefined;
		this.data = {
			properties: this.PROPERTIES,
			displayTypes: this.DISPLAY_TYPES,
			currentGameMode: c ? c.toUpperCase() : undefined
		}
	},
	hasDisplayType: function(a) {
		return this.readData("displayTypes")[a]
	},
	addDisplayType: function(a) {
		this.readData("displayTypes")[a] = true
	},
	removeDisplayType: function(a) {
		this.readData("displayTypes")[a] = false
	}
};
Interface.RoundStartButtonModel = Sys.extend(Core.Model, Interface.RoundStartButtonModel, "Interface.RoundStartButtonModel");
Sys.ns("Interface");
Interface.RoundStartButtonBaseView = {
	BUTTON_ID: "roundStartButton",
	BASE_CSS: "interface-roundStartButton_base",
	PRESSED_CSS: "interface-roundStartButton_pressed",
	URI_BASE_CSS: "interface-roundStartButton",
	PORTRAIT_POSITION: {
		TOP: 0.5,
		LEFT: 0.5
	},
	LANDSCAPE_POSITION: {
		TOP: 0.5,
		LEFT: 0.5
	},
	PORTRAIT_SIZE: {
		ASPECT_RATIO: 1,
		HEIGHT: 0.2
	},
	LANDSCAPE_SIZE: {
		ASPECT_RATIO: 1,
		WIDTH: 0.2
	},
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.RoundStartButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpDOMStructure: function() {
		var a = this;
		a.container = new Sys.Element({
			tag: "div",
			id: a.BUTTON_ID,
			cls: a.BASE_CSS + " " + a.URI_BASE_CSS + "_default_uri",
			renderTo: a.RENDER_TARGET
		});
		a.model.storeData("currentUri", a.URI_BASE_CSS + "_default_uri");
		a.show();
		if (Sys.isDefined(a.model.hasProperty) && !a.model.hasProperty("hidden")) {
			a.show()
		} else {
			a.hide()
		}
	},
	userInputStart: function(c) {
		var b = this,
			a = b.isInputTarget(c);
		if (a) {
			if (!b.hidden()) {
				b.press()
			}
		} else {
			if (b.shouldBeHiddenByUserInput(c)) {
				b.hide()
			}
		}
		b.model.storeData("wasInitialInputTarget", a)
	},
	shouldBeHiddenByUserInput: function(a) {
		return !this.model.hasProperty("visibleOnInput") && Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)
	},
	userInputMove: function(c) {
		var b = this,
			a = b.isInputTarget(c);
		if (b.model.readData("wasInitialInputTarget") && !a) {
			b.userInputEnd(c)
		}
	},
	userInputHover: function(a) {},
	userInputEnd: function(c) {
		var b = this,
			a;
		if (b.model.readData("wasInitialInputTarget")) {
			a = b.isInputTarget(c);
			b.release(a);
			if (a) {
				b.fireEvent("view:clicked")
			}
		} else {
			if (!b.model.hasProperty("hidden")) {
				b.show()
			}
		}
		b.model.storeData("wasInitialInputTarget", false)
	},
	isInputTarget: function(a) {
		return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	press: function() {
		this.container.addCls(this.PRESSED_CSS);
		this.fireEvent("view:pressed")
	},
	release: function(a) {
		this.container.removeCls(this.PRESSED_CSS);
		this.fireEvent("view:released", a)
	},
	hide: function() {
		if (!this.hidden()) {
			this.container.el.style.display = "none";
			this.fireEvent("view:hidden")
		}
	},
	hidden: function() {
		return this.container.el.style.display === "none"
	},
	show: function() {
		if (this.hidden()) {
			this.container.el.style.display = "block";
			this.fireEvent("view:shown")
		}
	},
	enable: function() {
		this.container.el.style.opacity = 1
	},
	disable: function() {
		this.container.el.style.opacity = 0.5
	},
	setAppearance: function(c) {
		var d = this.URI_BASE_CSS + "_" + c + "_uri",
			b = this.container,
			a = this.model.readData("currentUri");
		b.replaceCSSClass(a, d, true);
		this.model.storeData("currentUri", d)
	},
	disableRequested: function(a) {
		this.fireEvent("view:disable", a)
	},
	hideRequested: function(a) {
		if (Sys.isDefined(a)) {
			this.fireEvent("view:hide", a)
		} else {
			this.hide()
		}
	},
	beforeLoaderClose: function() {}
};
Interface.RoundStartButtonBaseView = Sys.extend(Core.View, Interface.RoundStartButtonBaseView, "Interface.RoundStartButtonBaseView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButton = {
	constructor: function() {
		Interface.Slots.SpinButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["orientation", "userInput", "properties", "trigger"],
			desktop: [{
				userInput: {
					inputEvents: ["start", "end", "cancel", "move", "hover"]
				}
			}, "properties", "animation", "trigger"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Interface.Slots.SpinButtonModel,
			view: Interface.Slots.SpinButtonBaseView,
			controller: Interface.Slots.SpinButtonController
		}
	}
};
Interface.Slots.SpinButton = Sys.extend(Interface.RoundStartButton, Interface.Slots.SpinButton, "Interface.Slots.SpinButton");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonController = {
	ROUND_START_EVENT: "request:spin.startNewRound",
	constructor: function() {
		Interface.Slots.SpinButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.Slots.SpinButtonController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
			"request:spinButton.startRound": a.startRound,
			"request:spinButton.showCounter": a.showCounter,
			"request:spinButton.hideCounter": a.hideCounter,
			"request:spinButton.updateCounter": a.updateCounter,
			"request:spinButton.pressed": a.onPressedRequest,
			"request:spinButton.released": a.onReleasedRequest,
			"request:spinButton.moveButton": a.onMoveButtonRequest,
			"notify:settingsManager.settingChanged": a.settingsChanged,
			"notify:stateHandler.enteringFreeSpinIntroState": a.onEnteringFreespinIntro,
			"notify:stateHandler.leavingFreeSpinIntroState": a.onLeavingFreespinIntro,
			"notify:stateHandler.enteringFreeSpinOutroState": a.onEnteringFreespinOutro,
			"notify:stateHandler.leavingFreeSpinOutroState": a.onLeavingFreespinOutro,
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"view:playSound": a.playSoundForView,
			"view:notify": a.onViewNotify
		});
		if (Sys.isGcmEnabled) {
			a.on({
				"notify:stateHandler.enteringspinTypeRespinRestoreState": a.disable,
				"notify:stateHandler.leavingspinTypeRespinRestoreState": a.enable
			})
		}
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:spinButton.clicked", this, "Executed when the spin button is clicked");
		Services.trigger.registerTrigger("notify:spinButton.up", this, "When the spin button returns to the up state.");
		Services.trigger.registerTrigger("notify:spinButton.hover", this, "Executed when the spin button is hovered");
		Services.trigger.registerTrigger("notify:spinButton.down", this, "Executed when the spin button is down")
	},
	onMoveButtonRequest: function(a) {
		this.view.moveButtonPosition(a);
		this.fireEvent("request:quickSettingsMenu.movePosition", a)
	},
	playSoundForView: function(a) {
		this.fireEvent("request:audioPlayer.play", {
			name: a
		})
	},
	startRound: function() {
		this.fireEvent(this.ROUND_START_EVENT)
	},
	onPressedRequest: function() {
		if (this.model.readData("inIdleState")) {
			this.view.onPressedRequest()
		}
	},
	onReleasedRequest: function() {
		if (this.model.readData("inIdleState")) {
			this.view.onReleasedRequest()
		}
	},
	onLandscape: function() {
		var a = this;
		Mixins.orientation.controller.methods.onLandscape.apply(a, arguments);
		if (a.model.hasProperty("hidden")) {
			if (a.view.canInteractWhileHidden()) {
				a.startListeningToUserInput()
			} else {
				a.stopListeningToUserInput()
			}
		}
	},
	onPortrait: function() {
		var a = this;
		Mixins.orientation.controller.methods.onPortrait.apply(a, arguments);
		if (a.model.hasProperty("hidden")) {
			if (a.view.canInteractWhileHidden()) {
				a.startListeningToUserInput()
			} else {
				a.stopListeningToUserInput()
			}
		}
	},
	onEnteringIdleState: function() {
		var a = this;
		Interface.Slots.SpinButtonController.superclass.onEnteringIdleState.apply(a, arguments);
		if (a.model.hasProperty("disabledDuringRound")) {
			a.enable(a.MODULE_NAME)
		}
		a.view.disableSpinningAnimations()
	},
	onLeavingIdleState: function() {
		var a = this;
		Interface.Slots.SpinButtonController.superclass.onLeavingIdleState.apply(a, arguments);
		if (a.model.hasProperty("disabledDuringRound")) {
			a.disable(a.MODULE_NAME)
		}
		if (!a.model.hasProperty("disabled")) {
			a.view.enableSpinningAnimations()
		}
	},
	onBeforeLoaderClose: function() {
		this.view.beforeLoaderClose();
		this.updateAppearance();
		this.view.setFullscreenSafeArea()
	},
	onClick: function() {
		var b = this,
			a = b.model;
		if (a.hasProperty("hidden")) {
			if (b.view.canInteractWhileHidden()) {
				b.fireEvent("notify:spinButton.clickedWhileHidden")
			}
		} else {
			b.fireEvent("request:audioPlayer.play", {
				name: "spinButtonClick"
			});
			b.fireEvent("notify:spinButton.clicked", {
				skip: a.readData("noStopOnSpin")
			});
			if (a.readData("inIdleState")) {
				b.fireEvent(b.ROUND_START_EVENT)
			}
		}
	},
	onViewNotify: function(a) {
		this.fireEvent(a)
	},
	showCounter: function(a) {
		this.view.showCounter();
		if (Sys.isDefined(a)) {
			this.view.updateCounter(a)
		}
	},
	hideCounter: function() {
		this.view.hideCounter()
	},
	updateCounter: function(a) {
		this.view.updateCounter(a)
	},
	updateAppearance: function() {
		var c = this,
			b = c.model,
			a = "default";
		if (b.hasDisplayType("autoPlay")) {
			a = "autoPlay"
		} else {
			if (b.hasDisplayType("autoPlayStop")) {
				a = "autoPlayStop"
			} else {
				if (b.hasDisplayType("quickSpin")) {
					a = "quickSpin"
				}
			}
		}
		c.view.setAppearance(a);
		c.updateVisibility()
	},
	updateVisibility: function() {
		var b = this,
			c = b.model.hasProperty("hidden"),
			a = b.model.hasProperty("disabled");
		if (c) {
			b.view.hide()
		} else {
			b.view.show()
		}
		if (a) {
			b.view.disable()
		} else {
			b.view.enable()
		}
		if (!a && (!c || b.view.canInteractWhileHidden())) {
			b.startListeningToUserInput()
		} else {
			b.stopListeningToUserInput()
		}
	},
	settingsChanged: function(a, c) {
		var b = this;
		if (a === "leftHandMode") {
			b.model.storeData("leftHandMode", c);
			b.view.setPosition()
		}
	},
	onEnteringFreespinIntro: function() {
		this.hide(this.MODULE_NAME)
	},
	onLeavingFreespinIntro: function() {
		this.show(this.MODULE_NAME)
	},
	onEnteringFreespinOutro: function() {
		this.hide(this.MODULE_NAME)
	},
	onLeavingFreespinOutro: function() {
		this.show(this.MODULE_NAME)
	}
};
Interface.Slots.SpinButtonController = Sys.extend(Interface.RoundStartButtonController, Interface.Slots.SpinButtonController, "Interface.Slots.SpinButtonController");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonModel = {
	DISPLAY_TYPES: {
		autoPlay: false,
		autoPlayStop: false,
		quickSpin: false
	},
	constructor: function() {
		Interface.Slots.SpinButtonModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Services.localStorageManager.hasData("leftHandMode") && Services.localStorageManager.readData("leftHandMode") === "true";
		Interface.Slots.SpinButtonModel.superclass.setupData.apply(this, arguments);
		this.storeData("leftHandMode", a)
	}
};
Interface.Slots.SpinButtonModel = Sys.extend(Interface.RoundStartButtonModel, Interface.Slots.SpinButtonModel, "Interface.Slots.SpinButtonModel");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonBaseView = {
	BUTTON_ID: "spinButton",
	BASE_CSS: "interface-roundStartButton_base",
	URI_BASE_CSS: "interface-spinButton",
	COUNTER_BASE_CSS: "utils_center interface-spinButton_counter",
	BUTTON_POSITION: {
		PORTRAIT: {
			LEFT: {
				RIGHT: 0.5
			},
			RIGHT: {
				LEFT: 0.5
			}
		},
		LANDSCAPE: {
			LEFT: {
				RIGHT: 0.5
			},
			RIGHT: {
				LEFT: 0.5
			}
		}
	},
	constructor: function() {
		Interface.Slots.SpinButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpDOMStructure: function() {
		var a = this;
		a.updatePositionProperties();
		Interface.Slots.SpinButtonBaseView.superclass.setUpDOMStructure.apply(a, arguments);
		a.counter = new Sys.Element({
			tag: "div",
			cls: a.COUNTER_BASE_CSS,
			style: "display:none;"
		});
		a.container.add(a.counter)
	},
	setFullscreenSafeArea: function() {
		var a = this;
		a.fireEvent("view:setSafeArea", "spinButton", {
			element: a.container.getEl()
		})
	},
	showCounter: function() {
		this.counter.el.style.display = "block"
	},
	hideCounter: function() {
		this.counter.el.style.display = "none"
	},
	updateCounter: function(a) {
		this.counter.el.textContent = a
	},
	setStyle: function(c) {
		var d = this,
			a = d.counter,
			b = c === "LANDSCAPE" ? "PORTRAIT" : "LANDSCAPE";
		Mixins.orientation.view.methods.setStyle.call(d, c);
		a.removeCls(d["COUNTER_" + b + "_CSS"]);
		a.addCls(d["COUNTER_" + c + "_CSS"])
	},
	canInteractWhileHidden: function() {
		return false
	},
	setPosition: function(a) {
		this.updatePositionProperties();
		Mixins.orientation.view.methods.setPosition.call(this, a || this.currentOrientation)
	},
	updatePositionProperties: function() {
		var b = this,
			a = b.model.readData("leftHandMode") ? "LEFT" : "RIGHT";
		b.LANDSCAPE_POSITION = b.BUTTON_POSITION.LANDSCAPE[a];
		b.PORTRAIT_POSITION = b.BUTTON_POSITION.PORTRAIT[a]
	},
	enable: function() {
		if (!this.model.hasProperty("hidden")) {
			this.show()
		}
	},
	disable: function() {
		this.hide()
	},
	enableSpinningAnimations: function() {},
	disableSpinningAnimations: function() {},
	onPressedRequest: function() {},
	onReleasedRequest: function() {},
	moveButtonPosition: function() {}
};
Interface.Slots.SpinButtonBaseView = Sys.extend(Interface.RoundStartButtonBaseView, Interface.Slots.SpinButtonBaseView, "Interface.Slots.SpinButtonBaseView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonMobileView = {
	BUTTON_POSITION: {
		PORTRAIT: {
			LEFT: {
				BELOW_GAME: true,
				TOP: 0.4,
				LEFT: 0.5,
				MIN_TOP: 825
			},
			RIGHT: {
				BELOW_GAME: true,
				TOP: 0.4,
				LEFT: 0.5,
				MIN_TOP: 825
			}
		},
		LANDSCAPE: {
			LEFT: {
				TOP: 0.5,
				RIGHT: 0.82
			},
			RIGHT: {
				TOP: 0.5,
				LEFT: 0.9
			}
		}
	},
	PORTRAIT_POSITION: {
		BELOW_GAME: true,
		TOP: 0.4,
		LEFT: 0.5,
		MIN_TOP: 825
	},
	LANDSCAPE_POSITION: {
		TOP: 0.5,
		LEFT: 0.9
	},
	PORTRAIT_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		WIDTH: 0.296
	},
	LANDSCAPE_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		HEIGHT: 0.296
	},
	constructor: function() {
		var a;
		Interface.Slots.SpinButtonMobileView.superclass.constructor.apply(this, arguments);
		this.canInteract = false;
		a = Resources.readData("config");
		this.hideSpinButtonInMobilePortrait = Sys.isObj(a) && Boolean(a.hideSpinButtonInMobilePortrait)
	},
	shouldBeHiddenByUserInput: function(a) {
		return Interface.Slots.SpinButtonMobileView.superclass.shouldBeHiddenByUserInput.apply(this, arguments) && (Environment.orientation() === "LANDSCAPE" || this.hideSpinButtonInMobilePortrait)
	},
	moveButtonPosition: function(b) {
		var c = this,
			a;
		if (Sys.isDefined(b)) {
			if (Sys.isDefined(b.orientation)) {
				a = b.orientation.toLowerCase() === "portrait" ? "PORTRAIT" : "LANDSCAPE";
				if (Sys.isDefined(b.vertical)) {
					c.BUTTON_POSITION[a].LEFT.TOP = c.BUTTON_POSITION[a].LEFT.TOP + b.vertical;
					c.BUTTON_POSITION[a].RIGHT.TOP = c.BUTTON_POSITION[a].RIGHT.TOP + b.vertical
				}
				if (Sys.isDefined(b.horizontal)) {
					c.BUTTON_POSITION[a].LEFT.RIGHT = c.BUTTON_POSITION[a].LEFT.RIGHT + (-1 * b.horizontal);
					c.BUTTON_POSITION[a].RIGHT.LEFT = c.BUTTON_POSITION[a].RIGHT.LEFT + b.horizontal
				}
			}
			c.setPosition()
		}
	},
	setStyle: function() {
		var a = this;
		Interface.Slots.SpinButtonMobileView.superclass.setStyle.apply(a, arguments);
		if (a.model.hasProperty("hidden")) {
			a.hide()
		} else {
			a.show()
		}
	},
	show: function(a) {
		this.container.el.style.opacity = 1;
		Interface.Slots.SpinButtonMobileView.superclass.show.call(this, a)
	},
	hide: function(a) {
		var b = this;
		if (Environment.orientation() === "PORTRAIT" && !b.hideSpinButtonInMobilePortrait) {
			b.container.el.style.opacity = "0.5";
			b.container.el.style.display = "block";
			b.canInteract = true
		} else {
			b.canInteract = false;
			b.container.el.style.opacity = 1;
			Interface.Slots.SpinButtonMobileView.superclass.hide.call(b, a)
		}
	},
	disable: function() {
		var a = this;
		if (a.model.hasProperty("hidden") && a.model.readData("currentGameMode") === "BASIC") {
			a.hide()
		} else {
			if (a.model.readData("currentGameMode") !== "BASIC") {
				a.fireEvent("view:show", "globalRequest");
				a.fireEvent("view:enable", "notInBasicGame");
				a.fireEvent("view:enable", "freespinSplash")
			}
		}
	},
	disableRequested: function() {
		this.disable()
	},
	hideRequested: function(b) {
		var a = this;
		if (a.model.readData("currentGameMode") === "BASIC") {
			a.fireEvent("view:hide", b)
		} else {
			if (a.model.readData("currentGameMode") !== "BASIC") {
				a.fireEvent("view:show", "globalRequest");
				a.fireEvent("view:enable", "notInBasicGame");
				a.fireEvent("view:enable", "freespinSplash")
			}
		}
	},
	hidden: function() {
		var a = this,
			b = Environment.orientation() === "PORTRAIT" && a.hideSpinButtonInMobilePortrait;
		return a.container.el.style.display === "none" || (b && a.container.el.style.opacity === "0.5")
	},
	canInteractWhileHidden: function() {
		return this.canInteract
	}
};
Interface.Slots.SpinButtonMobileView = Sys.extend(Interface.Slots.SpinButtonBaseView, Interface.Slots.SpinButtonMobileView, "Interface.Slots.SpinButtonMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonMobileFullscreenCanvasView = {
	BUTTON_POSITION: {
		PORTRAIT: {
			LEFT: {
				BOTTOM: 0.3,
				LEFT: 0.5,
				MIN_BOTTOM: 100
			},
			RIGHT: {
				BOTTOM: 0.3,
				LEFT: 0.5,
				MIN_BOTTOM: 100
			}
		},
		LANDSCAPE: {
			LEFT: {
				TOP: 0.5,
				RIGHT: 0.82
			},
			RIGHT: {
				TOP: 0.5,
				LEFT: 0.9
			}
		}
	},
	PORTRAIT_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		WIDTH: 0.296
	},
	constructor: function() {
		Interface.Slots.SpinButtonMobileFullscreenCanvasView.superclass.constructor.apply(this, arguments);
		this.canInteract = false
	}
};
Interface.Slots.SpinButtonMobileFullscreenCanvasView = Sys.extend(Interface.Slots.SpinButtonMobileView, Interface.Slots.SpinButtonMobileFullscreenCanvasView, "Interface.Slots.SpinButtonMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonTabletView = {
	BUTTON_POSITION: {
		PORTRAIT: {
			LEFT: {
				TOP: 0.5,
				RIGHT: 0.82
			},
			RIGHT: {
				TOP: 0.5,
				LEFT: 0.9
			}
		},
		LANDSCAPE: {
			LEFT: {
				TOP: 0.5,
				RIGHT: 0.82
			},
			RIGHT: {
				TOP: 0.5,
				LEFT: 0.9
			}
		}
	},
	PORTRAIT_POSITION: {
		TOP: 0.5,
		LEFT: 0.9
	},
	LANDSCAPE_POSITION: {
		TOP: 0.5,
		LEFT: 0.9
	},
	PORTRAIT_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		HEIGHT: 0.296
	},
	LANDSCAPE_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		HEIGHT: 0.222
	},
	constructor: function() {
		Interface.Slots.SpinButtonTabletView.superclass.constructor.apply(this, arguments)
	},
	disable: function() {
		var a = this;
		if (a.model.hasProperty("hidden") && a.model.readData("currentGameMode") === "BASIC") {
			a.hide()
		} else {
			if (a.model.readData("currentGameMode") !== "BASIC") {
				a.fireEvent("view:show", "globalRequest");
				a.fireEvent("view:enable", "notInBasicGame");
				a.fireEvent("view:enable", "freespinSplash")
			}
		}
	},
	disableRequested: function() {
		this.disable()
	},
	hideRequested: function(b) {
		var a = this;
		if (a.model.readData("currentGameMode") === "BASIC") {
			a.fireEvent("view:hide", b)
		} else {
			if (a.model.readData("currentGameMode") !== "BASIC") {
				a.fireEvent("view:show", "globalRequest");
				a.fireEvent("view:enable", "notInBasicGame");
				a.fireEvent("view:enable", "freespinSplash")
			}
		}
	}
};
Interface.Slots.SpinButtonTabletView = Sys.extend(Interface.Slots.SpinButtonBaseView, Interface.Slots.SpinButtonTabletView, "Interface.Slots.SpinButtonTabletView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonDesktopView = {
	SOUND_UP: "buttonUp",
	SOUND_DOWN: "buttonDown",
	SOUND_HOVER: "buttonHover",
	IMAGE_UP: "spinButtonIdle",
	IMAGE_DOWN: "spinButtonDown",
	IMAGE_OVER: "spinButtonOver",
	IMAGE_DISABLED: "spinButtonDisabled",
	BUTTON_POSITION: {
		x: 589,
		y: 597,
		width: 103,
		height: 105,
		centerX: 640,
		centerY: 649,
		radius: 51
	},
	constructor: function() {
		var a = this;
		Interface.Slots.SpinButtonDesktopView.superclass.constructor.apply(a, arguments);
		a.pressed = false;
		a.isHighlighted = false;
		a.permanentHighlight = false
	},
	initAnimations: function() {
		var c = this,
			b = new Animation.List({}),
			a = new Animation.Item({
				top: c.BUTTON_POSITION.y,
				left: c.BUTTON_POSITION.x,
				width: c.BUTTON_POSITION.width,
				height: c.BUTTON_POSITION.height,
				depth: c.getButtonDepth(),
				image: c.IMAGE_UP
			});
		b.add(a);
		Game.stage.view.addToRenderLoop(b);
		c.buttonList = b;
		c.buttonItem = a
	},
	getButtonDepth: function() {
		return 40
	},
	beforeLoaderClose: function() {
		this.fireEvent("view:addProperty", "visibleDuringRound", this.MODULE_NAME)
	},
	setUpDOMStructure: function() {},
	press: function() {
		var a = this;
		a.fireEvent("view:playSound", a.SOUND_DOWN);
		a.fireEvent("view:notify", "notify:spinButton.down");
		a.buttonItem.prop.image = a.IMAGE_DOWN
	},
	release: function() {
		this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
	},
	enable: function() {
		this.playButtonSpecialEffects();
		this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
	},
	disable: function() {
		this.removeHighlight();
		this.stopButtonSpecialEffects();
		this.buttonItem.prop.image = this.IMAGE_DISABLED
	},
	disableRequested: function(a) {
		this.fireEvent("view:disable", a)
	},
	userInputStart: function(b) {
		var a = this.isCollision(b) && !this.pressed;
		if (a) {
			this.press()
		}
		this.model.storeData("wasInitialInputTarget", a)
	},
	userInputMove: function(a) {
		if (this.model.readData("wasInitialInputTarget")) {
			this.toggleHighlight(a, true)
		}
	},
	userInputHover: function(a) {
		if (!this.pressed) {
			this.toggleHighlight(a)
		}
	},
	userInputEnd: function(c) {
		var b = this,
			a;
		if (b.model.readData("wasInitialInputTarget")) {
			a = b.isCollision(c);
			b.release(a);
			if (a) {
				if (!b.model.readData("noStopOnSpin")) {
					b.model.storeData("noStopOnSpin", true)
				}
				b.fireEvent("view:clicked")
			}
		}
		b.model.storeData("wasInitialInputTarget", false)
	},
	enableSpinningAnimations: function() {
		this.addHighlight(false, true);
		this.permanentHighlight = true
	},
	disableSpinningAnimations: function() {
		this.permanentHighlight = false;
		if (!this.isHoveredOver) {
			this.removeHighlight()
		}
	},
	shouldBeHiddenByUserInput: function() {},
	hide: function() {
		var a = this;
		if (a.model.hasProperty("hidden") || !a.model.hasProperty("visibleDuringRound")) {
			a.buttonList.stop();
			a.fireEvent("view:hidden")
		}
	},
	hidden: function() {},
	show: function() {
		this.buttonList.play();
		this.fireEvent("view:shown")
	},
	setAppearance: function(a) {},
	canInteractWhileHidden: function() {
		return false
	},
	showCounter: function() {},
	updateCounter: function() {},
	hideCounter: function() {},
	onPressedRequest: function() {
		this.pressed = true;
		this.press()
	},
	onReleasedRequest: function() {
		this.pressed = false;
		this.release(true);
		this.fireEvent("view:clicked")
	},
	toggleHighlight: function(c, b) {
		var a = this;
		if (a.isCollision(c)) {
			if (!a.isHoveredOver) {
				a.fireEvent("view:playSound", a.SOUND_HOVER);
				a.fireEvent("view:notify", "notify:spinButton.hover")
			}
			a.isHoveredOver = true;
			a.addHighlight(b)
		} else {
			if (a.isHoveredOver) {
				a.fireEvent("view:playSound", a.SOUND_UP);
				a.fireEvent("view:notify", "notify:spinButton.up")
			}
			a.isHoveredOver = false;
			a.removeHighlight(b)
		}
	},
	isCollision: function(h) {
		var e = this,
			c = Sys.UserInputUtils.getCoordinatesRelativeToElement(h, Game.stage.getGameContainer()),
			f = Environment.getWindowToVirtualScale(3),
			a = e.BUTTON_POSITION,
			d = Math.abs((c.x * f) - a.centerX),
			b = Math.abs((c.y * f) - a.centerY),
			g = Math.sqrt((d * d) + (b * b));
		return (g <= a.radius)
	},
	addHighlight: function(c, a) {
		var b = this;
		if ((!b.isHighlighted || a) && !b.permanentHighlight) {
			b.isHighlighted = true;
			b.buttonItem.prop.image = b.IMAGE_OVER;
			if (c) {
				b.press()
			}
		}
	},
	removeHighlight: function(b) {
		var a = this;
		if (a.isHighlighted && !a.permanentHighlight) {
			a.isHighlighted = false;
			a.buttonItem.prop.image = this.IMAGE_UP;
			if (b) {
				a.playButtonSpecialEffects()
			}
		}
	},
	stopButtonSpecialEffects: function() {},
	playButtonSpecialEffects: function() {},
	setFullscreenSafeArea: function() {}
};
Interface.Slots.SpinButtonDesktopView = Sys.extend(Interface.RoundStartButtonBaseView, Interface.Slots.SpinButtonDesktopView, "Interface.Slots.SpinButtonDesktopView");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButton = {
	constructor: function() {
		Interface.Slots.MaxBetButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Interface.Slots.MaxBetButtonModel,
			controller: Interface.Slots.MaxBetButtonController,
			view: Interface.Slots.MaxBetButtonBaseView
		}
	}
};
Interface.Slots.MaxBetButton = Sys.extend(Core.Module, Interface.Slots.MaxBetButton, "Interface.Slots.MaxBetButton");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonModel = {
	constructor: function() {
		Interface.Slots.MaxBetButtonModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var d = Resources.readData("gameServerInitResponseObject").betlevel.all,
			a = Resources.readData("config"),
			b = Object.keys(a.winSituationsDisplay.betlines.numbers.configurations),
			e = a.winSituationsDisplay.winSituationMinimumDisplayTime,
			c = 0;
		Interface.Slots.MaxBetButtonModel.superclass.setupData.apply(this, arguments);
		Sys.each(d, function(f) {
			c = Math.max(f, c)
		});
		this.storeData("maxBetLevel", c);
		this.storeData("betlines", b);
		this.storeData("winSituationMinimumDisplayTime", e)
	}
};
Interface.Slots.MaxBetButtonModel = Sys.extend(Core.Model, Interface.Slots.MaxBetButtonModel, "Interface.Slots.MaxBetButtonModel");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonController = {
	ROUND_START_EVENT: "request:spin.startNewRound",
	constructor: function() {
		Interface.Slots.MaxBetButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.disable.bind(a, "notInIdleState"),
			"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
			"notify:stateHandler.enteringIdleState": a.enable.bind(a, "notInIdleState"),
			"notify:gameModeChanged": a.onGameModeChanged,
			"view:clicked": a.onClick,
			"request:enableBasicGamePanel": a.enable,
			"request:disableBasicGamePanel": a.disable,
			"request:maxBetButton.enable": a.enable,
			"request:maxBetButton.disable": a.disable
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:maxBetButton.startedRound", this, "When the max bet button is clicked and started a round.")
	},
	onClick: function() {
		var d = this,
			b = Services.settingsManager.getSetting("betLevel"),
			c = d.model.readData("maxBetLevel"),
			a;
		if (b < c) {
			d.fireEvent("request:settingsManager.storeData", "betLevel", c);
			a = d.model.readData("betlines");
			d.fireEvent("request:winSituations.showDisplayBetline", a, "maxBetButton");
			setTimeout(d.fireEvent.bind(d, "request:winSituations.hideDisplayBetline", "maxBetButton"), d.model.readData("winSituationMinimumDisplayTime"))
		} else {
			d.startRound()
		}
	},
	onGameModeChanged: function(a) {
		if (a === "BASIC") {
			this.view.show("gameModeNotBasic")
		} else {
			this.view.hide("gameModeNotBasic")
		}
	},
	onLeavingIdleState: function() {
		var a = this;
		a.disable("notInIdleState");
		a.fireEvent("request:winSituations.hideDisplayBetline", "maxBetButton")
	},
	startRound: function() {
		var a = this;
		a.fireEvent("request:audioPlayer.play", {
			name: "spinButtonClick"
		});
		a.fireEvent(a.ROUND_START_EVENT);
		a.fireEvent("notify:maxBetButton.startedRound")
	},
	enable: function(a) {
		this.view.enable(a)
	},
	disable: function(a) {
		this.view.disable(a)
	}
};
Interface.Slots.MaxBetButtonController = Sys.extend(Core.Controller, Interface.Slots.MaxBetButtonController, "Interface.Slots.MaxBetButtonController");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonBaseView = {
	KEYPAD_BUTTON_CONFIG: {
		dimensions: {
			x: 700,
			y: 613,
			width: 143,
			height: 72
		},
		buttonImages: {
			up: "maxBetButtonUp",
			down: "maxBetButtonDown",
			hover: "maxBetButtonOver",
			disabled: "maxBetButtonDisabled"
		},
		buttonLabel: {
			width: 133,
			height: 67,
			text: Language.Keys.btn_maxbet,
			breakOn: "<br>",
			font: "24px NetentStandardUI",
			lineHeight: 24,
			color: "#000000",
			alignment: "center"
		}
	},
	constructor: function() {
		Interface.Slots.MaxBetButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	show: function(a) {
		this.keypadButton.show(a)
	},
	hide: function(a) {
		this.keypadButton.hide(a)
	},
	enable: function(a) {
		this.keypadButton.enable(a)
	},
	disable: function(a) {
		this.keypadButton.disable(a)
	},
	onButtonClick: function() {
		this.fireEvent("view:clicked")
	},
	initAnimations: function() {
		this.setUpKeypadButton()
	},
	setUpKeypadButton: function() {
		var b = this,
			a = Sys.applyProperties({
				clickCallback: b.onButtonClick.bind(b)
			}, b.KEYPAD_BUTTON_CONFIG);
		a.buttonLabel.depth = Layering.Game.Slots.Keypad.maxBet.label;
		if (Sys.isDefined(a.buttonLayoutParameters)) {
			a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.maxBet.button
		} else {
			a.dimensions.depth = Layering.Game.Slots.Keypad.maxBet.button
		}
		b.keypadButton = new Interface.utils.CanvasButton(a)
	},
	shouldBeHiddenByUserInput: function() {
		return false
	}
};
Interface.Slots.MaxBetButtonBaseView = Sys.extend(Core.View, Interface.Slots.MaxBetButtonBaseView, "Interface.Slots.MaxBetButtonBaseView");
Sys.ns("Core.Slots");
Core.Slots.SpinBaseController = {
	constructor: function() {
		Core.Slots.SpinBaseController.superclass.constructor.apply(this, arguments);
		this.stopper = 0
	},
	setupEvents: function() {
		var b = this,
			c = {
				"request:spin.child.storeServerResponse": b.handleServerResponse,
				"request:spin.child.wantStartSpin": b.startSpin,
				"request:spin.child.wantStopSpin": b.stopSpin,
				"request:spin.child.setSymbols": b.setSymbols,
				"request:spin.child.revertSpin": b.revertSpin
			},
			a = "notify:stateHandler.entering" + b.MODULE_NAME + "RestoreState";
		c[a] = b.onRestore;
		b.on(c)
	},
	handleServerResponse: function(b) {
		var a = this;
		a.model.storeServerResponse(b);
		if (b.clientaction === "init") {
			a.model.initData();
			if (a.model.readData("active")) {
				a.fireEvent("request:spin.activateInitReelset", "basic", a.model.readData("defaultScene"))
			}
		}
	},
	onRestore: function() {
		this.requestRestoreStateDialog();
		this.startSpin()
	},
	requestRestoreStateDialog: function() {
		var a = this;
		a.fireEvent("request:dialogWindow.showDialog", {
			title: Services.languageManager.getText(Language.Keys.restoredGameHeader),
			text: Services.languageManager.getText(Language.Keys.continuePlaying),
			buttons: [{
				scope: a,
				text: Services.languageManager.getText(Language.Keys.btn_continue),
				action: function() {
					a.fireEvent("notify:" + a.MODULE_NAME + "RestoreStateDialog.closed")
				}
			}]
		})
	},
	activateReelset: function() {
		var a = this,
			c = a.model.readData("requestedReelset"),
			b = a.model.readData("defaultScene");
		a.model.storeData("active", true);
		a.fireEvent("request:spin.activateReelset", c, b)
	},
	startSpin: function() {
		var b = this,
			a = b.model,
			d = a.readData("requestedReelset"),
			c = a.readData("defaultScene");
		if (!a.isState("spinning")) {
			b.fireEvent("request:settingsWindow.close");
			if (a.readData("spinRequested")) {
				a.storeData("active", true);
				a.setState("spinning");
				b.fireEvent("request:spin.startSpin", d, c)
			} else {
				a.storeData("active", false)
			}
		}
	},
	stopSpin: function() {
		var a = this,
			b = a.model.readData("serverResponse");
		if (a.model.readData("active")) {
			a.model.setState("stopped");
			a.fireEvent("request:spin.stopSpin", b.reelInfo, b.nearWinList, b)
		}
	},
	revertSpin: function() {
		if (this.model.readData("active")) {
			this.model.setState("stopped")
		}
	}
};
Core.Slots.SpinBaseController = Sys.extend(Core.Controller, Core.Slots.SpinBaseController, "Core.Slots.SpinBaseController");
Sys.ns("Core.Slots");
Core.Slots.SpinBaseModel = {
	DEFAULT_SCENE: "base",
	constructor: function() {
		Core.Slots.SpinBaseModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		Core.Slots.SpinBaseModel.superclass.setupData.apply(this, arguments);
		this.storeData("defaultScene", this.DEFAULT_SCENE)
	},
	storeServerResponse: function(b) {
		var a = this;
		a.storeData("serverResponse", b)
	},
	initData: function() {
		var b = this,
			a = Resources.readData("config");
		b.storeData("layeringConfig", a.layering)
	}
};
Core.Slots.SpinBaseModel = Sys.extend(Core.Model, Core.Slots.SpinBaseModel, "Core.Slots.SpinBaseModel");
Sys.ns("Core");
Core.Slots.SpinTypeBasic = {
	constructor: function() {
		Core.Slots.SpinTypeBasic.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				stopped: {
					queue: [function(c) {
						if (a.readData("spinRequested")) {
							c.stateHandler.pushState(c.states.idle)
						}
					}]
				}
			};
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.SpinTypeBasicModel,
			controller: Core.Slots.SpinBaseController
		}
	}
};
Core.Slots.SpinTypeBasic = Sys.extend(Core.Module, Core.Slots.SpinTypeBasic, "Core.Slots.SpinTypeBasic");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeBasicModel = {
	constructor: function() {
		Core.Slots.SpinTypeBasicModel.superclass.constructor.apply(this, arguments)
	},
	storeServerResponse: function(c) {
		var b = this,
			a;
		b.storeData("serverResponse", c);
		if (c.nextaction === "spin") {
			b.storeData("spinRequested", true);
			if (c.next) {
				a = c.next.rs
			} else {
				a = "basic"
			}
			b.storeData("requestedReelset", a)
		} else {
			b.storeData("spinRequested", false)
		}
	},
	initData: function() {
		var c = this,
			b = Resources.readData("gameServerInitResponse"),
			d = false,
			a = false;
		Core.Slots.SpinTypeBasicModel.superclass.initData.apply(c, arguments);
		if (b.nextaction === "spin") {
			d = true;
			a = true
		}
		c.storeData("active", d);
		c.storeData("spinRequested", a)
	}
};
Core.Slots.SpinTypeBasicModel = Sys.extend(Core.Slots.SpinBaseModel, Core.Slots.SpinTypeBasicModel, "Core.Slots.SpinTypeBasicModel");
Sys.ns("Core");
Core.Slots.SpinTypeRespin = {
	constructor: function() {
		Core.Slots.SpinTypeRespin.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				respinRestore: {
					state: {
						name: this.MODULE_NAME + "Restore",
						execute: function(c) {},
						waitEvents: {}
					}
				},
				stopped: {
					queue: [function(c) {
						if (a.readData("spinRequested")) {
							c.stateHandler.pushState(c.states.stopped);
							c.stateHandler.pushState(c.states.stopping);
							c.stateHandler.pushState(c.states.beforeStopping);
							c.stateHandler.pushState(c.states.spinning)
						}
					}]
				},
				beforeLoaderClose: {
					queue: [function(c) {
						if (a.readData("spinRequested")) {
							c.stateHandler.pushState(c.states.stopped);
							c.stateHandler.pushState(c.states.stopping);
							c.stateHandler.pushState(c.states.beforeStopping);
							c.stateHandler.pushState(c.states.spinning);
							if (a.readData("basicRestoreState")) {
								c.stateHandler.pushState(c.states.respinRestore)
							}
						}
					}]
				}
			};
		b.respinRestore.state.waitEvents["notify:" + this.MODULE_NAME + "RestoreStateDialog.closed"] = false;
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.SpinTypeRespinModel,
			controller: Core.Slots.SpinBaseController
		}
	}
};
Core.Slots.SpinTypeRespin = Sys.extend(Core.Module, Core.Slots.SpinTypeRespin, "Core.Slots.SpinTypeRespin");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeRespinModel = {
	constructor: function() {
		Core.Slots.SpinTypeRespinModel.superclass.constructor.apply(this, arguments)
	},
	storeServerResponse: function(c) {
		var b = this,
			a;
		b.storeData("serverResponse", c);
		if (c.nextaction === "respin" || c.nextaction === "drop") {
			b.storeData("spinRequested", true);
			b.storeData("basicRestoreState", (c.currentGameState === "basic") && (c.restore === true));
			if (c.next) {
				a = c.next.rs
			} else {
				a = "respin"
			}
			b.storeData("requestedReelset", a)
		} else {
			b.storeData("spinRequested", false)
		}
	},
	initData: function() {
		this.storeData("active", Resources.readData("gameServerInitResponseObject").nextaction === "respin");
		Core.Slots.SpinTypeRespinModel.superclass.initData.apply(this, arguments)
	}
};
Core.Slots.SpinTypeRespinModel = Sys.extend(Core.Slots.SpinBaseModel, Core.Slots.SpinTypeRespinModel, "Core.Slots.SpinTypeRespinModel");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeFreespin = {
	constructor: function() {
		Core.Slots.SpinTypeFreespin.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				stopped: {
					queue: [function(c) {
						if (a.readData("spinRequested")) {
							c.stateHandler.pushState(c.states.stopped);
							c.stateHandler.pushState(c.states.stopping);
							c.stateHandler.pushState(c.states.beforeStopping);
							c.stateHandler.pushState(c.states.spinning)
						}
					}]
				},
				beforeLoaderClose: {
					queue: [function(c) {
						if (a.readData("spinRequested")) {
							c.stateHandler.pushState(c.states.stopped);
							c.stateHandler.pushState(c.states.stopping);
							c.stateHandler.pushState(c.states.beforeStopping);
							c.stateHandler.pushState(c.states.spinning)
						}
					}]
				}
			};
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.SpinTypeFreespinModel,
			controller: Core.Slots.SpinBaseController
		}
	}
};
Core.Slots.SpinTypeFreespin = Sys.extend(Core.Module, Core.Slots.SpinTypeFreespin, "Core.Slots.SpinTypeFreespin");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeFreespinModel = {
	DEFAULT_NEXT_REELSET: "freespin",
	constructor: function() {
		Core.Slots.SpinTypeFreespinModel.superclass.constructor.apply(this, arguments)
	},
	storeServerResponse: function(e) {
		var c = this,
			a, d = e.freespins,
			b;
		c.storeData("serverResponse", e);
		if (c.isNextFreespin(e)) {
			c.storeData("spinRequested", true);
			if (e.clientaction === "init") {
				b = (d.left === d.initial && d.left === d.total);
				c.storeData("showRestoreStateDialog", !b)
			}
			if (e.next) {
				a = e.next.rs
			} else {
				a = c.DEFAULT_NEXT_REELSET
			}
			Services.storage.storeData("freespin.freespinsLeft", d.left);
			c.storeData("requestedReelset", a)
		} else {
			if (Sys.isObj(d) && Sys.isNumber(d.left)) {
				Services.storage.storeData("freespin.freespinsLeft", d.left)
			} else {
				Services.storage.storeData("freespin.freespinsLeft", null)
			}
			c.storeData("spinRequested", false)
		}
	},
	isNextFreespin: function(a) {
		return a.nextaction === "freespin"
	},
	initData: function() {
		var c = this,
			b = Resources.readData("gameServerInitResponse"),
			d = false,
			a = false;
		Core.Slots.SpinTypeFreespinModel.superclass.initData.apply(c, arguments);
		if (c.isNextFreespin(b)) {
			d = true;
			a = true
		}
		c.storeData("active", d);
		c.storeData("spinRequested", a);
		Services.storage.storeData("freespin.freespinsLeft", null)
	}
};
Core.Slots.SpinTypeFreespinModel = Sys.extend(Core.Slots.SpinBaseModel, Core.Slots.SpinTypeFreespinModel, "Core.Slots.SpinTypeFreespinModel");
Sys.ns("Core.Slots");
Core.Slots.StandardWin = {
	constructor: function() {
		Core.Slots.StandardWin.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				standardWinPresentation: {
					state: {
						name: "StandardWinPresentation",
						execute: function() {},
						waitEvents: {
							"notify:standardWin.presentationComplete": false
						}
					}
				},
				noWinPresentation: {
					state: {
						name: "NoWinPresentation",
						execute: function() {},
						waitEvents: {
							"notify:standardWin.presentationComplete": false
						}
					}
				},
				stopped: {
					queue: [function(c) {
						if (a.readData("isStandardWin")) {
							c.stateHandler.pushState(c.states.standardWinPresentation)
						} else {
							if (a.readData("isNoWin")) {
								c.stateHandler.pushState(c.states.noWinPresentation)
							}
						}
					}]
				}
			};
		return b
	},
	getMixinDependencies: function() {
		return ["serverResponse", "userInput", "waitSequence", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.StandardWinModel,
			view: Core.View,
			controller: Core.Slots.StandardWinController
		}
	}
};
Core.Slots.StandardWin = Sys.extend(Core.Module, Core.Slots.StandardWin, "Core.Slots.StandardWin");
Sys.ns("Core.Slots");
Core.Slots.StandardWinController = {
	constructor: function() {
		Core.Slots.StandardWinController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringStandardWinPresentationState": a.startPresentation,
			"notify:stateHandler.enteringNoWinPresentationState": a.startNoWinPresentation,
			"notify:winBanner.countUpComplete": a.onShowingTotal,
			"notify:coinsField.countUpComplete": a.onShowingTotal,
			"notify:spinButton.clicked": a.handleUserInput,
			"notify:spinButton.clickedWhileHidden": a.handleUserInput,
			"request:abortPresentation": a.handleUserInput,
			"notify:winSituationsDisplay.showingAllWins": a.waitForWinSituationsDisplay
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:standardWin.countupAborted", this, "When the countup is aborted.");
		Services.trigger.registerTrigger("notify:standardWin.presentationComplete", this, "When the standard win presentation has completed.");
		Services.trigger.registerTrigger("notify:standardWin.startPresentation", this, "When the win presentation starts.")
	},
	startPresentation: function() {
		var b = this,
			a = b.model.readData("winClip"),
			c = b.model.readData("countUpDuration"),
			d = b.model.readData("totalWinDisplayDuration");
		b.fireEvent("request:settingsWindow.close");
		b.startListeningToUserInput();
		b.model.setState("countingUp");
		b.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
			showDuration: c + d,
			"standardWin:countUpDuration": c,
			"standardWin:showTotalDuration": d
		});
		if (b.model.readData("countUpDisplay") === "winBanner") {
			b.fireEvent("request:winBanner.animate", c)
		} else {
			b.fireEvent("request:coinsField.countUp", c)
		}
		if (a) {
			b.fireEvent("request:audioPlayer.play", {
				name: a,
				id: "winClip"
			})
		}
		b.fireEvent("notify:standardWin.startPresentation", a)
	},
	startNoWinPresentation: function() {
		var b = this,
			a = b.model.readData("noWinDisplayDuration");
		b.fireEvent("request:coinsField.showWin");
		b.fireEvent("request:cashField.showWin");
		b.model.storeData("inNoWinPresentation", true);
		b.noWinTimeout = setTimeout(b.abortNoWinPresentation.bind(b), a)
	},
	abortNoWinPresentation: function() {
		var a = this;
		if (a.model.readData("inNoWinPresentation")) {
			clearTimeout(a.noWinTimeout);
			a.endPresentation();
			a.model.storeData("inNoWinPresentation", false)
		}
	},
	onUserInputStart: function(a) {
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
			this.handleUserInput()
		}
	},
	handleUserInput: function() {
		var a = this;
		if (a.model.readData("inNoWinPresentation")) {
			a.abortNoWinPresentation()
		} else {
			if (a.model.isState("countingUp")) {
				if (a.model.readData("countUpDisplay") === "winBanner") {
					a.fireEvent("request:winBanner.showTotal", {
						showUntilStopped: true
					})
				} else {
					a.fireEvent("request:coinsField.showWin")
				}
				a.fireEvent("request:audioPlayer.stop", "winClip");
				a.onShowingTotal();
				a.fireEvent("notify:standardWin.countupAborted")
			} else {
				if (a.model.isState("showingTotal")) {
					a.endPresentation(true)
				}
			}
		}
	},
	onShowingTotal: function() {
		var a = this;
		if (a.model.isState("countingUp")) {
			a.model.setState("showingTotal");
			a.fireEvent("notify:standardWin.showingWinTotal");
			a.fireEvent("request:coinsField.showWin");
			a.fireEvent("request:cashField.showWin");
			if (a.eventsToWaitFor.indexOf("notify:winSituationsDisplay.finishedShowingAllWins") === -1) {
				a.showWinTimeout = setTimeout(a.endPresentation.bind(a, false), a.model.readData("totalWinDisplayDuration"))
			}
		}
	},
	endPresentation: function(b) {
		var a = this;
		if (!a.model.isState("showingTotal") && !a.model.readData("inNoWinPresentation")) {
			return
		}
		a.stopListeningToUserInput();
		a.model.setState("complete");
		clearTimeout(a.showWinTimeout);
		a.fireEvent("request:winSituationsDisplay.abort");
		a.fireEvent("request:audioPlayer.stop", "winClip");
		if (a.model.readData("countUpDisplay") === "winBanner") {
			a.fireEvent("request:winBanner.hide")
		}
		if (a.model.shouldToggleWins()) {
			a.fireEvent("request:winSituationsDisplay.toggleWins")
		}
		a.fireEvent("notify:standardWin.presentationComplete", b)
	},
	waitForWinSituationsDisplay: function() {
		this.onWaitRequested("notify:winSituationsDisplay.finishedShowingAllWins")
	},
	onWaitIsComplete: function() {
		this.endPresentation(false)
	}
};
Core.Slots.StandardWinController = Sys.extend(Core.Controller, Core.Slots.StandardWinController, "Core.Slots.StandardWinController");
Sys.ns("Core.Slots");
Core.Slots.StandardWinModel = {
	STANDARD_WIN_TYPES: ["smallWin", "mediumWin", "largeWin"],
	COUNT_UP_DURATIONS: {
		smallWin: 1000,
		mediumWin: 2000,
		largeWin: 3000
	},
	NO_WIN_DISPLAY_DURATION: 500,
	NO_WIN_DISPLAY_DESKTOP_DURATION: 0,
	TOTAL_WIN_DISPLAY_DURATION: 3000,
	constructor: function() {
		Core.Slots.StandardWinModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.storeData("inFreeSpins", false);
		a.storeData("noWinDisplayDuration", a.NO_WIN_DISPLAY_DURATION);
		a.storeData("totalWinDisplayDuration", a.TOTAL_WIN_DISPLAY_DURATION);
		a.setupDesktopSpecificData()
	},
	processServerResponse: function(b) {
		var f = this,
			g = b.currentGameState === "freespin" ? "coinsField" : "winBanner",
			d = b.currentGameState === "freespin" || b.nextaction === "freespin",
			c, e, a;
		if (Sys.isDefined(b.wins)) {
			c = b.wins.winType;
			e = f.STANDARD_WIN_TYPES.contains(c);
			a = !Sys.isDefined(c);
			f.storeData("isStandardWin", e);
			f.storeData("isNoWin", a);
			f.storeData("countUpDuration", f.COUNT_UP_DURATIONS[c]);
			f.storeWinSound(c)
		}
		f.storeData("countUpDisplay", g);
		f.storeData("togglePreventedByFreeSpins", d)
	},
	storeWinSound: function(a) {
		this.storeData("winClip", a)
	},
	shouldToggleWins: function() {
		var a = Services.settingsManager.getSetting("autoPlayNrSpins");
		return (!Sys.isDefined(a) || a === 0) && !this.readData("togglePreventedByFreeSpins")
	},
	setupDesktopSpecificData: function() {
		if (Platform.isDesktopDevice) {
			this.storeData("noWinDisplayDuration", this.NO_WIN_DISPLAY_DESKTOP_DURATION)
		}
	}
};
Core.Slots.StandardWinModel = Sys.extend(Core.Model, Core.Slots.StandardWinModel, "Core.Slots.StandardWinModel");
Sys.ns("Core");
Core.AbstractCountUp = {
	constructor: function() {
		Core.AbstractCountUp.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.CountUpModel,
			view: Core.AbstractCountUpView,
			controller: Core.AbstractCountUpController
		}
	}
};
Core.AbstractCountUp = Sys.extend(Core.CountUp, Core.AbstractCountUp, "Core.AbstractCountUp");
Sys.ns("Core");
Core.AbstractCountUpView = {
	constructor: function() {
		Core.AbstractCountUpView.superclass.constructor.apply(this, arguments)
	},
	COUNT_UP_EASING_TYPE: "ease-out",
	SHOW_TOTAL_DURATION: 1000,
	countUpCallback: function(a) {},
	setCountUpCallback: function(a) {
		this.countUpCallback = a
	},
	createCountUpItem: function() {
		var a = this;
		return new Animation.CanvasAnimationItem({
			top: 0,
			left: 0,
			width: 0,
			height: 0,
			depth: a.COUNT_UP_DEPTH,
			executeBefore: function() {
				var d = this.value,
					c, e, b;
				if (a.model.readData("lastValue") !== d) {
					a.countUpCallback(d);
					a.model.storeData("lastValue", d);
					if (Sys.isDefined(this.fireOnValue)) {
						c = this.fireOnValue.length;
						for (b = -1; ++b < c;) {
							e = this.fireOnValue[b];
							if (!e.fired && d >= e.value) {
								e.scope.fireEvent(e.event, e.argument);
								e.fired = true
							}
						}
					}
				}
			},
			operations: {}
		})
	}
};
Core.AbstractCountUpView = Sys.extend(Core.CountUpView, Core.AbstractCountUpView, "Core.AbstractCountUpView");
Sys.ns("Core");
Core.AbstractCountUpController = {
	constructor: function() {
		Core.AbstractCountUpController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this,
			b = {};
		Core.AbstractCountUpController.superclass.setupEvents.apply(a, arguments);
		b["request:" + a.MODULE_NAME + ".setCallback"] = a.view.setCountUpCallback.bind(a.view);
		a.on(b)
	}
};
Core.AbstractCountUpController = Sys.extend(Core.CountUpController, Core.AbstractCountUpController, "Core.AbstractCountUpController");
Sys.ns("Game");
Game.AmbienceManager = {
	constructor: function() {
		Game.AmbienceManager.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.AmbienceManagerModel,
			controller: Game.AmbienceManagerController
		}
	}
};
Game.AmbienceManager = Sys.extend(Core.Module, Game.AmbienceManager, "Game.AmbienceManager");
Sys.ns("Game");
Game.AmbienceManagerModel = {
	constructor: function() {
		Game.AmbienceManagerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.storeData("activeAmbience", [{
			name: "ambienceGeneral",
			id: "ambienceGeneral",
			loop: true
		}]);
		Services.storage.storeData("AmbienceManager.playing", false)
	},
	getActiveAmbience: function() {
		return this.readData("activeAmbience")
	},
	setActiveAmbience: function(a) {
		this.storeData("activeAmbience", a)
	}
};
Game.AmbienceManagerModel = Sys.extend(Core.Model, Game.AmbienceManagerModel, "Game.AmbienceManagerModel");
Sys.ns("Game");
Game.AmbienceManagerController = {
	constructor: function() {
		Game.AmbienceManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:audioPlayer.soundLoaded": a.changeAmbienceEnableState.bind(a, true),
			"request:ambienceManager.ambienceEnableState": a.changeAmbienceEnableState,
			"request:ambienceManager.ambienceChangeActive": a.setActiveAmbience,
			"request:ambienceManager.ambiencePauseSwitch": a.changePauseSwitch,
			"request:ambienceManager.ambienceStopActive": a.stopAmbience,
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose
		})
	},
	onBeforeLoaderClose: function() {
		if (!this.model.isState("ambienceOn")) {
			this.changeAmbienceEnableState(false)
		}
		this.changePauseSwitch(false)
	},
	changeAmbienceEnableState: function(a) {
		var b = this;
		if (a) {
			if (!b.model.isState("ambienceOn")) {
				b.model.setState("ambienceOn");
				b.playActiveAmbience()
			}
		} else {
			b.model.setState("ambienceOff");
			b.stopAmbience()
		}
	},
	changePauseSwitch: function(a) {
		var b = this;
		if (a) {
			b.model.storeData("paused", true);
			if (b.model.isState("ambienceOn")) {
				b.stopAmbience()
			}
		} else {
			if (b.model.readData("paused")) {
				b.model.storeData("paused", false);
				if (b.model.isState("ambienceOn")) {
					b.playActiveAmbience()
				}
			}
		}
	},
	playAmbience: function(a) {
		var b = this;
		if (b.model.isState("ambienceOn")) {
			if (!b.model.readData("paused")) {
				Sys.each(a, function(c) {
					b.dispatchPlaySoundRequest(c)
				})
			}
		} else {
			b.model.setActiveAmbience(a)
		}
	},
	playActiveAmbience: function() {
		this.playAmbience(this.model.getActiveAmbience())
	},
	stopAmbience: function() {
		var b = this,
			a = b.model.getActiveAmbience();
		if (b.model.isState("ambienceOn")) {
			Sys.each(a, function(c) {
				b.dispatchStopSoundRequest(c)
			})
		}
	},
	setActiveAmbience: function(c) {
		var b = this,
			a;
		if (!Sys.isArray(c)) {
			a = [{
				name: c.name,
				id: c.id,
				loop: c.loop,
				buffer: c.buffer,
				syncWithId: c.syncWithId,
				fadeIn: c.fadeIn,
				fadeOut: c.fadeOut
			}]
		} else {
			a = c
		}
		b.playAmbience(a);
		b.stopAmbience();
		b.model.setActiveAmbience(a)
	},
	dispatchPlaySoundRequest: function(a) {
		if (this.model.isState("ambienceOn")) {
			this.fireEvent("request:audioPlayer.play", a)
		}
	},
	dispatchStopSoundRequest: function(a) {
		if (this.model.isState("ambienceOn")) {
			this.fireEvent("request:audioPlayer.stop", a.id)
		}
	}
};
Game.AmbienceManagerController = Sys.extend(Core.Controller, Game.AmbienceManagerController, "Game.AmbienceManagerController");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplay = {
	constructor: function() {
		Game.Slots.WinSituationsDisplay.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["waitSequence", "serverResponse"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.WinSituationsDisplayModel,
			controller: Game.Slots.WinSituationsDisplayController
		}
	}
};
Game.Slots.WinSituationsDisplay = Sys.extend(Core.Module, Game.Slots.WinSituationsDisplay, "Game.Slots.WinSituationsDisplay");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplayModel = {
	constructor: function() {
		Game.Slots.WinSituationsDisplayModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Resources.readData("config");
		this.storeData("winSituationMinimumDisplayTime", a.winSituationsDisplay.winSituationMinimumDisplayTime)
	},
	processServerResponse: function(c) {
		var b = this,
			a = [];
		if (c.wins && Sys.isArray(c.wins.winSituations)) {
			Sys.each(c.wins.winSituations, function(e, d) {
				if (b.shouldToggleWinSituation(e)) {
					a.push(d)
				}
			})
		}
		b.storeData("winSituationsToToggle", a)
	},
	shouldToggleWinSituation: function(a) {
		return a.wins.type === "coins"
	}
};
Game.Slots.WinSituationsDisplayModel = Sys.extend(Core.Model, Game.Slots.WinSituationsDisplayModel, "Game.Slots.WinSituationsDisplayModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplayController = {
	constructor: function() {
		Game.Slots.WinSituationsDisplayController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringSpinningState": a.abort,
			"request:winSituationsDisplay.abort": a.abort,
			"request:winSituationsDisplay.showAllWins": a.showAllWins,
			"request:winSituationsDisplay.toggleWins": a.startToggling,
			"notify:settingsManager.settingChanged": a.processSettingsChanges,
			"request:winSituationsDisplay.waitFor": a.handleWaitRequest
		})
	},
	showAllWins: function(b) {
		var a = this;
		a.model.setState("showingAllWins");
		a.initializeWaitSequence("notify:winSituationsDisplay.showingAllWins", b)
	},
	startToggling: function(b) {
		var a = this;
		a.winSituationCounter = -1;
		a.pulseDurationPassed = true;
		a.clearWaitSequence();
		a.model.storeData("extraTogglingParameters", b);
		a.showNextBetline()
	},
	showNextBetline: function() {
		var b = this,
			a = b.model.readData("winSituationsToToggle");
		if (b.eventsToWaitFor.length === 0 && a.length > 0 && b.pulseDurationPassed) {
			b.abort();
			b.model.setState("toggling");
			++b.winSituationCounter;
			b.initializeWaitSequence("notify:winSituationsDisplay.togglingWinSituation", a[b.winSituationCounter % a.length], b.model.readData("extraTogglingParameters"));
			b.pulseDurationPassed = false;
			b.toggleTimeout = setTimeout(function() {
				b.pulseDurationPassed = true;
				b.showNextBetline()
			}, b.model.readData("winSituationMinimumDisplayTime"))
		}
	},
	handleWaitRequest: function(a) {
		this.onWaitRequested(a)
	},
	onWaitIsComplete: function() {
		var b = this,
			a = b.model.isState("toggling");
		if (a) {
			b.showNextBetline()
		} else {
			b.abort()
		}
	},
	processSettingsChanges: function(a) {
		if (this.model.isState("toggling") && (a === "betLevel" || a === "denomination")) {
			this.abort()
		}
	},
	abort: function() {
		var b = this,
			a = b.model.isState("showingAllWins");
		clearTimeout(b.toggleTimeout);
		if (!b.model.isState("abort")) {
			b.model.setState("abort");
			b.fireEvent("notify:winSituationsDisplay.abort");
			if (a) {
				b.fireEvent("notify:winSituationsDisplay.finishedShowingAllWins")
			}
		}
	}
};
Game.Slots.WinSituationsDisplayController = Sys.extend(Core.Controller, Game.Slots.WinSituationsDisplayController, "Game.Slots.WinSituationsDisplayController");
Sys.ns("Game.Slots");
Game.Slots.WinSituations = {
	constructor: function() {
		Game.Slots.WinSituations.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "serverResponse"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.WinSituationsModel,
			view: Game.Slots.WinSituationsView,
			controller: Game.Slots.WinSituationsController
		}
	}
};
Game.Slots.WinSituations = Sys.extend(Core.Module, Game.Slots.WinSituations, "Game.Slots.WinSituations");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsController = {
	constructor: function() {
		Game.Slots.WinSituationsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:winSituationsDisplay.showingAllWins": a.animateAllWinningBetlines,
			"notify:winSituationsDisplay.togglingWinSituation": a.animateWinSituation,
			"notify:winSituationsDisplay.abort": a.abort,
			"request:winSituations.showDisplayBetline": a.showDisplayBetline,
			"request:winSituations.hideDisplayBetline": a.hideDisplayBetline,
			"view:animationComplete": a.fireEvent.bind(a, "notify:winSituations.animationComplete"),
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	animateAllWinningBetlines: function(a) {
		this.fireEvent("request:winSituationsDisplay.waitFor", "notify:winSituations.animationComplete");
		this.view.showAllWinningBetlines(a)
	},
	animateWinSituation: function(a, b) {
		this.fireEvent("request:winSituationsDisplay.waitFor", "notify:winSituations.animationComplete");
		this.model.storeData("currentWinSituationIndex", a);
		this.view.showSingleWinSituation(a, b)
	},
	abort: function() {
		this.view.stop();
		this.model.removeData("currentWinSituationIndex")
	},
	showDisplayBetline: function(b, a) {
		this.view.showDisplayBetline(b, a)
	},
	hideDisplayBetline: function(a) {
		this.view.hideDisplayBetline(a)
	}
};
Game.Slots.WinSituationsController = Sys.extend(Core.Controller, Game.Slots.WinSituationsController, "Game.Slots.WinSituationsController");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsModel = {
	constructor: function() {
		Game.Slots.WinSituationsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Resources.readData("config").winSituationsDisplay || {},
			b = a.betlines || {};
		this.storeData("lineConfig", b.lines);
		this.storeData("frameConfig", b.frames)
	},
	processServerResponse: function(b) {
		var a = this;
		if (b.wins && Sys.isArray(b.wins.winSituations)) {
			a.storeData("winSituations", b.wins.winSituations.slice(0))
		}
	},
	shouldFrameWinningSymbols: function() {
		return Sys.isDefined(this.readData("frameConfig"))
	}
};
Game.Slots.WinSituationsModel = Sys.extend(Core.Model, Game.Slots.WinSituationsModel, "Game.Slots.WinSituationsModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsView = {
	constructor: function() {
		Game.Slots.WinSituationsView.superclass.constructor.apply(this, arguments)
	},
	setAllBetlinesDisplayItemProps: function(a) {},
	setSingleWinSituationDisplayItemProps: function(a) {},
	initAnimations: function() {
		var a = this,
			b = Environment.getStageResolution();
		a.origin = {
			x: Environment.scaleX(0),
			y: Environment.scaleY(0)
		};
		a.offlineCanvas = document.createElement("canvas");
		a.offlineCanvas.width = b.width;
		a.offlineCanvas.height = b.height;
		a.offlineContext = a.offlineCanvas.getContext("2d");
		a.animationList = new Animation.CanvasAnimationList();
		a.hoverBetlineCanvas = document.createElement("canvas");
		a.hoverBetlineCanvas.width = b.width;
		a.hoverBetlineCanvas.height = b.height;
		a.hoverBetlineContext = a.hoverBetlineCanvas.getContext("2d");
		a.hoverBetlineAnimationList = new Animation.CanvasAnimationList();
		a.createAnimationItems();
		a.createHoverBetlineAnimationItems();
		Game.stage.view.addToRenderLoop(a.animationList);
		Game.stage.view.addToRenderLoop(a.hoverBetlineAnimationList);
		a.hoverBetlineAnimationList.stop();
		a.animationList.stop()
	},
	createAnimationItems: function() {
		var a = this;
		a.item = new Animation.CanvasAnimationItem({
			top: 0,
			left: 0,
			width: a.offlineCanvas.width,
			height: a.offlineCanvas.height,
			depth: Layering.Game.Slots.WinSituationsDisplay.betlines,
			image: a.offlineCanvas,
			operations: {
				fade: [{
					time: 0,
					value: 1,
					fireEvent: {
						event: "view:animationComplete",
						scope: a
					}
				}, {
					time: 1,
					value: 1,
					goTo: 0
				}]
			}
		});
		a.animationList.add(a.item)
	},
	createHoverBetlineAnimationItems: function() {
		var a = this,
			b = Layering.Game.Slots.WinSituationsDisplay.hoverBetlines || Layering.Game.Slots.WinSituationsDisplay.betlines;
		a.hoverItem = new Animation.CanvasAnimationItem({
			top: 0,
			left: 0,
			width: a.hoverBetlineCanvas.width,
			height: a.hoverBetlineCanvas.height,
			depth: b,
			image: a.hoverBetlineCanvas
		});
		a.hoverBetlineAnimationList.add(a.hoverItem)
	},
	showAllWinningBetlines: function(c) {
		var b = this,
			a = b.model.readData("winSituations");
		Sys.each(a, function(d) {
			if (Sys.isDefined(d.betline)) {
				b.drawBetline(d.betline)
			}
		});
		b.setAllBetlinesDisplayItemProps(c);
		b.animationList.restore();
		b.animationList.play()
	},
	drawBetline: function(e, b) {
		var d = this,
			g = d.model.readData("lineConfig"),
			c = g[e].lineCoordinates,
			f = g[e].color || g.defaultColor,
			a, h;
		b = b ? b : d.offlineContext;
		if (!Array.isArray(c)) {
			h = Environment.getConfigForCurrentDeviceState(c)
		} else {
			h = c
		}
		b.beginPath();
		b.moveTo(h[0], h[1]);
		if (g.lineType === "curve") {
			for (a = 2; a < h.length; a += 6) {
				b.bezierCurveTo(h[a], h[a + 1], h[a + 2], h[a + 3], h[a + 4], h[a + 5])
			}
		} else {
			for (a = 2; a < h.length; a += 2) {
				b.lineTo(h[a], h[a + 1])
			}
		}
		for (a = 0; a < g.drawingOperations.length; a++) {
			b.strokeStyle = f;
			b = Sys.applyProperties(b, g.drawingOperations[a]);
			b.stroke()
		}
	},
	showSingleWinSituation: function(c, d) {
		var b = this,
			a = b.model.readData("winSituations")[c];
		if (Sys.isDefined(a.betline)) {
			b.drawBetline(a.betline)
		}
		if (b.model.shouldFrameWinningSymbols()) {
			b.frameWinningSymbols(a)
		}
		b.setSingleWinSituationDisplayItemProps(d);
		b.animationList.restore();
		b.animationList.play()
	},
	frameWinningSymbols: function(l) {
		var h = this,
			b = h.model.readData("lineConfig"),
			g = h.model.readData("frameConfig"),
			e = (l.betline && b[l.betline].color) || b.defaultColor,
			c = h.offlineContext,
			k, m, j, a, n, f = g.image,
			d;
		if (f) {
			f = Resources.readData("animationImages")[f]
		}
		Sys.each(l.positions, function(o) {
			k = Game.stage.model.getSymbolConfiguration(o.reelIndex, o.symbolIndex);
			m = k.left + g.xOffset;
			j = k.top + g.yOffset;
			a = k.width - g.xOffset * 2;
			n = k.height - g.yOffset * 2;
			c.clearRect(m, j, a, n);
			if (f) {
				c.drawImage(f, m, j)
			} else {
				for (d = 0; d < b.drawingOperations.length; d++) {
					c.strokeStyle = e;
					c = Sys.applyProperties(c, b.drawingOperations[d]);
					c.strokeRect(m, j, a, n)
				}
			}
		})
	},
	stop: function() {
		var a = this;
		a.animationList.stop();
		a.offlineContext.clearRect(0, 0, a.offlineCanvas.width, a.offlineCanvas.height)
	},
	showDisplayBetline: function(a, b) {
		var d = this,
			c = d.model.readData("displayBetlineWho");
		if (!Sys.isArray(a)) {
			a = [a]
		}
		if (!Sys.isDefined(b)) {
			b = "hover"
		}
		if (b !== c) {
			d.hideDisplayBetline(c)
		}
		d.model.storeData("displayBetlineWho", b);
		a.forEach(function(e) {
			d.drawBetline(e, d.hoverBetlineContext)
		});
		d.hoverBetlineAnimationList.play()
	},
	hideDisplayBetline: function(a) {
		var b = this;
		if (!Sys.isDefined(a)) {
			a = "hover"
		}
		if (a === b.model.readData("displayBetlineWho")) {
			b.hoverBetlineAnimationList.stop();
			b.hoverBetlineContext.clearRect(0, 0, b.hoverBetlineCanvas.width, b.hoverBetlineCanvas.height)
		}
	},
	refresh: function() {
		var b = this.model.readData("currentWinSituationIndex"),
			a = this.item,
			c;
		this.animationList.stop();
		c = Environment.getStageResolution();
		this.offlineCanvas.width = c.width;
		this.offlineCanvas.height = c.height;
		if (Animation.utils.isAnimationItem(a)) {
			a.setWidth(c.width);
			a.setHeight(c.height);
			a.updatePivot()
		}
		if (Sys.isNumber(b)) {
			this.showSingleWinSituation(b, {})
		}
	}
};
Game.Slots.WinSituationsView = Sys.extend(Core.View, Game.Slots.WinSituationsView, "Game.Slots.WinSituationsView");
Sys.ns("Game.Slots");
Game.Slots.CoinWin = {
	constructor: function() {
		Game.Slots.CoinWin.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.CoinWinModel,
			view: Game.Slots.CoinWinView,
			controller: Game.Slots.CoinWinController
		}
	}
};
Game.Slots.CoinWin = Sys.extend(Core.Module, Game.Slots.CoinWin, "Game.Slots.CoinWin");
Sys.ns("Game.Slots");
Game.Slots.CoinWinModel = {
	SYMBOL_ORDER_FREFERENCE: [2, 1, 3, 0, 4],
	constructor: function() {
		Game.Slots.CoinWinModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(c) {
		var b = this,
			a = [];
		if (c.wins && Sys.isArray(c.wins.winSituations)) {
			Sys.each(c.wins.winSituations, function(d) {
				a.push(b.parseWinSituation(d))
			})
		}
		b.storeData("winSituations", a)
	},
	parseWinSituation: function(e) {
		var d, a = [],
			c, f, b;
		if (e.wins.type === "coins") {
			d = e.positions;
			for (b = 0; b < d.length; b++) {
				a.push(d[b].reelIndex)
			}
			for (b = 0; b < this.SYMBOL_ORDER_FREFERENCE.length; b++) {
				f = this.SYMBOL_ORDER_FREFERENCE[b];
				c = a.indexOf(f);
				if (c >= 0) {
					return {
						x: f,
						y: d[c].symbolIndex,
						coins: e.wins.coins
					}
				}
			}
		}
		return undefined
	}
};
Game.Slots.CoinWinModel = Sys.extend(Core.Model, Game.Slots.CoinWinModel, "Game.Slots.CoinWinModel");
Sys.ns("Game.Slots");
Game.Slots.CoinWinView = {
	NUMBER_IMAGE: undefined,
	NUMBER_WIDTH: 100,
	NUMBER_HEIGHT: 100,
	NUMBER_FONT: "bold 100px Verdana",
	NUMBER_OFFSET: 0,
	NUMBER_TEXT_OPERATIONS: [{
		fillStyle: "#fff"
	}, {
		lineWidth: 5,
		strokeStyle: "#000",
		drawType: "stroke"
	}],
	BACKGROUND_IMAGE: undefined,
	BACKGROUND_DRAWING_FUNCTION: function(a) {
		a.fillStyle = "#ff00e0";
		a.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
	},
	BACKGROUND_WIDTH: undefined,
	BACKGROUND_HEIGHT: undefined,
	constructor: function() {
		var b = this,
			a = {
				NUMBER_IMAGE: b.NUMBER_IMAGE,
				NUMBER_WIDTH: b.NUMBER_WIDTH,
				NUMBER_HEIGHT: b.NUMBER_HEIGHT,
				NUMBER_FONT: b.NUMBER_FONT,
				NUMBER_OFFSET: b.NUMBER_OFFSET,
				NUMBER_TEXT_OPERATIONS: b.NUMBER_TEXT_OPERATIONS,
				BACKGROUND_IMAGE: b.BACKGROUND_IMAGE,
				BACKGROUND_DRAWING_FUNCTION: b.BACKGROUND_DRAWING_FUNCTION,
				BACKGROUND_WIDTH: b.BACKGROUND_WIDTH,
				BACKGROUND_HEIGHT: b.BACKGROUND_HEIGHT
			};
		Game.Slots.CoinWinView.superclass.constructor.apply(b, arguments);
		b.CONFIG = b.CONFIG || {};
		b.CONFIG.DEFAULT = b.CONFIG.DEFAULT || {};
		Sys.applyProperties(b.CONFIG.DEFAULT, a);
		b.renderingProperties = {}
	},
	initAnimations: function() {
		var a = this;
		a.animationList = new Animation.CanvasAnimationList();
		a.textItem = a.createTextItem();
		a.backgroundItem = a.createBackgroundItem();
		a.animationList.add(a.backgroundItem);
		a.animationList.add(a.textItem);
		Game.stage.view.addToRenderLoop(a.animationList);
		a.animationList.stop()
	},
	createTextItem: function() {
		var b = this,
			a = Environment.getOrientationSpecificConfig(b.CONFIG, true),
			c = Animation.utils.text.createNumberDrawingProperties(a);
		b.renderingProperties[Environment.getOrientation()] = c;
		return new Animation.CanvasAnimationItem({
			top: 0,
			left: 0,
			width: 0,
			height: 0,
			depth: Layering.Game.Slots.CoinWin.text,
			customProps: {
				text: "not set yet",
				renderingProperties: c
			},
			executeBefore: function(d) {
				var e = this.customProps.renderingProperties;
				Animation.utils.text.drawTextFromImage(this.customProps.text, a.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, e.image, e.charMap, e.width, e.height, d)
			},
			operations: {
				fade: [{
					time: 0,
					value: 1,
					fireEvent: {
						event: "view:animationComplete",
						scope: b
					}
				}, {
					time: 1,
					value: 1,
					goTo: 0
				}]
			}
		})
	},
	createBackgroundItem: function() {
		var a = this,
			b = Game.stage.model.getSymbolConfiguration(0, 0);
		return new Animation.CanvasAnimationItem({
			width: a.CONFIG.DEFAULT.BACKGROUND_WIDTH || b.width,
			height: a.CONFIG.DEFAULT.BACKGROUND_HEIGHT || b.height,
			depth: Layering.Game.Slots.CoinWin.background,
			executeBefore: a.CONFIG.DEFAULT.BACKGROUND_DRAWING_FUNCTION,
			image: a.CONFIG.DEFAULT.BACKGROUND_IMAGE
		})
	},
	animate: function(a) {
		this.animationList.restore();
		this.updateAnimationItems(a);
		this.animationList.play()
	},
	updateAnimationItems: function(a) {
		var b = this,
			c;
		c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
		b.backgroundItem.prop.top = c.top;
		b.backgroundItem.prop.left = c.left;
		b.textItem.setTop(c.top + c.height / 2);
		b.textItem.setLeft(c.left + c.width / 2);
		b.textItem.prop.customProps.text = a.coins
	},
	abort: function() {
		this.animationList.stop();
		this.fireEvent("view:animationAborted")
	},
	updateItems: function() {
		var e = this,
			c = Environment.getOrientationSpecificConfig(e.CONFIG, true),
			d = e.model.readData("currentWinSituation") || {
				x: 0,
				y: 0
			},
			b = Environment.getOrientation(),
			f = Game.stage.model.getSymbolConfiguration(d.x, d.y),
			a = e.setRenderingProperties(c, b);
		if (Animation.utils.isAnimationItem(e.textItem)) {
			e.textItem.setWidth(a.width);
			e.textItem.setHeight(a.height);
			e.textItem.setTop(f.top + f.height / 2);
			e.textItem.setLeft(f.left + f.width / 2);
			e.textItem.prop.customProps.renderingProperties = a
		}
		if (Animation.utils.isAnimationItem(e.backgroundItem)) {
			e.backgroundItem.setWidth(c.BACKGROUND_WIDTH || f.width);
			e.backgroundItem.setHeight(c.BACKGROUND_HEIGHT || f.height);
			e.backgroundItem.setTop(f.top);
			e.backgroundItem.setLeft(f.left)
		}
	},
	setRenderingProperties: function(b, a) {
		if (!Sys.isDefined(this.renderingProperties[a])) {
			this.renderingProperties[a] = Animation.utils.text.createNumberDrawingProperties(b)
		}
		return this.renderingProperties[a]
	},
	refresh: function() {
		this.updateItems()
	}
};
Game.Slots.CoinWinView = Sys.extend(Core.View, Game.Slots.CoinWinView, "Game.Slots.CoinWinView");
Sys.ns("Game.Slots");
Game.Slots.CoinWinController = {
	constructor: function() {
		Game.Slots.CoinWinController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
			"notify:winSituationsDisplay.togglingWinSituation": a.animate,
			"notify:winSituationsDisplay.abort": a.abort,
			"view:animationComplete": a.animationComplete,
			"view:animationAborted": a.animationComplete,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	animate: function(b) {
		var d = this,
			a = d.model.readData("winSituations"),
			c = b % a.length;
		if (a.length > 0 && Sys.isDefined(a[c])) {
			d.model.setState("animating");
			d.view.animate(a[c]);
			d.model.storeData("currentWinSituation", a[c]);
			d.fireEvent("request:winSituationsDisplay.waitFor", "notify:coinWin.animationComplete")
		}
	},
	animationComplete: function() {
		this.fireEvent("notify:coinWin.animationComplete")
	},
	abort: function() {
		if (this.model.isState("animating")) {
			this.view.abort();
			this.model.removeData("currentWinSituation");
			this.model.setState("idle")
		}
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	}
};
Game.Slots.CoinWinController = Sys.extend(Core.Controller, Game.Slots.CoinWinController, "Game.Slots.CoinWinController");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbols = {
	constructor: function() {
		Game.Slots.NoWinSymbols.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.NoWinSymbolsModel,
			controller: Game.Slots.NoWinSymbolsController,
			view: Game.Slots.NoWinSymbolsView
		}
	}
};
Game.Slots.NoWinSymbols = Sys.extend(Core.Module, Game.Slots.NoWinSymbols, "Game.Slots.NoWinSymbols");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbolsModel = {
	constructor: function() {
		Game.Slots.NoWinSymbolsModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(f) {
		var d = f.reelInfo,
			h = 0,
			a, c, b, k, j = {},
			g = [],
			e;
		if (Sys.isDefined(d) && Sys.isDefined(f.wins) && Sys.isArray(f.wins.winSituations)) {
			a = d.length;
			for (c = 0; c < a; c++) {
				h = Math.max(h, d[c].symbols.length)
			}
			k = Sys.utils.init2dMatrix(a, h, false);
			Sys.each(f.wins.winSituations, function(l) {
				Sys.each(l.positions, function(m) {
					k[m.reelIndex][m.symbolIndex] = true
				})
			});
			for (c = 0; c < a; c++) {
				for (b = 0; b < d[c].symbols.length; b++) {
					if (!k[c][b]) {
						if (d[c].overlaySymbols[b]) {
							e = d[c].overlaySymbols[b]
						} else {
							e = d[c].symbols[b]
						}
						g.push({
							x: c,
							y: b,
							symbol: e
						});
						if (!j.hasOwnProperty(c)) {
							j[c] = []
						}
						j[c].push(b)
					}
				}
			}
		}
		this.storeData("symbolsToAnimateMatrix", j);
		this.storeData("symbolsToAnimate", g)
	}
};
Game.Slots.NoWinSymbolsModel = Sys.extend(Core.Model, Game.Slots.NoWinSymbolsModel, "Game.Slots.NoWinSymbolsModel");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbolsView = {
	constructor: function() {
		var a = this;
		Game.Slots.NoWinSymbolsView.superclass.constructor.apply(a, arguments);
		a.animationList = new Animation.List({
			id: "noWinSymbols"
		});
		Game.stage.view.addToRenderLoop(a.animationList);
		a.animationList.stop()
	},
	initAnimations: function() {},
	animateNoWinSymbols: function() {
		var b = this,
			a = b.model.readData("symbolsToAnimate"),
			c = Resources.readData("symbolLayout");
		Sys.each(a, function(e) {
			var d = Game.stage.model.getSymbolConfiguration(e.x, e.y);
			b.animationList.add(b.getAnimationItem({
				symbolName: e.symbol,
				reelIndex: e.x,
				symbolIndex: e.y,
				top: d.top,
				left: d.left,
				width: d.width,
				height: d.height,
				depth: c[e.x][e.y].depth
			}))
		});
		b.animationList.play()
	},
	refresh: function() {
		this.stopAnimateNoWinSymbols();
		if (this.model.readData("shouldAnimate")) {
			this.animateNoWinSymbols()
		}
	},
	getAnimationItem: function(a) {},
	stopAnimateNoWinSymbols: function() {
		this.animationList.stop();
		this.animationList.removeItems()
	}
};
Game.Slots.NoWinSymbolsView = Sys.extend(Core.View, Game.Slots.NoWinSymbolsView, "Game.Slots.NoWinSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbolsController = {
	constructor: function() {
		Game.Slots.NoWinSymbolsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:noWinSymbols.animate": a.animateNoWinSymbols,
			"request:noWinSymbols.stopAnimate": a.stopAnimateNoWinSymbols,
			"notify:winSituationsDisplay.showingAllWins": a.animateNoWinSymbols,
			"notify:stateHandler.enteringSpinningState": a.enteringSpinningState,
			"notify:stateHandler.enteringFreeSpinOutroState": a.stopAnimateNoWinSymbols,
			"notify:stateHandler.enteringFreeSpinIntroState": a.stopAnimateNoWinSymbols,
			"notify:settingsManager.settingChanged": a.onSettingsChanged,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	enteringSpinningState: function() {
		this.model.storeData("shouldAnimate", false);
		this.stopAnimateNoWinSymbols()
	},
	animateNoWinSymbols: function() {
		var c = this,
			b = c.model,
			a = b.readData("symbolsToAnimateMatrix");
		if (a && Object.keys(a).length > 0) {
			c.model.storeData("shouldAnimate", true);
			c.fireEvent("request:spin.hideSymbols", a);
			c.view.animateNoWinSymbols()
		}
	},
	stopAnimateNoWinSymbols: function() {
		var c = this,
			b = c.model,
			a = b.readData("symbolsToAnimateMatrix");
		if (a && Object.keys(a).length > 0) {
			c.view.stopAnimateNoWinSymbols();
			c.fireEvent("request:spin.showSymbols", a)
		}
	},
	onSettingsChanged: function(a) {
		if (["betLevel", "denomination"].contains(a)) {
			this.stopAnimateNoWinSymbols()
		}
	}
};
Game.Slots.NoWinSymbolsController = Sys.extend(Core.Controller, Game.Slots.NoWinSymbolsController, "Game.Slots.NoWinSymbolsController");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbols = {
	constructor: function() {
		Game.Slots.DimmedSymbols.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.DimmedSymbolsModel,
			view: Game.Slots.DimmedSymbolsView,
			controller: Game.Slots.DimmedSymbolsController
		}
	}
};
Game.Slots.DimmedSymbols = Sys.extend(Core.Module, Game.Slots.DimmedSymbols, "Game.Slots.DimmedSymbols");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbolsModel = {
	constructor: function() {
		Game.Slots.DimmedSymbolsModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(g) {
		var d = g.reelInfo,
			h = 0,
			a, c, b, j, f = [],
			e;
		if (Sys.isDefined(d) && Sys.isDefined(g.wins) && Sys.isArray(g.wins.winSituations)) {
			a = d.length;
			for (c = 0; c < a; c++) {
				h = Math.max(h, d[c].symbols.length)
			}
			j = Sys.utils.init2dMatrix(a, h, false);
			Sys.each(g.wins.winSituations, function(k) {
				Sys.each(k.positions, function(l) {
					j[l.reelIndex][l.symbolIndex] = true
				})
			});
			for (c = 0; c < a; c++) {
				for (b = 0; b < d[c].length; b++) {
					if (!j[c][b]) {
						if (d[c].overlaySymbols[b]) {
							e = d[c].overlaySymbols[b]
						} else {
							e = d[c].symbols[b]
						}
						f.push({
							x: c,
							y: b,
							symbol: e
						})
					}
				}
			}
		}
		this.storeData("symbolsToDim", f)
	}
};
Game.Slots.DimmedSymbolsModel = Sys.extend(Core.Model, Game.Slots.DimmedSymbolsModel, "Game.Slots.DimmedSymbolsModel");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbolsView = {
	OPACITY: 0.3,
	constructor: function() {
		Game.Slots.DimmedSymbolsView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var e = this,
			a = Resources.readData("animationImages"),
			b, c, d = {};
		Sys.iterate(a, function(f, g) {
			if (f.match(/^SYM\d+$/)) {
				b = document.createElement("canvas");
				b.width = g.width;
				b.height = g.height;
				c = b.getContext("2d");
				c.globalAlpha = e.OPACITY;
				c.drawImage(g, 0, 0);
				d[f] = b
			}
		});
		this.model.storeData("dimmedSymbolImages", d)
	},
	dimNoWinSymbols: function() {
		var d = this,
			b = d.model.readData("symbolsToDim"),
			g = d.model.readData("dimmedSymbolImages"),
			f, e, a = {},
			c = {};
		Sys.each(b, function(h) {
			f = h.x;
			e = h.y;
			if (!Sys.isDefined(a[f])) {
				a[f] = {};
				c[f] = {}
			}
			a[f][e] = g[h.symbol];
			c[f][e] = h.symbol
		});
		d.model.storeData("unDimSymbolConfig", c);
		d.fireEvent("view:setReelSymbols", a)
	},
	unDimNoWinSymbols: function() {
		this.fireEvent("view:setReelSymbols", this.model.readData("unDimSymbolConfig"))
	}
};
Game.Slots.DimmedSymbolsView = Sys.extend(Core.View, Game.Slots.DimmedSymbolsView, "Game.Slots.DimmedSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbolsController = {
	constructor: function() {
		Game.Slots.DimmedSymbolsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
			"notify:winSituationsDisplay.showingAllWins": a.dimNoWinSymbols,
			"request:dimmedSymbols.dimNoWinSymbols": a.dimNoWinSymbols,
			"notify:stateHandler.enteringSpinningState": a.unDimNoWinSymbols,
			"notify:stateHandler.enteringFreeSpinOutroState": a.unDimNoWinSymbols,
			"notify:stateHandler.enteringFreeSpinIntroState": a.unDimNoWinSymbols,
			"view:setReelSymbols": a.fireEvent.bind(a, "request:spin.setSymbols")
		})
	},
	dimNoWinSymbols: function() {
		var b = this,
			a = b.model;
		if (!a.isState("animateSymbols") && a.readData("symbolsToDim").length > 0) {
			a.setState("animateSymbols");
			b.view.dimNoWinSymbols()
		}
	},
	unDimNoWinSymbols: function() {
		if (this.model.isState("animateSymbols")) {
			this.model.setState("idle");
			this.view.unDimNoWinSymbols()
		}
	}
};
Game.Slots.DimmedSymbolsController = Sys.extend(Core.Controller, Game.Slots.DimmedSymbolsController, "Game.Slots.DimmedSymbolsController");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimations = {
	constructor: function() {
		Game.Slots.ReelStopAnimations.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "serverResponse", "trigger"]
	},
	getStateChanges: function() {
		var c = this,
			b = c.model,
			a = c.MODULE_NAME,
			d = {
				state: {
					name: a[0].toUpperCase() + a.substr(1),
					execute: function() {},
					waitEvents: {}
				}
			},
			e = {
				stopped: {
					queue: [function(f) {
						if (b.readData("shouldAnimate") && !b.readData("quickStopTriggered") && !b.readData("animationsComplete")) {
							f.stateHandler.pushState(f.states[a])
						}
					}]
				}
			};
		d.state.waitEvents["notify:" + a + ".animationsComplete"] = false;
		e[a] = d;
		return e
	},
	getDefaultMVCClasses: function() {
		return undefined
	}
};
Game.Slots.ReelStopAnimations = Sys.extend(Core.Module, Game.Slots.ReelStopAnimations, "Game.Slots.ReelStopAnimations");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimationsModel = {
	SYMBOLS_TO_ANIMATE: [],
	constructor: function() {
		Game.Slots.ReelStopAnimationsModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(d) {
		var a = this.SYMBOLS_TO_ANIMATE,
			c = [],
			b;
		Sys.each(d.reelInfo, function(e, f) {
			c.push([]);
			Sys.each(e.symbols, function(h, g) {
				b = e.overlaySymbols[g];
				if (a.contains(b)) {
					c[f].push({
						symbol: b,
						symbolIndex: g
					})
				} else {
					if (a.contains(h)) {
						c[f].push({
							symbol: h,
							symbolIndex: g
						})
					}
				}
			})
		});
		c = this.applyConditions(c);
		this.calculateLastReelToAnimate(c);
		this.storeData("symbolsToAnimateInOutcome", c)
	},
	applyConditions: function(a) {
		return a
	},
	calculateLastReelToAnimate: function(c) {
		var b = this,
			d = {},
			a = false;
		Sys.each(c, function(f, e) {
			Sys.each(f, function(g) {
				if (b.SYMBOLS_TO_ANIMATE.contains(g.symbol)) {
					a = true;
					d[g.symbol] = e
				}
			})
		});
		b.storeData("shouldAnimate", a);
		b.storeData("lastReelToAnimate", d)
	}
};
Game.Slots.ReelStopAnimationsModel = Sys.extend(Core.Model, Game.Slots.ReelStopAnimationsModel, "Game.Slots.ReelStopAnimationsModel");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimationsController = {
	constructor: function() {
		Game.Slots.ReelStopAnimationsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringSpinningState": a.onSpinStart,
			"notify:quickStopper.quickStop": a.onQuickStopTriggered,
			"request:reelStopAnimations.abort": a.abortTriggered,
			"notify:spin.reelStoppedSpinning": a.onReelStopped,
			"view:animationsComplete": a.onAnimationsComplete,
			"view:playSound": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopSound": a.fireEvent.bind(a, "request:audioPlayer.stop")
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:reelStopAnimations.symbolsToAnimate", this, "When there are scatter symbols to animate.")
	},
	onSpinStart: function() {
		this.model.storeData("quickStopTriggered", false);
		this.model.storeData("animationsComplete", false);
		this.model.storeData("abortTriggered", false)
	},
	onQuickStopTriggered: function() {
		this.model.storeData("quickStopTriggered", true);
		this.abort()
	},
	abortTriggered: function() {
		this.model.storeData("abortTriggered", true);
		this.abort()
	},
	onReelStopped: function(c) {
		var b = this.model,
			a = b.readData("symbolsToAnimateInOutcome")[c];
		if (!b.readData("quickStopTriggered") && !b.readData("abortTriggered") && a.length > 0) {
			this.view.animate(a, c);
			this.fireEvent("notify:reelStopAnimations.symbolsToAnimate", c, a)
		}
	},
	onAnimationsComplete: function() {
		this.model.storeData("animationsComplete", true);
		this.fireEvent("notify:" + this.MODULE_NAME + ".animationsComplete")
	},
	abort: function() {
		this.view.abort();
		this.fireEvent("notify:" + this.MODULE_NAME + ".animationsComplete")
	}
};
Game.Slots.ReelStopAnimationsController = Sys.extend(Core.Controller, Game.Slots.ReelStopAnimationsController, "Game.Slots.ReelStopAnimationsController");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinSymbolAttentionAnimation = {
	constructor: function() {
		Game.Slots.FreeSpinSymbolAttentionAnimation.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.FreeSpinSymbolAttentionAnimationModel,
			view: Game.Slots.FreeSpinSymbolAttentionAnimationView,
			controller: Game.Slots.ReelStopAnimationsController
		}
	}
};
Game.Slots.FreeSpinSymbolAttentionAnimation = Sys.extend(Game.Slots.ReelStopAnimations, Game.Slots.FreeSpinSymbolAttentionAnimation, "Game.Slots.FreeSpinSymbolAttentionAnimation");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinSymbolAttentionAnimationModel = {
	SYMBOLS_TO_ANIMATE: ["SYM0"],
	MINIMUM_COUNT_REQUIREMENT: [0, 0, 0, 1, 2],
	constructor: function() {
		Game.Slots.FreeSpinSymbolAttentionAnimationModel.superclass.constructor.apply(this, arguments)
	},
	applyConditions: function(c) {
		var b = this,
			a = 0;
		Sys.each(c, function(d, e) {
			if (e === c.length - 1) {
				d.length = 0
			} else {
				if (d.length > 0) {
					if (a < b.MINIMUM_COUNT_REQUIREMENT[e]) {
						d.length = 0
					}
					a++
				}
			}
		});
		return c
	}
};
Game.Slots.FreeSpinSymbolAttentionAnimationModel = Sys.extend(Game.Slots.ReelStopAnimationsModel, Game.Slots.FreeSpinSymbolAttentionAnimationModel, "Game.Slots.FreeSpinSymbolAttentionAnimationModel");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinSymbolAttentionAnimationView = {
	constructor: function() {
		Game.Slots.FreeSpinSymbolAttentionAnimationView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.animationList = new Animation.CanvasAnimationList();
		a.createAnimationItems();
		Game.stage.view.addToRenderLoop(a.animationList);
		a.animationList.stop()
	},
	createAnimationItems: function() {
		var b = this,
			d = Game.stage.model.getCurrentReelGroupConfiguration().symbolCols,
			c, a;
		b.animationItems = [];
		while (b.animationItems.length < d - 1) {
			c = Game.stage.model.getSymbolConfiguration(b.animationItems.length, 0);
			a = new Animation.CanvasAnimationItem({
				width: c.width,
				height: c.height,
				left: c.left,
				depth: Layering.Game.Slots.FreeSpinSymbolAttentionAnimation.animationItems,
				executeBefore: function(e) {
					e.fillStyle = "#ff0000";
					e.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
				}
			});
			b.animationList.add(a);
			b.animationItems.push(a)
		}
	},
	animate: function(b, f) {
		var d = this,
			a = b[0].symbolIndex,
			e = Game.stage.model.getSymbolConfiguration(f, a),
			c = d.animationItems[f];
		c.prop.operations = {
			fade: [{
				time: 0,
				value: 0
			}, {
				time: 250,
				value: 1
			}, {
				time: 500,
				value: 0
			}]
		};
		if (f === d.model.readData("lastReelToAnimate")[d.model.SYMBOLS_TO_ANIMATE[0]]) {
			c.prop.operations.fade[2].fireEvent = {
				event: "view:animationsComplete",
				scope: d
			}
		}
		c.prop.top = e.top;
		d.animationList.play(c)
	},
	abort: function() {
		this.animationList.stop()
	}
};
Game.Slots.FreeSpinSymbolAttentionAnimationView = Sys.extend(Core.View, Game.Slots.FreeSpinSymbolAttentionAnimationView, "Game.Slots.FreeSpinSymbolAttentionAnimationView");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbols = {
	constructor: function() {
		Game.Slots.WinningSymbols.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.WinningSymbolsModel,
			view: Game.Slots.WinningSymbolsView,
			controller: Game.Slots.WinningSymbolsController
		}
	}
};
Game.Slots.WinningSymbols = Sys.extend(Core.Module, Game.Slots.WinningSymbols, "Game.Slots.WinningSymbols");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsModel = {
	SYMBOLS_TO_ANIMATE_ON_TOGGLE: ["SYM0", "SYM1"],
	constructor: function() {
		Game.Slots.WinningSymbolsModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(h) {
		var j = this,
			e = h.reelInfo,
			d, c, a = [],
			g, b, k = [],
			f;
		if (h.wins && Sys.isArray(h.wins.winSituations)) {
			Sys.each(h.wins.winSituations, function(l) {
				g = [];
				Sys.each(l.positions, function(m) {
					d = m.reelIndex;
					c = m.symbolIndex;
					if (e[d].overlaySymbols[c]) {
						f = e[d].overlaySymbols[c]
					} else {
						f = e[d].symbols[c]
					}
					b = {
						x: d,
						y: c,
						symbol: f
					};
					k.push(b);
					if (j.SYMBOLS_TO_ANIMATE_ON_TOGGLE.contains(f)) {
						g.push(b)
					}
				});
				a.push(g)
			})
		}
		j.storeData("winningSymbols", k);
		j.storeData("winSituationSymbols", a)
	}
};
Game.Slots.WinningSymbolsModel = Sys.extend(Core.Model, Game.Slots.WinningSymbolsModel, "Game.Slots.WinningSymbolsModel");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsView = {
	constructor: function() {
		Game.Slots.WinningSymbolsView.superclass.constructor.apply(this, arguments)
	},
	ALL_WINNING_SYMBOLS_ANIMATION_TIME: 1000,
	WIN_SITUATION_ANIMATION_TIMES: {
		SYM0: 1000,
		SYM1: 1000
	},
	configureItemForAllWinningSymbolsDisplay: function(d, a, f) {
		var b = this,
			c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
			e = this.ALL_WINNING_SYMBOLS_ANIMATION_TIME;
		d.prop = Sys.apply(d.prop, {
			depth: Layering.Game.Slots.WinningSymbols.animationItems,
			executeBefore: function(h, j, g, l) {
				var k = l.prop;
				h.fillStyle = "#ffffff";
				h.fillRect(k.pivot.x, k.pivot.y, k.width, k.height)
			},
			operations: {
				fade: [{
					time: 0,
					value: 0
				}, {
					time: e / 2,
					value: 1
				}, {
					time: e,
					value: 0,
					fireEvent: {
						event: "view:animationComplete",
						scope: b
					}
				}]
			}
		});
		d.prop.top = c.top;
		d.prop.left = c.left;
		d.prop.width = c.width;
		d.prop.height = c.height;
		d.restore()
	},
	configureItemForWinSituationToggling: function(d, a, f) {
		var b = this,
			c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
			e = this.WIN_SITUATION_ANIMATION_TIMES[a.symbol];
		d.prop = Sys.apply(d.prop, {
			depth: Layering.Game.Slots.WinningSymbols.animationItems,
			executeBefore: function(g) {
				g.fillStyle = "#fdfd00";
				g.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
			},
			operations: {
				fade: [{
					time: 0,
					value: 0
				}, {
					time: e / 2,
					value: 1
				}, {
					time: e,
					value: 0,
					fireEvent: {
						event: "view:animationComplete",
						scope: b
					}
				}]
			}
		});
		d.prop.top = c.top;
		d.prop.left = c.left;
		d.prop.width = c.width;
		d.prop.height = c.height;
		d.restore()
	},
	initAnimations: function() {
		var c = this,
			d = Game.stage.model.getCurrentReelGroupConfiguration(),
			a = d.symbolCols,
			b = d.symbolRows;
		c.animationItems = Sys.utils.init2dMatrix(a, b);
		c.animationList = new Animation.CanvasAnimationList();
		Game.stage.view.addToRenderLoop(c.animationList);
		c.animationList.stop()
	},
	animateAllWinningSymbols: function(a) {
		this.animateSymbols(this.model.readData("winningSymbols"), this.configureItemForAllWinningSymbolsDisplay, a)
	},
	animateWinSituationSymbols: function(a, b) {
		this.animateSymbols(a, this.configureItemForWinSituationToggling, b)
	},
	animateSymbols: function(b, c, g) {
		var e = this,
			a, f, d;
		e.animationList.restore();
		e.animationList.stop();
		Sys.each(b, function(h) {
			a = h.x;
			f = h.y;
			if (Sys.isDefined(e.animationItems[a][f])) {
				d = e.animationItems[a][f]
			} else {
				d = new Animation.CanvasAnimationItem({});
				e.animationList.add(d);
				e.animationItems[a][f] = d
			}
			c.call(e, d, h, g);
			d.play()
		})
	},
	stop: function() {
		this.animationList.stop();
		this.fireEvent("view:animationComplete")
	},
	refresh: function() {
		var b = this,
			a = this.model.readData("winningSymbols");
		Sys.each(a, function(f) {
			var c = f.x,
				g = f.y,
				e = Game.stage.model.getSymbolConfiguration(c, g),
				d = b.animationItems[c][g];
			if (Animation.utils.isAnimationItem(d)) {
				d.prop.top = e.top;
				d.prop.left = e.left;
				d.prop.width = e.width;
				d.prop.height = e.height
			}
		})
	}
};
Game.Slots.WinningSymbolsView = Sys.extend(Core.View, Game.Slots.WinningSymbolsView, "Game.Slots.WinningSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsController = {
	constructor: function() {
		Game.Slots.WinningSymbolsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
			"notify:winSituationsDisplay.showingAllWins": a.animateAllWinningSymbols,
			"notify:winSituationsDisplay.togglingWinSituation": a.animateWinSituationSymbols,
			"notify:winSituationsDisplay.abort": a.abort,
			"view:animationComplete": a.onAnimationComplete,
			"view:hideSymbol": a.hideSymbol,
			"view:showSymbol": a.showSymbol,
			"view:playSound": a.playSound,
			"view:stopSound": a.stopSound,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	},
	playSound: function(a) {
		this.fireEvent("request:audioPlayer.play", a)
	},
	stopSound: function(a) {
		this.fireEvent("request:audioPlayer.stop", a)
	},
	animateWinSituationSymbols: function(b, d) {
		var c = this,
			a = c.model.readData("winSituationSymbols")[b];
		if (Sys.isArray(a) && a.length > 0) {
			c.model.setState("animating");
			c.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
			c.view.animateWinSituationSymbols(a, d)
		}
	},
	animateAllWinningSymbols: function(b) {
		var a = this;
		if (a.model.readData("winningSymbols").length > 0) {
			a.model.setState("animating");
			a.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
			a.view.animateAllWinningSymbols(b)
		}
	},
	abort: function() {
		if (this.model.isState("animating")) {
			this.view.stop()
		}
	},
	onAnimationComplete: function() {
		this.model.setState("idle");
		this.fireEvent("notify:winningSymbols.animationComplete")
	},
	hideSymbol: function(a) {
		this.fireEvent("request:spin.hideSymbols", a)
	},
	showSymbol: function(a) {
		this.fireEvent("request:spin.showSymbols", a)
	}
};
Game.Slots.WinningSymbolsController = Sys.extend(Core.Controller, Game.Slots.WinningSymbolsController, "Game.Slots.WinningSymbolsController");
Sys.ns("Interface.utils");
Interface.utils.CSSAnimation = {
	constructor: function(a) {
		Interface.utils.CSSAnimation.superclass.constructor.apply(this, arguments);
		this.init(a)
	},
	run: function(a, c) {
		var b = this;
		if (Sys.isDefined(c)) {
			b.setupEvent(a, "AnimationEnd", c)
		}
		a.style[b.animationType] = b.name + " " + b.duration + "ms " + b.delay + "ms";
		if (Sys.isDefined(b.timingFunction)) {
			a.style[b.animationType + "TimingFunction"] = b.timingFunction
		}
		if (Sys.isDefined(b.iterationCount)) {
			a.style[b.animationType + "IterationCount"] = b.iterationCount
		}
		if (Sys.isDefined(b.fillMode.mode)) {
			a.style[b.fillMode.type] = b.fillMode.mode
		}
	},
	removeAnimation: function(a) {
		a.style[this.animationType] = "none"
	},
	init: function(a) {
		var b = this;
		b.name = a.name;
		b.duration = a.duration;
		b.delay = Sys.isDefined(a.delay) ? a.delay : 0;
		b.timingFunction = a.timingFunction;
		b.iterationCount = a.iterationCount;
		b.fillMode = {
			type: Sys.utils.pollyFill("animationFillMode"),
			mode: a.fillMode
		};
		b.setupAnimation(a);
		b.animationType = Sys.utils.pollyFill("animation");
		b.prefixes = ["webkit", "moz", "MS", "o", ""]
	},
	setupAnimation: function(a) {
		var c = this,
			b = this.getRuleString(a);
		c.style = document.head.appendChild(document.createElement("style"));
		c.insertRule(b)
	},
	insertRule: function(a) {
		if (CSSRule.WEBKIT_KEYFRAMES_RULE) {
			this.style.sheet.insertRule("@-webkit-keyframes" + a, 0)
		} else {
			if (CSSRule.KEYFRAMES_RULE) {
				this.style.sheet.insertRule("@keyframes" + a, 0)
			}
		}
	},
	removeRule: function(a) {
		this.style.sheet.deleteRule(a)
	},
	getRuleString: function(a) {
		var g = Object.keys(a.frames),
			b = g.length,
			d = 0,
			f = " " + a.name + " {",
			k, l, h, e, c;
		while (d < b) {
			k = g[d];
			f += " " + k;
			l = Object.keys(a.frames[k]);
			e = l.length;
			c = 0;
			f += " {";
			while (c < e) {
				h = l[c];
				f += h + " : " + a.frames[k][h] + ";";
				++c
			}
			f += " }";
			++d
		}
		f += " }";
		return f
	},
	setupEvent: function(c, d, g) {
		var e = this,
			f = e.prefixes,
			b, a;
		for (b = -1, a = f.length; ++b < a;) {
			if (!f[b]) {
				d = d.toLowerCase()
			}
			c.addEventListener(f[b] + d, g, false)
		}
	},
	removeEvent: function(c, d, g) {
		var e = this,
			f = e.prefixes,
			b, a;
		for (b = -1, a = f.length; ++b < a;) {
			if (!f[b]) {
				d = d.toLowerCase()
			}
			c.removeEventListener(f[b] + d, g, false)
		}
	}
};
Interface.utils.CSSAnimation = Sys.extend(Sys.Observable, Interface.utils.CSSAnimation, "Interface.utils.CSSAnimation");
Sys.ns("Interface.utils");
Interface.utils.CardNavigation = {
	CSS: {
		ARROWS: "interface-cardNavigation_arrows clearfix trim",
		ARROWS_PREVIOUS: "interface-cardNavigation_arrows_previous",
		ARROWS_CLOSE: "interface-cardNavigation_arrows_close",
		ARROWS_NEXT: "interface-cardNavigation_arrows_next",
		INDICATORS: "interface-cardNavigation_indicators clearfix utils_horizontal_center trim",
		INDICATORS_CHILD: "interface-cardNavigation_indicator",
		INDICATORS_SELECTED: "interface-cardNavigation_selectedIndicator",
		DISABLED: "interface-cardNavigation_disabled"
	},
	constructor: function(a) {
		this.currentCard = 0;
		Interface.utils.CardNavigation.superclass.constructor.apply(this, arguments)
	},
	getArrows: function() {
		return this.arrowContainer
	},
	getIndicators: function() {
		return this.indicatorContainer
	},
	getContainer: function(a) {
		if (a === "arrows") {
			return this.getArrows()
		} else {
			if (a === "indicators") {
				return this.getIndicators()
			}
		}
		return undefined
	},
	getCurrentCardIndex: function() {
		return this.currentCard
	},
	next: function() {
		var c = this,
			a = c.currentCard + 1,
			b = false;
		if (a >= c.numCards) {
			a = 0;
			b = true
		}
		c.selectCard(a, false, b)
	},
	previous: function() {
		var c = this,
			a = c.currentCard - 1,
			b = false;
		if (a < 0) {
			a = c.numCards - 1;
			b = true
		}
		c.selectCard(a, false, b)
	},
	selectCard: function(b, e, a) {
		var d = this,
			c = d.indicatorChildren;
		if (b >= 0 && b < d.numCards) {
			c[d.currentCard].removeCls(d.CSS.INDICATORS_SELECTED);
			c[b].addCls(d.CSS.INDICATORS_SELECTED);
			if (e !== true) {
				d.selectionCallback(b, d.currentCard, a)
			}
			d.currentCard = b
		}
	},
	enable: function() {
		var a = this;
		a.enabled = true;
		a.arrowContainer.removeCls(a.CSS.DISABLED);
		a.indicatorContainer.removeCls(a.CSS.DISABLED);
		a.performActionOnSubComponent("enable")
	},
	disable: function() {
		var a = this;
		a.enabled = false;
		a.arrowContainer.removeCls(a.CSS.DISABLED);
		a.indicatorContainer.removeCls(a.CSS.DISABLED);
		a.performActionOnSubComponent("disable")
	},
	close: function() {
		if (this.hasCloseButton) {
			this.closeCallback()
		}
	},
	performActionOnSubComponent: function(d) {
		var c = this.subComponents,
			a = c.length,
			b;
		for (b = -1; ++b < a;) {
			c[b][d]()
		}
	},
	setupContainer: function(b) {
		var c = this,
			a = Sys.isDefined(b.selectedCard) ? b.selectedCard : 0;
		c.numCards = b.numCards;
		c.selectionCallback = b.selectionCallback;
		c.closeCallback = b.closeCallback;
		c.hasCloseButton = Sys.isDefined(b.closeCallback);
		c.subComponents = [];
		c.setupArrows(b.arrowLabels);
		c.setupIndicators();
		c.selectCard(a, true)
	},
	setupArrows: function(c) {
		var b = this,
			a = Sys.isObj(c);
		b.arrowContainer = new Sys.Element({
			id: b.id + "_arrows",
			tag: "ul",
			cls: b.CSS.ARROWS
		});
		b.previousArrow = new Interface.utils.DOMButton({
			id: "paytablePrevious",
			tag: "li",
			baseCSS: b.CSS.ARROWS_PREVIOUS,
			textContent: (a && Sys.isDefined(c.previous)) ? c.previous : "",
			clickCallback: b.previous.bind(b)
		});
		b.arrowContainer.add(b.previousArrow.getContainer());
		b.subComponents.push(b.previousArrow);
		if (b.hasCloseButton) {
			b.closeArrow = new Interface.utils.DOMButton({
				id: "paytableClose",
				tag: "li",
				baseCSS: b.CSS.ARROWS_CLOSE,
				textContent: (a && Sys.isDefined(c.close)) ? c.close : "",
				clickCallback: b.close.bind(b)
			});
			b.arrowContainer.add(b.closeArrow.getContainer());
			b.subComponents.push(b.closeArrow)
		}
		b.nextArrow = new Interface.utils.DOMButton({
			id: "paytableNext",
			tag: "li",
			baseCSS: b.CSS.ARROWS_NEXT,
			textContent: (a && Sys.isDefined(c.next)) ? c.next : "",
			clickCallback: b.next.bind(b)
		});
		b.arrowContainer.add(b.nextArrow.getContainer());
		b.subComponents.push(b.nextArrow)
	},
	setupIndicators: function() {
		var c = this,
			d = new Sys.Element({
				id: c.id + "indicators",
				tag: "ul",
				cls: c.CSS.INDICATORS
			}),
			b = [],
			e, a;
		for (a = -1; ++a < c.numCards;) {
			e = new Interface.utils.DOMButton({
				id: "paytableIndicator_" + a,
				tag: "li",
				baseCSS: c.CSS.INDICATORS_CHILD,
				clickCallback: c.selectCard.bind(c, a)
			});
			b.push(d.add(e.getContainer()));
			c.subComponents.push(e)
		}
		c.indicatorContainer = d;
		c.indicatorChildren = b
	}
};
Interface.utils.CardNavigation = Sys.extend(Interface.utils.UserInputBase, Interface.utils.CardNavigation, "Interface.utils.CardNavigation");
Sys.ns("Interface.utils");
Interface.utils.ToggleSwitch = {
	CSS: {
		base: "interface-toggleSwitch_base",
		disabled: "interface-toggleSwitch_disabled",
		label: "interface-toggleSwitch_label",
		button_wrapper: "interface-toggleSwitch_buttonWrapper",
		button_background: "interface-toggleSwitch_buttonBackground interface-toggleSwitch_buttonBackgroundSize",
		button_handle: "interface-toggleSwitch_buttonHandle interface-toggleSwitch_buttonHandleSize",
		loadAnimation: "interface-toggleSwitch_loadAnimation interface-smallSpinner_uri hidden"
	},
	constructor: function(a) {
		Interface.utils.ToggleSwitch.superclass.constructor.apply(this, arguments)
	},
	init: function(b) {
		var c = this,
			a = b.CSS || {};
		b.cls = Sys.isString(b.cls) ? b.cls : "";
		if (Sys.isDefined(a)) {
			c.CSS = Sys.applyIf(a, c.CSS)
		}
		c.title = b.title;
		c.callback = b.callback;
		c.turnedOn = false;
		Interface.utils.ToggleSwitch.superclass.init.apply(c, arguments)
	},
	setupContainer: function(a) {
		var b = this;
		b.container = new Sys.Element({
			id: b.id,
			tag: "div",
			cls: a.cls + " " + b.CSS.base + " off"
		});
		if (b.title) {
			b.label = b.container.add(new Sys.Element({
				id: b.id + "_title",
				tag: "div",
				cls: b.CSS.label,
				textContent: b.title
			}))
		}
		b.buttonWrapper = b.container.add(new Sys.Element({
			id: b.id + "_button_wrapper",
			tag: "div",
			cls: b.CSS.button_wrapper
		}));
		b.background = b.buttonWrapper.add(new Sys.Element({
			id: b.id + "_button_background",
			tag: "div",
			cls: b.CSS.button_background
		}));
		b.handle = b.background.add(new Sys.Element({
			id: b.id + "_button_handle",
			tag: "div",
			cls: b.CSS.button_handle
		}));
		b.loadAnimation = b.container.add(new Sys.Element({
			id: b.id + "_loadAnimation",
			tag: "div",
			cls: b.CSS.loadAnimation
		}))
	},
	setCSS: function(e) {
		var d = this,
			b = d.container,
			c = d.button,
			a = d.CSS;
		if (e.base) {
			b.replaceCSSClass(a.base, e.base)
		}
		if (!d.enabled && e.disabled) {
			b.replaceCSSClass(a.disabled, e.disabled)
		}
		if (e.label) {
			d.label.replaceCSSClass(a.label, e.label)
		}
		if (e.button_wrapper) {
			c.replaceCSSClass(a.button_wrapper, e.button_wrapper)
		}
		if (e.button_background) {
			c.replaceCSSClass(a.button_background, e.button_background)
		}
		if (e.button_handle) {
			c.replaceCSSClass(a.button_handle, e.button_handle)
		}
		d.CSS = Sys.applyIf(e, a)
	},
	toggle: function(e, d) {
		var b = this,
			a = b.turnedOn,
			c = Sys.isDefined(e) ? e : !a;
		if (b.isLocked()) {
			return
		}
		if (c !== a) {
			if (c) {
				b.container.replaceCSSClass("off", "on")
			} else {
				b.container.replaceCSSClass("on", "off")
			}
			b.turnedOn = c;
			if (!d) {
				b.callback(c)
			}
		}
	},
	isOn: function() {
		return this.turnedOn
	},
	onUserInputStart: function(a) {
		this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.buttonWrapper.el, a) && this.enabled
	},
	onUserInputEnd: function(c) {
		var b = this,
			a = Sys.UserInputUtils.isCoordinateTarget(b.buttonWrapper.el, c);
		if (a && b.wasInitialInputTarget) {
			b.toggle()
		}
		b.wasInitialInputTarget = false
	},
	startListeningToUserInput: function() {
		var a = this;
		a.on({
			"notify:userInputManager.userInputStarted": a.onUserInputStart,
			"notify:userInputManager.userInputEnded": a.onUserInputEnd
		})
	},
	stopListeningToUserInput: function() {
		this.removeListener("notify:userInputManager.userInputStarted");
		this.removeListener("notify:userInputManager.userInputEnded")
	},
	displayLoadAnimation: function() {
		this.loadAnimation.removeCls("hidden");
		this.buttonWrapper.addCls("hidden")
	},
	hideLoadAnimation: function() {
		this.loadAnimation.addCls("hidden");
		this.buttonWrapper.removeCls("hidden")
	},
	setValue: function(b, a) {
		this.toggle(b, a)
	}
};
Interface.utils.ToggleSwitch = Sys.extend(Interface.utils.UserInputBase, Interface.utils.ToggleSwitch, "Interface.utils.ToggleSwitch");
Sys.ns("Interface.utils");
Interface.utils.Slider = {
	CSS: {
		base: "interface-slider_base",
		disabled: "interface-slider_disabled",
		label: "interface-slider_label",
		sliderWrapper: "interface-slider_sliderWrapper",
		background: "interface-slider_background",
		handle: "utils_center interface-slider_handle",
		fill: "interface-slider_fill",
		display: "utils_center interface-slider_display",
		verticalLine: "utils_center interface-slider_verticalLine"
	},
	constructor: function() {
		Interface.utils.Slider.superclass.constructor.apply(this, arguments)
	},
	init: function(b) {
		var d = this,
			a, c;
		if (Sys.isArray(b.values)) {
			a = b.values
		} else {
			a = [];
			for (c = b.minValue; c <= b.maxValue; c = Animation.utils.toNthDecimalPlace(c + b.valueStep, 5)) {
				a.push(c)
			}
		}
		if (!Sys.isDefined(b.useStepIndicator)) {
			b.useStepIndicator = true
		}
		d.callback = b.callback;
		d.values = a;
		d.callbackOnlyOnEndEvent = (b.callbackOnlyOnEndEvent === true);
		d.endCallback = Sys.isFunc(b.endCallback) ? b.endCallback : function() {};
		Interface.utils.Slider.superclass.init.apply(d, arguments);
		d.setStartValue(b);
		d.selectRenderFunction();
		d.transform = Sys.utils.pollyFill("transform")
	},
	setStartValue: function(c) {
		var b = c.startValue,
			a = this.values,
			d = (Sys.isDefined(b) && a.indexOf(b) !== -1) ? b : a[0];
		this.setValue(d, true)
	},
	setupContainer: function(a) {
		var b = this,
			c;
		b.container = new Sys.Element({
			id: b.id,
			tag: "div",
			cls: b.CSS.base,
			"data-input": true
		});
		b.sliderWrapper = b.container.add(new Sys.Element({
			id: b.id + "Slider",
			tag: "div",
			cls: b.CSS.sliderWrapper
		}));
		b.background = b.sliderWrapper.add(new Sys.Element({
			id: b.id + "SliderBackground",
			tag: "div",
			cls: b.CSS.background
		}));
		b.fill = b.background.add(new Sys.Element({
			id: b.id + "Fill",
			tag: "div",
			cls: b.CSS.fill
		}));
		if (a.showLabels) {
			c = b.values[0].toString();
			b.minimumLabel = b.container.addAsFirst(new Sys.Element({
				id: b.id + "Minimum",
				tag: "div",
				cls: b.CSS.label + " " + b.CSS.label + "_left",
				textContent: c
			}));
			c = b.values[b.values.length - 1].toString();
			b.maximumLabel = b.container.add(new Sys.Element({
				id: b.id + "Maximum",
				tag: "div",
				cls: b.CSS.label + " " + b.CSS.label + "_right",
				textContent: c
			}))
		}
		b.handle = b.sliderWrapper.add(new Sys.Element({
			id: b.id + "Handle",
			tag: "div",
			cls: b.CSS.handle
		}));
		if (a.showDisplay !== false) {
			b.display = b.sliderWrapper.add(new Sys.Element({
				id: b.id + "Display",
				tag: "div",
				cls: b.CSS.display
			}));
			b.showDisplay = true
		}
	},
	onUserInputStart: function(a) {
		var c = this,
			b = Sys.UserInputUtils.isCoordinateTarget(c.container.el, a) && c.enabled;
		c.startValue = c.value;
		if (b) {
			c.moveSliderToCoordinate(a, c.callbackOnlyOnEndEvent)
		}
		this.wasInitialInputTarget = b
	},
	onUserInputMove: function(a) {
		var b = this;
		if (this.wasInitialInputTarget) {
			if (!b.bigDisplayShowing) {
				if (b.showDisplay) {
					b.display.addCls("interface-slider_bigDisplay")
				}
				b.bigDisplayShowing = true
			}
			this.animationFunction.call(window, function() {
				b.moveSliderToCoordinate(a, b.callbackOnlyOnEndEvent)
			})
		}
	},
	onUserInputEnd: function() {
		var b = this,
			a;
		if (b.wasInitialInputTarget) {
			b.animationFunction(function() {
				a = b.calculatePercentageFromValue(b.value);
				b.moveSlider(a, false, true);
				if (b.showDisplay) {
					b.display.removeCls("interface-slider_bigDisplay")
				}
				if (b.bigDisplayShowing) {
					b.bigDisplayShowing = false
				}
			});
			b.endCallback(b.value)
		}
		b.wasInitialInputTarget = false
	},
	moveSliderToCoordinate: function(b, c) {
		var a = this.calculatePercentageFromCoordinate(b);
		this.moveSlider(a, c)
	},
	calculatePercentageFromCoordinate: function(c) {
		var a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, this.sliderWrapper.el).x,
			d = this.sliderWrapper.el.offsetWidth,
			b;
		if (a < 0) {
			b = 0
		} else {
			if (a > d) {
				b = 1
			} else {
				b = a / d
			}
		}
		return b
	},
	moveSlider: function(c, g, f) {
		var d = this,
			a = Animation.utils.toNthDecimalPlace((c * 100), 2) + "%",
			e = d.getValueFromPercentage(c),
			b = d.value;
		d.fill.el.style.width = a;
		d.handle.el.style.marginLeft = a;
		if (d.showDisplay) {
			d.display.el.style.marginLeft = a
		}
		if (e !== b || f) {
			d.setValue(e, g)
		}
	},
	getValueFromPercentage: function(a) {
		var b = this.values,
			c = Math.round(a * (b.length - 1));
		return b[c]
	},
	setValue: function(b, c) {
		var a = this;
		a.value = b;
		if (a.showDisplay) {
			a.display.el.textContent = b
		}
		if (!a.wasInitialInputTarget) {
			a.moveSlider(a.calculatePercentageFromValue(b), c)
		}
		if (!c) {
			a.callback(b)
		}
	},
	calculatePercentageFromValue: function(d) {
		var b = this.values,
			c = b.indexOf(d),
			a = 1 / (b.length - 1);
		return c * a
	},
	getValue: function() {
		return this.value
	},
	selectRenderFunction: function() {
		var a = this;
		a.animationFunction = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(b) {
			clearTimeout(a.renderTimeout);
			a.renderTimeout = setTimeout(b, Math.round(1000 / 60))
		}).bind(window)
	}
};
Interface.utils.Slider = Sys.extend(Interface.utils.UserInputBase, Interface.utils.Slider, "Interface.utils.Slider");
Sys.ns("Interface.utils");
Interface.utils.VerticalSlider = {
	CSS: {
		base: "interface-verticalSlider_base",
		disabled: "interface-slider_disabled",
		label: "interface-slider_label",
		sliderWrapper: "interface-verticalSlider_sliderWrapper",
		background: "interface-verticalSlider_background interface-soundSettings_sliderBar_background_uri",
		handle: "interface-verticalSlider_handle interface-soundSettings_sliderHandle_uri",
		fill: "interface-verticalSlider_fill interface interface-soundSettings_sliderBar_fill_uri",
		display: "utils_center interface-verticalSlider_display",
		verticalLine: "utils_center interface-slider_verticalLine"
	},
	ASCENDING_GROWTH: false,
	constructor: function() {
		Interface.utils.VerticalSlider.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var c = this,
			b = (a.ascendingGrowth === true);
		c.ASCENDING_GROWTH = b;
		Interface.utils.VerticalSlider.superclass.init.apply(this, arguments);
		if (b) {
			c.fill.el.style.top = "auto";
			c.fill.el.style.bottom = 0
		}
	},
	calculatePercentageFromCoordinate: function(c) {
		var d = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, this.sliderWrapper.el).y,
			a = this.sliderWrapper.el.offsetHeight,
			b;
		if (d < 0) {
			b = 0
		} else {
			if (d > a) {
				b = 1
			} else {
				b = d / a
			}
		}
		if (this.ASCENDING_GROWTH) {
			b = 1 - b
		}
		return b
	},
	moveSlider: function(c, g, f) {
		var d = this,
			a = Animation.utils.toNthDecimalPlace((c * 100), 2) + "%",
			e = d.getValueFromPercentage(c),
			b = d.value;
		d.fill.el.style.height = a;
		a = Animation.utils.toNthDecimalPlace(((d.ASCENDING_GROWTH ? 1 - c : c) * 100), 2) + "%";
		d.handle.el.style.top = a;
		if (e !== b || f) {
			d.setValue(e, g)
		}
	}
};
Interface.utils.VerticalSlider = Sys.extend(Interface.utils.Slider, Interface.utils.VerticalSlider, "Interface.utils.VerticalSlider");
Sys.ns("Interface.utils");
Interface.utils.CanvasValueSelector = {
	FONT_LABEL: "10px Verdana",
	FILLSTYLE_LABEL: "rgba( 238, 239, 206, 1 )",
	POSITION_OFFSET_LABEL: {
		x: 0,
		y: -18
	},
	FONT_VALUE: "bold 12px Verdana",
	FILLSTYLE_VALUE: "rgba( 238, 239, 206, 1 )",
	POSITION_OFFSET_VALUE: {
		x: 0,
		y: 9
	},
	IMAGE_RIGHT_UP: "selectorPlusUp",
	IMAGE_RIGHT_OVER: "selectorPlusUp",
	IMAGE_RIGHT_CLICK: "selectorPlusUp",
	IMAGE_RIGHT_DISABLED: "selectorPlusDisabled",
	IMAGE_RIGHT_DOWN: "selectorPlusDown",
	IMAGE_RIGHT_HOVER: "selectorPlusOver",
	IMAGE_LEFT_UP: "selectorMinusUp",
	IMAGE_LEFT_OVER: "selectorMinusUp",
	IMAGE_LEFT_CLICK: "selectorMinusUp",
	IMAGE_LEFT_DISABLED: "selectorMinusDisabled",
	IMAGE_LEFT_DOWN: "selectorMinusDown",
	IMAGE_LEFT_HOVER: "selectorMinusOver",
	HANDLE_DIMENSIONS: {
		LEFT: {
			width: 44,
			height: 52
		},
		RIGHT: {
			width: 44,
			height: 52
		}
	},
	HANDLE_POSITION_OFFSET: {
		LEFT: {
			x: 0,
			y: 0
		},
		RIGHT: {
			x: 88,
			y: 0
		}
	},
	HANDLE_COLLISION_BOX: {
		LEFT: {
			xOffset: 0,
			yOffset: 0,
			width: 44,
			height: 52
		},
		RIGHT: {
			xOffset: 0,
			yOffset: 0,
			width: 44,
			height: 52
		}
	},
	BAR_BACKGROUND: "selectorBarBackground",
	BAR_BACKGROUND_DISABLED: "selectorBarBackgroundDisabled",
	BAR_FILL: "selectorBarFill",
	BAR_FILL_DISABLED: "selectorBarFillDisabled",
	BAR_DIMENSIONS: {
		background: {
			width: 57,
			height: 7
		},
		fill: {
			width: 53,
			height: 3
		}
	},
	BAR_POSITION_OFFSET: {
		background: {
			x: 37,
			y: 36
		},
		fill: {
			x: 39,
			y: 38
		}
	},
	SLIDER_BAR_INPUT_OFFSET: {
		start: {
			width: 0,
			height: 0
		},
		move: {
			width: 0,
			height: 0
		}
	},
	constructor: function() {
		Interface.utils.CanvasValueSelector.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var b = this;
		Interface.utils.CanvasValueSelector.superclass.init.call(b, a);
		b.currentIndex = 0;
		b.callback = a.callback;
		b.label = a.label;
		b.valueArray = a.values;
		b.valueNameArray = Sys.isDefined(a.valueNames) ? a.valueNames : b.valueArray;
		b.basePosition = {
			x: a.x,
			y: a.y
		};
		b.setupConfiguration(a);
		b.setupLayering(a);
		b.setupFontStyle(a);
		b.initAnimations();
		if (a.disabled === true) {
			b.disable("CanvasValueSelector")
		} else {
			b.enable("CanvasValueSelector")
		}
	},
	setupConfiguration: function(a) {
		var c = this,
			b = {
				position: {
					offsetLabel: a.positionOffsetLabel || c.POSITION_OFFSET_LABEL,
					offsetValue: a.positionOffsetValue || c.POSITION_OFFSET_VALUE
				},
				rightButton: a.rightButtonImage || {},
				leftButton: a.leftButtonImage || {},
				handle: {
					positionOffset: a.handlePositionOffset || c.HANDLE_POSITION_OFFSET,
					dimensions: a.handleDimensions || c.HANDLE_DIMENSIONS,
					collisionBox: a.handleCollisionBox || c.HANDLE_COLLISION_BOX
				},
				bar: {
					background: a.barBackground || c.BAR_BACKGROUND,
					backgroundDisabled: a.barBackgroundDisabled || c.BAR_BACKGROUND_DISABLED,
					fill: a.barFill || c.BAR_FILL,
					fillDisabled: a.barFillDisabled || c.BAR_FILL_DISABLED,
					dimensions: a.barDimensions || c.BAR_DIMENSIONS,
					positionOffset: a.barPositionOffset || c.BAR_POSITION_OFFSET
				}
			};
		c.setupPositionConfig(b.position);
		c.setupRightButtonConfig(b.rightButton);
		c.setupLeftButtonConfig(b.leftButton);
		c.setupHandleConfig(b.handle);
		c.setupBarConfig(b.bar)
	},
	setupPositionConfig: function(a) {
		var b = this;
		b.POSITION_OFFSET_LABEL = a.offsetLabel || b.POSITION_OFFSET_LABEL;
		b.POSITION_OFFSET_VALUE = a.offsetValue || b.POSITION_OFFSET_VALUE
	},
	setupRightButtonConfig: function(a) {
		var b = this;
		if (a && !Sys.isEmpty(a)) {
			b.IMAGE_RIGHT_UP = a.up || b.IMAGE_RIGHT_UP;
			b.IMAGE_RIGHT_DOWN = a.down || b.IMAGE_RIGHT_DOWN;
			b.IMAGE_RIGHT_HOVER = a.hover || b.IMAGE_RIGHT_HOVER;
			b.IMAGE_RIGHT_DISABLED = a.disabled || b.IMAGE_RIGHT_DISABLED
		}
	},
	setupLeftButtonConfig: function(a) {
		var b = this;
		if (a && !Sys.isEmpty(a)) {
			b.IMAGE_LEFT_UP = a.up || b.IMAGE_LEFT_UP;
			b.IMAGE_LEFT_DOWN = a.down || b.IMAGE_LEFT_DOWN;
			b.IMAGE_LEFT_HOVER = a.hover || b.IMAGE_LEFT_HOVER;
			b.IMAGE_LEFT_DISABLED = a.disabled || b.IMAGE_LEFT_DISABLED
		}
	},
	setupHandleConfig: function(a) {
		var b = this;
		b.HANDLE_POSITION_OFFSET = a.positionOffset || b.HANDLE_POSITION_OFFSET;
		b.HANDLE_DIMENSIONS = a.dimensions || b.HANDLE_DIMENSIONS;
		b.HANDLE_COLLISION_BOX = a.collisionBox || b.HANDLE_COLLISION_BOX
	},
	setupBarConfig: function(a) {
		var b = this;
		b.BAR_BACKGROUND = a.background || b.BAR_BACKGROUND;
		b.BAR_BACKGROUND_DISABLED = a.backgroundDisabled || b.BAR_BACKGROUND_DISABLED;
		b.BAR_FILL = a.fill || b.BAR_FILL;
		b.BAR_FILL_DISABLED = a.fillDisabled || b.BAR_FILL_DISABLED;
		b.BAR_DIMENSIONS = a.dimensions || b.BAR_DIMENSIONS;
		b.BAR_POSITION_OFFSET = a.positionOffset || b.BAR_POSITION_OFFSET
	},
	setupLayering: function(a) {
		var b = a.depth;
		this.layeringConfig = {
			background: b,
			barBackground: b + 1,
			value: b + 2,
			barFrame: b + 3,
			barFill: b + 4,
			buttons: b + 4,
			label: b + 4
		}
	},
	setupFontStyle: function(a) {
		var b = this;
		b.FILLSTYLE_LABEL = a.fillstyleLabel || b.FILLSTYLE_LABEL;
		b.FILLSTYLE_VALUE = a.fillstyleValue || b.FILLSTYLE_VALUE;
		b.FONT_LABEL = a.fontLabel || b.FONT_LABEL;
		b.FONT_VALUE = a.fontValue || b.FONT_VALUE
	},
	initAnimations: function() {
		var a = this;
		a.initAnimationLists();
		a.initCanvasButtons(a.HANDLE_POSITION_OFFSET, a.HANDLE_DIMENSIONS, a.HANDLE_COLLISION_BOX);
		a.initBar();
		a.initValueItem();
		a.initLabelItem()
	},
	initAnimationLists: function() {
		var e = ["VALUE", "BAR", "LABEL"],
			b = {},
			c, a, d;
		for (c = -1, a = e.length; ++c < a;) {
			d = new Animation.List({});
			b[e[c]] = d;
			Game.stage.view.addToRenderLoop(d)
		}
		this.animationLists = b
	},
	initCanvasButtons: function(a, c, b) {
		var d = this;
		d.buttons = {
			LEFT: d.createCanvasButton(a.LEFT, c.LEFT, b.LEFT, "LEFT"),
			RIGHT: d.createCanvasButton(a.RIGHT, c.RIGHT, b.RIGHT, "RIGHT")
		}
	},
	initBar: function() {
		var a = this;
		a.bar = new Interface.utils.CanvasStepSlider({
			images: {
				background: {
					enabled: a.BAR_BACKGROUND,
					disabled: a.BAR_BACKGROUND_DISABLED
				},
				fill: {
					enabled: a.BAR_FILL,
					disabled: a.BAR_FILL_DISABLED
				}
			},
			dimensions: {
				background: {
					x: a.basePosition.x + a.BAR_POSITION_OFFSET.background.x,
					y: a.basePosition.y + a.BAR_POSITION_OFFSET.background.y,
					width: a.BAR_DIMENSIONS.background.width,
					height: a.BAR_DIMENSIONS.background.height
				},
				fill: {
					x: a.basePosition.x + a.BAR_POSITION_OFFSET.fill.x,
					y: a.basePosition.y + a.BAR_POSITION_OFFSET.fill.y,
					width: a.BAR_DIMENSIONS.fill.width,
					height: a.BAR_DIMENSIONS.fill.height
				}
			},
			depth: {
				background: a.layeringConfig.barBackground,
				fill: a.layeringConfig.barFill
			},
			sliderInputOffsets: a.SLIDER_BAR_INPUT_OFFSET,
			values: a.valueArray,
			callback: a.onBarChanged.bind(a)
		});
		a.animationLists.BAR.add(a.bar.getContainer());
		a.updateBar()
	},
	initValueItem: function() {
		var a = this,
			b = Animation.utils.text.createText(0, a.FONT_VALUE, 0, [{
				fillStyle: a.FILLSTYLE_VALUE,
				drawType: "fill"
			}]);
		a.valueItem = new Animation.Item({
			top: 0,
			left: 0,
			width: 0,
			height: 0,
			depth: a.layeringConfig.value,
			image: b,
			customProps: {
				ctx: b.getContext("2d")
			}
		});
		a.animationLists.VALUE.add(a.valueItem);
		a.updateValueItem(a.valueArray[a.currentIndex])
	},
	initLabelItem: function() {
		var a = this,
			f = Animation.utils.text.createText(a.label, a.FONT_LABEL, 0, [{
				fillStyle: a.FILLSTYLE_LABEL,
				drawType: "fill"
			}]),
			e = a.HANDLE_DIMENSIONS.RIGHT.width + a.HANDLE_POSITION_OFFSET.RIGHT.x,
			d = a.POSITION_OFFSET_LABEL,
			c = ((a.basePosition.x + (e / 2)) - (f.width / 2)) + d.x,
			b = a.basePosition.y + d.y;
		a.labelItem = new Animation.Item({
			top: b,
			left: c,
			width: f.width,
			height: f.height,
			depth: a.layeringConfig.label,
			image: f
		});
		a.animationLists.LABEL.add(a.labelItem)
	},
	createCanvasButton: function(a, d, b, c) {
		var e = this;
		return new Interface.utils.CanvasButton({
			buttonLayoutParameters: {
				x: e.basePosition.x + a.x,
				y: e.basePosition.y + a.y,
				width: d.width,
				height: d.height,
				depth: e.layeringConfig.buttons
			},
			dimensions: {
				x: e.basePosition.x + a.x + b.xOffset,
				y: e.basePosition.y + a.y + b.yOffset,
				width: b.width,
				height: b.height
			},
			buttonImages: {
				up: e["IMAGE_" + c + "_UP"],
				down: e["IMAGE_" + c + "_DOWN"],
				hover: e["IMAGE_" + c + "_HOVER"],
				disabled: e["IMAGE_" + c + "_DISABLED"]
			},
			clickCallback: e.click.bind(e, c)
		})
	},
	click: function(a) {
		var b = this,
			c = b.getValue(a);
		if (this.enabled) {
			b.updateValueItem(c);
			b.callback(c)
		}
	},
	getValue: function(a) {
		var b = this;
		b.currentIndex = (a === "LEFT") ? b.currentIndex -= 1 : b.currentIndex += 1;
		if (b.currentIndex < 0) {
			b.currentIndex = 0
		} else {
			if (b.currentIndex > b.valueArray.length - 1) {
				b.currentIndex = b.valueArray.length - 1
			}
		}
		return b.valueArray[b.currentIndex]
	},
	updateValueItem: function(e) {
		var b = this,
			h = b.valueItem.prop,
			a = h.customProps.ctx,
			d = b.valueNameArray[b.valueArray.indexOf(e)],
			c = Animation.utils.text.measureText(d, b.FONT_VALUE, 0, a),
			g = b.HANDLE_DIMENSIONS.RIGHT.width + b.HANDLE_POSITION_OFFSET.RIGHT.x,
			f = b.POSITION_OFFSET_VALUE;
		h.image.width = c.width;
		h.image.height = c.height;
		h.width = c.width;
		h.height = c.height;
		h.top = b.basePosition.y + f.y;
		h.left = ((b.basePosition.x + (g / 2)) - (h.image.width / 2)) + f.x;
		a.clearRect(0, 0, h.width, h.height);
		Animation.utils.text.performOperations(d, b.FONT_VALUE, 0, c.height / 2, [{
			fillStyle: b.FILLSTYLE_VALUE,
			drawType: "fill"
		}], a)
	},
	updateBar: function() {
		var a = this;
		a.bar.setValue(a.valueArray[a.currentIndex], true)
	},
	onBarChanged: function(a) {
		this.update(a);
		this.callback(a)
	},
	enable: function(b) {
		var a = this;
		a.enabled = true;
		if (Sys.isDefined(this.animationLists) && Sys.isDefined(a.buttons)) {
			a.enableLeftButton(b);
			a.enableRightButton(b);
			a.bar.enable(b)
		}
	},
	disable: function(b) {
		var a = this;
		if (Sys.isDefined(a.animationLists) && Sys.isDefined(a.buttons)) {
			a.bar.disable(b);
			a.disableLeftButton(b);
			a.disableRightButton(b);
			a.enabled = false
		}
	},
	enableLeftButton: function(b) {
		var a = this;
		if (Sys.isDefined(a.buttons)) {
			a.buttons.LEFT.enable(b)
		}
	},
	disableLeftButton: function(b) {
		var a = this;
		if (Sys.isDefined(a.buttons)) {
			a.buttons.LEFT.disable(b)
		}
	},
	enableRightButton: function(b) {
		var a = this;
		if (Sys.isDefined(a.buttons)) {
			a.buttons.RIGHT.enable(b)
		}
	},
	disableRightButton: function(b) {
		var a = this;
		if (Sys.isDefined(a.buttons)) {
			a.buttons.RIGHT.disable(b)
		}
	},
	hide: function(b) {
		var a = this;
		Sys.iterate(a.animationLists, function(c, d) {
			d.stop()
		});
		a.buttons.LEFT.hide(b);
		a.buttons.RIGHT.hide(b)
	},
	show: function(b) {
		var a = this;
		Sys.iterate(a.animationLists, function(c, d) {
			d.play()
		});
		a.buttons.LEFT.show(b);
		a.buttons.RIGHT.show(b)
	},
	update: function(e) {
		var c = this,
			b = this.valueArray,
			a = b.indexOf(e),
			d = "CanvasValueSelector";
		if (a === 0) {
			c.disableLeftButton(d);
			c.enableRightButton(d)
		} else {
			if (a === b.length - 1) {
				c.disableRightButton(d);
				c.enableLeftButton(d)
			} else {
				c.enableLeftButton(d);
				c.enableRightButton(d)
			}
		}
		if (Sys.isDefined(b[a])) {
			c.currentIndex = a;
			c.updateValueItem(b[a]);
			c.updateBar()
		}
	}
};
Interface.utils.CanvasValueSelector = Sys.extend(Interface.utils.UserInputBase, Interface.utils.CanvasValueSelector, "Interface.utils.CanvasValueSelector");
Sys.ns("Interface");
Interface.AbstractButton = {
	STATES: ["UP", "DOWN", "HOVER", "CLICK"],
	SOUND_UP: "buttonUp",
	SOUND_DOWN: "buttonDown",
	SOUND_CLICK: "buttonClick",
	SOUND_HOVER: "buttonHover",
	ID: "button",
	DEFAULT_USER_INPUT_EVENTS: {
		started: "notify:userInputManager.userInputStarted",
		ended: "notify:userInputManager.userInputEnded",
		move: "notify:userInputManager.userInputMove",
		hover: "notify:userInputManager.userInputHover"
	},
	constructor: function(a) {
		Interface.AbstractButton.superclass.constructor.apply(this, arguments);
		this.init(a)
	},
	enable: function(a) {
		this.removeProperty("disabled", a);
		this.tryStartListeningToUserInput()
	},
	disable: function(a) {
		this.addProperty("disabled", a);
		this.stopListeningToUserInput()
	},
	isEnabled: function() {
		return !this.hasProperty("disabled")
	},
	show: function(a) {
		this.removeProperty("hidden", a);
		this.tryStartListeningToUserInput()
	},
	hide: function(a) {
		this.addProperty("hidden", a);
		this.stopListeningToUserInput()
	},
	isHidden: function() {
		return !this.hasProperty("hidden")
	},
	init: function(a) {
		var b = this;
		b.dimensions = a.dimensions;
		b.properties = {};
		if (Sys.isDefined(a.id)) {
			b.ID = a.id
		}
		if (Sys.isDefined(a.upCallback)) {
			b.upCallback = a.upCallback
		} else {
			b.upCallback = function() {}
		}
		if (Sys.isDefined(a.downCallback)) {
			b.downCallback = a.downCallback
		} else {
			b.downCallback = function() {}
		}
		if (Sys.isDefined(a.overCallback)) {
			b.overCallback = a.overCallback
		} else {
			b.overCallback = function() {}
		}
		if (Sys.isDefined(a.clickCallback)) {
			b.clickCallback = a.clickCallback
		} else {
			b.clickCallback = function() {}
		}
		if (Sys.isDefined(a.hoverCallback)) {
			b.hoverCallback = a.hoverCallback
		} else {
			b.hoverCallback = function() {}
		}
		b.userInputEvents = b.DEFAULT_USER_INPUT_EVENTS;
		if (Sys.isDefined(a.exclusiveUserInput)) {
			b.userInputEvents = {
				started: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveStart",
				ended: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveEnd",
				move: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveMove",
				hover: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveKeyUp"
			}
		}
		if (Sys.isDefined(a.userInputEvents)) {
			Sys.iterate(a.userInputEvents, function(c, d) {
				b.userInputEvents[c] = d
			})
		}
		b.startListeningToUserInput();
		b.state = "up";
		if (Sys.isDefined(a.sounds)) {
			b.setupSounds(a.sounds)
		}
		if (Sys.isDefined(Services.trigger)) {
			b.registerTriggers()
		}
	},
	setupSounds: function(b) {
		var e = this,
			c = e.STATES,
			d, a, f;
		for (d = -1, a = c.length; ++d < a;) {
			f = c[d].toLowerCase();
			if (Sys.isDefined(b[f])) {
				e["SOUND_" + e[c[d]]] = b.state
			}
		}
	},
	registerTriggers: function() {
		var a = this.ID;
		Services.trigger.registerTrigger("notify:" + a + ".up", this, "When the button returns to the up state.");
		Services.trigger.registerTrigger("notify:" + a + ".hover", this, "When the button is hovered.");
		Services.trigger.registerTrigger("notify:" + a + ".over", this, "When the button hovered but wasn't the initial input target.");
		Services.trigger.registerTrigger("notify:" + a + ".down", this, "When the button is pressed down.");
		Services.trigger.registerTrigger("notify:" + a + ".click", this, "When the button is clicked.")
	},
	up: function() {
		var a = this;
		if (a.state !== "up") {
			a.state = "up";
			a.upCallback();
			a.fireEvent("request:audioPlayer.play", {
				name: a.SOUND_UP
			});
			a.fireEvent("notify:" + a.ID + ".up")
		}
	},
	click: function() {
		var a = this;
		a.clickCallback();
		a.fireEvent("request:audioPlayer.play", {
			name: a.SOUND_CLICK
		});
		a.fireEvent("notify:" + a.ID + ".click")
	},
	over: function() {
		var a = this;
		if (a.state !== "over") {
			a.overCallback();
			a.state = "over";
			a.fireEvent("notify:" + a.ID + ".over")
		}
	},
	down: function() {
		var a = this;
		if (a.state !== "down") {
			a.downCallback();
			a.state = "down";
			a.fireEvent("request:audioPlayer.play", {
				name: a.SOUND_DOWN
			});
			a.fireEvent("notify:" + a.ID + ".down")
		}
	},
	hover: function(a) {
		var b = this;
		if (b.state !== "hover") {
			b.hoverCallback();
			b.state = "hover";
			if (!a) {
				b.fireEvent("request:audioPlayer.play", {
					name: b.SOUND_HOVER
				})
			}
			b.fireEvent("notify:" + b.ID + ".hover", a)
		}
	},
	userInputStart: function(c) {
		var b = this,
			a = b.isInputTarget(c);
		if (a) {
			b.down()
		}
		b.active = a;
		b.wasInitialInputTarget = a
	},
	userInputHover: function(c) {
		var b = this,
			a = b.isInputTarget(c);
		if (a) {
			b.hover()
		} else {
			if (b.state !== "up") {
				b.up()
			}
		}
	},
	userInputEnd: function(b) {
		var a = this;
		if (a.isInputTarget(b) && a.wasInitialInputTarget) {
			a.wasInitialInputTarget = false;
			a.hover(true);
			a.click()
		} else {
			if (a.active) {
				a.up()
			}
		}
	},
	userInputMove: function(c) {
		var b = this,
			a = b.isInputTarget(c);
		if (a) {
			if (b.wasInitialInputTarget) {
				b.down()
			} else {
				b.over()
			}
			b.active = true
		} else {
			if (b.wasInitialInputTarget || b.active) {
				b.up()
			}
		}
	},
	tryStartListeningToUserInput: function() {
		if (!this.hasProperty("disabled") && !this.hasProperty("hidden")) {
			this.startListeningToUserInput()
		}
	},
	startListeningToUserInput: function() {
		var a = this;
		if (Sys.isDefined(a.userInputEvents.started)) {
			a.addListener(a.userInputEvents.started, a.userInputStart)
		}
		if (Sys.isDefined(a.userInputEvents.started)) {
			a.addListener(a.userInputEvents.ended, a.userInputEnd)
		}
		if (Sys.isDefined(a.userInputEvents.move)) {
			a.addListener(a.userInputEvents.move, a.userInputMove)
		}
		if (Sys.isDefined(a.userInputEvents.hover)) {
			a.addListener(a.userInputEvents.hover, a.userInputHover)
		}
	},
	stopListeningToUserInput: function() {
		var a = this;
		if (Sys.isDefined(a.userInputEvents.started)) {
			a.removeListener(a.userInputEvents.started)
		}
		if (Sys.isDefined(a.userInputEvents.ended)) {
			a.removeListener(a.userInputEvents.ended)
		}
		if (Sys.isDefined(a.userInputEvents.move)) {
			a.removeListener(a.userInputEvents.move)
		}
		if (Sys.isDefined(a.userInputEvents.hover)) {
			a.removeListener(a.userInputEvents.hover)
		}
	},
	isInputTarget: function(c) {
		var a = this,
			b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
		return a.isDOMElement(a.dimensions) ? Sys.UserInputUtils.isCoordinateTarget(a.dimensions, c) : Sys.UserInputUtils.isUserInputInSegment(b, a.dimensions)
	},
	isDOMElement: function(a) {
		return a.nodeType === 1
	},
	hasProperty: function(b) {
		var a = this.properties[b];
		return Sys.isDefined(a) && a.length > 0
	},
	addProperty: function(d, c) {
		var b = this.properties,
			a = false;
		if (!Sys.isDefined(b[d])) {
			b[d] = [c];
			a = true
		} else {
			if (!b[d].contains(c)) {
				a = b[d].length === 0;
				b[d].push(c)
			}
		}
		if (a) {
			this.update()
		}
	},
	removeProperty: function(c, b) {
		var a = this.properties[c];
		if (Sys.isDefined(a) && a.contains(b)) {
			a.splice(a.indexOf(b), 1);
			if (a.length === 0) {
				this.update()
			}
		}
	},
	update: function() {}
};
Interface.AbstractButton = Sys.extend(Sys.Observable, Interface.AbstractButton, "Interface.AbstractButton");
Sys.ns("Interface.utils");
Interface.utils.AbstractUserInputBase = {
	constructor: function(a) {
		Interface.utils.UserInputBase.superclass.constructor.apply(this, arguments);
		this.init(a)
	},
	enable: function() {
		this.enabled = true;
		this.startListeningToUserInput()
	},
	disable: function() {
		this.enabled = false;
		this.stopListeningToUserInput()
	},
	isEnabled: function() {
		return this.enabled
	},
	init: function(a) {
		var b = this;
		b.id = a.id;
		if (a.enabled) {
			b.enable()
		} else {
			b.disable()
		}
	},
	onUserInputStart: function() {},
	onUserInputEnd: function() {},
	startListeningToUserInput: function() {
		this.on({
			"notify:userInputManager.userInputStarted": this.onUserInputStart,
			"notify:userInputManager.userInputEnded": this.onUserInputEnd
		})
	},
	stopListeningToUserInput: function() {
		this.removeListener("notify:userInputManager.userInputStarted");
		this.removeListener("notify:userInputManager.userInputEnded")
	}
};
Interface.utils.AbstractUserInputBase = Sys.extend(Sys.Observable, Interface.utils.AbstractUserInputBase, "Interface.utils.AbstractUserInputBase");
Sys.ns("Interface.utils");
Interface.utils.AbstractSlider = {
	constructor: function(a) {
		var b = this;
		Interface.utils.AbstractControlList.superclass.constructor.apply(b, arguments);
		b.callback = a.callback;
		b.wasInitialInputTarget = false;
		b.properties = {};
		b.setUpContent(a)
	},
	setUpContent: function() {},
	enable: function(a) {
		this.removeProperty("disabled", a);
		this.tryStartListeningToUserInput()
	},
	disable: function(a) {
		this.addProperty("disabled", a);
		this.stopListeningToUserInput()
	},
	tryStartListeningToUserInput: function() {
		if (!this.hasProperty("disabled") && !this.hasProperty("hidden")) {
			this.startListeningToUserInput()
		}
	},
	startListeningToUserInput: function() {
		var a = this;
		a.on({
			"notify:userInputManager.userInputStarted": a.userInputStart,
			"notify:userInputManager.userInputEnded": a.userInputEnd,
			"notify:userInputManager.userInputMove": a.userInputMove
		})
	},
	stopListeningToUserInput: function() {
		var a = this;
		a.removeListener("notify:userInputManager.userInputStarted");
		a.removeListener("notify:userInputManager.userInputEnded");
		a.removeListener("notify:userInputManager.userInputMove")
	},
	hasProperty: function(b) {
		var a = this.properties[b];
		return Sys.isDefined(a) && a.length > 0
	},
	addProperty: function(d, c) {
		var b = this.properties,
			a = false;
		if (!Sys.isDefined(b[d])) {
			b[d] = [c];
			a = true
		} else {
			if (!b[d].contains(c)) {
				a = b[d].length === 0;
				b[d].push(c)
			}
		}
		if (a) {
			this.update()
		}
	},
	removeProperty: function(c, b) {
		var a = this.properties[c];
		if (Sys.isDefined(a) && a.contains(b)) {
			a.splice(a.indexOf(b), 1);
			if (a.length === 0) {
				this.update()
			}
		}
	},
	userInputMove: function(b) {
		var a = this;
		if (a.wasInitialInputTarget) {
			a.movedTo(b)
		}
	},
	userInputEnd: function(b) {
		var a = this;
		if (a.wasInitialInputTarget && a.isInputTarget(b)) {
			a.clickedAt(b)
		}
	},
	userInputStart: function(b) {
		var a = this;
		a.wasInitialInputTarget = a.isInputTarget(b)
	},
	update: function() {},
	setValue: function() {},
	clickedAt: function() {},
	movedTo: function() {},
	isInputTarget: function() {}
};
Interface.utils.AbstractSlider = Sys.extend(Sys.Observable, Interface.utils.AbstractSlider, "Interface.utils.AbstractSlider");
Sys.ns("Interface.utils");
Interface.utils.AbstractOptionScroller = {
	constructor: function() {
		Interface.utils.AbstractOptionScroller.superclass.constructor.apply(this, arguments)
	},
	onUserInputStart: function(a) {
		this.initialInputTarget = this.getInputTarget(a)
	},
	onUserInputEnd: function(d) {
		var b = this,
			a = b.getInputTarget(d),
			c = b.initialInputTarget;
		if (Sys.isDefined(c) && a === c) {
			b.scroll(a)
		} else {
			if (Sys.isObj(a) && Sys.isObj(c) && a.value === c.value) {
				b.callback(a)
			} else {
				b.initialInputTarget = undefined
			}
		}
	},
	init: function(a) {
		Interface.utils.AbstractOptionScroller.superclass.init.apply(this, arguments);
		this.callback = a.callback
	},
	getInputTarget: function(a) {},
	scroll: function(a) {}
};
Interface.utils.AbstractOptionScroller = Sys.extend(Interface.utils.AbstractUserInputBase, Interface.utils.AbstractOptionScroller, "Interface.utils.AbstractOptionScroller");
Sys.ns("Interface.utils");
Interface.utils.AbstractInputField = {
	constructor: function() {
		Interface.utils.AbstractInputField.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		Interface.utils.AbstractInputField.superclass.init.apply(this, arguments);
		this.callback = a.callback
	},
	onKeyUp: function(a) {
		var b = this,
			c;
		if (b.enabled && b.active) {
			c = b.getValue(a);
			b.setValue(c);
			b.callback(c)
		}
	},
	getValue: function(a) {},
	setValue: function(a) {}
};
Interface.utils.AbstractInputField = Sys.extend(Interface.utils.AbstractUserInputBase, Interface.utils.AbstractInputField, "Interface.utils.AbstractInputField");
Sys.ns("Interface.utils");
Interface.utils.AbstractControlList = {
	constructor: function(a) {
		var b = this;
		Interface.utils.AbstractControlList.superclass.constructor.apply(b, arguments);
		b.callback = a.callback;
		b.model = new Core.Model({
			name: a.id + "ControlListModel"
		});
		b.controls = {};
		b.setUpContent(a)
	},
	setUpContent: function(a) {},
	getContainer: function() {},
	getControl: function(a) {
		return this.controls[a]
	}
};
Interface.utils.AbstractControlList = Sys.extend(Sys.Observable, Interface.utils.AbstractControlList, "Interface.utils.AbstractControlList");
Sys.ns("Interface.utils");
Interface.utils.AbstractCheckBoxWithInput = {
	constructor: function(a) {
		var b = this;
		Interface.utils.AbstractCheckBoxWithInput.superclass.constructor.apply(b, arguments);
		b.callback = a.callback;
		b.model = new Core.Model({
			name: a.id + "CheckBoxWithInputModel"
		});
		b.setUpContent(a)
	},
	setUpContent: function() {},
	getContainer: function() {}
};
Interface.utils.AbstractCheckBoxWithInput = Sys.extend(Sys.Observable, Interface.utils.AbstractCheckBoxWithInput, "Interface.utils.AbstractCheckBoxWithInput");
Sys.ns("Interface.utils");
Interface.utils.CanvasButton = {
	constructor: function(a) {
		Interface.utils.CanvasButton.superclass.constructor.apply(this, arguments);
		this.setUpAnimations(a)
	},
	down: function() {
		Interface.utils.CanvasButton.superclass.down.apply(this, arguments);
		this.setActiveAnimation(this.downAnimation)
	},
	up: function() {
		Interface.utils.CanvasButton.superclass.up.apply(this, arguments);
		this.setActiveAnimation(this.upAnimation)
	},
	hover: function() {
		Interface.utils.CanvasButton.superclass.hover.apply(this, arguments);
		this.setActiveAnimation(this.hoverAnimation)
	},
	setActiveAnimation: function(a) {
		this.activeAnimation = a;
		this.update()
	},
	update: function() {
		var a = this;
		a.animationList.stop();
		if (!a.hasProperty("hidden")) {
			if (a.hasProperty("disabled")) {
				a.textLabelAnimation.prop.ownOpacity = 0.32;
				a.animationList.play(a.disabledAnimation)
			} else {
				a.textLabelAnimation.prop.ownOpacity = 1;
				a.animationList.play(a.activeAnimation)
			}
			a.animationList.play(a.textLabelAnimation)
		}
	},
	isInputTarget: function(c) {
		var a = this,
			b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
		return Sys.UserInputUtils.isUserInputInSegment(b, a.dimensions) && Sys.UserInputUtils.isCoordinateTarget(a.canvasElement, c)
	},
	init: function(a) {
		Interface.utils.CanvasButton.superclass.init.apply(this, arguments);
		this.canvasElement = (a.canvasElement) ? a.canvasElement : document.getElementById("canvasAnimationManager")
	},
	setUpAnimations: function(b) {
		var d = this,
			e = new Animation.List({}),
			g = b.buttonImages,
			f, c, a = b.buttonLabel;
		["up", "down", "hover", "disabled"].forEach(function(h) {
			f = d.verifyImage(g[h]);
			c = new Animation.Item(d.createBaseConfig(f, b.buttonLayoutParameters));
			d[h + "Animation"] = c;
			e.add(c)
		});
		if (Sys.isDefined(a)) {
			d.textLabelAnimation = d.createTextLabel(a)
		} else {
			d.textLabelAnimation = new Animation.Item({})
		}
		e.add(d.textLabelAnimation);
		e.stop();
		Game.stage.view.addToRenderLoop(e);
		d.animationList = e;
		d.setActiveAnimation(d.upAnimation)
	},
	verifyImage: function(a) {
		if (a.indexOf("#") === 0 || a.indexOf("rgba") === 0) {
			return this.createButtonImage(a)
		}
		return a
	},
	createTextLabel: function(j) {
		var g = this,
			f = j.text,
			c = j.offsetY || 0,
			e = j.offsetX || 0,
			k = 0,
			l = j.width,
			d = j.height,
			b = Animation.utils.getInMemoryCanvas(l, d),
			a = Services.languageManager.hasText(f) ? Services.languageManager.getText(f) : f;
		if (j.alignment === "center") {
			b.ctx.textAlign = j.alignment;
			k = l / 2
		}
		Animation.utils.text.wrapCanvasText(a, j.font, k, 0, l, j.lineHeight, [{
			fillStyle: j.color,
			drawType: "fill"
		}], b.ctx, true, j.breakOn);
		return new Animation.Item({
			width: l,
			height: d,
			left: g.dimensions.x + Math.round(Math.abs((l - g.dimensions.width) / 2)) + e,
			top: g.dimensions.y + Math.round(Math.abs((d - g.dimensions.height) / 2)) + c,
			depth: j.depth,
			image: b.canvas
		})
	},
	createBaseConfig: function(c, b) {
		var a = Sys.isDefined(b) ? b : this.dimensions;
		return {
			width: a.width,
			height: a.height,
			left: a.x,
			top: a.y,
			depth: a.depth,
			image: c
		}
	},
	createButtonImage: function(a) {
		var d = this,
			b = document.createElement("canvas"),
			c;
		b.width = d.dimensions.width;
		b.height = d.dimensions.height;
		c = b.getContext("2d");
		c.fillStyle = a;
		c.fillRect(0, 0, d.dimensions.width, d.dimensions.height);
		return b
	}
};
Interface.utils.CanvasButton = Sys.extend(Interface.AbstractButton, Interface.utils.CanvasButton, "Interface.utils.CanvasButton");
Sys.ns("Interface.utils");
Interface.utils.CanvasStepSlider = {
	DEFAULT_CANVAS_ELEMENT_ID: "canvasAnimationManager",
	constructor: function(a) {
		var b = this;
		b.canvasElement = Sys.isDefined(a.canvasElement) ? a.canvasElement : document.getElementById(b.DEFAULT_CANVAS_ELEMENT_ID);
		b.dimensions = a.dimensions;
		b.depth = a.depth;
		b.images = a.images;
		b.valueArray = a.values;
		b.sliderInputOffsets = a.sliderInputOffsets || {
			start: {
				width: 0,
				height: 0
			},
			move: {
				width: 0,
				height: 0
			},
			end: {
				width: 0,
				height: 0
			}
		};
		if (Sys.isDefined(a.collisionDimensions)) {
			b.collisionDimensions = a.collisionDimensions
		} else {
			b.collisionDimensions = a.dimensions.background
		}
		b.stepWidth = b.dimensions.fill.width / b.valueArray.length;
		b.currentIndex = 0;
		Interface.utils.CanvasStepSlider.superclass.constructor.apply(b, arguments)
	},
	setUpAnimations: function() {
		var a = this;
		a.animationList = new Animation.List({});
		a.backgroundAnimation = a.createItem(a.images.background.enabled, a.dimensions.background, a.depth.background);
		a.fillAnimation = a.createItem(a.images.fill.enabled, a.dimensions.fill, a.depth.fill);
		a.animationList.add(a.backgroundAnimation);
		a.animationList.add(a.fillAnimation);
		a.animationList.play();
		a.update()
	},
	getContainer: function() {
		return this.animationList
	},
	createItem: function(b, a, c) {
		return new Animation.CanvasAnimationItem({
			width: a.width,
			height: a.height,
			top: a.y,
			left: a.x,
			depth: c,
			image: b
		})
	},
	setUpContent: function(a) {
		this.setUpAnimations(a)
	},
	localCoordinates: function(a) {
		return Sys.UserInputUtils.getCoordinatesRelativeToElement(a, Game.stage.getGameContainer())
	},
	relativeCoordinates: function(c) {
		var a = this,
			b = a.localCoordinates(c);
		return {
			x: b.x - a.collisionDimensions.x,
			y: b.y - a.collisionDimensions.y
		}
	},
	isInputTarget: function(f, e) {
		var b = this,
			d = b.localCoordinates(f),
			a = e || {
				width: 0,
				height: 0
			},
			c = {
				x: b.collisionDimensions.x - a.width / 2,
				y: b.collisionDimensions.y - a.height / 2,
				width: b.collisionDimensions.width + a.width,
				height: b.collisionDimensions.height + a.height
			};
		return Sys.UserInputUtils.isUserInputInSegment(d, c) && Sys.UserInputUtils.isCoordinateTarget(b.canvasElement, f)
	},
	userInputStart: function(b) {
		var a = this;
		a.wasInitialInputTarget = a.isInputTarget(b, a.sliderInputOffsets.start);
		a.on({
			"notify:userInputManager.userInputMove": a.userInputMove
		})
	},
	userInputMove: function(b) {
		var a = this;
		if (a.wasInitialInputTarget) {
			if (a.isInputTarget(b, a.sliderInputOffsets.move)) {
				a.movedTo(b)
			} else {
				a.removeListener("notify:userInputManager.userInputMove")
			}
		}
	},
	userInputEnd: function(b) {
		var a = this;
		if (a.wasInitialInputTarget && a.isInputTarget(b, a.sliderInputOffsets.end)) {
			a.clickedAt(b)
		}
	},
	update: function() {
		var a = this;
		a.fillAnimation.prop.width = a.stepWidth + (a.stepWidth * a.currentIndex);
		if (!a.hasProperty("hidden")) {
			if (a.hasProperty("disabled")) {
				a.backgroundAnimation.prop.image = a.images.background.disabled;
				a.fillAnimation.prop.image = a.images.fill.disabled
			} else {
				a.backgroundAnimation.prop.image = a.images.background.enabled;
				a.fillAnimation.prop.image = a.images.fill.enabled
			}
		}
	},
	setValue: function(d, a) {
		var c = this,
			b = c.valueArray.indexOf(d);
		if (b >= 0 && Sys.isDefined(c.valueArray[b])) {
			c.currentIndex = b;
			c.update();
			if (!a) {
				c.sendValueUpdate()
			}
		}
	},
	getValue: function() {
		var a = this;
		return a.valueArray[a.currentIndex]
	},
	sendValueUpdate: function() {
		var a = this,
			b = a.getValue();
		a.callback(b)
	},
	updateFromCoordinates: function(d) {
		var c = this,
			a = Math.floor(d.x / c.stepWidth),
			b = c.valueArray.length - 1;
		if (a < 0) {
			a = 0
		} else {
			if (a > b) {
				a = b
			}
		}
		if (a !== c.currentIndex) {
			c.currentIndex = a;
			c.update();
			c.sendValueUpdate()
		}
	},
	clickedAt: function(c) {
		var a = this,
			b = a.relativeCoordinates(c);
		a.updateFromCoordinates(b)
	},
	movedTo: function(c) {
		var a = this,
			b = a.relativeCoordinates(c);
		a.updateFromCoordinates(b)
	}
};
Interface.utils.CanvasStepSlider = Sys.extend(Interface.utils.AbstractSlider, Interface.utils.CanvasStepSlider, "Interface.utils.CanvasStepSlider");
Sys.ns("Interface.utils");
Interface.utils.DOMControlList = {
	constructor: function(a) {
		Interface.utils.DOMControlList.superclass.constructor.apply(this, arguments);
		this.callback = a.callback
	},
	setUpContent: function(c) {
		var f = this,
			d, b = c.controls,
			a, g, e;
		f.container = new Sys.Element({
			id: c.id,
			tag: "ul",
			cls: "",
			renderTo: "gameWrapper"
		});
		for (d = 0; d < b.length; d++) {
			a = b[d];
			e = f.container.add(new Sys.Element({
				id: c.id + "_" + a.id,
				tag: "li"
			}));
			if (!Sys.isDefined(f.controls[a.id])) {
				f.controls[a.id] = []
			}
			if (a.type === "checkbox") {
				if (Sys.isDefined(a.withInput)) {
					g = f.setupCheckBoxWithInput(a.id, a.label, a.withInput);
					f.controls[a.id].push(g);
					e.add(g.getContainer())
				} else {
					g = f.setupCheckBox(a.id, a.label);
					f.controls[a.id].push(g);
					e.add(g.getContainer())
				}
				f.model.storeData(a.id, false)
			}
		}
	},
	setupCheckBoxWithInput: function(d, a, c) {
		var b = this;
		return new Interface.utils.DOMCheckBoxWithInput({
			id: d,
			label: b.getTranslatedText(a),
			inputConfig: c,
			callback: b.onControlChanged.bind(b)
		})
	},
	onControlChanged: function(b, a) {
		this.model.storeData(b, a);
		this.callback(b, a)
	},
	setupCheckBox: function(c, a) {
		var b = this;
		return new Interface.utils.DOMCheckBox({
			id: c,
			title: b.getTranslatedText(a),
			enabled: true,
			callback: b.onControlChanged.bind(b, c)
		})
	},
	getContainer: function() {
		return this.container
	},
	update: function(c, b) {
		var a = this.controls[c];
		this.model.storeData(c, b);
		if (Sys.isDefined(a)) {
			Sys.each(a, function(d) {
				d.setValue(b)
			})
		}
	},
	hide: function(b) {
		var a = this.controls[b];
		if (Sys.isDefined(a)) {
			Sys.each(a, function(c) {
				c.getContainer().el.parentElement.style.display = "none"
			})
		}
	},
	show: function(b) {
		var a = this.controls[b];
		if (Sys.isDefined(a)) {
			Sys.each(a, function(c) {
				c.getContainer().el.parentElement.style.display = ""
			})
		}
	},
	disable: function(b) {
		var a = this.controls[b];
		if (Sys.isDefined(a)) {
			Sys.each(a, function(c) {
				c.disable()
			})
		}
	},
	enable: function(b) {
		var a = this.controls[b];
		if (Sys.isDefined(a)) {
			Sys.each(a, function(c) {
				c.enable()
			})
		}
	},
	getTranslatedText: function(a) {
		return Services.languageManager.hasText(a) ? Services.languageManager.getText(a) : a
	}
};
Interface.utils.DOMControlList = Sys.extend(Interface.utils.AbstractControlList, Interface.utils.DOMControlList, "Interface.utils.DOMControlList");
Sys.ns("Interface.utils");
Interface.utils.DOMCheckBoxWithInput = {
	DEFAULT_INPUT_TYPE: "money",
	DEFAULT_INPUT_FILTER: /[^\d]/g,
	DEFAULT_CLEAR_ON_FOCUS: false,
	DEFAULT_CHECKBOX_VALUE: false,
	DEFAULT_INPUT_VALUE: "",
	NOT_CHECKED_VALUE: false,
	NOT_DEFINED_INPUT_VALUE: "",
	constructor: function(a) {
		var b = this;
		b.checkBox = undefined;
		b.input = undefined;
		Interface.utils.DOMCheckBoxWithInput.superclass.constructor.apply(b, arguments)
	},
	setUpContent: function(a) {
		var b = this;
		b.id = a.id;
		b.checkBoxId = b.id + "CheckBox";
		b.inputId = b.id + "Input";
		b.container = new Sys.Element({
			id: b.id,
			tag: "div",
			cls: ""
		});
		b.checkBox = b.setUpCheckBox(a.label);
		b.input = b.setUpInput(a.inputConfig);
		b.container.add(b.checkBox.getContainer());
		b.container.add(b.input.getContainer())
	},
	getContainer: function() {
		return this.container
	},
	setValue: function(d) {
		var c = this,
			b, a;
		if (d === false) {
			b = false;
			a = ""
		} else {
			b = true;
			a = d
		}
		c.setCheckBoxValue(b);
		c.setInputValue(a)
	},
	getValue: function() {
		var c = this,
			b = c.model.readData(c.checkBoxId),
			a = c.model.readData(c.inputId),
			d;
		if (b && a !== c.NOT_DEFINED_INPUT_VALUE) {
			d = a
		} else {
			d = c.NOT_CHECKED_VALUE
		}
		return d
	},
	enable: function() {
		this.checkBox.enable();
		this.input.enable()
	},
	disable: function() {
		this.checkBox.disable();
		this.input.disable()
	},
	setUpCheckBox: function(a) {
		var b = this,
			c = b.checkBoxId;
		b.model.storeData(c, b.DEFAULT_CHECKBOX_VALUE);
		return new Interface.utils.DOMCheckBox({
			id: c,
			enabled: true,
			title: a,
			callback: b.onCheckBoxToggled.bind(b)
		})
	},
	setUpInput: function(a) {
		var c = this,
			d = c.inputId,
			b = Sys.isDefined(a.type) ? a.type : c.DEFAULT_INPUT_TYPE;
		c.model.storeData(d, c.DEFAULT_INPUT_VALUE);
		return new Interface.utils.DOMInputField({
			id: d,
			enabled: true,
			label: Sys.isDefined(a.label) ? a.label : "",
			callback: c.onInputFieldEdited.bind(c, b),
			clearOnFocus: Sys.isDefined(a.clearOnFocus) ? a.clearOnFocus : c.DEFAULT_CLEAR_ON_FOCUS,
			inputFilter: Sys.isDefined(a.inputFilter) ? a.inputFilter : c.DEFAULT_INPUT_FILTER,
			blurCallback: function() {
				setTimeout(function() {
					var e = c.model.readData(d);
					if (e === c.NOT_DEFINED_INPUT_VALUE) {
						c.setCheckBoxValue(false)
					}
				}, 0)
			}
		})
	},
	onCheckBoxToggled: function(b) {
		var a = this,
			c = a.checkBoxId;
		a.model.storeData(c, b);
		if (b) {
			a.input.setActive(true)
		}
		a.sendValueUpdate()
	},
	onInputFieldEdited: function(b, d) {
		var c = this,
			e = c.inputId,
			a;
		if (d === "") {
			a = c.NOT_DEFINED_INPUT_VALUE
		} else {
			if (b === "money") {
				a = Math.floor(Number(d) * 100);
				a = isNaN(a) ? c.NOT_DEFINED_INPUT_VALUE : a
			} else {
				a = d
			}
		}
		if (a !== c.NOT_DEFINED_INPUT_VALUE) {
			c.setCheckBoxValue(true)
		}
		c.model.storeData(e, a);
		c.sendValueUpdate()
	},
	sendValueUpdate: function() {
		var a = this,
			b = a.getValue();
		a.callback(a.id, b)
	},
	setCheckBoxValue: function(b) {
		var a = this;
		a.checkBox.setValue(b);
		a.model.storeData(a.checkBoxId, b)
	},
	setInputValue: function(b) {
		var a = this;
		a.input.setValue(b);
		a.model.storeData(a.inputId, b)
	}
};
Interface.utils.DOMCheckBoxWithInput = Sys.extend(Interface.utils.AbstractCheckBoxWithInput, Interface.utils.DOMCheckBoxWithInput, "Interface.utils.DOMControlList");
Sys.ns("Interface.utils");
Interface.utils.DOMCheckBox = {
	CSS: {
		base: "interface-checkBox_base",
		disabled: "disabled",
		label: "interface-checkBox_label",
		button_wrapper: "interface-checkBox_box",
		button_background: "interface-checkBox_background",
		button_handle: "interface-checkBox_handle",
		loadAnimation: ""
	},
	constructor: function() {
		Interface.utils.DOMCheckBox.superclass.constructor.apply(this, arguments)
	}
};
Interface.utils.DOMCheckBox = Sys.extend(Interface.utils.ToggleSwitch, Interface.utils.DOMCheckBox, "Interface.utils.DOMCheckBox");
Sys.ns("Interface.utils");
Interface.utils.DOMInputField = {
	CSS: {
		base: "interface-inputField_base",
		label: "interface-inputField_label",
		input: "interface-inputField_input"
	},
	constructor: function() {
		Interface.utils.DOMInputField.superclass.constructor.apply(this, arguments)
	},
	onUserInputStart: function(a) {
		this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	onUserInputEnd: function(b) {
		var a = this.wasInitialInputTarget && Sys.UserInputUtils.isCoordinateTarget(this.container.el, b);
		this.setActive(a)
	},
	enable: function() {
		Interface.utils.DOMInputField.superclass.enable.apply(this, arguments);
		this.container.removeCls("disabled");
		this.input.el.disabled = false
	},
	disable: function() {
		Interface.utils.DOMInputField.superclass.enable.apply(this, arguments);
		this.container.addCls("disabled");
		this.input.el.disabled = true
	},
	getContainer: function() {
		return this.container
	},
	init: function(a) {
		this.setUpDOMStructure(a);
		Interface.utils.DOMInputField.superclass.init.apply(this, arguments);
		this.clearOnFocus = a.clearOnFocus
	},
	setUpDOMStructure: function(b) {
		var c = this,
			a;
		if (Sys.isDefined(b.CSS)) {
			a = Sys.applyPropertiesIf(Sys.applyProperties({}, b.CSS), c.CSS)
		} else {
			a = c.CSS
		}
		c.container = new Sys.Element({
			id: b.id,
			tag: "div",
			cls: a.base
		});
		if (Sys.isDefined(b.label)) {
			c.label = c.container.add(new Sys.Element({
				id: b.id + "_label",
				tag: "span",
				cls: a.label,
				textContent: b.label
			}))
		}
		c.input = c.container.add(new Sys.Element({
			id: b.id + "_input",
			tag: "input",
			cls: a.input
		}));
		c.id = Sys.isDefined(b.id) ? b.id : "DOMInputField";
		c.input.el.onkeyup = c.onKeyUp.bind(c, b.inputFilter);
		c.input.el.onfocus = c.onFocusChanged.bind(c, true);
		c.input.el.onblur = c.onFocusChanged.bind(c, false);
		if (Sys.isDefined(b.blurCallback)) {
			c.blurCallback = b.blurCallback
		} else {
			c.blurCallback = function() {}
		}
	},
	setActive: function(b) {
		var a = this;
		a.active = b;
		if (b && a.enabled) {
			a.container.addCls("active");
			a.input.el.focus();
			if (a.clearOnFocus) {
				a.input.el.value = "";
				a.onKeyUp()
			}
		} else {
			a.container.removeCls("active");
			a.input.el.blur()
		}
	},
	getValue: function(a) {
		if (a) {
			return this.input.el.value.replace(a, "")
		}
		return this.input.el.value
	},
	setValue: function(b) {
		var a = this;
		if (a.input.el.value !== b) {
			a.input.el.value = b
		}
	},
	onFocusChanged: function(b) {
		var a = this;
		if (b) {
			a.fireEvent("request:keyboardManager.addProperty", "disabled", a.id)
		} else {
			a.fireEvent("request:keyboardManager.removeProperty", "disabled", a.id);
			a.blurCallback()
		}
	}
};
Interface.utils.DOMInputField = Sys.extend(Interface.utils.AbstractInputField, Interface.utils.DOMInputField, "Interface.utils.DOMInputField");
Sys.ns("Interface.utils");
Interface.utils.DOMOptionScroller = {
	CSS: {
		base: "interface-DOMOptionScroller_base",
		buttonBase: "interface-DOMOptionScroller_buttonBase",
		buttonUp: "interface-DOMOptionScroller_buttonUp interface-DOMOptionScroller_buttonUp_uri",
		buttonDown: "interface-DOMOptionScroller_buttonDown interface-DOMOptionScroller_buttonDown_uri",
		valuesHolder: "interface-DOMOptionScroller_valuesHolder",
		value: "interface-DOMOptionScroller_value interface-DOMOptionScroller_value_uri",
		wrapper: "interface-DOMOptionScroller_valueWrapper"
	},
	PIXEL_FACTOR: 0.01,
	constructor: function() {
		Interface.utils.DOMOptionScroller.superclass.constructor.apply(this, arguments)
	},
	onUserInputStart: function() {},
	onUserInputEnd: function() {},
	enable: function() {
		Interface.utils.DOMOptionScroller.superclass.enable.apply(this, arguments);
		this.container.removeCls("disabled")
	},
	disable: function() {
		Interface.utils.DOMOptionScroller.superclass.enable.apply(this, arguments);
		this.container.addCls("disabled")
	},
	getContainer: function() {
		return this.container
	},
	init: function(a) {
		this.setUpDOMStructure(a);
		Interface.utils.DOMOptionScroller.superclass.init.apply(this, arguments)
	},
	setUpDOMStructure: function(b) {
		var d = this,
			a = Sys.applyIf(Sys.apply({}, b.CSS), d.CSS),
			c;
		d.id = b.id || "DOMOptionScroller";
		d.valueChilds = [];
		d.valueButtons = [];
		d.wrapperChilds = [];
		d.avg = 0;
		d.container = new Sys.Element({
			id: d.id,
			tag: "div",
			cls: a.base
		});
		d.downButton = new Interface.utils.DOMButton({
			id: d.id + "_downButton",
			baseCSS: a.buttonBase + " " + a.buttonDown,
			clickCallback: function() {
				d.scroll("down")
			}
		});
		d.downButton.disable("lowerBoundReached");
		d.container.add(d.downButton.getContainer());
		d.values = d.container.add(new Sys.Element({
			id: d.id + "_values",
			tag: "div",
			cls: a.valuesHolder
		}));
		d.valuesScroller = d.values.add(new Sys.Element({
			id: d.id + "_valuesScroller",
			tag: "div",
			style: "position:absolute; height:100%;white-space: nowrap;"
		}));
		d.valuesScroller.el.style[Sys.utils.pollyFill("transition")] = "transform 100ms";
		Sys.each(b.values, function(h, e) {
			var f, g = false;
			if (Sys.isDefined(b.replaceTextByIndex)) {
				Sys.each(b.replaceTextByIndex, function(j) {
					if (e === j.index) {
						f = j.text;
						if (j.skip) {
							g = true
						}
					}
				})
			}
			if (!g) {
				c = new Interface.utils.DOMButton({
					id: "value" + h,
					baseCSS: a.value,
					textContent: (Sys.isDefined(f) ? f : h),
					clickCallback: function() {
						d.callback(h)
					}
				});
				d.valuesScroller.add(c.getContainer());
				d.valueChilds.push(c.getContainer());
				d.valueButtons.push(c)
			}
		});
		d.upButton = new Interface.utils.DOMButton({
			id: d.id + "_upButton",
			baseCSS: a.buttonBase + " " + a.buttonUp,
			clickCallback: function() {
				d.scroll("up")
			}
		});
		d.container.add(d.upButton.getContainer());
		d.calculateOffsetValues();
		d.valueWidth = b.valueWidth;
		d.scrollOffsetModifier = b.scrollOffsetModifier;
		d.scrollOffset = d.scrollOffsetModifier * b.valueWidth;
		d.currentScrollOffset = 0;
		d.maxScrollOffset = 0;
		d.minScrollOffset = -(((b.values.length - 1) * d.valueWidth) - d.scrollOffset);
		if (d.minScrollOffset >= d.currentScrollOffset) {
			d.upButton.disable("upperBoundReached")
		}
	},
	calculateOffsetValues: function() {
		var b = this,
			a = 0;
		Sys.each(b.valueChilds, function(c) {
			if (c.el.clientWidth > 0) {
				a += c.el.clientWidth
			}
		});
		if (a > 0) {
			b.scrollOffset = (a / b.valueChilds.length) * b.scrollOffsetModifier
		}
		b.totalValueWidth = a
	},
	scroll: function(b) {
		var a = this,
			c = b === "up" ? -1 : 1;
		if (!Sys.isDefined(a.totalValueWidth) || a.tot === 0) {
			a.calculateOffsetValues()
		}
		a.currentScrollOffset = Math.max(Math.min(a.currentScrollOffset + c * a.scrollOffset, a.maxScrollOffset), a.minScrollOffset);
		a.valuesScroller.el.style[Sys.utils.pollyFill("transform")] = "translate3d(" + a.currentScrollOffset * a.PIXEL_FACTOR + "rem,0,0)";
		if (a.currentScrollOffset === a.minScrollOffset) {
			a.upButton.disable("upperBoundReached")
		} else {
			a.upButton.enable("upperBoundReached")
		}
		if (a.currentScrollOffset === 0) {
			a.downButton.disable("lowerBoundReached")
		} else {
			a.downButton.enable("lowerBoundReached")
		}
	}
};
Interface.utils.DOMOptionScroller = Sys.extend(Interface.utils.AbstractOptionScroller, Interface.utils.DOMOptionScroller, "Interface.utils.DOMOptionScroller");
Sys.ns("Interface.utils");
Interface.utils.DOMButton = {
	BASE_CSS: "DOMButton",
	textContent: "",
	container: undefined,
	renderTo: undefined,
	constructor: function() {
		Interface.utils.DOMButton.superclass.constructor.apply(this, arguments)
	},
	init: function(a) {
		var b = this;
		b.id = a.id;
		b.BASE_CSS = a.baseCSS || b.BASE_CSS;
		b.textContent = a.textContent || b.textContent;
		b.tagType = a.tag || "div";
		b.renderTo = a.renderTo;
		b.setupContainer();
		Interface.utils.DOMButton.superclass.init.apply(b, arguments)
	},
	up: function() {
		Interface.utils.DOMButton.superclass.up.apply(this, arguments);
		this.update()
	},
	down: function() {
		Interface.utils.DOMButton.superclass.down.apply(this, arguments);
		this.update()
	},
	hover: function() {
		Interface.utils.DOMButton.superclass.hover.apply(this, arguments);
		this.update()
	},
	getContainer: function() {
		return this.container
	},
	setupContainer: function() {
		var a = this;
		a.container = new Sys.Element({
			id: a.id,
			tag: a.tagType,
			cls: a.BASE_CSS,
			textContent: a.textContent,
			renderTo: a.renderTo
		})
	},
	isInputTarget: function(a) {
		return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	update: function() {
		var b = this,
			a = b.container;
		a.removeCSSClass("hidden");
		a.removeCSSClass("disabled");
		a.removeCSSClass("active");
		a.removeCSSClass("hover");
		a.removeCSSClass("down");
		if (b.hasProperty("hidden")) {
			a.addCSSClass("hidden")
		}
		if (b.hasProperty("disabled")) {
			a.addCSSClass("disabled")
		} else {
			if (b.hasProperty("active")) {
				a.addCSSClass("active")
			} else {
				if (b.state === "hover") {
					a.addCSSClass("hover")
				} else {
					if (b.state === "down") {
						a.addCSSClass("down")
					}
				}
			}
		}
	}
};
Interface.utils.DOMButton = Sys.extend(Interface.AbstractButton, Interface.utils.DOMButton, "Interface.utils.DOMButton");
Sys.ns("Interface.utils");
Interface.utils.DOMScrollableContent = {
	constructor: function(a) {
		Interface.utils.DOMScrollableContent.superclass.constructor.apply(this, arguments)
	},
	setupContainer: function(b) {
		var c = this,
			a = b.snap;
		c.content = b.content;
		c.model = new Core.Model({});
		c.container = new Sys.Element({
			id: c.id + "_container",
			tag: "div",
			cls: c.CSS.base
		});
		c.container.add(c.content);
		c._scroller = new Scroller(c.onScroll.bind(c), {
			scrollingX: false,
			snapping: Sys.isObj(a),
			speedMultiplier: 1.5 / Number(Environment.getScale()),
			scrollingComplete: c.onScrollComplete.bind(c, b.scrollCompleteCallback)
		});
		if (Sys.isObj(a)) {
			c._scroller.setSnapSize(a.width, a.height)
		}
	},
	onScroll: function(c, b) {
		var a = this;
		a.content.el.style[Sys.utils.pollyFill("transform")] = "translate3d(0," + (-b) + "px,0)";
		if (Sys.isDefined(a.scrollBar)) {
			a.moveScrollIndicator(b)
		}
	},
	onScrollComplete: function(c) {
		var b = this,
			a = b._scroller,
			d = a.getValues().top;
		if (!b.model.isState("scrollingByProxy")) {
			a.scrollTo(0, d, false)
		}
		if (Sys.isDefined(c)) {
			c(d)
		}
	},
	show: function() {
		var a = this;
		a.container.el.style.display = "block";
		a.updateScrollerDimensions();
		if (a.isScrollBarVisible) {
			a.showScrollBar()
		}
	},
	hide: function() {
		this.container.el.style.display = "none";
		this.hideScrollBar()
	},
	enable: function() {
		Interface.utils.DOMScrollableContent.superclass.enable.apply(this, arguments);
		this.updateScrollerDimensions()
	},
	onUserInputStart: function(d) {
		var c = this,
			a = c.model,
			b = c.contentIsScrollable();
		if (b) {
			if (Sys.isDefined(c.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(c.scrollBar.el, d)) {
				a.setState("scrollingByProxy");
				c.onBarIndicatorMove(d)
			} else {
				if (Sys.UserInputUtils.isCoordinateTarget(c.content.el, d)) {
					a.setState("scrolling");
					c._scroller.doTouchStart([{
						pageX: d.x,
						pageY: d.y
					}], Date.now())
				}
			}
			if ((a.isState("scrolling") || a.isState("scrollingByProxy")) && !a.readData("hasSetDimensions")) {
				c.updateScrollerDimensions();
				a.storeData("hasSetDimensions", true)
			}
		}
	},
	contentIsScrollable: function() {
		var b = this,
			c = b.container.el.clientHeight,
			a = b.content.el.scrollHeight;
		return c < a + 20
	},
	updateScrollerDimensions: function() {
		var d = this,
			e, c, f, b, a;
		e = d.container.el.clientHeight;
		c = d.content.el.scrollHeight;
		d._scroller.setDimensions(d.container.el.clientWidth, e + 20, d.content.el.scrollWidth, c + 60);
		b = d.container.el.getBoundingClientRect();
		d._scroller.setPosition(b.left + d.container.clientLeft, b.top + d.container.clientTop);
		if (e > 0 && c > 0) {
			a = (e < c + 20)
		}
		if (a) {
			if (!Sys.isDefined(d.scrollBar)) {
				d.addScrollBar()
			}
			d.isScrollBarVisible = true;
			d.showScrollBar();
			f = d.scrollBar.el.clientHeight;
			d.scrollIndicatorHeight = d.scrollIndicator.el.clientHeight;
			d.maxScroll = d._scroller.getScrollMax().top;
			d.scrollBarHeight = f - d.scrollIndicatorHeight
		} else {
			if (Sys.isDefined(d.scrollBar)) {
				d.isScrollBarVisible = false;
				d.hideScrollBar()
			}
		}
	},
	onUserInputMove: function(c) {
		var b = this,
			a = b.contentIsScrollable();
		if (a) {
			if (b.model.isState("scrolling")) {
				b._scroller.doTouchMove([{
					pageX: c.x,
					pageY: c.y
				}], Date.now())
			} else {
				if (b.model.isState("scrollingByProxy")) {
					b.onBarIndicatorMove(c)
				}
			}
		}
	},
	onUserInputEnd: function() {
		var b = this,
			a = b.model,
			c = a.isState("scrolling") || a.isState("scrollingByProxy");
		a.setState("idle");
		if (c) {
			b._scroller.doTouchEnd(Date.now())
		}
	},
	onUserInputScroll: function(g, c) {
		var e = this,
			a = e.model,
			d = Sys.UserInputUtils.isCoordinateTarget(e.content.el, g),
			f = Sys.isDefined(e.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(e.scrollBar.el, g),
			b = (d || f) && e.contentIsScrollable();
		if (b) {
			a.setState("scrollingByProxy");
			e._scroller.scrollBy(0, c.deltaY || c.detail * 30, false);
			if (!a.readData("hasSetDimensions")) {
				e.updateScrollerDimensions();
				a.storeData("hasSetDimensions", true)
			}
		}
	},
	moveScrollIndicator: function(d) {
		var c = this,
			b = c.maxScroll,
			a = Math.round(c.scrollIndicatorHeight / 2);
		if (d < 0) {
			d = 0
		} else {
			if (d > b) {
				d = b
			}
		}
		c.scrollIndicator.el.style.top = Math.round(c.scrollBarHeight * (d / b) + a) + "px"
	},
	onBarIndicatorMove: function(f) {
		var b = this,
			e = Sys.UserInputUtils.getCoordinatesRelativeToElement(f, b.scrollBar.el),
			c = e.y,
			d = b.scrollBarHeight,
			a;
		if (c < 0) {
			c = 0
		} else {
			if (c > d) {
				c = d
			}
		}
		a = Math.round(b.maxScroll * (c / d));
		b._scroller.scrollTo(0, a, true)
	},
	addScrollBar: function() {
		var a = this;
		if (!Sys.isDefined(a.container)) {
			return
		}
		a.maxScroll = 0;
		a.scrollBar = a.container.add(new Sys.Element({
			tag: "div",
			id: a.id + "_scrollbar",
			"class": "interface-scrollableContent_scrollBar"
		}));
		a.scrollBarBackground = a.scrollBar.add(new Sys.Element({
			tag: "div",
			"class": "interface-scrollableContent_scrollBarBackground utils_horizontal_center"
		}));
		a.scrollIndicator = a.scrollBar.add(new Sys.Element({
			tag: "div",
			"class": "interface-scrollableContent_scrollBarHandle utils_center"
		}))
	},
	showScrollBar: function() {
		if (Sys.isDefined(this.scrollBar)) {
			this.scrollBar.el.style.display = "block"
		}
	},
	hideScrollBar: function() {
		if (Sys.isDefined(this.scrollBar)) {
			this.scrollBar.el.style.display = "none"
		}
	},
	startListeningToUserInput: function() {
		Interface.utils.DOMScrollableContent.superclass.startListeningToUserInput.apply(this, arguments);
		this.addListener("notify:userInputManager.userInputScroll", this.onUserInputScroll)
	},
	stopListeningToUserInput: function() {
		Interface.utils.DOMScrollableContent.superclass.stopListeningToUserInput.apply(this, arguments);
		this.removeListener("notify:userInputManager.userInputScroll")
	},
	scrollTo: function(b) {
		var a = this._scroller;
		a.scrollTo(0, b, false);
		a.options.scrollingComplete(a.getValues().top)
	}
};
Interface.utils.DOMScrollableContent = Sys.extend(Interface.utils.UserInputBase, Interface.utils.DOMScrollableContent, "Interface.utils.DOMScrollableContent");
Sys.ns("Interface.utils");
Interface.utils.GroupTitle = {
	CSS: {
		base: "interface-groupTitle_base",
		disabled: "interface-groupTitle_disabled",
		label: "interface-groupTitle_label"
	},
	constructor: function(a) {
		Interface.utils.GroupTitle.superclass.constructor.apply(this, arguments)
	},
	init: function(b) {
		var c = this,
			a = b.CSS;
		if (Sys.isDefined(a)) {
			c.CSS = Sys.applyIf(a, c.CSS)
		}
		c.title = b.title;
		Interface.utils.GroupTitle.superclass.init.apply(c, arguments)
	},
	setupContainer: function(a) {
		var b = this;
		b.container = new Sys.Element({
			id: b.id,
			tag: "div",
			cls: a.cls + " " + b.CSS.base
		});
		if (b.title) {
			b.label = b.container.add(new Sys.Element({
				id: b.id + "_title",
				tag: "div",
				cls: b.CSS.label,
				textContent: b.title
			}))
		}
	},
	setCSS: function(d) {
		var c = this,
			b = c.container,
			a = c.CSS;
		if (d.base) {
			b.replaceCSSClass(a.base, d.base)
		}
		if (!c.enabled && d.disabled) {
			b.replaceCSSClass(a.disabled, d.disabled)
		}
		if (d.label) {
			c.label.replaceCSSClass(a.label, d.label)
		}
		c.CSS = Sys.applyIf(d, a)
	}
};
Interface.utils.GroupTitle = Sys.extend(Interface.utils.UserInputBase, Interface.utils.GroupTitle, "Interface.utils.GroupTitle");
Sys.ns("Interface");
Interface.SettingsSection = {
	constructor: function() {
		Interface.SettingsSection.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["userInput", "orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Model,
			view: Interface.SettingsSectionView,
			controller: Interface.SettingsSectionController
		}
	}
};
Interface.SettingsSection = Sys.extend(Core.Module, Interface.SettingsSection, "Interface.SettingsSection");
Sys.ns("Interface");
Interface.SettingsSectionController = {
	constructor: function() {
		Interface.SettingsSectionController.superclass.constructor.apply(this, arguments);
		this.setUpContent()
	},
	setupEvents: function() {
		var a = this,
			b = {
				"view:addToContainer": a.addViewToContainer,
				"view:removeFromContainer": a.removeViewFromContainer,
				"view:addToNavigator": a.addOptionToNavigator,
				"view:userAction": a.onUserAction,
				"view:disableSetting": a.disableSetting,
				"view:showRequest": a.onShowRequest,
				"view:hideRequest": a.onHideRequest,
				"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
				"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
				"request:enableBasicGamePanel": a.onEnableBasicGamePanel,
				"request:disableBasicGamePanel": a.onDisableBasicGamePanel,
				"notify:featureSplash.showing": a.onFeatureSplashShowing,
				"notify:featureSplash.closed": a.onFeatureSplashClosed
			};
		b["request:" + a.MODULE_NAME + ".show"] = a.onShowRequest;
		b["request:" + a.MODULE_NAME + ".hide"] = a.onHideRequest;
		b["request:" + a.MODULE_NAME + ".enable"] = a.enable;
		b["request:" + a.MODULE_NAME + ".disable"] = a.disable;
		a.on(b)
	},
	setUpContent: function() {
		this.view.setUpContent()
	},
	onShowRequest: function(b) {
		var c = this,
			a = c.model.readData("currentContainer");
		if (!c.model.readData("showing")) {
			if (Sys.isDefined(a)) {
				c.fireEvent("request:" + a + ".openChild", c.MODULE_NAME, b)
			} else {
				c.show(b)
			}
		}
		Services.storage.storeData(c.MODULE_NAME + ".showing", true)
	},
	onHideRequest: function() {
		var b = this,
			a = b.model.readData("currentContainer");
		if (b.model.readData("showing")) {
			if (Sys.isDefined(a)) {
				b.fireEvent("request:" + a + ".closeChild", b.MODULE_NAME)
			} else {
				b.hide()
			}
		}
		Services.storage.storeData(b.MODULE_NAME + ".showing", false)
	},
	addViewToContainer: function(a, c) {
		var d = this,
			b = this.model.readData("currentContainer");
		if (b) {
			d.removeViewFromContainer(b)
		}
		d.model.storeData("currentContainer", a);
		d.addListener("notify:" + a + ".openedChild", d.containerOpenedChild);
		d.addListener("notify:" + a + ".closedChild", d.containerClosedChild);
		d.fireEvent("request:" + a + ".addChild", d.MODULE_NAME, c)
	},
	containerOpenedChild: function(b, a) {
		if (b === this.MODULE_NAME) {
			this.show(a)
		}
	},
	containerClosedChild: function(a) {
		if (a === this.MODULE_NAME) {
			this.hide()
		}
	},
	show: function(a) {
		var b = this;
		if (!b.model.readData("showing")) {
			b.model.storeData("showing", true);
			Services.storage.storeData(b.MODULE_NAME + ".showing", true);
			b.fireEvent("notify:" + b.MODULE_NAME + ".shown");
			b.view.show(a);
			b.startListeningToUserInput()
		}
	},
	hide: function() {
		var a = this;
		if (a.model.readData("showing")) {
			a.model.storeData("showing", false);
			Services.storage.storeData(a.MODULE_NAME + ".showing", false);
			a.fireEvent("notify:" + a.MODULE_NAME + ".hidden");
			a.stopListeningToUserInput();
			a.view.hide()
		}
	},
	removeViewFromContainer: function(a, b) {
		var c = this;
		c.removeListener("notify:" + a + ".openedChild");
		c.removeListener("notify:" + a + ".closedChild");
		c.fireEvent("request:" + a + ".removeChild", c.MODULE_NAME, b)
	},
	addOptionToNavigator: function(a, b) {
		this.fireEvent("request:" + a + ".addChild", this.MODULE_NAME, b)
	},
	onUserAction: function() {},
	onUserInputStart: function() {
		this.view.onUserInputStart.apply(this.view, arguments)
	},
	onUserInputMove: function() {
		this.view.onUserInputMove.apply(this.view, arguments)
	},
	onUserInputEnd: function() {
		this.view.onUserInputEnd.apply(this.view, arguments)
	},
	onUserInputScroll: function() {
		this.view.onUserInputScroll.apply(this.view, arguments)
	},
	enable: function(a) {
		this.model.storeData("disabled", false);
		this.view.enable(a)
	},
	disable: function(a) {
		this.model.storeData("disabled", true);
		this.view.disable(a)
	},
	onPortrait: function() {
		this.model.storeData("hasSetDimensions", false);
		Mixins.orientation.controller.methods.onPortrait.apply(this, arguments)
	},
	onLandscape: function() {
		this.model.storeData("hasSetDimensions", false);
		Mixins.orientation.controller.methods.onLandscape.apply(this, arguments)
	},
	onLeavingIdleState: function() {
		var a = this;
		if (Sys.isDefined(a.view.onLeavingIdleState)) {
			a.view.onLeavingIdleState()
		}
	},
	onEnteringIdleState: function() {
		var a = this;
		if (Sys.isDefined(a.view.onEnteringIdleState)) {
			a.view.onEnteringIdleState()
		}
	},
	onEnableBasicGamePanel: function(b) {
		var a = this;
		if (Sys.isDefined(a.view.onEnableBasicGamePanel)) {
			a.view.onEnableBasicGamePanel(b)
		}
	},
	onDisableBasicGamePanel: function(b) {
		var a = this;
		if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
			a.view.onDisableBasicGamePanel(b)
		}
	},
	onFeatureSplashShowing: function() {
		var a = this;
		if (Sys.isDefined(a.view.onFeatureSplashShowing)) {
			a.view.onFeatureSplashShowing()
		}
	},
	onFeatureSplashClosed: function() {
		var a = this;
		if (Sys.isDefined(a.view.onFeatureSplashClosed)) {
			a.view.onFeatureSplashClosed()
		}
	},
	disableSetting: function(a) {
		this.fireEvent("request:settingsManager.disableSetting", a)
	}
};
Interface.SettingsSectionController = Sys.extend(Core.Controller, Interface.SettingsSectionController, "Interface.SettingsSectionController");
Sys.ns("Interface");
Interface.SettingsSectionModel = {
	constructor: function() {
		Interface.SettingsSectionModel.superclass.constructor.apply(this, arguments)
	},
	initData: function(b) {
		var c = this,
			d = b.defaultValue,
			a = Sys.isDefined(b.silent) ? b.silent : true;
		if (b.settingsManager) {
			if (b.localStorage && !b.ignoreLocalStorageValue && Services.localStorageManager.hasData(b.key)) {
				d = Sys.utils.parseValue(Services.localStorageManager.readData(b.key))
			}
			Services.settingsManager.storeSetting(b.key, d, b.localStorage, a)
		}
		c.storeData(b.key, d)
	},
	setupData: function() {
		Services.storage.storeData(this.MODULE_NAME + ".showing", false)
	}
};
Interface.SettingsSectionModel = Sys.extend(Core.Model, Interface.SettingsSectionModel, "Interface.SettingsSectionModel");
Sys.ns("Interface");
Interface.SettingsSectionView = {
	SCROLL_BAR_CSS: "interface-settingsSection_scrollBar",
	SCROLL_INDICATOR_CSS: "interface-settingsSection_scrollIndicator utils_center",
	DISABLE_BUTTON_DURING_SPIN: true,
	ENABLED_ONLY_IN_BASIC_GAME: false,
	DISABLE_BUTTON_DURING_FEATURE_SPLASH: true,
	constructor: function() {
		Interface.SettingsSectionView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		this.container = new Sys.Element({
			tag: "div"
		})
	},
	addContainerToSettings: function() {},
	addScrolling: function() {
		var a = this;
		if (Sys.isDefined(a.container) && Sys.isDefined(a.container.parent)) {
			a._wrapper = a.container.parent
		} else {
			return
		}
		a._scroller = new Scroller(a.onScroll.bind(a), {
			scrollingX: false,
			speedMultiplier: 1.5 / Number(Environment.getScale())
		})
	},
	onScroll: function(c, b) {
		var a = this;
		a.container.el.style[Sys.utils.pollyFill("transform")] = "translate3d(0," + (-b) + "px,0)";
		if (Sys.isDefined(a.scrollBar)) {
			a.moveScrollIndicator(b)
		}
	},
	show: function() {
		var a = this;
		a.container.el.style.display = "block";
		a.updateScrollerDimensions();
		if (a.isScrollBarVisible) {
			a.showScrollBar()
		}
		if (!a.model.readData("disabled")) {
			a.callFunctionOnSubComponents("startListeningToUserInput")
		}
	},
	hide: function() {
		this.container.el.style.display = "none";
		this.hideScrollBar();
		this.callFunctionOnSubComponents("stopListeningToUserInput")
	},
	enable: function() {},
	disable: function() {},
	adaptToOrientation: function() {
		var a = this;
		Mixins.orientation.view.methods.adaptToOrientation.apply(this, arguments);
		clearTimeout(a.orientationAdaptationTimeout);
		a.orientationAdaptationTimeout = setTimeout(function() {
			a.updateScrollerDimensions()
		}, 50)
	},
	onUserInputStart: function(d) {
		var c = this,
			a = c.model,
			b = c.contentIsScrollable() && !c.userInputOnSubControl(d);
		if (b) {
			if (Sys.isDefined(c.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(c.scrollBar.el, d)) {
				a.setState("scrollingByProxy");
				c.onBarIndicatorMove(d)
			} else {
				if (Sys.UserInputUtils.isCoordinateTarget(c.container.el, d)) {
					a.setState("scrolling");
					c._scroller.doTouchStart([{
						pageX: d.x,
						pageY: d.y
					}], Date.now())
				}
			}
			if ((a.isState("scrolling") || a.isState("scrollingByProxy")) && !a.readData("hasSetDimensions")) {
				c.updateScrollerDimensions();
				a.storeData("hasSetDimensions", true)
			}
		}
	},
	userInputOnSubControl: function(d) {
		var b = this,
			a = b.container.el.querySelectorAll("[data-input]"),
			c = false;
		Sys.each(a, function(e) {
			if (Sys.UserInputUtils.isCoordinateTarget(e, d)) {
				c = true
			}
		});
		return c
	},
	contentIsScrollable: function() {
		var b = this,
			c = b._wrapper.el.clientHeight,
			a = b.container.el.scrollHeight;
		return c + 40 < a
	},
	updateScrollerDimensions: function() {
		var d = this,
			e, c, f, b, a;
		if (!Sys.isDefined(d._wrapper)) {
			return
		}
		e = d._wrapper.el.clientHeight;
		c = d.container.el.scrollHeight;
		d._scroller.setDimensions(d._wrapper.el.clientWidth, e + 20, d.container.el.scrollWidth, c + 40);
		b = d._wrapper.el.getBoundingClientRect();
		d._scroller.setPosition(b.left + d._wrapper.clientLeft, b.top + d._wrapper.clientTop);
		if (e > 0 && c > 0) {
			a = (e + 40 < c)
		}
		if (a) {
			if (!Sys.isDefined(d.scrollBar)) {
				d.addScrollBar()
			}
			d.isScrollBarVisible = true;
			d.showScrollBar();
			f = d.scrollBar.el.clientHeight;
			d.scrollIndicatorHeight = d.scrollIndicator.el.clientHeight;
			d.maxScroll = d._scroller.getScrollMax().top;
			d.scrollBarHeight = f - d.scrollIndicatorHeight
		} else {
			if (Sys.isDefined(d.scrollBar)) {
				d.isScrollBarVisible = false;
				d.hideScrollBar()
			}
		}
	},
	onUserInputMove: function(b) {
		var a = this;
		if (a.model.isState("scrolling")) {
			a._scroller.doTouchMove([{
				pageX: b.x,
				pageY: b.y
			}], Date.now())
		} else {
			if (a.model.isState("scrollingByProxy")) {
				a.onBarIndicatorMove(b)
			}
		}
	},
	onUserInputEnd: function() {
		if (this.model.isState("scrolling")) {
			this._scroller.doTouchEnd(Date.now())
		}
		this.model.setState("idle")
	},
	onUserInputScroll: function(g, c) {
		var e = this,
			a = e.model,
			d = Sys.UserInputUtils.isCoordinateTarget(e.container.el, g),
			f = Sys.isDefined(e.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(e.scrollBar.el, g),
			b = (d || f) && e.contentIsScrollable();
		if (b) {
			a.setState("scrollingByProxy");
			e._scroller.scrollBy(0, c.deltaY || c.detail * 30, false);
			if (!a.readData("hasSetDimensions")) {
				e.updateScrollerDimensions();
				a.storeData("hasSetDimensions", true)
			}
		}
	},
	callFunctionOnSubComponents: function(c, a) {
		var b = this;
		if (!b.model.readData("disabled")) {
			Sys.each(b.subComponents, function(d) {
				d[c].apply(d, a)
			})
		}
	},
	moveScrollIndicator: function(d) {
		var c = this,
			b = c.maxScroll,
			a = Math.round(c.scrollIndicatorHeight / 2);
		if (d < 0) {
			d = 0
		} else {
			if (d > b) {
				d = b
			}
		}
		c.scrollIndicator.el.style.top = Math.round(c.scrollBarHeight * (d / b) + a) + "px"
	},
	onBarIndicatorMove: function(e) {
		var b = this,
			f = Sys.UserInputUtils.getCoordinatesRelativeToElement(e, b.scrollBar.el),
			c = f.y,
			d = b.scrollBarHeight,
			a;
		if (c < 0) {
			c = 0
		} else {
			if (c > d) {
				c = d
			}
		}
		a = Math.round(b.maxScroll * (c / d));
		b._scroller.scrollTo(0, a, true)
	},
	addScrollBar: function() {
		var a = this;
		if (!Sys.isDefined(a._wrapper)) {
			return
		}
		a.maxScroll = 0;
		a.scrollBar = a._wrapper.add(new Sys.Element({
			tag: "div",
			id: a.MODULE_NAME + "_scrollbar",
			"class": a.SCROLL_BAR_CSS
		}));
		a.scrollBarBackground = a.scrollBar.add(new Sys.Element({
			tag: "div",
			"class": "interface-settingsSection_scrollBarBackground utils_horizontal_center"
		}));
		a.scrollIndicator = a.scrollBar.add(new Sys.Element({
			tag: "div",
			"class": a.SCROLL_INDICATOR_CSS
		}))
	},
	showScrollBar: function() {
		if (Sys.isDefined(this.scrollBar)) {
			this.scrollBar.el.style.display = "block"
		}
	},
	hideScrollBar: function() {
		if (Sys.isDefined(this.scrollBar)) {
			this.scrollBar.el.style.display = "none"
		}
	},
	onEnteringIdleState: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
			a.menuButton.removeCls("disabled");
			a.abstractButton.enable("notInIdleState")
		}
	},
	onLeavingIdleState: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
			a.menuButton.addCls("disabled");
			a.abstractButton.disable("notInIdleState")
		}
	},
	onEnableBasicGamePanel: function(b) {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
			a.abstractButton.enable(b);
			if (!a.abstractButton.hasProperty("disabled") && !a.abstractButton.hasProperty("hidden")) {
				a.menuButton.removeCls("disabled")
			}
		}
	},
	onDisableBasicGamePanel: function(b) {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
			a.menuButton.addCls("disabled");
			a.abstractButton.disable(b)
		}
	},
	onFeatureSplashShowing: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
			a.menuButton.addCls("disabled");
			a.abstractButton.disable("featureSplashShowing")
		}
	},
	onFeatureSplashClosed: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
			a.menuButton.removeCls("disabled");
			a.abstractButton.enable("featureSplashShowing")
		}
	}
};
Interface.SettingsSectionView = Sys.extend(Core.View, Interface.SettingsSectionView, "Interface.SettingsSectionView");
Sys.ns("Interface");
Interface.StandAloneSettingsSectionView = {
	BASE_CSS: "interface-standAloneSettingsSection",
	BACKGROUND_CSS: {
		top: "interface-standAloneSettingsSection_backgroundTop interface-standAloneSettingsSectionTop_uri",
		title: "interface-standAloneSettingsSection_title",
		bottom: "interface-standAloneSettingsSection_backgroundBottom interface-standAloneSettingsSectionBottom_uri",
		arrow: "interface-standAloneSettingsSection_backgroundArrow interface-standAloneSettingsSectionArrow_uri",
		middle: "interface-standAloneSettingsSectionMiddle interface-standAloneSettingsSectionMiddle_uri"
	},
	ARROW_LEFT_VALUE: "0.00rem",
	DIVIDER_CSS: "interface-standAloneSettingsSection_divider interface-standAloneSettingsSectionDivider_uri",
	CLOSE_BUTTON_CSS: "interface-standAloneSettingsSection_closeButton",
	MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button",
	CHECKBOX_CSS: {
		base: "interface-standAloneSettingsSectionContainer_checkBox",
		disabled: "interface-standAloneSettingsSectionContainer_checkBox_disabled",
		label: "interface-standAloneSettingsSectionContainer_checkBox_label",
		button_wrapper: "interface-standAloneSettingsSectionContainer_checkBox_wrapper",
		button_background: "interface-standAloneSettingsSectionContainer_checkBox_default",
		button_handle: "interface-standAloneSettingsSectionContainer_checkBox_checked"
	},
	RENDER_TARGET: "gameWrapper",
	TITLE: "Placeholder Header",
	ORDER: -1,
	constructor: function() {
		Interface.SettingsSectionView.superclass.constructor.apply(this, arguments)
	},
	getDivider: function() {
		return new Sys.Element({
			tag: "div",
			cls: this.DIVIDER_CSS
		})
	},
	setUpContent: function() {
		var a = this;
		a.wrapper = new Sys.Element({
			id: a.MODULE_NAME,
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET,
			style: "display:none;"
		});
		a.container = new Sys.Element({
			id: a.MODULE_NAME,
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET,
			style: "display:none;"
		});
		a.setupBackground();
		a.setupCloseButton();
		a.setUpMenuButton()
	},
	setupBackground: function() {
		var c = this,
			d = c.wrapper.add(new Sys.Element({
				id: "backgroundTop",
				tag: "div",
				cls: c.BACKGROUND_CSS.top
			})),
			a = c.wrapper.add(new Sys.Element({
				id: "backgroundMiddle",
				tag: "div",
				cls: c.BACKGROUND_CSS.middle
			})),
			b = c.wrapper.add(new Sys.Element({
				id: "backgroundBottom",
				tag: "div",
				cls: c.BACKGROUND_CSS.bottom
			}));
		d.add(new Sys.Element({
			id: "title",
			tag: "span",
			cls: c.BACKGROUND_CSS.title,
			textContent: c.getTitle()
		}));
		c.top = d;
		b.add(new Sys.Element({
			id: "backgroundArrow",
			tag: "div",
			cls: c.BACKGROUND_CSS.arrow,
			style: "left:" + c.ARROW_LEFT_VALUE + ";"
		}));
		c.container = a
	},
	getTitle: function() {
		return Services.languageManager.getText(this.TITLE)
	},
	setupCloseButton: function() {
		var a = this;
		a.closeButton = new Interface.utils.DOMButton({
			id: "closeButton",
			baseCSS: a.CLOSE_BUTTON_CSS,
			clickCallback: a.fireEvent.bind(a, "view:hideRequest"),
			hoverCallback: function() {
				a.top.addCls("hover")
			},
			upCallback: function() {
				a.top.removeCls("hover")
			}
		});
		a.container.add(a.closeButton.getContainer())
	},
	setUpMenuButton: function() {
		var a = this;
		a.menuButton = new Interface.utils.DOMButton({
			id: a.MODULE_NAME + "SettingsButton",
			baseCSS: a.MENU_BUTTON_CSS,
			clickCallback: a.onButtonClick.bind(a)
		});
		a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
			order: a.ORDER,
			element: a.menuButton.getContainer()
		})
	},
	onButtonClick: function() {
		var a = this.model.readData("showing") ? "hide" : "show";
		this.fireEvent("view:" + a + "Request")
	},
	show: function() {
		this.wrapper.el.style.display = "block";
		this.menuButton.addProperty("active", "sectionShowing")
	},
	hide: function() {
		this.wrapper.el.style.display = "none";
		this.menuButton.removeProperty("active", "sectionShowing")
	},
	enable: function(a) {
		this.menuButton.enable(a)
	},
	disable: function(a) {
		this.menuButton.disable(a)
	},
	onUserInputStart: function() {},
	onUserInputEnd: function() {},
	onEnteringIdleState: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
			a.menuButton.enable("notInIdleState")
		}
	},
	onLeavingIdleState: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
			a.menuButton.disable("notInIdleState")
		}
	},
	onEnableBasicGamePanel: function(b) {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
			a.menuButton.enable(b)
		}
	},
	onDisableBasicGamePanel: function(b) {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
			a.menuButton.disable(b)
		}
	},
	onFeatureSplashShowing: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
			a.menuButton.disable("featureSplashShowing")
		}
	},
	onFeatureSplashClosed: function() {
		var a = this;
		if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
			a.menuButton.enable("featureSplashShowing")
		}
	}
};
Interface.StandAloneSettingsSectionView = Sys.extend(Interface.SettingsSectionView, Interface.StandAloneSettingsSectionView, "Interface.StandAloneSettingsSectionView");
Sys.ns("Interface");
Interface.CashField = {
	constructor: function() {
		Interface.CashField.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["serverResponse", "orientation"],
			desktop: ["serverResponse", "animation"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Interface.CashFieldModel,
			controller: Interface.CashFieldController,
			view: Interface.CashFieldBaseView
		}
	}
};
Interface.CashField = Sys.extend(Core.Module, Interface.CashField, "Interface.CashField");
Sys.ns("Interface");
Interface.CashFieldModel = {
	constructor: function() {
		Interface.CashFieldModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponse");
		if (a.playforfun) {
			b.storeData("funPlay", true)
		} else {
			b.storeData("funPlay", false)
		}
	},
	processServerResponse: function(a) {
		var b = this;
		b.checkAndSetState(a);
		b.storeWins(a)
	},
	checkAndSetState: function(a) {
		var b = this;
		if (Sys.isDefined(a.freeRoundsLeft)) {
			if (!b.isState("freerounds")) {
				b.setState("freerounds")
			}
		} else {
			if ((a.nextaction === "freespin" && a.clientaction !== "init")) {
				if (!b.isState("freespin")) {
					b.setState("freespin")
				}
			} else {
				if (a.clientaction === "init" && Sys.isDefined(a.freespins)) {
					if (!b.isState("freespinRestore")) {
						b.setState("freespinRestore")
					}
				} else {
					if (a.nextaction === "respin" && a.clientaction !== "init") {
						if (!b.isState("respin")) {
							b.setState("respin")
						}
					} else {
						if (a.clientaction === "respin" && a.nextaction === "spin") {
							if (!b.isState("respinLast")) {
								b.setState("respinLast")
							}
						} else {
							if (a.clientaction === "init" && a.nextaction === "respin" && !Sys.isDefined(a.freespins)) {
								if (!b.isState("respinRestore")) {
									b.setState("respinRestore")
								}
							} else {
								if (a.clientaction === "freespin" || (a.clientaction === "freespin") && a.nextaction === "spin") {
									if (!b.isState("freespinLast")) {
										b.setState("freespinLast")
									}
								} else {
									if (!b.isState("basic")) {
										b.setState("basic")
									}
								}
							}
						}
					}
				}
			}
		}
	},
	resetWins: function() {
		this.storeData("basicWinValues", {
			cents: 0,
			centsTotal: 0
		});
		this.storeData("freespinWinValues", {
			totalWinCents: 0
		})
	},
	storeWins: function(a) {
		var b = this;
		if (Sys.isDefined(a.wins)) {
			b.storeData("basicWinValues", {
				cents: a.wins.cents || 0,
				centsTotal: a.wins.centsTotal || 0
			});
			Services.storage.storeData("cashField.winInCents", a.wins.centsTotal)
		}
		if (Sys.isDefined(a.wins)) {
			b.storeData("freespinWinValues", {
				totalWinCents: a.wins.centsTotal || 0
			})
		}
		if (Sys.isDefined(a.freeRoundsLeft)) {
			b.storeData("freeroundValues", {
				left: a.freeRoundsLeft,
				totalWin: a.freeRoundsWinTot
			})
		}
	},
	setBetValues: function(a) {
		this.storeData("betValues", a)
	},
	setBalanceValues: function(a) {
		this.storeData("balanceValues", a)
	}
};
Interface.CashFieldModel = Sys.extend(Core.Model, Interface.CashFieldModel, "Interface.CashFieldModel");
Sys.ns("Interface");
Interface.CashFieldController = {
	TOGGLE_SEQUENCE: [{
		action: "creditBetWin",
		displayDuration: 10000
	}, {
		action: "funPlay",
		displayDuration: 3000
	}],
	constructor: function() {
		Interface.CashFieldController.superclass.constructor.apply(this, arguments);
		this.dispatchAppendToRequest()
	},
	init: function() {
		Interface.CashFieldController.superclass.init.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringIdleState": a.updateAllAndStartToggling.bind(a, "idle"),
			"notify:stateHandler.enteringSpinningState": a.onSpinningState,
			"notify:stateHandler.enteringBeforeLoaderCloseState": a.updateAllAndStartToggling.bind(a, "beforeLoaderClose"),
			"notify:settingsWindow.open": a.onSettingsWindowOpened,
			"notify:settingsWindow.closed": a.startToggling,
			"notify:serverManager.serverErrorReceived": a.onServerErrorReceived,
			"notify:moneyManager.betChanged": a.onBetChanged,
			"notify:moneyManager.balanceChanged": a.onBalanceChanged,
			"notify:standardWin.presentationComplete": a.updateCreditAndWin.bind(a, "idle"),
			"request:cashField.showWin": a.updateCreditAndWin.bind(a, "winPresentation")
		})
	},
	dispatchAppendToRequest: function() {
		this.fireEvent("request:balanceDisplay.appendChild", this.view.getCashDisplayConfig())
	},
	onBetChanged: function(a) {
		var b = this;
		b.model.setBetValues(a);
		b.view.updateValue("bet", b.model.readData("betValues").playerBetFormatted)
	},
	onBalanceChanged: function(a) {
		this.model.setBalanceValues(a);
		this.view.updateValue("credit", a.playerBalanceFormatted);
		this.notifyBalanceChanged(a.playerBalanceCents)
	},
	onSpinningState: function() {
		var a = this,
			b = a.model.getState();
		a[b + "UpdateCreditValue"]();
		a.resetWinValue()
	},
	onServerErrorReceived: function() {
		var b = this,
			a = b.model.getState();
		b.model.resetWins();
		b[a + "UpdateWinValues"](a)
	},
	updateCreditAndWin: function(a) {
		var b = this,
			d = b.model.getState(),
			c = Services.moneyManager.getBalanceCents();
		b[d + "UpdateCreditValue"](c);
		b[d + "UpdateWinValues"](a);
		b.notifyBalanceChanged(c)
	},
	notifyBalanceChanged: function(a) {
		this.fireEvent("notify:cashField.update", a)
	},
	updateAllAndStartToggling: function(a) {
		this.updateCreditAndWin(a);
		this.startToggling()
	},
	onFreespinOutro: function() {
		var a = this,
			b = a.model.getState();
		a[b + "UpdateCreditValue"](Services.moneyManager.getBalanceCents());
		a[b + "UpdateWinValues"]("freespinOutro")
	},
	basicUpdateWinValues: function() {
		this.updateBasicWinValue();
		this.view.showSubComponent("creditBetWin")
	},
	freespinUpdateWinValues: function() {
		this.updateFreespinWinValue()
	},
	freespinRestoreUpdateWinValues: function() {
		this.updateFreespinWinValue()
	},
	freespinLastUpdateWinValues: function() {
		this.updateFreespinWinValue()
	},
	respinUpdateWinValues: function() {
		this.updateRespinWinValue()
	},
	respinUpdateCreditValue: function() {},
	respinLastUpdateWinValues: function() {
		this.updateRespinWinValue()
	},
	respinLastUpdateCreditValue: function(a) {
		this.basicUpdateCreditValue(a)
	},
	freeroundsUpdateCreditValue: function() {
		this.view.showSubComponent("freeRounds")
	},
	freeroundsUpdateWinValues: function(b) {
		var c = this,
			d = c.model.readData("freeroundValues").left,
			a = c.model.readData("freeroundValues").totalWin;
		c.view.updateValue("freeRoundTotalWin", a);
		if (b !== "winPresentation") {
			c.view.updateValue("freeRoundLeft", d.toString())
		}
		this.view.showSubComponent("freeRounds")
	},
	freespinUpdateCreditValue: function() {},
	freespinRestoreUpdateCreditValue: function(b) {
		var a = this;
		if (!Sys.isDefined(b)) {
			b = a.model.readData("balanceValues").playerBalanceFormatted
		}
		a.view.updateValue("credit", b);
		a.view.showSubComponent("creditBetWin")
	},
	respinRestoreUpdateCreditValue: function(b) {
		var a = this;
		if (!Sys.isDefined(b)) {
			b = a.model.readData("balanceValues").playerBalanceFormatted
		}
		a.view.updateValue("credit", b);
		a.view.showSubComponent("creditBetWin")
	},
	respinRestoreUpdateWinValues: function() {
		this.updateRespinWinValue()
	},
	freespinLastUpdateCreditValue: function(a) {
		this.basicUpdateCreditValue(a)
	},
	basicUpdateCreditValue: function(b) {
		var a = this;
		if (!Sys.isDefined(b)) {
			b = a.model.readData("balanceValues").playerBalanceFormatted
		}
		a.view.updateValue("credit", b);
		a.view.showSubComponent("creditBetWin")
	},
	updateBasicWinValue: function() {
		var a = this.model.readData("basicWinValues");
		if (a.cents) {
			this.view.updateWinValue(a.cents)
		}
	},
	updateFreespinWinValue: function() {
		var a = this.model.readData("freespinWinValues");
		if (a.totalWinCents) {
			this.view.updateWinValue(a.totalWinCents)
		}
	},
	updateRespinWinValue: function() {
		var a = this.model.readData("basicWinValues");
		if (a.centsTotal) {
			this.view.updateWinValue(a.centsTotal)
		}
	},
	resetWinValue: function() {
		if (this.model.isState("basic") || this.model.isState("respinLast") || this.model.isState("freespinLast")) {
			this.view.updateWinValue(0)
		}
	},
	onSettingsWindowOpened: function() {
		var a = this;
		clearTimeout(a.toggleTimeout);
		if (a.model.isState("freerounds")) {
			a.view.showSubComponent("freeRounds")
		} else {
			a.view.showSubComponent("creditBetWin", true)
		}
	},
	startToggling: function() {
		var a = this;
		if (a.model.readData("funPlay") === true) {
			clearTimeout(a.toggleTimeout);
			a.model.storeData("nextToggleIndex", 0);
			a.showNextInToggleSequence()
		}
	},
	showNextInToggleSequence: function() {
		var c = this,
			b = c.TOGGLE_SEQUENCE,
			d = c.model.readData("nextToggleIndex"),
			a = b[d];
		c.model.storeData("nextToggleIndex", (d + 1) % b.length);
		c.view.showSubComponent(a.action, true);
		c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
	}
};
Interface.CashFieldController = Sys.extend(Core.Controller, Interface.CashFieldController, "Interface.CashFieldController");
Sys.ns("Interface");
Interface.CashFieldBaseView = {
	CSS_CLASSES: {
		BASE: "interface-cashField_base",
		PORTRAIT: "interface-cashField_portrait",
		LANDSCAPE: "interface-cashField_landscape",
		SUB_COMPONENT: "interface-cashField_subComponent"
	},
	RESOLUTION: Environment.getResolution(),
	SCREEN_SIZE: Environment.getScreenSize(),
	FIRST_CHILD: false,
	constructor: function() {
		Interface.CashFieldBaseView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Interface.CashFieldBaseView.superclass.init.apply(a, arguments);
		a.displays = a.getDisplayConfig();
		a.getLocalText = function(b) {
			return Services.languageManager.getText(b)
		};
		a.getFormattedCentsValue = function(b, c) {
			return Services.moneyManager.formatMoneyCurrencySign(b, c)
		};
		a.constructDOMElements()
	},
	showSubComponent: function(b, d) {
		var c = this,
			a = c.model.readData("currentlyShowingElement");
		if ((!c.model.readData("funPlay") && a !== c[b]) || (a !== c[b] && c.model.readData("funPlay") && d)) {
			if (Sys.isDefined(a)) {
				c.hideElement(a)
			}
			c.showElement(c[b]);
			c.model.storeData("currentlyShowingElement", c[b])
		}
	},
	hideElement: function(a) {
		a.el.style.visibility = "hidden"
	},
	showElement: function(a) {
		a.el.style.visibility = "visible"
	},
	getDisplayConfig: function() {
		var a = this;
		return {
			credit: {
				wrapper: a.creditWrapper,
				displayID: "credit",
				textID: Language.Keys.cashColonVar,
				display: {},
				stringValue: "",
				valueElement: {}
			},
			bet: {
				wrapper: a.betWrapper,
				displayID: "bet",
				textID: Language.Keys.betColonVar,
				display: {},
				stringValue: "",
				valueElement: {}
			},
			win: {
				wrapper: a.winWrapper,
				displayID: "win",
				textID: Language.Keys.winColonVar,
				display: {},
				stringValue: "",
				valueElement: {}
			},
			funPlay: {
				wrapper: a.funPlayWrapper,
				displayID: "funPlay",
				textID: Language.Keys.playingForFun,
				display: {}
			},
			freeRoundLeft: {
				wrapper: a.freeRoundLeftWrapper,
				displayID: "freeRoundLeft",
				textID: Language.Keys.freeRoundsLeftColon,
				display: {},
				stringValue: "",
				valueElement: {}
			},
			freeRoundTotalWin: {
				wrapper: a.freeRoundTotalWinWrapper,
				displayID: "freeRoundTotalWin",
				textID: Language.Keys.totalWinColonVar,
				display: {},
				stringValue: "",
				valueElement: {}
			}
		}
	},
	getCashDisplayConfig: function() {
		return this.cashDisplay
	},
	constructDOMElements: function() {
		var b = this,
			a = b.displays;
		b.cashDisplay = new Sys.Element({
			tag: "div",
			cls: b.CSS_CLASSES.BASE
		});
		b.creditBetWin = new Sys.Element({
			tag: "div",
			cls: b.CSS_CLASSES.SUB_COMPONENT,
			style: "visibility:hidden;"
		});
		b.freeRounds = new Sys.Element({
			tag: "div",
			cls: b.CSS_CLASSES.SUB_COMPONENT,
			style: "visibility:hidden;"
		});
		b.funPlay = new Sys.Element({
			tag: "div",
			cls: b.CSS_CLASSES.SUB_COMPONENT,
			style: "visibility:hidden;"
		});
		b.constructElement(a.credit);
		b.constructElement(a.bet);
		b.constructElement(a.win);
		b.constructElement(a.funPlay);
		b.constructElement(a.freeRoundLeft);
		b.constructElement(a.freeRoundTotalWin);
		b.creditBetWin.add(a.credit.wrapper);
		b.creditBetWin.add(a.bet.wrapper);
		b.creditBetWin.add(a.win.wrapper);
		b.updateWinValue(0);
		b.cashDisplay.add(b.creditBetWin);
		b.freeRounds.add(a.freeRoundLeft.wrapper);
		b.freeRounds.add(a.freeRoundTotalWin.wrapper);
		b.cashDisplay.add(b.freeRounds);
		b.funPlay.add(a.funPlay.wrapper);
		b.cashDisplay.add(b.funPlay)
	},
	constructTextElement: function(b, f, g) {
		var d = this,
			e = [],
			c, a;
		if (b.contains("{0}")) {
			a = d.getTextStringOrder(b);
			Sys.each(a, function(h) {
				if (Sys.isString(h)) {
					e.push(c = new Sys.Element({
						tag: "span",
						cls: "text"
					}));
					c.el.textContent = h
				} else {
					if (Sys.isNumber(h)) {
						e.push(c = new Sys.Element({
							tag: "span",
							cls: "text value"
						}));
						c.el.textContent = f || "";
						g.valueElement = c
					}
				}
			})
		} else {
			e.push(c = new Sys.Element({
				tag: "span",
				cls: "text"
			}));
			c.el.textContent = b
		}
		return e
	},
	constructTextValueWrapper: function() {
		var b = "margin-right:2%;",
			a = "margin-left:2%;";
		return new Sys.Element({
			tag: "div",
			cls: "wrapper",
			style: b + a
		})
	},
	constructElement: function(f) {
		var e = this,
			d, c = (!e.debug) ? e.getLocalText(f.textID) : e.worstCaseSpec[f.displayID].text,
			a = (!e.debug) ? f.value : e.worstCaseSpec[f.displayID].value,
			b = e.constructTextValueWrapper();
		f.wrapper = new Sys.Element({
			tag: "span"
		});
		f.wrapper.addCls("inline");
		f.wrapper.addCls("field");
		f.wrapper.addCls(f.displayID);
		d = e.constructTextElement(c, a, f);
		Sys.each(d, function(g) {
			b.add(g)
		});
		f.wrapper.add(b)
	},
	updateValue: function(b, a) {
		a = (Sys.isNumber(a)) ? this.getFormattedCentsValue(a) : a;
		if (this.displays[b].valueElement.el) {
			this.displays[b].valueElement.el.textContent = a
		}
	},
	updateWinValue: function(a) {
		var b = this;
		if (a >= 0) {
			a = b.getFormattedCentsValue(a)
		} else {}
		if (b.displays.win.valueElement.el) {
			b.displays.win.valueElement.el.textContent = a
		}
	},
	onPortrait: function() {
		var b = this,
			a = b.CSS_CLASSES,
			c = b.cashDisplay;
		c.addCls(a.PORTRAIT);
		c.removeCls(a.LANDSCAPE)
	},
	onLandscape: function() {
		var b = this,
			a = b.CSS_CLASSES,
			c = b.cashDisplay;
		c.addCls(a.LANDSCAPE);
		c.removeCls(a.PORTRAIT)
	},
	getTextStringOrder: function(e) {
		var b = [],
			d = /(\{\d+\})/g,
			a = e.split(d),
			c;
		Sys.each(a, function(f) {
			if (f.match(/\{\d+\}/)) {
				c = f.substring(1, f.length - 1);
				b.push(Sys.utils.toInt(c))
			} else {
				if (e.length > 0) {
					b.push(f)
				}
			}
		});
		return b
	}
};
Interface.CashFieldBaseView = Sys.extend(Core.View, Interface.CashFieldBaseView, "Interface.CashFieldBaseView");
Sys.ns("Interface");
Interface.CashFieldMobileView = {
	CSS_CLASSES: {
		BASE: "interface-cashField_base interface-cashField_mobile",
		PORTRAIT: "interface-cashField_portrait_mobile",
		LANDSCAPE: "interface-cashField_landscape",
		SUB_COMPONENT: "interface-cashField_subComponent"
	},
	constructor: function() {
		Interface.CashFieldMobileView.superclass.constructor.apply(this, arguments)
	}
};
Interface.CashFieldMobileView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldMobileView, "Interface.CashFieldMobileView");
Sys.ns("Interface");
Interface.CashFieldTabletView = {
	CSS_CLASSES: {
		BASE: "interface-cashField_base interface-cashField_tablet",
		PORTRAIT: "interface-cashField_portrait interface-cashField_portrait interface-cashField_tablet",
		LANDSCAPE: "interface-cashField_landscape interface-cashField_landscape interface-cashField_tablet",
		SUB_COMPONENT: "interface-cashField_subComponent"
	},
	constructor: function() {
		Interface.CashFieldTabletView.superclass.constructor.apply(this, arguments)
	}
};
Interface.CashFieldTabletView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldTabletView, "Interface.CashFieldTabletView");
Sys.ns("Interface");
Interface.CashFieldDesktopView = {
	CSS_CLASSES: {
		BASE: "interface-cashField_base interface-cashField_desktop interface-cashField_desktop_uri",
		PORTRAIT: "",
		LANDSCAPE: "",
		SUB_COMPONENT: "interface-cashField_subComponent"
	},
	constructor: function() {
		Interface.CashFieldDesktopView.superclass.constructor.apply(this, arguments)
	}
};
Interface.CashFieldDesktopView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldDesktopView, "Interface.CashFieldDesktopView");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsField = {
	constructor: function() {
		Interface.Slots.CoinsField.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["serverResponse", "orientation"],
			desktop: ["serverResponse", "animation"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Interface.Slots.CoinsFieldModel,
			controller: Interface.Slots.CoinsFieldController,
			view: Interface.Slots.CoinsFieldBaseView
		}
	}
};
Interface.Slots.CoinsField = Sys.extend(Core.Module, Interface.Slots.CoinsField, "Interface.Slots.CoinsField");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldModel = {
	WIN_UP_TO: "[MAX COIN WIN]",
	constructor: function() {
		Interface.Slots.CoinsFieldModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.storeData("gameMode", "BASIC")
	},
	processServerResponse: function(b) {
		var a = this;
		if (Sys.isDefined(b.wins)) {
			if (Sys.isDefined(b.wins.coinsTotal)) {
				a.storeData("totalWin", b.wins.coinsTotal)
			} else {
				a.storeData("totalWin", "")
			}
			if (Sys.isDefined(b.wins.coins)) {
				a.storeData("win", b.wins.coins)
			} else {
				a.storeData("win", 0)
			}
			if (Sys.isDefined(b.wins.freespins)) {
				a.storeData("additionalFreeSpins", b.wins.freespins)
			} else {
				a.storeData("additionalFreeSpins", 0)
			}
		}
		if (Sys.isDefined(b.freespins) && Sys.isDefined(b.freespins.left)) {
			a.storeData("freeSpinsLeft", b.freespins.left)
		} else {
			a.storeData("freeSpinsLeft", 0)
		}
	},
	setWinToTotalWin: function() {
		this.storeData("win", this.readData("totalWin"))
	},
	getBetText: function() {
		return Services.moneyManager.getBetCoins()
	},
	getBalanceText: function() {
		return Services.moneyManager.getBalanceCoins()
	},
	getWinText: function() {
		var a = this.readData("win");
		return a === 0 ? "" : a
	},
	getProgressiveWinText: function() {
		return this.readData("win")
	},
	getTotalWinText: function() {
		return this.readData("totalWin")
	},
	getTotalWinCountUpValues: function() {
		var b = this.readData("win"),
			a = this.readData("totalWin");
		return {
			from: a - b,
			to: a
		}
	},
	getFreeSpinsLeftText: function() {
		return this.readData("freeSpinsLeft")
	},
	getAdditionalFreeSpinsWonText: function() {
		return this.readData("additionalFreeSpins")
	},
	getWinUpToText: function() {
		return this.WIN_UP_TO
	}
};
Interface.Slots.CoinsFieldModel = Sys.extend(Core.Model, Interface.Slots.CoinsFieldModel, "Interface.Slots.CoinsFieldModel");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldController = {
	TOGGLE_SEQUENCE: [{
		action: "showWin",
		displayDuration: 3000
	}, {
		action: "showBalanceAndBet",
		displayDuration: 3000
	}, {
		action: "showWinUpTo",
		displayDuration: 3000
	}, {
		action: "showBalanceAndBet",
		displayDuration: 3000
	}],
	constructor: function() {
		Interface.Slots.CoinsFieldController.superclass.constructor.apply(this, arguments);
		this.view.setupView()
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
			"notify:stateHandler.enteringFreeSpinIntroState": a.onEnteringFreeSpinIntroState,
			"notify:stateHandler.enteringSpinningState": a.onEnteringSpinningState,
			"notify:moneyManager.betChanged": a.onInfoChanged,
			"notify:settingsWindow.open": a.onSettingsWindowOpened,
			"notify:settingsWindow.closed": a.onSettingsWindowClosed,
			"request:coinsField.showWin": a.onShowWinRequest,
			"request:coinsField.showNormalWin": a.onShowNormalWinRequest,
			"request:coinsField.showProgressiveWin": a.onShowProgressiveWinRequest,
			"request:coinsField.showFreeSpinsLeft": a.showFreeSpinsLeft,
			"request:coinsField.showAdditionalFreeSpinsWon": a.showAdditionalFreeSpinsWon,
			"request:coinsField.countUp": a.view.countUpProgressiveWin.bind(a.view),
			"notify:gameModeChanged": a.onGameModeChanged,
			"view:appendToGameFooter": a.fireEvent.bind(a, "request:balanceDisplay.appendChild"),
			"view:setCountUpCallback": a.fireEvent.bind(a, "request:coinsFieldCountUp.setCallback"),
			"view:startCountUp": a.fireEvent.bind(a, "request:coinsFieldCountUp.start"),
			"view:stopCountUp": a.fireEvent.bind(a, "request:coinsFieldCountUp.stop"),
			"view:countUpComplete": a.fireEvent.bind(a, "notify:coinsField.countUpComplete")
		})
	},
	onBeforeLoaderClose: function() {
		this.showBalanceAndBet()
	},
	onEnteringIdleState: function() {
		var a = this;
		if (a.model.readData("showProgressiveWinDisplay")) {
			a.model.storeData("showProgressiveWinDisplay", false);
			a.model.setWinToTotalWin()
		}
		if (a.model.readData("hasPlayedInitialRound")) {
			a.startToggling()
		} else {
			a.showBalanceAndBet()
		}
	},
	onEnteringSpinningState: function() {
		var a = this;
		clearTimeout(a.toggleTimeout);
		a.model.storeData("hasPlayedInitialRound", true);
		a.model.storeData("win", "");
		if (a.model.readData("showProgressiveWinDisplay")) {
			a.showProgressiveWin()
		} else {
			a.showBalanceAndBet()
		}
	},
	onEnteringFreeSpinIntroState: function() {
		this.view.onEnteringFreeSpinIntroState()
	},
	onInfoChanged: function() {
		this.view.showBalanceAndBet()
	},
	onSettingsWindowOpened: function() {
		clearTimeout(this.toggleTimeout);
		this.showBalanceAndBet()
	},
	onShowWinRequest: function() {
		if (this.model.readData("showProgressiveWinDisplay")) {
			this.showProgressiveWin()
		} else {
			this.showWin()
		}
	},
	onShowNormalWinRequest: function() {
		var a = this.model;
		if (a.readData("showProgressiveWinDisplay")) {
			a.storeData("showProgressiveWinDisplay", false);
			a.setWinToTotalWin()
		}
		this.showWin()
	},
	onShowProgressiveWinRequest: function(a) {
		this.model.storeData("showProgressiveWinDisplay", true);
		this.showProgressiveWin(a)
	},
	showBalanceAndBet: function() {
		this.view.showBalanceAndBet()
	},
	showWin: function() {
		this.view.showWin()
	},
	showProgressiveWin: function(a) {
		if (a) {
			this.model.storeData("win", "")
		}
		this.view.showProgressiveWin()
	},
	showFreeSpinsLeft: function() {
		this.view.showFreeSpinsLeft()
	},
	showAdditionalFreeSpinsWon: function() {
		this.view.showAdditionalFreeSpinsWon()
	},
	startToggling: function() {
		this.model.storeData("nextToggleIndex", 0);
		this.showNextInToggleSequence()
	},
	showNextInToggleSequence: function() {
		var c = this,
			b = c.TOGGLE_SEQUENCE,
			d = c.model.readData("nextToggleIndex"),
			a = b[d];
		c.model.storeData("nextToggleIndex", (d + 1) % b.length);
		c.view[a.action]();
		c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
	},
	onGameModeChanged: function(a) {
		this.model.storeData("gameMode", a);
		this.view.onGameModeChanged(a)
	}
};
Interface.Slots.CoinsFieldController = Sys.extend(Core.Controller, Interface.Slots.CoinsFieldController, "Interface.Slots.CoinsFieldController");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldBaseView = {
	BASE_CSS: "interface-coinsField_base",
	BACKGROUND_URI: "interface-coinsField_uri",
	PORTRAIT_CSS: "interface-coinsField_portrait",
	LANDSCAPE_CSS: "interface-coinsField_landscape",
	SUB_COMPONENT_CSS: "interface-coinsField_subComponent",
	constructor: function() {
		Interface.Slots.CoinsFieldBaseView.superclass.constructor.apply(this, arguments)
	},
	setupView: function() {
		var d = this,
			g = 0,
			f = "<span class='number'></span>",
			e = "<div class='number' style='display: inline-block; text-align: left; min-width: 3em;'></div>",
			b = "<span class='number'>" + d.model.getWinUpToText() + "</span>",
			c = "margin-right:2%;",
			a = "margin-left:2%;";
		d.container = new Sys.Element({
			id: "coinsField",
			tag: "div",
			cls: d.BASE_CSS + " " + d.BACKGROUND_URI
		});
		d.betAndBalance = d.container.add(new Sys.Element({
			id: "coinsField_betAndBalance",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			style: "visibility:hidden; z-index:" + (g++) + ";"
		}));
		d.balanceDisplay = d.betAndBalance.add(new Sys.Element({
			id: "coinsField_betAndBalance_balanceDisplay",
			tag: "span",
			innerHTML: Services.languageManager.getText(Language.Keys.coinsColonVar).replace("{0}", f),
			style: c
		}));
		d.betDisplay = d.betAndBalance.add(new Sys.Element({
			id: "coinsField_betAndBalance_betDisplay",
			tag: "span",
			innerHTML: Services.languageManager.getText(Language.Keys.betColonVar).replace("{0}", f),
			style: a
		}));
		d.balanceCoinsElement = d.balanceDisplay.el.getElementsByTagName("span")[0] || document.createElement("span");
		d.betCoinsElement = d.betDisplay.el.getElementsByTagName("span")[0] || document.createElement("span");
		d.win = d.container.add(new Sys.Element({
			id: "coinsField_win",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			innerHTML: Services.languageManager.getText(Language.Keys.winColonVar).replace("{0}", f),
			style: "visibility:hidden; z-index:" + (g++) + ";"
		}));
		d.winCoinsElement = d.win.el.getElementsByTagName("span")[0] || document.createElement("span");
		d.youWon = d.container.add(new Sys.Element({
			id: "coinsField_youWon",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			innerHTML: Services.languageManager.getText(Language.Keys.youWonCoins).replace("{0}", f),
			style: "visibility:hidden; z-index:" + (g++) + ";"
		}));
		d.youWonCoinsElement = d.youWon.el.getElementsByTagName("span")[0] || document.createElement("span");
		d.progressiveWin = d.container.add(new Sys.Element({
			id: "coinsField_progressiveWin",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			style: "visibility:hidden; z-index:" + (g++) + ";"
		}));
		d.progressiveWinDisplay = d.progressiveWin.add(new Sys.Element({
			id: "coinsField_progressiveWin_winDisplay",
			tag: "span",
			innerHTML: Services.languageManager.getText(Language.Keys.winColonVar).replace("{0}", e),
			style: c
		}));
		d.totalWinDisplay = d.progressiveWin.add(new Sys.Element({
			id: "coinsField_progressiveWin_totalWinDisplay",
			tag: "span",
			innerHTML: Services.languageManager.getText(Language.Keys.totalWinColonVar).replace("{0}", e),
			style: a
		}));
		d.progressiveWinCoinsElement = d.progressiveWinDisplay.el.getElementsByTagName("div")[0] || document.createElement("div");
		d.totalWinCoinsElement = d.totalWinDisplay.el.getElementsByTagName("div")[0] || document.createElement("div");
		d.freeSpinsLeft = d.container.add(new Sys.Element({
			id: "coinsField_freeSpinsLeft",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			innerHTML: Services.languageManager.getText(Language.Keys.freeSpinsLeftColonVar).replace("{0}", f),
			style: "visibility:hidden; z-index:" + (g++) + ";"
		}));
		d.freeSpinsLeftNumberElement = d.freeSpinsLeft.el.getElementsByTagName("span")[0] || document.createElement("span");
		d.additionalFreeSpinsWon = d.container.add(new Sys.Element({
			id: "coinsField_additionalFreeSpinsWon",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			innerHTML: Services.languageManager.getText(Language.Keys.additonalFreeSpinsWon).replace("{0}", f),
			style: "visibility:hidden; z-index:" + (g++) + ";"
		}));
		d.additionalFreeSpinsNumberElement = d.additionalFreeSpinsWon.el.getElementsByTagName("span")[0] || document.createElement("span");
		d.winUpTo = d.container.add(new Sys.Element({
			id: "coinsField_winUpTo",
			tag: "div",
			cls: d.SUB_COMPONENT_CSS,
			innerHTML: Services.languageManager.getText(Language.Keys.winUpTo).replace("{0}", b),
			style: "visibility:hidden; z-index:" + g + ";"
		}));
		d.fireEvent("view:appendToGameFooter", d.container)
	},
	showBalanceAndBet: function() {
		var a = this;
		a.betCoinsElement.textContent = a.model.getBetText();
		a.balanceCoinsElement.textContent = a.model.getBalanceText();
		a.show(a.betAndBalance)
	},
	showWin: function() {
		var a = this,
			b = a.model.getWinText();
		if (b > 0) {
			a.youWonCoinsElement.textContent = b;
			a.show(a.youWon)
		} else {
			a.winCoinsElement.textContent = b;
			a.show(a.win)
		}
	},
	showProgressiveWin: function() {
		var a = this;
		a.fireEvent("view:stopCountUp");
		a.progressiveWinCoinsElement.textContent = a.model.getProgressiveWinText();
		a.totalWinCoinsElement.textContent = a.model.getTotalWinText();
		a.show(a.progressiveWin)
	},
	countUpCallback: function(a) {
		this.totalWinCoinsElement.textContent = a
	},
	countUpProgressiveWin: function(c) {
		var b = this,
			a = b.model.getTotalWinCountUpValues();
		if (!b.model.readData("hasRegisteredCallback")) {
			b.fireEvent("view:setCountUpCallback", b.countUpCallback.bind(b));
			b.model.storeData("hasRegisteredCallback", true)
		}
		a.duration = c;
		a.fireEventsOnValue = [{
			value: a.to,
			event: "view:countUpComplete",
			scope: b
		}];
		b.progressiveWinCoinsElement.textContent = b.model.getProgressiveWinText();
		b.fireEvent("view:startCountUp", a)
	},
	showFreeSpinsLeft: function() {
		var a = this;
		a.freeSpinsLeftNumberElement.textContent = a.model.getFreeSpinsLeftText();
		a.show(a.freeSpinsLeft)
	},
	showAdditionalFreeSpinsWon: function() {
		var a = this;
		a.additionalFreeSpinsNumberElement.textContent = a.model.getAdditionalFreeSpinsWonText();
		a.show(a.additionalFreeSpinsWon)
	},
	showWinUpTo: function() {
		this.show(this.winUpTo)
	},
	show: function(b) {
		var c = this,
			a = c.model.readData("currentlyShowingElement");
		if (a !== b) {
			if (Sys.isDefined(a)) {
				c.hideElement(a)
			}
			c.showElement(b);
			c.model.storeData("currentlyShowingElement", b)
		}
	},
	hideElement: function(a) {
		a.el.style.visibility = "hidden"
	},
	showElement: function(a) {
		a.el.style.visibility = "visible"
	},
	onEnteringFreeSpinIntroState: function() {},
	onGameModeChanged: function() {}
};
Interface.Slots.CoinsFieldBaseView = Sys.extend(Core.View, Interface.Slots.CoinsFieldBaseView, "Interface.Slots.CoinsFieldBaseView");
Sys.ns("interface.Slots");
Interface.Slots.CoinsFieldMobileView = {
	BASE_CSS: "interface-coinsField_base interface-coinsField_mobile",
	PORTRAIT_CSS: "interface-coinsField_portrait_mobile",
	LANDSCAPE_CSS: "interface-coinsField_landscape_mobile",
	constructor: function() {
		Interface.Slots.CoinsFieldMobileView.superclass.constructor.apply(this, arguments)
	}
};
Interface.Slots.CoinsFieldMobileView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Interface.Slots.CoinsFieldMobileView, "Interface.Slots.CoinsFieldMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldDesktopView = {
	GAME_MODES: ["BASIC", "FREESPIN"],
	BASIC_BET_LABEL: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 160,
			y: 615,
			width: 267,
			height: 133
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	BASIC_BET_VALUE: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 160,
			y: 643,
			width: 267,
			height: 133
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	BASIC_BALANCE_LABEL: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 1071,
			y: 615,
			width: 267,
			height: 133
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	BASIC_BALANCE_VALUE: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 1071,
			y: 643,
			width: 267,
			height: 133
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	BASIC_BACKGROUND: {
		image: "keypadBackground",
		position: {
			x: 7,
			y: 606,
			width: 1265,
			height: 84
		}
	},
	FREESPIN_BET_LABEL: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 25,
			y: 656,
			width: 100,
			height: 20
		},
		alignment: {
			horizontal: "right",
			vertical: false
		}
	},
	FREESPIN_BET_VALUE: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 133,
			y: 656,
			width: 267,
			height: 20
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	FREESPIN_BALANCE_LABEL: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 1000,
			y: 656,
			width: 100,
			height: 20
		},
		alignment: {
			horizontal: "right",
			vertical: false
		}
	},
	FREESPIN_BALANCE_VALUE: {
		font: "10px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 1107,
			y: 656,
			width: 267,
			height: 20
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	FREESPIN_WIN_LABEL: {
		font: "15px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 530,
			y: 580,
			width: 120,
			height: 40
		},
		alignment: {
			horizontal: "right",
			vertical: true
		}
	},
	FREESPIN_WIN_VALUE: {
		font: "22px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 663,
			y: 580,
			width: 150,
			height: 40
		},
		alignment: {
			horizontal: "left",
			vertical: true
		}
	},
	FREESPIN_TOTAL_WIN_LABEL: {
		font: "15px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 530,
			y: 623,
			width: 120,
			height: 40
		},
		alignment: {
			horizontal: "right",
			vertical: true
		}
	},
	FREESPIN_TOTAL_WIN_VALUE: {
		font: "22px Verdana",
		fillstyle: "rgba( 255, 255, 255, 1 )",
		position: {
			x: 663,
			y: 623,
			width: 150,
			height: 40
		},
		alignment: {
			horizontal: "left",
			vertical: true
		}
	},
	FREESPIN_BACKGROUND: {
		image: "keypadFreeSpinBackground",
		position: {
			x: 429,
			y: 567,
			width: 421,
			height: 114
		}
	},
	constructor: function() {
		Interface.Slots.CoinsFieldDesktopView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.initBackground();
		a.initTexts();
		a.onGameModeChanged("BASIC")
	},
	initBackground: function() {
		var h = this,
			c = h.getKeypadLayering(),
			g = new Animation.List({}),
			a = {},
			b = h.GAME_MODES,
			e, d, f, j;
		for (d = -1, f = b.length; ++d < f;) {
			e = b[d];
			j = h[e + "_BACKGROUND"].position;
			a[b[d]] = new Animation.Item({
				top: j.y,
				left: j.x,
				width: j.width,
				height: j.height,
				depth: c["background_" + e.toLowerCase()],
				image: h[e + "_BACKGROUND"].image
			});
			g.add(a[b[d]])
		}
		Game.stage.view.addToRenderLoop(g);
		h.backgroundItems = a
	},
	getKeypadLayering: function() {
		return Layering.Game.Slots.Keypad
	},
	getMainTypes: function() {
		var a = this;
		return {
			BET: {
				LABEL: {
					defaultMode: "FREESPIN",
					content: function() {
						return Services.languageManager.getText(Language.Keys.machinetext_bet)
					}
				},
				VALUE: {
					defaultMode: "FREESPIN",
					content: function() {
						return a.model.getBetText()
					}
				}
			},
			BALANCE: {
				LABEL: {
					defaultMode: "FREESPIN",
					content: function() {
						return Services.languageManager.getText(Language.Keys.machinetext_coins)
					}
				},
				VALUE: {
					defaultMode: "FREESPIN",
					content: function() {
						return a.model.getBalanceText()
					}
				}
			},
			WIN: {
				LABEL: {
					modes: ["FREESPIN"],
					defaultMode: "FREESPIN",
					content: function() {
						return Services.languageManager.getText(Language.Keys.winColon_uc)
					}
				},
				VALUE: {
					modes: ["FREESPIN"],
					defaultMode: "FREESPIN",
					content: function() {
						return a.model.getWinText()
					}
				}
			},
			TOTAL_WIN: {
				LABEL: {
					modes: ["FREESPIN"],
					defaultMode: "FREESPIN",
					content: function() {
						return Services.languageManager.getText(Language.Keys.totalWinColon_uc)
					}
				},
				VALUE: {
					modes: ["FREESPIN"],
					defaultMode: "FREESPIN",
					content: function() {
						return a.model.getTotalWinText()
					}
				}
			}
		}
	},
	initTexts: function() {
		var f = this,
			g = new Animation.List({}),
			d = f.GAME_MODES,
			a = d.length,
			e = {},
			c, b;
		for (b = -1; ++b < a;) {
			c = d[b];
			e[c] = f.getTextsForGameMode(c, g)
		}
		f.textItems = e;
		f.updateTexts();
		Game.stage.view.addToRenderLoop(g)
	},
	getTextsForGameMode: function(k, f) {
		var h = this,
			b = h.getKeypadLayering(),
			g = h.getMainTypes(),
			j = Object.keys(g),
			d = j.length,
			a = {},
			e, c;
		for (c = -1; ++c < d;) {
			e = j[c];
			a[e] = h.createTextItems(e, g[e], b[e.toLowerCase()], f, k)
		}
		return a
	},
	createTextItems: function(j, f, s, o, k) {
		var q = this,
			c = {},
			l, b, a, g, h, t = Object.keys(f),
			n = t.length,
			e, r, p, d, m;
		for (m = -1; ++m < n;) {
			e = t[m];
			l = f[e];
			b = Sys.isDefined(l.defaultMode) ? l.defaultMode : false;
			a = k + "_" + j + "_" + e;
			g = b + "_" + j + "_" + e;
			r = Sys.isDefined(q[a]) ? q[a].position : q[g].position;
			h = q.getAlignment(a, g);
			if (Sys.isObj(l) && Sys.isArray(l.modes)) {
				if (l.modes.contains(k)) {
					l = l.content
				} else {
					continue
				}
			}
			p = this.initTextItem(r.width, r.height, r.x, r.y, s, b, h);
			d = (typeof l === "function") ? l : l.content;
			c[e] = {
				item: p,
				valueFunction: d
			};
			o.add(p);
			p.stop()
		}
		return c
	},
	updateTexts: function() {
		var d = this,
			c = d.GAME_MODES,
			e = d.model.readData("gameMode"),
			a = c.length,
			b;
		if (Sys.isDefined(d.textItems)) {
			for (b = -1; ++b < a;) {
				d.updateMainTypesTexts(d.textItems[c[b]], e, (c[b] === e))
			}
		}
	},
	updateMainTypesTexts: function(a, d, b) {
		var g = Object.keys(a),
			f = g.length,
			e, c;
		for (c = -1; ++c < f;) {
			e = g[c];
			this.updateSubTypeTexts(a[e], d, b, e)
		}
	},
	updateSubTypeTexts: function(h, j, f, e) {
		var n = this,
			k = Object.keys(h),
			r = k.length,
			p, m, q, b, g, a, d, c, o, l;
		for (g = -1; ++g < r;) {
			p = k[g];
			m = h[p];
			q = m.item;
			b = q.prop;
			a = j + "_" + e + "_" + p;
			d = b.customProps.defaultMainType + "_" + e + "_" + p;
			c = (Sys.isDefined(n[a]) ? n[a].font : n[d].font);
			o = (Sys.isDefined(n[a]) ? n[a].fillstyle : n[d].fillstyle);
			l = n.getAlignment(a, d);
			if (f) {
				n.updateTextItem(q, m.valueFunction.call(n), c, o, l);
				if (!q.prop.running) {
					q.play()
				}
			} else {
				q.stop()
			}
		}
	},
	initTextItem: function(a, j, g, f, c, h, d) {
		var e = this,
			b = e.getInMemoryCanvas(a, j);
		if (Sys.isDefined(d)) {
			b.ctx.textAlign = d.horizontal
		}
		return new Animation.Item({
			top: f,
			left: g,
			width: a,
			height: j,
			depth: c,
			image: b.canvas,
			customProps: {
				inMemCanvas: b,
				defaultMainType: h,
				alignment: d
			}
		})
	},
	updateTextItem: function(m, b, c, l, e, j) {
		var a = m.prop,
			h = Sys.isDefined(e) ? e : {
				horizontal: "left",
				vertical: false
			},
			g = h.horizontal === "right" ? a.width : 0,
			d = a.customProps.inMemCanvas,
			f = Animation.utils.text.measureText(b.toString(), c, 0, d.ctx).height / 2,
			k = Sys.isDefined(j) ? j : 20;
		d.ctx.clearRect(0, 0, d.canvas.width, d.canvas.height);
		Animation.utils.text.wrapCanvasText(b.toString(), c, g, f, a.width, k, [{
			fillStyle: l,
			drawType: "fill"
		}], d.ctx, h.vertical)
	},
	getInMemoryCanvas: function(d, a) {
		var c = document.createElement("canvas"),
			b = c.getContext("2d");
		c.width = d;
		c.height = a;
		return {
			canvas: c,
			ctx: b
		}
	},
	showBalanceAndBet: function() {
		this.updateTexts()
	},
	showWin: function() {
		this.updateTexts()
	},
	onGameModeChanged: function(g) {
		var f = this,
			b = f.backgroundItems,
			d = f.GAME_MODES,
			c, e, a;
		for (c = -1, a = d.length; ++c < a;) {
			e = b[d[c]];
			if (d[c] === g) {
				e.play()
			} else {
				e.stop()
			}
		}
		this.updateTexts()
	},
	showProgressiveWin: function() {
		this.updateTexts()
	},
	getAlignment: function(b, a) {
		var c = this;
		return Sys.isDefined(c[b]) ? c[b].alignment : c[a].alignment
	},
	countUpCallback: function() {},
	countUpProgressiveWin: function() {
		this.fireEvent("view:countUpComplete")
	},
	showFreeSpinsLeft: function() {},
	showAdditionalFreeSpinsWon: function() {},
	showWinUpTo: function() {},
	show: function() {},
	hideElement: function() {},
	showElement: function() {},
	setupView: function() {}
};
Interface.Slots.CoinsFieldDesktopView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Interface.Slots.CoinsFieldDesktopView, "Interface.Slots.CoinsFieldDesktopView");
Sys.ns("Interface");
Interface.SettingsWindow = {
	constructor: function() {
		Interface.SettingsWindow.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SettingsWindowController,
			model: Interface.SettingsWindowModel,
			view: Interface.SettingsWindowBaseView
		}
	},
	getMixinDependencies: function() {
		return ["orientation"]
	}
};
Interface.SettingsWindow = Sys.extend(Core.Module, Interface.SettingsWindow, "Interface.SettingsWindow");
Sys.ns("Interface");
Interface.SettingsWindowController = {
	constructor: function() {
		Interface.SettingsWindowController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:opened": a.opened,
			"view:close": a.onCloseRequest,
			"view:closed": a.closed,
			"request:settingsWindow.open": a.onOpenRequest,
			"request:settingsWindow.close": a.onCloseRequest,
			"request:settingsWindow.openChild": a.onOpenChildRequest,
			"request:settingsWindow.closeChild": a.onCloseChildRequest,
			"request:settingsWindow.addChild": a.addChild,
			"request:settingsWindow.removeChild": a.removeChild,
			"request:settingsWindow.activateChild": a.activateChild,
			"request:settingsWindow.deactivateChild": a.deactivateChild
		})
	},
	onOpenRequest: function() {
		var a = this;
		if (!a.model.readData("open")) {
			a.open(this.model.readData("currentlyShowingChild"))
		}
	},
	onOpenChildRequest: function(d, a) {
		var b = this,
			c = b.model.isActiveChild(d);
		if (c) {
			if (!b.model.readData("open")) {
				b.open(d, a)
			} else {
				b.openChild(d, a)
			}
		}
	},
	onCloseRequest: function() {
		var a = this;
		if (a.model.readData("open")) {
			a.close()
		}
	},
	onCloseChildRequest: function(b) {
		var a = this;
		if (b === a.model.readData("currentlyShowingChild")) {
			a.close()
		}
	},
	open: function(c, a) {
		var b = this;
		b.model.storeData("open", true);
		b.view.open();
		if (Sys.isDefined(c)) {
			b.openChild(c, a)
		}
	},
	openChild: function(a, c) {
		var d = this,
			b = d.model.readData("currentlyShowingChild");
		if (b !== a) {
			d.model.storeData("currentlyShowingChild", a);
			d.closeChild(b)
		}
		d.fireEvent("notify:settingsWindow.openedChild", a, c);
		d.view.showChild(a)
	},
	close: function() {
		var a = this;
		a.model.storeData("open", false);
		a.closeChild(a.model.readData("currentlyShowingChild"));
		a.view.close()
	},
	closeChild: function(a) {
		this.fireEvent("notify:settingsWindow.closedChild", a)
	},
	opened: function() {
		this.fireEvent("notify:settingsWindow.open")
	},
	closed: function() {
		this.fireEvent("notify:settingsWindow.closed")
	},
	addChild: function(b, a) {
		this.model.addChild(b, a);
		this.view.addChild(a)
	},
	removeChild: function(a) {
		this.view.removeChild(a);
		this.model.removeChild(a)
	},
	activateChild: function(a) {
		this.model.activateChild(a)
	},
	deactivateChild: function(a) {
		this.model.deactivateChild(a)
	}
};
Interface.SettingsWindowController = Sys.extend(Core.Controller, Interface.SettingsWindowController, "Interface.SettingsWindowController");
Sys.ns("Interface");
Interface.SettingsWindowModel = {
	constructor: function() {
		Interface.SettingsWindowModel.superclass.constructor.apply(this, arguments)
	},
	addChild: function(c, a) {
		var b = this.readData("children");
		if (!Sys.isDefined(b[c])) {
			b[c] = {
				active: true,
				config: a
			}
		}
	},
	removeChild: function(a) {
		delete this.readData("children")[a]
	},
	isActiveChild: function(a) {
		var b = this.readData("children")[a];
		return Sys.isDefined(b) && b.active
	},
	getChildConfig: function(a) {
		return this.readData("children")[a].config
	},
	activateChild: function(a) {
		var b = this.readData("children")[a];
		if (!Sys.isDefined(b)) {
			b.active = true
		}
	},
	deactivateChild: function(a) {
		var b = this.readData("children")[a];
		if (!Sys.isDefined(b)) {
			b.active = false
		}
	},
	setupData: function() {
		this.storeData("children", {});
		this.storeData("open", false)
	}
};
Interface.SettingsWindowModel = Sys.extend(Core.Model, Interface.SettingsWindowModel, "Interface.SettingsWindowModel");
Sys.ns("Interface");
Interface.SettingsWindowBaseView = {
	BASE_CSS: "interface-settingsWindow_base",
	PORTRAIT_CSS: "interface-settingsWindow_portrait",
	LANDSCAPE_CSS: "interface-settingsWindow_landscape",
	HEADER_CSS: "interface-settingsWindow_header interface-settingsSection_subSection_uri",
	CONTENT_CSS: "interface-settingsWindow_content",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.SettingsWindowBaseView.superclass.constructor.apply(this, arguments)
	},
	open: function() {
		this.container.el.style.display = "block";
		this.fireEvent("view:opened")
	},
	close: function() {
		this.container.el.style.display = "none";
		this.fireEvent("view:closed")
	},
	adaptToOrientation: function(a) {
		this.setStyle(a)
	},
	addChild: function(a) {
		this.content.add(a.content)
	},
	removeChild: function(a) {
		this.content.remove(this.model.getChildConfig(a).content)
	},
	showChild: function(a) {
		if (Environment.orientation() === "portrait") {
			this.open()
		}
		this.setTitle(this.model.getChildConfig(a).title)
	},
	init: function() {
		var a = this;
		Interface.SettingsWindowBaseView.superclass.init.apply(a, arguments);
		a.closeAnimation = {};
		a.openAnimation = {};
		a.setupDOMStructure()
	},
	setupDOMStructure: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "settingsWindow",
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET
		});
		a.header = a.container.add(new Sys.Element({
			id: "settingsWindowHeader",
			tag: "div",
			cls: a.HEADER_CSS
		}));
		a.content = a.container.add(new Sys.Element({
			id: "settingsWindowContent",
			tag: "div",
			cls: a.CONTENT_CSS
		}))
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:childAdded": a.addChild,
			"model:childRemoved": a.removeChild,
			"model:showChild": a.showChild
		})
	},
	removeAnimations: function() {
		var a = this;
		if (Sys.isDefined(a.openAnimation.LANDSCAPE)) {
			a.openAnimation.LANDSCAPE.removeAnimation(a.container.el)
		}
		if (Sys.isDefined(a.openAnimation.PORTRAIT)) {
			a.openAnimation.PORTRAIT.removeAnimation(a.container.el)
		}
	},
	setTitle: function(a) {
		this.header.el.textContent = a
	}
};
Interface.SettingsWindowBaseView = Sys.extend(Core.View, Interface.SettingsWindowBaseView, "Interface.SettingsWindowBaseView");
Sys.ns("Interface");
Interface.SettingsWindowMobileView = {
	PORTRAIT_CSS: "interface-settingsWindow_portrait_mobile",
	LANDSCAPE_CSS: "interface-settingsWindow_landscape_mobile",
	constructor: function() {
		Interface.SettingsWindowMobileView.superclass.constructor.apply(this, arguments)
	},
	adaptToOrientation: function(a) {
		Interface.SettingsWindowMobileView.superclass.adaptToOrientation.call(this, a);
		this.setHeight(a)
	},
	setHeight: function(a) {
		if (a === "PORTRAIT") {
			this.container.el.style.height = (Environment.getGameHeight() + Environment.getSpaceBelowGame()) + "px"
		} else {
			this.container.el.style.height = ""
		}
	}
};
Interface.SettingsWindowMobileView = Sys.extend(Interface.SettingsWindowBaseView, Interface.SettingsWindowMobileView, "Interface.SettingsWindowMobileView");
Sys.ns("Interface");
Interface.SettingsWindowDesktopView = {
	BASE_CSS: "interface-settingsWindow_base",
	LANDSCAPE_CSS: "interface-settingsWindow_landscape_desktop",
	CLOSE_BUTTON_CSS: "interface-settingsWindow_desktop_closeButton interface-settingsWindow_closeButton_uri",
	constructor: function() {
		Interface.SettingsWindowDesktopView.superclass.constructor.apply(this, arguments)
	},
	setupDOMStructure: function() {
		var a = this;
		Interface.SettingsWindowDesktopView.superclass.setupDOMStructure.apply(a, arguments);
		a.closeButton = new Interface.utils.DOMButton({
			id: "settingsWindowCloseButton",
			baseCSS: a.CLOSE_BUTTON_CSS,
			clickCallback: a.fireEvent.bind(a, "view:close"),
			enabled: false
		});
		a.container.add(a.closeButton.getContainer())
	},
	open: function() {
		Interface.SettingsWindowDesktopView.superclass.open.apply(this, arguments);
		this.closeButton.enable("sectionClosed")
	},
	close: function() {
		Interface.SettingsWindowDesktopView.superclass.close.apply(this, arguments);
		this.closeButton.disable("sectionClosed")
	}
};
Interface.SettingsWindowDesktopView = Sys.extend(Interface.SettingsWindowBaseView, Interface.SettingsWindowDesktopView, "Interface.SettingsWindowDesktopView");
Sys.ns("Interface");
Interface.SettingsMenu = {
	constructor: function() {
		Interface.SettingsMenu.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SettingsMenuController,
			model: Interface.SettingsMenuModel,
			view: Interface.SettingsMenuBaseView
		}
	},
	getMixinDependencies: function() {
		return ["userInput", "orientation"]
	}
};
Interface.SettingsMenu = Sys.extend(Core.Module, Interface.SettingsMenu, "Interface.SettingsMenu");
Sys.ns("Interface");
Interface.SettingsMenuController = {
	constructor: function() {
		Interface.SettingsMenuController.superclass.constructor.apply(this, arguments);
		this.deactivatedAtSpinStart = true
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:settingsMenu.open": a.onOpenRequest,
			"request:settingsMenu.close": a.onCloseRequest,
			"request:settingsMenu.addChild": a.addChild,
			"request:settingsMenu.removeChild": a.removeChild,
			"request:settingsMenu.activateChild": a.activateChild,
			"request:settingsMenu.deactivateChild": a.deactivateChild,
			"notify:stateHandler.enteringIdleState": a.activateChildrenAfterSpin,
			"notify:stateHandler.leavingIdleState": a.deactivateChildrenDuringSpin,
			"notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderFinished,
			"view:contentChanged": a.onContentChangedInView,
			"view:contentClosed": a.onContentClosedInView
		})
	},
	onBeforeLoaderFinished: function() {
		var a = this;
		a.model.storeData("loaderFinished", true);
		if (!a.model.readData("determinedChildSize")) {
			a.view.onBeforeLoaderFinished()
		}
	},
	onModulesFinishedLoading: function() {
		if (this.model.readData("alwaysOpen") === true) {
			this.open()
		}
	},
	onOpenRequest: function(a) {
		var e = this,
			b = e.model.readData("open"),
			d = e.view.canOpenWithoutSelection(),
			c = e.model.readData("lastSelectedChild"),
			f = Sys.isDefined(c);
		if (!f) {
			c = e.model.readData("defaultChild");
			f = Sys.isDefined(c)
		}
		if (!b && (d || (a && f))) {
			e.open();
			if (a && f) {
				e.select(c)
			}
		}
	},
	onCloseRequest: function() {
		var a = this;
		if (a.model.readData("open")) {
			a.close();
			a.deselectCurrentChild()
		}
	},
	open: function() {
		var a = this;
		a.startListeningToUserInput();
		a.model.storeData("open", true);
		a.view.open();
		a.fireEvent("notify:settingsMenu.open")
	},
	close: function() {
		var a = this;
		a.stopListeningToUserInput();
		a.view.close();
		a.model.storeData("open", false);
		a.fireEvent("notify:settingsMenu.closed")
	},
	select: function(a) {
		this.view.selectChildByName(a)
	},
	deselectCurrentChild: function() {
		this.view.deselectCurrentChild()
	},
	addChild: function(c, a) {
		var b = this;
		b.addListener("notify:" + c + ".shown", b.onChildOpened.bind(b, c));
		b.addListener("notify:" + c + ".hidden", b.onChildClosed.bind(b, c));
		b.model.addChild(c, a);
		b.view.addChild(c)
	},
	onChildOpened: function(a) {
		if (!this.model.readData("open")) {
			this.open()
		}
		this.select(a)
	},
	onChildClosed: function(a) {
		if (this.model.readData("currentlySelectedChild") === a) {
			this.deselectCurrentChild()
		}
	},
	removeChild: function(b) {
		var a = this;
		a.removeListener("notify:" + b + ".shown");
		a.removeListener("notify:" + b + ".hidden");
		a.view.removeChild(b);
		a.model.removeChild(b)
	},
	activateChild: function(a) {
		this.model.activateChild(a)
	},
	deactivateChild: function(a) {
		this.model.deactivateChild(a)
	},
	activateChildrenAfterSpin: function() {
		this.model.storeData("inIdleState", true);
		if (this.deactivatedAtSpinStart) {
			this.deactivatedAtSpinStart = false;
			this.toggleChildrenDuringSpin(true)
		}
	},
	deactivateChildrenDuringSpin: function() {
		this.model.storeData("inIdleState", false);
		this.deactivatedAtSpinStart = true;
		this.toggleChildrenDuringSpin(false)
	},
	toggleChildrenDuringSpin: function(e) {
		var a = this.model.getChildrenDisabledDuringSpins(),
			d = a.length,
			c = (e) ? "activateChild" : "deactivateChild",
			b;
		for (b = -1; ++b < d;) {
			a[b].active = (e && a[b].active);
			this.view[c](a[b])
		}
	},
	onPortrait: function() {
		this.view.onPortrait()
	},
	onLandscape: function() {
		this.view.onLandscape()
	},
	onUserInputStart: function(a) {
		if (this.model.readData("open")) {
			this.view.onUserInputStart(a)
		}
	},
	onUserInputMove: function(a) {
		if (this.model.readData("open")) {
			this.view.onUserInputMove(a)
		}
	},
	onUserInputEnd: function(a) {
		if (this.model.readData("open")) {
			this.view.onUserInputEnd(a)
		}
	},
	onContentChangedInView: function(a) {
		this.model.storeData("currentlySelectedChild", a);
		if (Sys.isString(a)) {
			this.fireEvent("request:" + a + ".show")
		}
	},
	onContentClosedInView: function(c) {
		var b = this,
			a = b.model;
		a.storeData("lastSelectedChild", c);
		if (a.readData("currentlySelectedChild") === c) {
			a.storeData("currentlySelectedChild", undefined);
			if (!b.view.canOpenWithoutSelection()) {
				b.close()
			}
		}
		if (Sys.isString(c)) {
			b.fireEvent("request:" + c + ".hide")
		}
	}
};
Interface.SettingsMenuController = Sys.extend(Core.Controller, Interface.SettingsMenuController, "Interface.SettingsMenuController");
Sys.ns("Interface");
Interface.SettingsMenuModel = {
	constructor: function() {
		Interface.SettingsMenuModel.superclass.constructor.apply(this, arguments)
	},
	addChild: function(f, c) {
		var e = this,
			d = e.readData("children"),
			b = e.readData("disableDuringSpin"),
			a = Sys.isDefined(c) ? c : {};
		if (!Sys.isDefined(d[f])) {
			d[f] = {
				name: f,
				active: false,
				order: a.order,
				accessibleDuringSpins: a.accessibleDuringSpins,
				toggleOnSelection: (a.toggleOnSelection === true)
			};
			if (Sys.isDefined(a.isDefault) && a.isDefault) {
				e.storeData("defaultChild", f)
			}
			if (!Sys.isDefined(a.accessibleDuringSpins) || !a.accessibleDuringSpins) {
				b.push(d[f])
			}
		}
	},
	removeChild: function(e) {
		var d = this.readData("children"),
			c = d[e],
			a = this.readData("disableDuringSpin"),
			b = a.indexOf(c);
		if (!Sys.isDefined(c)) {
			if (b >= 0) {
				a.splice(b, 1)
			}
			delete(d[e])
		}
	},
	activateChild: function(d) {
		var b = this,
			a = b.readData("children")[d],
			c = b.getChildrenDisabledDuringSpins();
		if (Sys.isDefined(a)) {
			if (c.contains(a)) {
				a.accessibleDuringSpins = true;
				c = c.splice(c.indexOf(a), 1);
				b.storeData("disableDuringSpin", c)
			}
			a.active = true;
			b.fireEvent("model:childActivated", a)
		}
	},
	deactivateChild: function(d) {
		var b = this,
			a = b.readData("children")[d],
			c = b.getChildrenDisabledDuringSpins();
		if (Sys.isDefined(a)) {
			if (!c.contains(a)) {
				a.accessibleDuringSpins = false;
				c.push(a);
				b.storeData("disableDuringSpin", c)
			}
			a.active = false;
			b.fireEvent("model:childDeactivated", a)
		}
	},
	getChildrenDisabledDuringSpins: function() {
		return this.readData("disableDuringSpin")
	},
	setupData: function() {
		var a = this;
		a.storeData("children", {});
		a.storeData("disableDuringSpin", []);
		a.storeData("status", "closed");
		if (Environment.getCurrentPlatform() === "desktop") {
			a.storeData("alwaysOpen", true)
		}
	}
};
Interface.SettingsMenuModel = Sys.extend(Core.Model, Interface.SettingsMenuModel, "Interface.SettingsMenuModel");
Sys.ns("Interface");
Interface.SettingsMenuBaseView = {
	BASE_CSS: "interface-settingsMenu_base",
	PORTRAIT_CSS: "interface-settingsMenu_portrait",
	LANDSCAPE_CSS: "interface-settingsMenu_landscape",
	CHILDREN_CSS: "interface-settingsMenu_children",
	CHILD_CSS: "interface-settingsMenu_child_base",
	RENDER_TARGET: "gameWrapper",
	START_INDEX: 2,
	CAN_OPEN_WITHOUT_SELECTION: false,
	constructor: function() {
		Interface.SettingsMenuBaseView.superclass.constructor.apply(this, arguments)
	},
	open: function() {
		var c = this,
			b = c.childElements.getChildren().length,
			a = Environment.orientation();
		c.container.el.style.display = "block";
		if (b > 0 && c.totalChildWidth === 0) {
			c.adaptToOrientation(a)
		}
	},
	canOpenWithoutSelection: function() {
		return this.CAN_OPEN_WITHOUT_SELECTION
	},
	close: function() {
		this.container.el.style.display = "none"
	},
	onUserInputStart: function(c) {
		var b = this,
			a = Sys.UserInputUtils.isCoordinateTarget(b.container.el, c);
		if (a) {
			b.distanceSinceUserInputStart = 0;
			b.prevX = c.x;
			b.scroller.doTouchStart([{
				pageX: c.x,
				pageY: c.y
			}], Date.now())
		}
		b.wasInitialInputTarget = a;
		if (a && !b.shouldScroll) {
			b.onUserInputEnd(c)
		}
	},
	onUserInputMove: function(b) {
		var a = this;
		if (a.wasInitialInputTarget) {
			a.distanceSinceUserInputStart += Math.abs(a.prevX - b.x);
			a.prevX = b.x;
			a.scroller.doTouchMove([{
				pageX: b.x,
				pageY: b.y
			}], Date.now())
		}
	},
	onUserInputEnd: function(d) {
		var c = this,
			e, b, a;
		if (c.wasInitialInputTarget) {
			c.scroller.doTouchEnd(Date.now());
			if (c.distanceSinceUserInputStart < 10) {
				a = Sys.UserInputUtils.getCoordinatesRelativeToElement(d, c.childElements.el).x;
				b = c.getIndexFromPosition(a);
				e = c.getChildFromElement(c.childElements.getChildren()[b]);
				if (Sys.isDefined(e) && e.name === c.model.readData("currentlySelectedChild")) {
					if (e.toggleOnSelection) {
						c.deselectCurrentChild()
					}
					c.snapToIndex(b)
				} else {
					c.selectChild(e, b)
				}
			}
		}
		c.wasInitialInputTarget = false
	},
	selectChildByName: function(a) {
		var b = this,
			c = b.model.readData("children")[a];
		if (a !== b.model.readData("currentlySelectedChild") && Sys.isDefined(c)) {
			b.selectChild(c, b.getChildIndex(c))
		}
	},
	deselectCurrentChild: function() {
		var b = this,
			a = b.model.readData("children"),
			c = a[b.model.readData("currentlySelectedChild")];
		if (Sys.isDefined(c)) {
			b.deselectChild(c)
		}
	},
	adaptToOrientation: function(c) {
		var f = this,
			d, g, b, e, a;
		f.setStyle(c);
		d = f.model.readData("children");
		g = d[f.model.readData("currentlySelectedChild")];
		b = f.getChildIndex(g);
		e = f.scrollerWrapper.el.clientWidth;
		f.determineChildSize();
		if (Object.keys(d).length > 0 && f.totalChildWidth === 0) {
			return
		}
		f.menuWidth = e;
		f.scroller.setPosition(Math.round(Math.abs(e - f.totalChildWidth)), 0);
		f.scroller.setDimensions(e, 10, f.totalChildWidth + e - f.childWidth, 10);
		if (f.totalChildWidth > e) {
			a = b >= 0 ? b * f.childWidth : f.START_INDEX * f.childWidth;
			f.toggleFade(true);
			f.padding = Math.round((e - f.childWidth) / 2);
			f.shouldScroll = true;
			f.useScrollOffset = true;
			f.childElements.el.style.left = 0;
			f.scroller.scrollTo(a, 0, false)
		} else {
			f.toggleFade(false);
			f.padding = 0;
			f.useScrollOffset = false;
			f.scroller.scrollTo(0, 0, false);
			f.childElements.el.style.left = Math.round((e - f.totalChildWidth) / 2) + "px";
			f.shouldScroll = false
		}
	},
	selectChild: function(d, a) {
		var c = this,
			b = c.model.readData("children")[c.model.readData("currentlySelectedChild")];
		d.element.addCls("selected");
		c.snapToIndex(a);
		c.fireEvent("view:contentChanged", d.name);
		if (Sys.isDefined(b)) {
			c.deselectChild(b)
		}
	},
	deselectChild: function(a) {
		a.element.removeCls("selected");
		this.fireEvent("view:contentClosed", a.name)
	},
	snapToIndex: function(a) {
		this.scroller.scrollTo(Math.round(a * this.childWidth), 0, true)
	},
	getIndexFromPosition: function(a) {
		var c = Math.floor(a / this.childWidth),
			b = this.childElements.getChildren().length;
		if (c < 0) {
			c = 0
		} else {
			if (c >= b) {
				c = b - 1
			}
		}
		return c
	},
	init: function() {
		var a = this;
		Interface.SettingsMenuBaseView.superclass.init.apply(a, arguments);
		a.childWidth = 0;
		a.totalChildWidth = 0;
		a.menuWidth = 0;
		a.distanceSinceUserInputStart = 0;
		a.closeAnimation = {};
		a.openAnimation = {};
		a.padding = 0;
		a.prevX = 0;
		a.x = 0;
		a.useScrollOffset = false;
		a.shouldScroll = true;
		a.setupDOMStructure()
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:childActivated": a.activateChild,
			"model:childDeactivated": a.deactivateChild
		})
	},
	toggleFade: function(a) {
		var b = (a) ? "block" : "none";
		this.leftFade.el.style.display = b;
		this.rightFade.el.style.display = b
	},
	determineChildSize: function() {
		var c = this,
			e = c.childElements.getChildren(),
			d = e.length,
			a, b;
		if (d === 0) {
			return
		}
		b = Math.ceil(Math.round(e[0].getBoundingClientRect().width) * (1 / Environment.scale));
		a = b * d;
		if (c.totalChildWidth !== a) {
			c.childElements.el.style.width = a + "px"
		}
		c.totalChildWidth = a;
		c.childWidth = b
	},
	addChild: function(b) {
		var d = this,
			e = d.model.readData("children")[b],
			c = this.createChild(e.name),
			a = d.getNextClosestSibling(e);
		e.left = d.childWidth * e.order;
		e.element = c;
		if (Sys.isDefined(a)) {
			d.childElements.addBefore(c, a.element)
		} else {
			d.childElements.add(c)
		}
		d.determineChildSize()
	},
	removeChild: function(a) {
		var b = this,
			c = b.model.readData("children")[a];
		if (Sys.isDefined(c)) {
			b.childElements.remove(c.element);
			b.determineChildSize()
		}
	},
	activateChild: function(a) {
		a.element.removeCls("deactivated")
	},
	deactivateChild: function(a) {
		a.element.addCls("deactivated")
	},
	setupDOMStructure: function() {
		var a = this;
		a.container = new Sys.Element({
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET
		});
		a.touchArea = a.container.add(new Sys.Element({
			tag: "div",
			cls: "interface-settingsMenu_touchArea"
		}));
		a.leftFade = a.container.add(new Sys.Element({
			tag: "div",
			cls: "interface-settingsMenu_leftFade interface-settingsMenu_fade_uri"
		}));
		a.rightFade = a.container.add(new Sys.Element({
			tag: "div",
			cls: "interface-settingsMenu_rightFade interface-settingsMenu_fade_uri"
		}));
		a.scrollerWrapper = a.container.add(new Sys.Element({
			tag: "div",
			cls: "interface-settingsMenu_scrollerWrapper"
		}));
		a.childElements = a.scrollerWrapper.add(new Sys.Element({
			tag: "ul",
			cls: a.CHILDREN_CSS
		}));
		a.scroller = new Scroller(a.scrollCallback.bind(a), {
			scrollingY: false,
			speedMultiplier: 1.5 / Number(Environment.getScale())
		})
	},
	scrollCallback: function(d, c) {
		var a = this,
			b = (a.useScrollOffset) ? ((a.menuWidth - a.childWidth) / 2) : 0;
		if (a.shouldScroll) {
			a.childElements.el.style[Sys.utils.pollyFill("transform")] = "translate(" + Math.round(-d + b) + "px, " + (-c) + "px)";
			a.x = -d
		}
	},
	createChild: function(c) {
		var b = this,
			a = new Sys.Element({
				tag: "li",
				cls: b.CHILD_CSS
			});
		a.add(new Sys.Element({
			tag: "div",
			cls: "interface-settingsMenu_child_image interface-settingsMenu_child_" + c + "_uri"
		}));
		return a
	},
	onPortrait: function() {
		this.adaptToOrientation("PORTRAIT")
	},
	onLandscape: function() {
		this.adaptToOrientation("LANDSCAPE")
	},
	getChildIndex: function(a) {
		if (Sys.isDefined(a)) {
			return this.childElements.getChildren().indexOf(a.element.el)
		}
		return -1
	},
	getChildFromElement: function(b) {
		var a = this.model.readData("children"),
			c;
		Sys.iterate(a, function(d, e) {
			if (e.element.el === b) {
				c = e;
				return false
			}
			return undefined
		});
		return c
	},
	getNextClosestSibling: function(c) {
		var b = this.model.readData("children"),
			a;
		Sys.iterate(b, function(d, e) {
			if (e !== c && (e.order > c.order && (!Sys.isDefined(a) || e.order < a.order))) {
				a = e
			}
		});
		return a
	},
	onBeforeLoaderFinished: function() {}
};
Interface.SettingsMenuBaseView = Sys.extend(Core.View, Interface.SettingsMenuBaseView, "Interface.SettingsMenuBaseView");
Sys.ns("Interface");
Interface.SettingsMenuMobileView = {
	PORTRAIT_CSS: "interface-settingsMenu_portrait_mobile",
	LANDSCAPE_CSS: "interface-settingsMenu_landscape_mobile",
	constructor: function() {
		Interface.SettingsMenuMobileView.superclass.constructor.apply(this, arguments)
	}
};
Interface.SettingsMenuMobileView = Sys.extend(Interface.SettingsMenuBaseView, Interface.SettingsMenuMobileView, "Interface.SettingsMenuMobileView");
Sys.ns("Interface");
Interface.DesktopSettingsMenu = {
	constructor: function() {
		Interface.DesktopSettingsMenu.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.DesktopSettingsMenuController,
			view: Interface.DesktopSettingsMenuView
		}
	}
};
Interface.DesktopSettingsMenu = Sys.extend(Core.Module, Interface.DesktopSettingsMenu, "Interface.DesktopSettingsMenu");
Sys.ns("Interface");
Interface.DesktopSettingsMenuController = {
	constructor: function() {
		Interface.DesktopSettingsMenuController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:desktopSettingsMenu.addChild": a.view.addChild.bind(a.view),
			"request:desktopSettingsMenu.removeChild": a.view.removeChild.bind(a.view)
		})
	}
};
Interface.DesktopSettingsMenuController = Sys.extend(Core.Controller, Interface.DesktopSettingsMenuController, "Interface.DesktopSettingsMenuController");
Sys.ns("Interface");
Interface.DesktopSettingsMenuView = {
	BASE_CSS: "interface-desktopSettingsMenu_base",
	CHILDREN_CSS: "interface-settingsMenu_children",
	CHILD_CSS: "interface-settingsMenu_child_desktop",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.DesktopSettingsMenuView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Interface.DesktopSettingsMenuView.superclass.init.apply(a, arguments);
		a.childWidth = 0;
		a.setupDOMStructure();
		a.children = {}
	},
	setupDOMStructure: function() {
		var a = this;
		a.container = new Sys.Element({
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET
		});
		a.childElements = a.container.add(new Sys.Element({
			tag: "ul",
			cls: a.CHILDREN_CSS
		}))
	},
	addChild: function(c, b) {
		var d = this,
			e = d.createListItem(b.element),
			a;
		b.element = e;
		a = d.getNextClosestSibling(b);
		d.children[c] = b;
		if (Sys.isDefined(a)) {
			d.childElements.addBefore(e, a.element)
		} else {
			d.childElements.add(e)
		}
	},
	createListItem: function(a) {
		var c = this,
			b = new Sys.Element({
				tag: "li",
				cls: c.CHILD_CSS
			});
		b.add(a);
		return b
	},
	getNextClosestSibling: function(b) {
		var c = this.children,
			a;
		Sys.iterate(c, function(d, e) {
			if (e !== b && (e.order > b.order && (!Sys.isDefined(a) || e.order < a.order))) {
				a = e
			}
		});
		return a
	},
	removeChild: function(a) {
		var b = this,
			c = b.children[a];
		if (Sys.isDefined(c)) {
			b.childElements.remove(c.element)
		}
	}
};
Interface.DesktopSettingsMenuView = Sys.extend(Core.View, Interface.DesktopSettingsMenuView, "Interface.DesktopSettingsMenuView");
Sys.ns("Interface");
Interface.SettingsButton = {
	constructor: function() {
		Interface.SettingsButton.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SettingsButtonController,
			model: Interface.SettingsButtonModel,
			view: Interface.SettingsButtonBaseView
		}
	},
	getMixinDependencies: function() {
		return [{
			userInput: {
				listenToUserInput: true
			}
		}, "orientation", "properties"]
	}
};
Interface.SettingsButton = Sys.extend(Core.Module, Interface.SettingsButton, "Interface.SettingsButton");
Sys.ns("Interface");
Interface.SettingsButtonController = {
	TOGGLE_DELAY: 500,
	constructor: function() {
		Interface.SettingsButtonController.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		Interface.SettingsButtonController.superclass.init.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:settingsButton.enable": a.enable,
			"request:settingsButton.disable": a.disable,
			"notify:stateHandler.enteringIdleState": a.enable.bind(a, "notInIdleState"),
			"notify:stateHandler.leavingIdleState": a.disable.bind(a, "notInIdleState"),
			"notify:settingsMenu.open": a.onSettingsMenuOpened,
			"notify:settingsMenu.closed": a.onSettingsMenuClosed
		})
	},
	enable: function(b) {
		var a = this;
		a.model.removeProperty("disabledByOtherModule", b);
		if (!a.model.hasProperty("disabledByOtherModule")) {
			a.view.enable();
			a.model.storeData("disabled", false)
		}
	},
	disable: function(b) {
		var a = this;
		if (!a.model.hasProperty("disabledByOtherModule")) {
			a.view.disable();
			a.model.storeData("disabled", true);
			if (a.model.readData("status") === "open") {
				a.close()
			}
		}
		a.model.addProperty("disabledByOtherModule", b)
	},
	open: function() {
		this.fireEvent("request:settingsMenu.open", true);
		this.model.storeData("status", "open");
		this.view.adaptToOrientation(Environment.orientation().toUpperCase())
	},
	close: function() {
		this.fireEvent("request:settingsMenu.close");
		this.model.storeData("status", "closed");
		this.view.adaptToOrientation(Environment.orientation().toUpperCase())
	},
	onSettingsMenuOpened: function() {
		this.model.storeData("status", "open");
		this.view.adaptToOrientation(Environment.orientation().toUpperCase())
	},
	onSettingsMenuClosed: function() {
		this.model.storeData("status", "closed");
		this.view.adaptToOrientation(Environment.orientation().toUpperCase())
	},
	onUserInputStart: function(a) {
		this.view.onUserInputStart(a)
	},
	onUserInputEnd: function(c) {
		var b = this,
			a = Date.now();
		if (b.model.readData("disabled")) {
			return
		}
		if ((!Sys.isDefined(b.lastToggleOccured) || (a - b.lastToggleOccured > b.TOGGLE_DELAY)) && b.view.checkHit(c)) {
			if (b.model.readData("status") === "open") {
				b.close()
			} else {
				b.open()
			}
			b.lastToggleOccured = Date.now()
		}
	}
};
Interface.SettingsButtonController = Sys.extend(Core.Controller, Interface.SettingsButtonController, "Interface.SettingsButtonController");
Sys.ns("Interface");
Interface.SettingsButtonModel = {
	constructor: function() {
		Interface.SettingsButtonModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.storeData("status", "closed");
		this.storeData("disabled", true)
	}
};
Interface.SettingsButtonModel = Sys.extend(Core.Model, Interface.SettingsButtonModel, "Interface.SettingsButtonModel");
Sys.ns("Interface");
Interface.SettingsButtonBaseView = {
	BASE_BUTTON_CSS: "interface-settingsButton_baseButton",
	OPEN_URI: "interface-settingsButton_open_uri",
	CLOSED_URI: "interface-settingsButton_closed_uri",
	DISABLE_CSS: "interface-buttonDisable",
	PORTRAIT_CSS: "interface-settingsButton_portrait",
	LANDSCAPE_CSS: "interface-settingsButton_landscape",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.SettingsButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	adaptToOrientation: function(a) {
		this.setStyle(a)
	},
	enable: function() {
		this.container.removeCls(this.DISABLE_CSS)
	},
	disable: function() {
		this.container.addCls(this.DISABLE_CSS)
	},
	onUserInputStart: function(a) {
		this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	checkHit: function(b) {
		var a = false;
		if (this.wasInitialInputTarget) {
			a = Sys.UserInputUtils.isCoordinateTarget(this.container.el, b)
		}
		this.wasInitialInputTarget = false;
		return a
	},
	init: function() {
		var a = this;
		Interface.SettingsWindowBaseView.superclass.init.apply(a, arguments);
		a.previousCSS = "";
		a.wasInitialInputTarget = false;
		a.setupDOMStructure()
	},
	setStyle: function(b) {
		var c = this,
			a = c.model.readData("status").toUpperCase();
		Mixins.orientation.view.methods.setStyle.apply(c, arguments);
		if (a === "OPEN") {
			c.container.replaceCSSClass(c.CLOSED_URI, c.OPEN_URI)
		} else {
			if (a === "CLOSED") {
				c.container.replaceCSSClass(c.OPEN_URI, c.CLOSED_URI)
			}
		}
	},
	setupDOMStructure: function() {
		var a = this;
		a.container = new Sys.Element({
			tag: "div",
			cls: a.BASE_BUTTON_CSS + " " + a.CLOSED_URI + " " + a.DISABLE_CSS,
			renderTo: a.RENDER_TARGET
		})
	}
};
Interface.SettingsButtonBaseView = Sys.extend(Core.View, Interface.SettingsButtonBaseView, "Interface.SettingsButtonBaseView");
Sys.ns("Interface");
Interface.SettingsButtonMobileView = {
	PORTRAIT_CSS: "interface-settingsButton_portrait_mobile",
	LANDSCAPE_CSS: "interface-settingsButton_landscape_mobile",
	BACKGROUND_CSS: "interface-settingsButton_background",
	constructor: function() {
		Interface.SettingsButtonMobileView.superclass.constructor.apply(this, arguments)
	},
	setStyle: function(a) {
		Interface.SettingsButtonMobileView.superclass.setStyle.apply(this, arguments);
		if (a === "PORTRAIT") {
			this.background.el.style.display = "block"
		} else {
			this.background.el.style.display = "none"
		}
	},
	setupDOMStructure: function() {
		var a = this;
		Interface.SettingsButtonMobileView.superclass.setupDOMStructure.apply(a, arguments);
		a.background = new Sys.Element({
			tag: "div",
			"class": a.BACKGROUND_CSS,
			renderTo: a.RENDER_TARGET
		})
	}
};
Interface.SettingsButtonMobileView = Sys.extend(Interface.SettingsButtonBaseView, Interface.SettingsButtonMobileView, "Interface.SettingsButtonMobileView");
Sys.ns("Interface");
Interface.BetSettings = {
	constructor: function() {
		Interface.BetSettings.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["userInput"],
			desktop: ["userInput", "animation"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.BetSettingsController,
			model: Interface.BetSettingsModel,
			view: Interface.BetSettingsBaseView
		}
	}
};
Interface.BetSettings = Sys.extend(Interface.SettingsSection, Interface.BetSettings, "Interface.BetSettings");
Sys.ns("Interface");
Interface.BetSettingsController = {
	constructor: function() {
		Interface.BetSettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this,
			b;
		Interface.BetSettingsController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"notify:moneyManager.betChanged": a.view.update.bind(a.view),
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"notify:stateHandler.enteringIdleState": a.enable.bind(a, "notInIdleState"),
			"notify:stateHandler.leavingIdleState": a.disable.bind(a, "notInIdleState"),
			"notify:gameModeChanged": a.onGameModeChanged,
			"notify:stateHandler.enteringspinTypeRespinRestoreState": a.disable.bind(a, "notInIdleState"),
			"request:betSettings.hideCashDisplay": a.view.hideCashDisplay.bind(a.view),
			"request:betSettings.showCashDisplay": a.view.showCashDisplay.bind(a.view),
			"request:enableBasicGamePanel": a.enable,
			"request:disableBasicGamePanel": a.disable,
			"request:betSettings.enable": a.enable,
			"request:betSettings.disable": a.disable
		});
		b = !a.model.readData("inFreerounds");
		a.fireEvent("request:settingsManager.storeData", "betLevel", a.model.readData("betLevel"), b);
		a.fireEvent("request:settingsManager.storeData", "denomination", a.model.readData("denomination"), b)
	},
	onGameModeChanged: function(b) {
		var a = this;
		if (b === "BASIC") {
			a.view.showSelectors();
			a.view.hideFreespinLabels()
		} else {
			a.view.hideSelectors();
			a.view.showFreespinLabels()
		}
	},
	onSettingChanged: function(a, b) {
		if (a === "betLevel" || a === "denomination") {
			this.model.storeData(a, b)
		}
	},
	onUserAction: function(c, b) {
		var a, d = b;
		if (c === "betLevelChanged") {
			a = "betLevel"
		} else {
			if (c === "coinValueChanged") {
				a = "denomination";
				d = this.model.getDenomination(d)
			}
		}
		if (Sys.isDefined(a)) {
			this.fireEvent("request:settingsManager.storeData", a, d, !this.model.readData("inFreerounds"))
		}
	}
};
Interface.BetSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.BetSettingsController, "Interface.BetSettingsController");
Sys.ns("Interface");
Interface.BetSettingsModel = {
	constructor: function() {
		Interface.BetSettingsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var k = this,
			b = Services.localStorageManager.readData("ignoreInitialBet") || false,
			h = Resources.readData("gameServerInitResponseObject"),
			g = h.betlevel.standard,
			a = h.denomination.standard,
			d = h.betlevel.all,
			j = h.denomination.all,
			l = [],
			o, n, f = false,
			m, e, c;
		Interface.BetSettingsModel.superclass.setupData.apply(k, arguments);
		if (!Sys.isArray(d)) {
			d = [d]
		}
		if (!Sys.isArray(j)) {
			j = [j]
		}
		if (Sys.isDefined(h.freeRoundsLeft) && Number(h.freeRoundsLeft) > 0) {
			k.storeData("inFreerounds", true)
		}
		if (!Sys.isArray(h.denomination.all)) {
			h.denomination.all = [h.denomination.all]
		}
		o = k.getCustomCoinValues(h.denomination.all);
		n = k.getInitialBetChanges(o, h.betlevel.all);
		if (!k.readData("inFreerounds") && o && n) {
			j = o;
			if (!b) {
				f = true;
				Services.localStorageManager.storeData("ignoreInitialBet", true.toString())
			}
		}
		for (e = 0; e < j.length; e++) {
			l.push(k.getCoinValue(j[e]))
		}
		if (Services.localStorageManager.hasData("betLevel")) {
			m = Number(Services.localStorageManager.readData("betLevel"))
		}
		if (Sys.isDefined(h.bet) && Sys.isDefined(h.bet.betlevel)) {
			g = h.bet.betlevel
		} else {
			if (f && n.defaultBetLevel) {
				g = n.defaultBetLevel
			} else {
				if (Sys.isNumber(m) && d.contains(m)) {
					g = m
				}
			}
		}
		if (Services.localStorageManager.hasData("denomination")) {
			m = Number(Services.localStorageManager.readData("denomination"))
		}
		if (Sys.isDefined(h.bet) && Sys.isDefined(h.bet.denomination)) {
			a = h.bet.denomination
		} else {
			if (f && n.defaultCoinValue) {
				a = n.defaultCoinValue
			} else {
				if (Sys.isNumber(m) && j.contains(m)) {
					a = m
				}
			}
		}
		c = [{
			key: "betLevels",
			defaultValue: d,
			settingsManager: false,
			localStorage: false
		}, {
			key: "updatableBetLevels",
			defaultValue: (d.length > 1),
			settingsManager: false,
			localStorage: false
		}, {
			key: "coinValues",
			defaultValue: l,
			settingsManager: false,
			localStorage: false
		}, {
			key: "updatableCoinValues",
			defaultValue: (l.length > 1),
			settingsManager: false,
			localStorage: false
		}, {
			key: "betLevel",
			defaultValue: g,
			settingsManager: true,
			ignoreLocalStorageValue: true,
			localStorage: !k.readData("inFreerounds"),
			silent: false
		}, {
			key: "denomination",
			defaultValue: a,
			settingsManager: true,
			ignoreLocalStorageValue: true,
			localStorage: !k.readData("inFreerounds"),
			silent: false
		}];
		c.forEach(k.initData, k)
	},
	getCustomCoinValues: function(g) {
		var f = this,
			b = Resources.readData("queryData"),
			h, a, d, e = [],
			c;
		if (!Sys.isDefined(g) || !Sys.isDefined(b["customConfiguration.coinValues"])) {
			return null
		}
		a = f.decodeDataString(b["customConfiguration.coinValues"]);
		if (a.trim().length === 0) {
			return null
		}
		h = a.split(",");
		for (c = 0; c < h.length; c++) {
			d = parseInt(h[c], 10);
			if (g.indexOf(d) === -1) {
				return null
			}
			e.push(d)
		}
		return e.sort(function(k, j) {
			return k - j
		})
	},
	getInitialBetChanges: function(b, e) {
		var a = Resources.readData("queryData"),
			d = parseInt(a["customConfiguration.defaultBetLevel"], 10),
			c = parseInt(a["customConfiguration.defaultCoinValue"], 10);
		if (!Sys.isArray(b) || !Sys.isArray(e) || e.indexOf(d) === -1 || b.indexOf(c) === -1) {
			return null
		}
		return {
			defaultBetLevel: d,
			defaultCoinValue: c
		}
	},
	decodeDataString: function(a) {
		if (a.match(/%/)) {
			return decodeURIComponent(a)
		}
		return a
	},
	storeData: function(a, b) {
		Interface.BetSettingsModel.superclass.storeData.call(this, a, b);
		if (a === "denomination") {
			Interface.BetSettingsModel.superclass.storeData.call(this, "coinValue", this.getCoinValue(b))
		}
	},
	getDenomination: function(a) {
		return a * 100
	},
	getCoinValue: function(a) {
		return a / 100
	}
};
Interface.BetSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.BetSettingsModel, "Interface.BetSettingsModel");
Sys.ns("Interface");
Interface.BetSettingsBaseView = {
	BASE_CSS: "tab interface-betSettings_base",
	SECTION_CSS: "interface-settingsSection_subSection",
	PORTRAIT_CSS: "interface-betSettings_portrait",
	LANDSCAPE_CSS: "interface-betSettings_landscape",
	constructor: function() {
		Interface.BetSettingsBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var c = this,
			b = c.model,
			a;
		c.subComponents = [];
		c.container = new Sys.Element({
			id: "BetSettings",
			tag: "div",
			cls: c.BASE_CSS
		});
		c.betDisplays = c.container.add(new Sys.Element({
			tag: "ul",
			"class": "interface-betSettings_betDisplays"
		}));
		c.betInCashDisplay = c.betDisplays.add(new Sys.Element({
			tag: "li",
			"class": "interface-betSettings_betDisplays_size interface-betSettings_displayText",
			textContent: Services.languageManager.getText(Language.Keys.betInCash)
		}));
		c.betInCashValue = c.betInCashDisplay.add(new Sys.Element({
			tag: "div",
			textContent: "0",
			"class": "interface-betSettings_displayValue"
		}));
		c.betInCoinsDisplay = c.betDisplays.add(new Sys.Element({
			tag: "li",
			"class": "interface-betSettings_betDisplays_size interface-betSettings_displayText",
			textContent: Services.languageManager.getText(Language.Keys.betInCoins)
		}));
		c.betInCoinsValue = c.betInCoinsDisplay.add(new Sys.Element({
			tag: "div",
			textContent: "0",
			"class": "interface-betSettings_displayValue"
		}));
		c.settings = c.container.add(new Sys.Element({
			tag: "ul",
			"class": "interface-settingsSection_dynamicSliderPosition_container"
		}));
		c.betLevelText = c.settings.add(new Sys.Element({
			tag: "li",
			"class": "interface-settingsSection_dynamicSliderPosition_label",
			textContent: Services.languageManager.getText(Language.Keys.betLevel)
		}));
		a = b.readData("betLevels");
		if (!b.readData("updatableBetLevels")) {
			a = [a[0], ""];
			c.betLevelText.el.style.opacity = 0.5
		}
		c.betLevelSlider = new Interface.utils.Slider({
			id: "betSettingsBetLevelSlider",
			values: a,
			callback: c.onSliderValueChange.bind(c, "betLevelChanged"),
			showLabels: true
		});
		c.settings.add(new Sys.Element({
			tag: "li",
			"class": "interface-settingsSection_dynamicSliderPosition_slider"
		})).add(c.betLevelSlider.getContainer());
		if (b.readData("updatableBetLevels")) {
			c.subComponents.push(c.betLevelSlider)
		}
		c.coinValueText = c.settings.add(new Sys.Element({
			tag: "li",
			"class": "interface-settingsSection_dynamicSliderPosition_label",
			textContent: Services.languageManager.getText(Language.Keys.coinValue)
		}));
		a = b.readData("coinValues");
		if (!b.readData("updatableCoinValues")) {
			a = [a[0], ""];
			c.coinValueText.el.style.opacity = 0.5
		}
		c.coinValueSlider = new Interface.utils.Slider({
			id: "betSettingsCoinValueSlider",
			values: a,
			callback: c.onSliderValueChange.bind(c, "coinValueChanged"),
			showLabels: true
		});
		c.settings.add(new Sys.Element({
			tag: "li",
			"class": "interface-settingsSection_dynamicSliderPosition_slider"
		})).add(c.coinValueSlider.getContainer());
		if (b.readData("updatableCoinValues")) {
			c.subComponents.push(c.coinValueSlider)
		}
		c.portraitInformation = c.container.add(new Sys.Element({
			tag: "ul",
			"class": "interface-betSettings_portraitInfo"
		}));
		c.cashBalanceText = c.portraitInformation.add(new Sys.Element({
			tag: "li",
			"class": "interface-betSettings_portraitInfo_label",
			textContent: Services.languageManager.getText(Language.Keys.cashColon)
		}));
		c.cashBalanceValue = c.portraitInformation.add(new Sys.Element({
			tag: "li",
			"class": "interface-betSettings_portraitInfo_numbers"
		}));
		c.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.betSettings_uc),
			content: c.container
		});
		c.fireEvent("view:addToNavigator", "settingsMenu", {
			order: 3,
			isDefault: true
		});
		c.addScrolling();
		if (!c.model.readData("disabled")) {
			c.enable()
		}
		c.update()
	},
	onSliderValueChange: function(b, a) {
		this.fireEvent("view:userAction", b, a)
	},
	enable: function() {
		var a = this;
		a.callFunctionOnSubComponents("enable");
		a.cashBalanceValue.el.textContent = Services.moneyManager.formatMoneyCurrencySign(Services.moneyManager.getBalanceCents())
	},
	disable: function() {
		this.callFunctionOnSubComponents("disable")
	},
	show: function() {
		Interface.BetSettingsBaseView.superclass.show.apply(this, arguments);
		this.cashBalanceValue.el.textContent = Services.moneyManager.formatMoneyCurrencySign(Services.moneyManager.getBalanceCents())
	},
	hideCashDisplay: function() {
		this.portraitInformation.el.style.display = "none"
	},
	showCashDisplay: function() {
		this.portraitInformation.el.style.display = "block"
	},
	update: function() {
		var c = this,
			a = c.model,
			b = Services.moneyManager;
		if (a.readData("updatableBetLevels")) {
			c.betLevelSlider.setValue(c.model.readData("betLevel"), true)
		}
		if (a.readData("updatableCoinValues")) {
			c.coinValueSlider.setValue(c.model.readData("coinValue"), true)
		}
		c.betInCashValue.el.textContent = b.formatMoneyCurrencySign(b.getBetCents());
		c.betInCoinsValue.el.textContent = b.getBetCoins();
		c.cashBalanceValue.el.textContent = b.formatMoneyCurrencySign(b.getBalanceCents())
	},
	hideSelectors: function() {},
	showSelectors: function() {},
	showFreespinLabels: function() {},
	hideFreespinLabels: function() {}
};
Interface.BetSettingsBaseView = Sys.extend(Interface.SettingsSectionView, Interface.BetSettingsBaseView, "Interface.BetSettingsBaseView");
Sys.ns("Interface");
Interface.BetSettingsDesktopView = {
	GAME_MODES: ["BASIC", "FREESPIN"],
	BASIC_BETLEVEL_LABEL: {
		font: "17px Verdana",
		fillstyle: "rgb(218,218,171)"
	},
	BASIC_BETLEVEL_VALUE: {
		font: "17px Verdana",
		fillstyle: "rgb(238,239,206)"
	},
	BASIC_COINVALUE_LABEL: {
		font: "17px Verdana",
		fillstyle: "rgb(218,218,171)"
	},
	BASIC_COINVALUE_VALUE: {
		font: "17px Verdana",
		fillstyle: "rgb(238,239,206)"
	},
	FREESPIN_BETLEVEL_LABEL: {
		font: "17px Verdana",
		fillstyle: "rgb(218,218,171)",
		position: {
			x: 210,
			y: 641,
			width: 100,
			height: 20
		},
		alignment: {
			horizontal: "right",
			vertical: false
		}
	},
	FREESPIN_BETLEVEL_VALUE: {
		font: "17px Verdana",
		fillstyle: "rgb(238,239,206)",
		position: {
			x: 315,
			y: 641,
			width: 267,
			height: 20
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	FREESPIN_COINVALUE_LABEL: {
		font: "17px Verdana",
		fillstyle: "rgb(218,218,171)",
		position: {
			x: 877,
			y: 641,
			width: 100,
			height: 20
		},
		alignment: {
			horizontal: "right",
			vertical: false
		}
	},
	FREESPIN_COINVALUE_VALUE: {
		font: "17px Verdana",
		fillstyle: "rgb(238,239,206)",
		position: {
			x: 982,
			y: 641,
			width: 267,
			height: 20
		},
		alignment: {
			horizontal: "left",
			vertical: false
		}
	},
	BETLEVEL_VALUE_SELECTOR_BASE_POSITION: {
		x: 264,
		y: 629
	},
	COINVALUE_VALUE_SELECTOR_BASE_POSITION: {
		x: 889,
		y: 629
	},
	VALUE_SELECTOR_POSITION_OFFSET_LABEL: {
		x: 0,
		y: -18
	},
	VALUE_SELECTOR_POSITION_OFFSET_VALUE: {
		x: 0,
		y: 9
	},
	VALUE_SELECTOR_RIGHT_BUTTON_IMAGE: undefined,
	VALUE_SELECTOR_LEFT_BUTTON_IMAGE: undefined,
	VALUE_SELECTOR_HANDLE_POSITION_OFFSET: undefined,
	VALUE_SELECTOR_HANDLE_DIMENSIONS: undefined,
	VALUE_SELECTOR_HANDLE_COLLISION_BOX: {
		LEFT: {
			xOffset: 7,
			yOffset: 7,
			width: 28,
			height: 37
		},
		RIGHT: {
			xOffset: 9,
			yOffset: 7,
			width: 28,
			height: 37
		}
	},
	VALUE_SELECTOR_BAR_BACKGROUND: undefined,
	VALUE_SELECTOR_BAR_BACKGROUND_DISABLED: undefined,
	VALUE_SELECTOR_BAR_FILL: undefined,
	VALUE_SELECTOR_BAR_FILL_DISABLED: undefined,
	VALUE_SELECTOR_BAR_DIMENSIONS: undefined,
	VALUE_SELECTOR_BAR_POSITIONS_OFFSET: undefined,
	constructor: function() {
		Interface.BetSettingsDesktopView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.betLevelLabel = Services.languageManager.getText(Language.Keys.level);
		a.coinValueLabel = Services.languageManager.getText(Language.Keys.machinetext_coinvalue);
		a.keyPadLayering = Layering.Game.Slots.Keypad;
		a.itemList = new Animation.List({});
		a.enabled = true;
		a.initSelectors();
		a.initFreespinItems();
		a.update()
	},
	updateValueItem: function(a, e, c) {
		var f = a.prop,
			b = f.customProps.inMemCanvas.ctx,
			d;
		b.clearRect(0, 0, f.width, f.height);
		d = Animation.utils.text.measureText(e, c.font, 0, b);
		Animation.utils.text.performOperations(e, c.font, 0, d.height / 2, [{
			fillStyle: c.fillstyle,
			drawType: "fill"
		}], b)
	},
	initSelectors: function() {
		var c = this,
			b = c.keyPadLayering,
			a;
		a = c.model.readData("coinValues").map(function(d) {
			return Sys.utils.numberToFixedDigits(d, 3)
		});
		c.selectors = {
			betLevelSelector: new Interface.utils.CanvasValueSelector({
				id: "betLevelSelector",
				x: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.x,
				y: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.y,
				depth: b.betLevelSelector,
				values: c.model.readData("betLevels"),
				callback: c.onValueChange.bind(c, "betLevelChanged"),
				disabled: !c.model.readData("updatableBetLevels"),
				label: Services.languageManager.getText(Language.Keys.level),
				fontLabel: c.BASIC_BETLEVEL_LABEL.font,
				fontValue: c.BASIC_BETLEVEL_VALUE.font,
				fillstyleLabel: c.BASIC_BETLEVEL_LABEL.fillstyle,
				fillstyleValue: c.BASIC_BETLEVEL_VALUE.fillstyle,
				positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
				positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
				rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
				leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
				handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
				handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
				handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
				barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
				barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
				barFill: c.VALUE_SELECTOR_BAR_FILL,
				barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
				barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
				barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
			}),
			coinValueSelector: new Interface.utils.CanvasValueSelector({
				id: "coinValueSelector",
				x: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.x,
				y: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.y,
				depth: b.betLevelSelector,
				values: c.model.readData("coinValues"),
				valueNames: a,
				callback: c.onValueChange.bind(c, "coinValueChanged"),
				disabled: !c.model.readData("updatableCoinValues"),
				label: Services.languageManager.getText(Language.Keys.machinetext_coinvalue),
				fontLabel: c.BASIC_COINVALUE_LABEL.font,
				fontValue: c.BASIC_COINVALUE_VALUE.font,
				fillstyleLabel: c.BASIC_COINVALUE_LABEL.fillstyle,
				fillstyleValue: c.BASIC_COINVALUE_VALUE.fillstyle,
				positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
				positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
				rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
				leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
				handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
				handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
				handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
				barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
				barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
				barFill: c.VALUE_SELECTOR_BAR_FILL,
				barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
				barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
				barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
			})
		}
	},
	initFreespinItems: function() {
		var a = this;
		a.betLevelLabelItem = a.initTextItem(a.betLevelLabel, a.FREESPIN_BETLEVEL_LABEL, a.keyPadLayering.betLevelSelector);
		a.betLevelValueItem = a.initTextItem(a.model.readData("betLevel"), a.FREESPIN_BETLEVEL_VALUE, a.keyPadLayering.betLevelSelector);
		a.coinValueLabelItem = a.initTextItem(a.coinValueLabel, a.FREESPIN_COINVALUE_LABEL, a.keyPadLayering.betLevelSelector);
		a.coinValueValueItem = a.initTextItem(a.model.readData("coinValue"), a.FREESPIN_COINVALUE_VALUE, a.keyPadLayering.betLevelSelector);
		a.itemList.addItems([a.betLevelLabelItem, a.betLevelValueItem, a.coinValueLabelItem, a.coinValueValueItem]);
		Game.stage.view.addToRenderLoop(a.itemList);
		a.itemList.stop()
	},
	initTextItem: function(h, c, g) {
		var d = this,
			b = c.position,
			f = d.getInMemoryCanvas(b.width, b.height),
			a = c.alignment.horizontal === "right" ? c.position.width : 0,
			e;
		if (Sys.isDefined(c.alignment)) {
			f.ctx.textAlign = c.alignment.horizontal
		}
		e = Animation.utils.text.measureText(h, c.font, 0, f.ctx);
		Animation.utils.text.performOperations(h, c.font, a, e.height / 2, [{
			fillStyle: c.fillstyle,
			drawType: "fill"
		}], f.ctx);
		return new Animation.Item({
			top: b.y,
			left: b.x,
			width: b.width,
			height: b.height,
			depth: g,
			image: f.canvas,
			customProps: {
				inMemCanvas: f
			}
		})
	},
	getInMemoryCanvas: function(d, a) {
		var c = document.createElement("canvas"),
			b = c.getContext("2d");
		c.width = d;
		c.height = a;
		return {
			canvas: c,
			ctx: b
		}
	},
	onValueChange: function(b, a) {
		this.fireEvent("view:userAction", b, a)
	},
	setUpContent: function() {},
	onSliderValueChange: function(b, a) {},
	enable: function(b) {
		var a = this;
		a.enabled = true;
		Sys.iterate(a.selectors, function(c) {
			if ((c === "betLevelSelector" && a.model.readData("updatableBetLevels")) || (c === "coinValueSelector" && a.model.readData("updatableCoinValues"))) {
				a.selectors[c].enable(b)
			}
		});
		a.update()
	},
	disable: function(a) {
		this.enabled = false;
		Sys.iterate(this.selectors, function(b) {
			this[b].disable(a)
		})
	},
	hideSelectors: function() {
		this.disable("BetSettings");
		Sys.iterate(this.selectors, function(b, a) {
			a.hide("BetSettings")
		})
	},
	showSelectors: function() {
		this.enable("BetSettings");
		Sys.iterate(this.selectors, function(b, a) {
			a.show("BetSettings")
		})
	},
	showFreespinLabels: function() {
		this.itemList.play()
	},
	hideFreespinLabels: function() {
		this.itemList.stop()
	},
	update: function() {
		var b = this,
			a = b.model;
		if (Sys.isDefined(b.selectors) && this.enabled) {
			if (a.readData("updatableBetLevels")) {
				b.selectors.betLevelSelector.update(b.model.readData("betLevel"));
				b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
			}
			if (a.readData("updatableCoinValues")) {
				b.selectors.coinValueSelector.update(b.model.readData("coinValue"));
				b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
			}
		}
		if (Sys.isDefined(b.coinValueValueItem && b.betLevelValueItem)) {
			if (a.readData("updatableBetLevels")) {
				b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
			}
			if (a.readData("updatableCoinValues")) {
				b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
			}
		}
	},
	hideCashDisplay: function() {}
};
Interface.BetSettingsDesktopView = Sys.extend(Interface.BetSettingsBaseView, Interface.BetSettingsDesktopView, "Interface.BetSettingsDesktopView");
Sys.ns("Interface");
Interface.GameHistory = {
	constructor: function() {
		Interface.GameHistory.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.GameHistoryController,
			model: Interface.GameHistoryModel,
			view: Interface.GameHistoryBaseView
		}
	}
};
Interface.GameHistory = Sys.extend(Interface.SettingsSection, Interface.GameHistory, "Interface.GameHistory");
Sys.ns("Interface");
Interface.GameHistoryController = {
	constructor: function() {
		Interface.GameHistoryController.superclass.constructor.apply(this, arguments)
	},
	onUserAction: function(a) {
		if (a === "goToHistory") {
			Environment.goTo(Resources.readData("historyUrl"))
		}
	}
};
Interface.GameHistoryController = Sys.extend(Interface.SettingsSectionController, Interface.GameHistoryController, "Interface.GameHistoryController");
Sys.ns("Interface");
Interface.GameHistoryModel = {
	constructor: function() {
		Interface.GameHistoryModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Resources.readData("gameServerInitResponse");
		Interface.GameHistoryModel.superclass.setupData.apply(this, arguments);
		if (a.playforfun) {
			this.storeData("disabled", true)
		} else {
			if (Sys.isDefined(a.historybutton) && !a.historybutton) {
				this.storeData("removed", true)
			}
		}
	}
};
Interface.GameHistoryModel = Sys.extend(Core.Model, Interface.GameHistoryModel, "Interface.GameHistoryModel");
Sys.ns("Interface");
Interface.GameHistoryBaseView = {
	BASE_CSS: "tab interface-gameHistory_base",
	PORTRAIT_CSS: "interface-gameHistory_portrait",
	LANDSCAPE_CSS: "interface-gameHistory_landscape",
	BUTTON_BASE_CSS: "button interface-gameHistory_button",
	BUTTON_DISABLED_CSS: "interface-gameHistory_buttonDisabled",
	BUTTON_PRESSED_CSS: "interface-gameHistory_buttonPressed",
	constructor: function() {
		Interface.GameHistoryBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "gameHistory",
			tag: "div",
			cls: a.BASE_CSS
		});
		a.text = a.container.add(new Sys.Element({
			id: "gameHistoryDisabledText",
			tag: "div",
			style: "margin-top: 10%;"
		}));
		a.text.el.textContent = Services.languageManager.getText(Language.Keys.newHistoryWindow);
		a.button = new Interface.utils.Button({
			id: "gameHistoryButton",
			CSS: {
				base: a.BUTTON_BASE_CSS,
				disabled: a.BUTTON_DISABLED_CSS
			}
		});
		a.container.add(a.button.getContainer());
		a.button.setText(Services.languageManager.getText(Language.Keys.gameHistory));
		if (a.model.readData("disabled")) {
			a.disable()
		}
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.gameHistory_uc),
			content: a.container
		});
		if (!a.model.readData("removed")) {
			a.fireEvent("view:addToNavigator", "settingsMenu", {
				order: 5
			})
		}
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	enable: function() {
		this.text.el.textContent = Services.languageManager.getText(Language.Keys.newHistoryWindow);
		this.button.enable()
	},
	disable: function() {
		this.text.el.textContent = Services.languageManager.getText(Language.Keys.historyNotAvailable);
		this.button.disable()
	},
	onUserInputStart: function(b) {
		var a = this;
		if (!a.model.readData("disabled") && Sys.UserInputUtils.isCoordinateTarget(a.button.getContainer().getEl(), b)) {
			a.model.storeData("buttonPressed", true);
			a.container.addCls(a.PRESSED_CSS)
		}
	},
	onUserInputEnd: function(c) {
		var b = this,
			a = this.model.readData("buttonPressed");
		b.model.storeData("buttonPressed", false);
		b.container.removeCls(this.PRESSED_CSS);
		if (a && Sys.UserInputUtils.isCoordinateTarget(b.button.getContainer().getEl(), c)) {
			b.fireEvent("view:userAction", "goToHistory")
		}
	}
};
Interface.GameHistoryBaseView = Sys.extend(Interface.SettingsSectionView, Interface.GameHistoryBaseView, "Interface.GameHistoryBaseView");
Sys.ns("Interface");
Interface.GameRules = {
	constructor: function() {
		Interface.GameRules.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return [{
			userInput: {
				inputEvents: ["start", "end", "cancel", "move", "scroll"]
			}
		}, "orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.GameRulesController,
			model: Interface.GameRulesModel,
			view: Interface.GameRulesBaseView
		}
	}
};
Interface.GameRules = Sys.extend(Interface.SettingsSection, Interface.GameRules, "Interface.GameRules");
Sys.ns("Interface");
Interface.GameRulesController = {
	constructor: function() {
		Interface.GameRulesController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.GameRulesController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"notify:stateHandler.enteringspinTypeRespinRestoreState": a.view.disableButton.bind(a.view)
		});
		if (Sys.isGcmEnabled) {
			a.removeListener("view:addToNavigator")
		}
	},
	show: function() {
		var a = this;
		if (!a.model.readData("hasLoadedGameRules") && !a.model.isState("fetchingGameRules")) {
			a.model.setState("fetchingGameRules");
			a.fetchGameRules()
		}
		Interface.GameRulesController.superclass.show.apply(a, arguments)
	},
	fetchGameRules: function() {
		var b = this,
			a = new Sys.Deferred();
		a.when(Sys.utils.httpGet({
			url: b.model.readData("templateURL")
		}), Sys.utils.httpGet({
			url: b.model.readData("textURL")
		}), Sys.utils.httpGet({
			url: b.model.readData("manifestURL")
		})).fail(b.onRulesLoadingFailed, b).done(b.onRulesPartsFetched, b)
	},
	onRulesPartsFetched: function(c, b, a) {
		this.model.processGameRules(c, b, a);
		this.view.updateContent()
	},
	onRulesLoadingFailed: function() {}
};
Interface.GameRulesController = Sys.extend(Interface.SettingsSectionController, Interface.GameRulesController, "Interface.GameRulesController");
Sys.ns("Interface");
Interface.GameRulesModel = {
	constructor: function() {
		Interface.GameRulesModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var d = this,
			c = Resources.readData("config").gameRules,
			e = Resources.readData("language"),
			b = Resources.readData("queryData").gameId,
			a = "../";
		b = b.replace(/_sw$/, "");
		if (Sys.isDefined(c)) {
			if (Platform.isDesktopDevice) {
				b = (b.indexOf("netent_") > -1) ? "netent_" + c.desktop : c.desktop
			} else {
				b = (b.indexOf("netent_") > -1) ? "netent_" + c.touch : c.touch
			}
		}
		Interface.GameRulesModel.superclass.setupData.apply(this, arguments);
		d.storeData("templateURL", a + "gamerules/template/" + b + ".template");
		d.storeData("textURL", a + "gamerules/rules/" + e.lang + "/rulestext.xml");
		d.storeData("manifestURL", a + "gamerules/META-INF/MANIFEST.MF");
		d.storeData("hasLoadedGameRules", false)
	},
	processGameRules: function(f, d, b) {
		var c = this,
			e = c.parseTextsToObject(d.responseText),
			a = c.insertTextsInTemplate(f.responseText, e);
		a = c.removeLinkTags(a);
		a = c.addTimestamp(a, b);
		a = c.removeNoncharacters(a);
		c.storeData("content", a);
		c.storeData("hasLoadedGameRules", true);
		c.setState("idle")
	},
	parseTextsToObject: function(d) {
		var a = {},
			b = /<ds.+name="([\w\d-]+)"[^>]*>(.+)<\/ds>/g,
			c = document.createElement("div");
		d.replace(b, function(g, e, f) {
			c.innerHTML = f;
			a[e] = c.textContent
		});
		return a
	},
	insertTextsInTemplate: function(b, a) {
		var c = b.replace(/<#([\w\d-]+)#\/>/g, function(d, e) {
			if (a[e]) {
				return a[e]
			} else {
				if (Services.languageManager.hasText(e)) {
					return Services.languageManager.getText(e)
				}
			}
			return "[rules string '" + e + "' not found]"
		});
		return c
	},
	removeLinkTags: function(a) {
		return a.replace(/<link.+>/g, "")
	},
	addTimestamp: function(a, b) {
		var c = this.parseDateFromManifest(b);
		return a + "<div id='manifest_timestamp' style='margin-top:10px;'>" + c + "</div>"
	},
	removeNoncharacters: function(a) {
		return decodeURIComponent(encodeURIComponent(a).replace(/%EF%BF%BF/g, ""))
	},
	parseDateFromManifest: function(b) {
		var a = this.checkIfRegExpMatch(b.response),
			c;
		b.responseText.replace(a, function(f, d, e) {
			c = d + " " + e + " (UTC)"
		});
		return c
	},
	checkIfRegExpMatch: function(c) {
		var b, a;
		b = /Git-CommitTime:\s([\d\-]+)T([\d:]+)/;
		a = /Subversion-(?:Commited)?Date: ([\d\-]+)T([\d:]+)/;
		return b.test(c) ? b : a
	}
};
Interface.GameRulesModel = Sys.extend(Core.Model, Interface.GameRulesModel, "Interface.GameRulesModel");
Sys.ns("Interface");
Interface.GameRulesBaseView = {
	BASE_CSS: "tab interface-gameRules_base",
	PORTRAIT_CSS: "interface-gameRules_portrait",
	LANDSCAPE_CSS: "interface-gameRules_landscape",
	RULES_WRAPPER_CSS: "interface-gameRules_rulesWrapper",
	LOADER_CSS: "interface-gameRules_rulesLoader",
	LOADER_URI: "interface-smallSpinner_uri",
	constructor: function() {
		Interface.GameRulesBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "gameRules",
			tag: "div",
			cls: a.BASE_CSS
		});
		a.rulesWrapper = a.container.add(new Sys.Element({
			id: "gameRules_rules",
			tag: "div",
			cls: a.RULES_WRAPPER_CSS
		}));
		a.rulesLoader = new Sys.Element({
			tag: "div",
			cls: a.LOADER_CSS + " " + a.LOADER_URI
		});
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.gameRules_uc),
			content: a.container
		});
		a.fireEvent("view:addToNavigator", "settingsMenu", {
			order: 4
		});
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	updateContent: function() {
		var a = this;
		a.rulesWrapper.remove(a.rulesLoader);
		a.rulesWrapper.el.innerHTML = a.model.readData("content");
		a.updateScrollerDimensions()
	},
	show: function() {
		Interface.GameRulesBaseView.superclass.show.apply(this, arguments);
		if (this.model.isState("fetchingGameRules")) {
			this.rulesWrapper.add(this.rulesLoader)
		}
	},
	enable: function() {},
	disable: function() {},
	disableButton: function() {
		if (Sys.isDefined(this.abstractButton)) {
			this.abstractButton.disable("notInIdleState")
		}
	}
};
Interface.GameRulesBaseView = Sys.extend(Interface.SettingsSectionView, Interface.GameRulesBaseView, "Interface.GameRulesBaseView");
Sys.ns("Interface");
Interface.GameRulesDesktopView = {
	BUTTON_CSS: "interface-desktopSettingsMenu_button interface-gameRules_icon_uri",
	WRAPPER_CSS: "tab interface-settingsWindow_content",
	ENABLED_ONLY_IN_BASIC_GAME: true,
	constructor: function() {
		Interface.GameRulesDesktopView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var a = this;
		a.containerWrapper = new Sys.Element({
			id: "containerWrapper",
			tag: "div",
			cls: a.WRAPPER_CSS
		});
		a.container = a.containerWrapper.add(new Sys.Element({
			id: "gameRules",
			tag: "div",
			cls: a.BASE_CSS
		}));
		a.rulesWrapper = a.container.add(new Sys.Element({
			id: "gameRules_rules",
			tag: "div",
			cls: a.RULES_WRAPPER_CSS
		}));
		a.rulesLoader = new Sys.Element({
			tag: "div",
			cls: a.LOADER_CSS + " " + a.LOADER_URI
		});
		a.createButton();
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.gameRules_uc),
			content: a.containerWrapper
		});
		a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
			order: 4,
			element: a.menuButton
		});
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	createButton: function() {
		var a = this;
		a.menuButton = new Sys.Element({
			id: "gameRulesButton",
			tag: "div",
			cls: a.BUTTON_CSS
		});
		a.abstractButton = new Interface.AbstractButton({
			dimensions: a.menuButton.el,
			clickCallback: function() {
				if (!a.model.readData("showing")) {
					a.fireEvent("view:showRequest")
				} else {
					a.fireEvent("view:hideRequest")
				}
			},
			hoverCallback: function() {
				a.menuButton.addCls("hover")
			},
			upCallback: function() {
				a.menuButton.removeCls("hover")
			}
		})
	},
	hide: function() {
		this.containerWrapper.el.style.display = "none";
		Interface.GameRulesDesktopView.superclass.hide.apply(this, arguments)
	},
	show: function() {
		this.containerWrapper.el.style.display = "block";
		Interface.GameRulesDesktopView.superclass.show.apply(this, arguments)
	},
	disableButton: function() {
		this.abstractButton.disable("notInIdleState")
	}
};
Interface.GameRulesDesktopView = Sys.extend(Interface.GameRulesBaseView, Interface.GameRulesDesktopView, "Interface.GameRulesDesktopView");
Sys.ns("Interface");
Interface.Paytable = {
	constructor: function() {
		Interface.Paytable.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["userInput", "orientation"],
			desktop: ["animation", "userInput"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.PaytableController,
			model: Interface.PaytableModel,
			view: Interface.PaytableBaseView
		}
	}
};
Interface.Paytable = Sys.extend(Interface.SettingsSection, Interface.Paytable, "Interface.Paytable");
Sys.ns("Interface");
Interface.PaytableController = {
	constructor: function() {
		Interface.PaytableController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:paytable.forward": a.onForwardRequest,
			"request:paytable.backward": a.onBackwardRequest,
			"notify:responseParser.paytableResponseParsed": a.onPaytableResponse,
			"view:pageSwitch": a.fireEvent.bind(a, "notify:paytable.pageSwitched"),
			"notify:gameModeChanged": a.onGameModeChanged
		});
		Interface.PaytableController.superclass.setupEvents.apply(a, arguments)
	},
	setUpContent: function() {
		this.fireEvent("request:serverManager.sendAction", "paytable", "notify:responseParser.paytableResponseParsed")
	},
	onPaytableResponse: function(a) {
		this.model.processPaytableResponse(a);
		this.view.setUpContent()
	},
	onShowRequest: function(a) {
		var b = this;
		if (!b.model.readData("showing")) {
			Interface.PaytableController.superclass.onShowRequest.apply(b, arguments)
		} else {
			b.view.show(a)
		}
	},
	onForwardRequest: function() {
		if (this.model.readData("showing")) {
			this.view.showNextPage()
		}
	},
	onBackwardRequest: function() {
		if (this.model.readData("showing")) {
			this.view.showPreviousPage()
		}
	},
	onGameModeChanged: function(a) {
		if (Sys.isDefined(this.view.showButton) && Sys.isDefined(this.view.hideButton)) {
			if (a === "BASIC") {
				this.view.showButton()
			} else {
				this.view.hideButton()
			}
		}
	}
};
Interface.PaytableController = Sys.extend(Interface.SettingsSectionController, Interface.PaytableController, "Interface.PaytableController");
Sys.ns("Interface");
Interface.PaytableModel = {
	constructor: function() {
		Interface.PaytableModel.superclass.constructor.apply(this, arguments)
	},
	setNumberOfPages: function(a) {
		Services.storage.storeData("paytable.numberOfPages", a)
	},
	setCurrentPage: function(a) {
		Services.storage.storeData("paytable.currentPage", a)
	},
	processPaytableResponse: function(a) {
		var b = this,
			c = a.pt,
			d = {};
		Sys.iterate(c, function(f, e) {
			b.parseGameMode(f, e, d)
		});
		b.storeData("paytableInfo", d)
	},
	parseGameMode: function(c, a, e) {
		var d = this,
			b = {
				scatterWins: {},
				betlineWins: {}
			};
		Sys.iterate(a.comp, function(f, g) {
			d.parsePaytableComponent(f, g, b)
		});
		e[a.id] = b
	},
	parsePaytableComponent: function(b, d, a) {
		var g = d.symbol,
			c = d.type + "Wins",
			f = d.n,
			e;
		if (d.type !== "scatter" && d.type !== "betline") {
			return
		}
		if (!Sys.isDefined(a[c][g])) {
			a[c][g] = {
				freeSpins: [],
				betMultiplier: []
			}
		}
		e = a[c][g];
		e.freeSpins[f] = d.freespins;
		e.betMultiplier[f] = d.multi
	},
	getCondensedInfo: function(b, a, c, f) {
		var h = this.readData("paytableInfo")[f || "basic"][c || "betlineWins"][b][a || "betMultiplier"],
			d = 1,
			j = 0,
			g = h[0],
			e = [];
		for (; d < h.length; d++) {
			if (h[d] !== g) {
				e.push({
					from: j,
					to: d - 1,
					value: g
				});
				j = d;
				g = h[d]
			}
		}
		e.push({
			from: j,
			to: d - 1,
			value: g
		});
		return e
	},
	setupData: function() {
		var a = Game.stage.model.getCurrentReelGroupConfiguration();
		this.storeData("symbolWidth", a.symbolWidth);
		this.storeData("symbolHeight", a.symbolHeight);
		Services.storage.storeData("paytable.showing", false)
	}
};
Interface.PaytableModel = Sys.extend(Core.Model, Interface.PaytableModel, "Interface.PaytableModel");
Sys.ns("Interface");
Interface.PaytableBaseView = {
	BASE_CSS: "tab interface-paytable_base",
	PORTRAIT_CSS: "interface-paytable_portrait",
	LANDSCAPE_CSS: "interface-paytable_landscape",
	SECTION_CSS: "interface-paytable_section interface-settingsSection_subSection",
	SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
	HEADING_CSS: "interface-paytable_heading",
	SECTIONS: ["SymbolValues", "Betlines", "Disclaimer"],
	HIGH_WIN: {
		COLOR: "",
		SYMBOLS: []
	},
	MEDIUM_WIN: {
		COLOR: "",
		SYMBOLS: []
	},
	LOW_WIN: {
		COLOR: "",
		SYMBOLS: []
	},
	DISCLAIMER_STRINGS: [Language.Keys.paytable_highest, Language.Keys.paytable_betLineWinsLeftToRightOnly, Language.Keys.paytable_voidAllPays, Language.Keys.paytable_extraInfo],
	constructor: function() {
		Interface.PaytableBaseView.superclass.constructor.apply(this, arguments);
		this.setupContainer();
		this.sectionElements = {}
	},
	setupContainer: function() {
		this.container = new Sys.Element({
			id: "paytable",
			tag: "div",
			cls: this.BASE_CSS
		})
	},
	setUpContent: function() {
		var a = this;
		a.model.setNumberOfPages(1);
		a.model.setCurrentPage(1);
		a.createSections();
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.paytable_uc),
			content: a.container
		});
		a.fireEvent("view:addToNavigator", "settingsMenu", {
			order: 3
		});
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	showNextPage: function() {},
	showPreviousPage: function() {},
	createSections: function() {
		var c = this,
			d = c.SECTIONS,
			a = d.length,
			b;
		for (b = -1; ++b < a;) {
			if (Sys.isFunc(c["create" + d[b]])) {
				c["create" + d[b]]()
			}
		}
	},
	createSymbolValues: function() {
		var a = this,
			b = new Sys.Element({
				tag: "div",
				"class": a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
			});
		b.add(new Sys.Element({
			tag: "div",
			textContent: Services.languageManager.getText(Language.Keys.paytable_symbolPayout),
			"class": a.HEADING_CSS + " utils_center_text"
		}));
		if (a.HIGH_WIN.SYMBOLS.length > 0) {
			b.add(a.createSymbolSubSection(a.HIGH_WIN.SYMBOLS, a.HIGH_WIN.COLOR))
		}
		if (a.MEDIUM_WIN.SYMBOLS.length > 0) {
			b.add(a.createSymbolSubSection(a.MEDIUM_WIN.SYMBOLS, a.MEDIUM_WIN.COLOR))
		}
		if (a.LOW_WIN.SYMBOLS.length > 0) {
			b.add(a.createSymbolSubSection(a.LOW_WIN.SYMBOLS, a.LOW_WIN.COLOR))
		}
		a.sectionElements.SymbolValues = b;
		a.container.add(b)
	},
	createSymbolSubSection: function(d, c) {
		var f = this,
			b = new Sys.Element({
				tag: "table",
				"class": "interface-paytable_symbols"
			}),
			a = d.length,
			g, e;
		for (e = -1; ++e < a;) {
			if (e % 2 === 0) {
				g = b.add(new Sys.Element({
					tag: "tr"
				}))
			}
			f.appendSymbolContainer(g, d[e], c)
		}
		return b
	},
	appendSymbolContainer: function(a, d, e, b, f, l) {
		var j = Resources.readData("animationImages"),
			o = this.model.readData("symbolHeight"),
			c = a.add(new Sys.Element({
				tag: "td",
				style: "min-height: " + o + "px; text-align: center;"
			})),
			h = this.model.getCondensedInfo(d, b, f, l).sort(function(q, p) {
				return p.from - q.from
			}),
			k = h.length,
			n, m, g;
		if (Sys.isDefined(j[d])) {
			c.el.appendChild(j[d])
		}
		n = a.add(new Sys.Element({
			tag: "td",
			style: "min-height: " + o + "px;"
		})).add(new Sys.Element({
			tag: "ul",
			"class": "interface-paytable_symbolValues"
		}));
		for (g = -1; ++g < k;) {
			m = h[g];
			if (Sys.isDefined(m.value)) {
				n.add(new Sys.Element({
					tag: "li",
					textContent: m.from,
					style: "width: 33%; color: " + e + ";"
				}));
				n.add(new Sys.Element({
					tag: "li",
					textContent: m.value,
					style: "width: 66%;"
				}))
			}
		}
	},
	createBetlines: function() {
		var b = this,
			a = Resources.readData("animationImages"),
			c = new Sys.Element({
				tag: "div",
				"class": b.SECTION_CSS + " utils_center_text " + b.SECTION_SEPARATOR_URI
			});
		c.add(new Sys.Element({
			tag: "div",
			textContent: Services.languageManager.getText(Language.Keys.paytable_winningBetLinesHeading),
			"class": b.HEADING_CSS
		}));
		if (Sys.isObj(a) && Sys.isDefined(a.betlines)) {
			c.el.appendChild(a.betlines)
		}
		b.sectionElements.Betlines = c;
		b.container.add(c)
	},
	createDisclaimer: function() {
		var c = this,
			d = new Sys.Element({
				tag: "div",
				"class": c.SECTION_CSS + " utils_center_text " + c.SECTION_SEPARATOR_URI
			}),
			a = c.DISCLAIMER_STRINGS,
			e = a.length,
			b;
		for (b = -1; ++b < e;) {
			d.add(new Sys.Element({
				tag: "div",
				textContent: Services.languageManager.getText(a[b])
			}))
		}
		c.sectionElements.Disclaimer = d;
		c.container.add(d)
	}
};
Interface.PaytableBaseView = Sys.extend(Interface.SettingsSectionView, Interface.PaytableBaseView, "Interface.PaytableBaseView");
Sys.ns("Interface");
Interface.PaytableDesktopView = {
	BASE_CSS: "tab interface-paytableDesktop_base",
	KEYPAD_BUTTON_CONFIG: {
		dimensions: {
			x: 50,
			y: 623,
			width: 52,
			height: 52
		},
		buttonImages: {
			up: "paytableButtonUp",
			down: "paytableButtonDown",
			hover: "paytableButtonOver",
			disabled: "paytableButtonDisabled"
		}
	},
	constructor: function() {
		Interface.PaytableDesktopView.superclass.constructor.apply(this, arguments)
	},
	show: function(b) {
		var c = this,
			a = c.navigation.getCurrentCardIndex();
		Interface.PaytableDesktopView.superclass.show.apply(c, arguments);
		if (Sys.isNumber(b) && b > 0 && b <= c.SECTIONS.length) {
			a = b - 1
		}
		c.navigation.selectCard(a);
		c.navigation.enable(c.MODULE_NAME)
	},
	hide: function() {
		var c = this,
			e, d, a, b;
		Interface.PaytableDesktopView.superclass.hide.apply(c, arguments);
		e = c.SECTIONS;
		d = c.sectionElements;
		a = e.length;
		for (b = -1; ++b < a;) {
			d[e[b]].el.style.display = "none"
		}
		c.navigation.disable(c.MODULE_NAME)
	},
	showNextPage: function() {
		this.navigation.next()
	},
	showPreviousPage: function() {
		this.navigation.previous()
	},
	enable: function(a) {
		if (this.animationsReady) {
			this.button.enable(a)
		}
	},
	disable: function(a) {
		if (this.animationsReady) {
			this.button.disable(a)
		}
	},
	setUpContent: function() {
		var a = this;
		a.model.setNumberOfPages(a.SECTIONS.length);
		a.model.setCurrentPage(1);
		a.createSections();
		a.createNavigation();
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.paytable_uc),
			content: a.container
		});
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	createNavigation: function() {
		var a = this;
		a.navigation = new Interface.utils.CardNavigation({
			id: "paytableNavigation",
			numCards: this.SECTIONS.length,
			selectionCallback: a.onCardSelection.bind(a),
			closeCallback: a.onCloseCallback.bind(a),
			arrowLabels: {
				next: "Next",
				previous: "Previous"
			}
		});
		a.subComponents = [a.navigation];
		a.container.add(a.navigation.getArrows());
		a.container.add(a.navigation.getIndicators())
	},
	onCardSelection: function(b, e, a) {
		var c = this,
			d;
		c.hideSection(e);
		c.showSection(b);
		c.model.setCurrentPage(b + 1);
		if (b !== e) {
			d = (b > e) ? "forward" : "backward";
			if (a) {
				d = (b < e) ? "forward" : "backward"
			}
			c.fireEvent("view:pageSwitch", d)
		}
	},
	onCloseCallback: function() {
		this.fireEvent("view:hideRequest")
	},
	showSection: function(a) {
		this.sectionElements[this.SECTIONS[a]].el.style.display = "block"
	},
	hideSection: function(a) {
		this.sectionElements[this.SECTIONS[a]].el.style.display = "none"
	},
	showButton: function() {
		if (this.animationsReady) {
			this.button.show("buttonHideRequest");
			this.hidden = false
		}
	},
	hideButton: function() {
		if (this.animationsReady) {
			this.button.hide("buttonHideRequest");
			this.hidden = true
		}
	},
	enableButton: function() {
		if (!this.hidden) {
			this.button.enable("buttonDisableRequest")
		}
	},
	disableButton: function() {
		if (!this.hidden) {
			this.button.disable("buttonDisableRequest")
		}
	},
	initAnimations: function() {
		var b = this,
			a = Sys.applyProperties({
				clickCallback: b.onButtonClick.bind(b)
			}, b.KEYPAD_BUTTON_CONFIG);
		if (Sys.isDefined(a.buttonLabel)) {
			a.buttonLabel.depth = Layering.Game.Slots.Keypad.paytable.label
		}
		if (Sys.isDefined(a.buttonLayoutParameters)) {
			a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.paytable.button
		} else {
			a.dimensions.depth = Layering.Game.Slots.Keypad.paytable.button
		}
		b.button = new Interface.utils.CanvasButton(a);
		b.button.id = "paytable";
		b.animationsReady = true
	},
	onButtonClick: function() {
		if (!this.model.readData("showing")) {
			this.fireEvent("view:showRequest")
		} else {
			this.fireEvent("view:hideRequest")
		}
	},
	shouldBeHiddenByUserInput: function() {
		return false
	},
	onDisableBasicGamePanel: function() {
		this.disable("disableBasicGamePanel")
	},
	onEnableBasicGamePanel: function() {
		this.enable("disableBasicGamePanel")
	},
	onScroll: function() {}
};
Interface.PaytableDesktopView = Sys.extend(Interface.PaytableBaseView, Interface.PaytableDesktopView, "Interface.PaytableDesktopView");
Sys.ns("Core");
Core.PortraitMessage = {
	constructor: function() {},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Model,
			view: Core.PortraitMessageView,
			controller: Core.PortraitMessageController
		}
	}
};
Core.PortraitMessage = Sys.extend(Core.Module, Core.PortraitMessage, "Core.PortraitMessage");
Sys.ns("Core");
Core.PortraitMessageController = {
	constructor: function() {},
	init: function() {
		if (Sys.useLegacyScaling) {
			Core.PortraitMessageController.superclass.init.apply(this, arguments);
			this.fireEvent("notify:potraitMessage.active");
			if (Services.orientation.isPortrait()) {
				this.show()
			}
		}
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:loader.closed": a.onLoaderClose,
			"request:portraitMessage.hide": a.hide,
			"request:portraitMessage.show": a.show,
			"notify:viewport.PORTRAIT": a.view.onPortrait.bind(a.view)
		})
	},
	onLoaderClose: function() {
		var a = this;
		a.model.storeData("loaderClosed", true);
		if (a.model.readData("showRequested")) {
			a.model.setState("show")
		}
	},
	hide: function() {
		this.model.setState("hide");
		this.model.storeData("showRequested", false)
	},
	show: function() {
		this.model.setState("show")
	}
};
Core.PortraitMessageController = Sys.extend(Core.Controller, Core.PortraitMessageController, "Core.PortraitMessageController");
Sys.ns("Core");
Core.PortraitMessageView = {
	constructor: function() {},
	init: function() {
		Core.PortraitMessageView.superclass.init.apply(this, arguments);
		if (Sys.useLegacyScaling) {
			this.buildContent()
		}
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:show": a.show,
			"model:hide": a.hide
		})
	},
	show: function() {
		this.graphicsContainer.el.style.display = "block"
	},
	hide: function() {
		this.graphicsContainer.el.style.display = "none"
	},
	buildContent: function() {
		var c = this,
			b, a, d;
		b = new Sys.Element({
			id: "portraitMessage",
			tag: "div"
		});
		b.add(new Sys.Element({
			id: "phoneOutline",
			tag: "div",
			cls: "iphone_outline_uri portraitMessage_phoneOutline"
		}));
		b.add(new Sys.Element({
			id: "portraitLogo",
			tag: "div",
			cls: "portraitLogo_uri portraitMessage_logo"
		}));
		a = b.add(new Sys.Element({
			tag: "div",
			id: "rotatingPhone",
			cls: "iphone_outline_uri portraitMessage_rotatingPhone"
		}));
		d = b.add(new Sys.Element({
			id: "portraitMessageText",
			tag: "div",
			cls: "portraitMessage_text",
			textContent: Services.languageManager.getText(Language.Keys.landscapeMode)
		}));
		document.body.insertBefore(b.el, document.getElementById("viewport"));
		c.rotatingPhone = a;
		c.graphicsContainer = b;
		c.text = d
	},
	onPortrait: function() {
		var a = this.graphicsContainer.el.offsetHeight;
		this.text.el.style.fontSize = (a * 0.02) + "px"
	}
};
Core.PortraitMessageView = Sys.extend(Core.View, Core.PortraitMessageView, "Core.PortraitMessageView");
Sys.ns("Interface");
Interface.SpinSettingsBase = {
	constructor: function() {
		Interface.SpinSettingsBase.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SpinSettingsBaseController,
			model: Interface.SpinSettingsBaseModel,
			view: Core.View
		}
	}
};
Interface.SpinSettingsBase = Sys.extend(Interface.SettingsSection, Interface.SpinSettingsBase, "Interface.SpinSettingsBase");
Sys.ns("Interface");
Interface.SpinSettingsBaseController = {
	constructor: function() {
		Interface.SpinSettingsBaseController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.SpinSettingsBaseController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"request:spinSettings.showStopIfFreeSpinsWon": a.showStopIfFreeSpinsWon,
			"request:spinSettings.showStopIfAutoplayingBonusGameWon": a.showStopIfAutoplayingBonusGameWon,
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"notify:settingsManager.settingEnabled": a.onSettingEnabled,
			"notify:settingsManager.settingDisabled": a.onSettingDisabled,
			"notify:settingsManager.settingLocked": a.onSettingLocked,
			"notify:settingsManager.unlockSetting": a.onSettingUnlocked,
			"notify:moneyManager.betChanged": a.onBetChanged,
			"notify:stateHandler.enteringSetupGameState": a.checkIfAutoplayDisabled
		})
	},
	checkIfAutoplayDisabled: function() {
		var b = this,
			a = b.model.getAutoplaySpinsArray();
		if (a.length === 1 && (a[0] < 5 || a[0] > 1000)) {
			b.fireEvent("request:settingsManager.disableSetting", "autoPlayNrSpins");
			b.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0);
			b.fireEvent("request:settingsManager.lockSetting", "autoPlayNrSpins", b.MODULE_NAME)
		}
	},
	onSettingChanged: function(a, c) {
		var b = this;
		if (a === "autoPlayNrSpins") {
			if (c === 0) {
				c = b.model.getAutoplaySpinsArray()[0]
			}
			b.model.storeData(a, c);
			b.view.update()
		}
	},
	onBetChanged: function() {
		var a = Services.settingsManager.getSetting("autoPlayNrSpins");
		if (a > 0 && !this.canStartAutoplay()) {
			this.showWarningDialog()
		}
	},
	canStartAutoplay: function() {
		var c = Services.moneyManager.getBetCents(),
			a = this.model.readData("isRestrictedMode"),
			b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy");
		if (a || b > 0) {
			return c <= b
		}
		return true
	},
	onSettingDisabled: function(a) {
		this.view.removeSetting(a)
	},
	onSettingEnabled: function() {},
	onSettingLocked: function(a) {
		this.view.lockSetting(a)
	},
	onSettingUnlocked: function(a) {
		this.view.unlockSetting(a)
	},
	onUserAction: function(a, b) {
		this.model.storeData(a, b);
		if (a === "autoPlayNrSpins" && isNaN(Number(b))) {
			b = 0
		}
		this.fireEvent("request:settingsManager.storeData", a, b)
	},
	showWarningDialog: function() {
		var b = this,
			a = Services.languageManager;
		if (Environment.getCurrentPlatform() === "desktop") {
			b.fireEvent("request:dialogWindow.showDialog", {
				title: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesBy),
				text: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesByWarning),
				buttons: [{
					text: a.getText(Language.Keys.btn_ok)
				}]
			})
		} else {
			b.fireEvent("request:dialogWindow.showDialog", {
				title: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesBy),
				text: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesByWarningTouch),
				buttons: [{
					text: a.getText(Language.Keys.btn_close),
					action: function() {
						b.fireEvent("request:autoPlayer.stop")
					}
				}, {
					text: a.getText(Language.Keys.btn_ok),
					action: function() {
						b.fireEvent("request:spinSettings.openAdvancedSettingKeyboard", "stopAutoplayIfBalanceDecreasedBy")
					}
				}]
			})
		}
	},
	showStopIfFreeSpinsWon: function() {},
	showStopIfAutoplayingBonusGameWon: function() {}
};
Interface.SpinSettingsBaseController = Sys.extend(Interface.SettingsSectionController, Interface.SpinSettingsBaseController, "Interface.SpinSettingsBaseController");
Sys.ns("Interface");
Interface.SpinSettingsBaseModel = {
	AUTOPLAY_SPINS: [0, 10, 25, 50, 100, 250, 500, 750, 1000],
	constructor: function() {
		Interface.SpinSettingsBaseModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var d = this,
			b = Resources.readData("gameServerInitResponseObject").autoplay,
			a, c;
		if (Sys.isDefined(b) && ((b === 0 || d.validateSingleAutoPlayValue(b) || d.validateAutoplayArray(b)))) {
			if (!Sys.isArray(b)) {
				b = [b]
			} else {
				b = b.slice()
			}
			if (!b.contains(0)) {
				b = [0].concat(b)
			}
			b.sort(function(f, e) {
				return f - e
			})
		} else {
			b = d.AUTOPLAY_SPINS
		}
		a = [{
			key: "autoPlayNrSpins",
			defaultValue: b[0],
			settingsManager: true,
			localStorage: false
		}, {
			key: "autoplaySpinsArray",
			defaultValue: b,
			settingsManager: false,
			localStorage: false
		}];
		a.forEach(d.initData, d);
		Services.storage.storeData("spinSettings.autoplayRoundsAvailable", b.slice(1));
		Interface.SpinSettingsBaseModel.superclass.setupData.apply(this, arguments);
		c = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
		this.storeData("isRestrictedMode", c)
	},
	validateAutoplayArray: function(a) {
		var b = this,
			c = true,
			d = a.length;
		if (Sys.isArray(a) && d > 0 && d < 9) {
			Sys.each(a, function(f, e) {
				a[e] = Sys.utils.toInt(f);
				if (!b.validateSingleAutoPlayValue(a[e])) {
					c = false
				}
			})
		} else {
			c = false
		}
		return c
	},
	validateSingleAutoPlayValue: function(a) {
		var b = true,
			c = Sys.utils.toInt(a);
		if (Sys.isArray(a) || isNaN(c) || c < 5 || c > 1000) {
			b = false
		}
		return b
	},
	getAutoplaySpinsArray: function() {
		return this.readData("autoplaySpinsArray")
	}
};
Interface.SpinSettingsBaseModel = Sys.extend(Interface.SettingsSectionModel, Interface.SpinSettingsBaseModel, "Interface.SpinSettingsBaseModel");
Sys.ns("Interface");
Interface.SpinSettings = {
	constructor: function() {
		Interface.SpinSettings.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SpinSettingsController,
			model: Interface.SpinSettingsModel,
			view: Interface.SpinSettingsView
		}
	}
};
Interface.SpinSettings = Sys.extend(Interface.SpinSettingsBase, Interface.SpinSettings, "Interface.SpinSettings");
Sys.ns("Interface");
Interface.SpinSettingsModel = {
	setupData: function() {
		var b = this,
			a = [{
				key: "stopAutoplayIfBalanceDecreasedBy",
				defaultValue: false,
				settingsManager: true,
				localStorage: true
			}, {
				key: "leftHandMode",
				defaultValue: false,
				settingsManager: true,
				localStorage: true
			}, {
				key: "quickSpin",
				defaultValue: false,
				settingsManager: true,
				localStorage: true
			}, {
				key: "stopAutoplayIfFreeSpinWon",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}, {
				key: "stopAutoplayIfAutoplayingBonusGameWon",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}, {
				key: "stopAutoplayIfWinExceeds",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}];
		Interface.SpinSettingsModel.superclass.setupData.apply(this, arguments);
		a.forEach(b.initData, b)
	}
};
Interface.SpinSettingsModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.SpinSettingsModel, "Interface.SpinSettingsModel");
Sys.ns("Interface");
Interface.SpinSettingsController = {
	constructor: function() {
		Interface.SpinSettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.SpinSettingsController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"request:spinSettings.openAdvancedSettingKeyboard": a.openAdvancedSettingsKeyboard,
			"notify.dialogWindow.showingDialog": a.onShowingDialog,
			"view:autoPlaySliderEnd": a.userInteractionEnded,
			"notify:freeRounds.started": a.view.onFreeRoundsStateChange.bind(a.view, true),
			"notify:freeRounds.ended": a.view.onFreeRoundsStateChange.bind(a.view, false)
		})
	},
	userInteractionEnded: function(c) {
		var b = this,
			a = b.model.readData("isRestrictedMode");
		if (a === true && c > 0) {
			b.fireEvent("request:userInputManager.activateExclusivity", "spinSettings.addingValue");
			b.addValueToLossLimit()
		}
	},
	onBetChanged: function(a) {
		var b = this;
		Interface.SpinSettingsController.superclass.onBetChanged.apply(b, arguments);
		if (b.view.advancedSettings && b.view.advancedSettings.stopAutoplayIfBalanceDecreasedBy) {
			b.view.advancedSettings.stopAutoplayIfBalanceDecreasedBy.setMinValue(a.playerBetCents > 0 ? a.playerBetCents : undefined)
		}
	},
	onUserAction: function(c, e) {
		var d = this,
			b = d.model.readData("isRestrictedMode"),
			a = d.model.readData("freeRoundsActive") || false;
		Interface.SpinSettingsController.superclass.onUserAction.apply(this, arguments);
		if (c === "leftHandMode" || c === "quickSpin") {
			Services.localStorageManager.storeData(c, e.toString())
		}
		if (c === "autoPlayNrSpins") {
			this.enableAdvancedSettings(e)
		}
		if (b === true && c === "stopAutoplayIfBalanceDecreasedBy" && e === 0 && !a) {
			Services.settingsManager.storeSetting("autoPlayNrSpins", 0)
		}
	},
	enableAdvancedSettings: function(d) {
		var c = this,
			a = c.model.readData("isRestrictedMode"),
			e = c.model.readData("freeRoundsActive"),
			b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy") || 0;
		d = Sys.isDefined(d) ? d : 0;
		if (d > 0) {
			c.view.showAdvancedSettings();
			c.view.enableAdvancedSettings()
		} else {
			c.view.hideAdvancedSettings();
			c.view.disableAdvancedSettings()
		}
		if (a === true && !e && b === 0) {
			c.view.disableAdvancedSettings()
		}
	},
	onSettingChanged: function(c, e) {
		var d = this,
			b = d.model.readData("isRestrictedMode"),
			a = d.model.readData("freeRoundsActive") || false;
		Interface.SpinSettingsController.superclass.onSettingChanged.apply(d, arguments);
		if (c === "quickSpin") {
			d.model.storeData(c, e);
			d.view.update()
		}
		if (b === true && c === "stopAutoplayIfBalanceDecreasedBy" && e === 0 && !a) {
			Services.settingsManager.storeSetting("autoPlayNrSpins", 0)
		}
	},
	showStopIfAutoplayingBonusGameWon: function() {
		this.view.showStopIfAutoplayingBonusGameWon()
	},
	openAdvancedSettingsKeyboard: function(b) {
		var a = this;
		a.fireEvent("request:settingsWindow.openChild", "spinSettings");
		a.view.openAdvancedSetting(b)
	},
	addValueToLossLimit: function() {
		var c = this,
			b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy"),
			a = c.model.readData("freeRoundsActive");
		if ((!b || b === 0) && !a) {
			setTimeout(function() {
				c.fireEvent("request:userInputManager.deactivateExclusivity", "spinSettings.addingValue");
				c.view.openAdvancedSetting("stopAutoplayIfBalanceDecreasedBy");
				c.view.enableAdvancedSettings()
			}, 1000)
		} else {
			c.fireEvent("request:userInputManager.deactivateExclusivity", "spinSettings.addingValue");
			c.view.enableAdvancedSettings()
		}
	},
	onShowingDialog: function() {
		if (this.model.readData("showing")) {
			this.fireEvent("request:keyboard.cancel")
		}
	}
};
Interface.SpinSettingsController = Sys.extend(Interface.SpinSettingsBaseController, Interface.SpinSettingsController, "Interface.SpinSettingsController");
Sys.ns("Interface");
Interface.SpinSettingsView = {
	BASE_CSS: "tab interface-spinSettings_base",
	PORTRAIT_CSS: "interface-spinSettings_portrait",
	LANDSCAPE_CSS: "interface-spinSettings_landscape",
	SECTION_CSS: "interface-settingsSection_subSection",
	SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
	AUTOPLAY_SETTINGS_CSS: "interface-spinSettings_autoPlayContainer",
	AUTO_PLAY_ADDVALUE: "ifCashDecreasesByAddValue",
	AUTOPLAYING_BONUS_GAME_LABEL: Language.Keys.autoplay_setting_ifFBonusIsStarted,
	FREEROUND_ACTIVE_CONTROLS: ["stopAutoplayIfFreeSpinWon", "stopIfAutoplayingBonusGameWon"],
	ADVANCED_AUTOPLAY_SETTINGS: {
		stopAutoplayTitle: {
			labelOCTKey: Language.Keys.autoplay_setting_stopAutoPlay,
			type: "settingGroupTitle"
		},
		stopAutoplayIfBalanceDecreasedBy: {
			labelOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesBy,
			buttonTextOCTKey: Language.Keys.btn_addValue,
			infoOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesByInfoTouch,
			type: "interactiveContainer",
			defaultValue: 0
		},
		stopAutoplayIfWinExceeds: {
			labelOCTKey: Language.Keys.autoplay_setting_ifWinExeeds,
			buttonTextOCTKey: Language.Keys.btn_addValue,
			type: "interactiveContainer",
			defaultValue: 0
		},
		stopAutoplayIfBalanceIncreasedBy: {
			labelOCTKey: Language.Keys.autoplay_setting_ifCashIncreasesBy,
			buttonTextOCTKey: Language.Keys.btn_addValue,
			type: "interactiveContainer",
			defaultValue: 0
		},
		stopAutoplayIfFreeSpinWon: {
			type: "ToggleSwitch",
			titleOCTKey: Language.Keys.stopIfFreeSpins,
			defaultValue: false
		}
	},
	constructor: function() {
		Interface.SpinSettingsView.superclass.constructor.apply(this, arguments);
		this.lockedControllers = []
	},
	setUpContent: function() {
		var a = this,
			b;
		a.container = new Sys.Element({
			id: "spinSettings",
			tag: "div",
			cls: a.BASE_CSS
		});
		a.autoplayContainer = a.container.add(new Sys.Element({
			id: "spinSettings_autoplaySettings",
			tag: "div",
			cls: a.SECTION_CSS + " " + a.AUTOPLAY_SETTINGS_CSS
		}));
		a.numberOfAutoPlaysSetting = a.autoplayContainer.add(new Sys.Element({
			id: "nrOfAutoplaySpins",
			tag: "ul",
			"class": "interface-settingsSection_dynamicSliderPosition_container"
		}));
		a.nrOfSpinsText = a.numberOfAutoPlaysSetting.add(new Sys.Element({
			id: "nrAutoPlaySpinsLabel",
			tag: "li",
			"class": "interface-settingsSection_dynamicSliderPosition_label",
			textContent: Services.languageManager.getText(Language.Keys.autoplay)
		}));
		a.nrAutoPlaySpins = new Interface.utils.Slider({
			id: "nrAutoPlaySpinsSlider",
			values: a.model.getAutoplaySpinsArray(),
			callback: a.onSettingsControllerChanged.bind(a, "autoPlayNrSpins"),
			endCallback: a.fireEvent.bind(a, "view:autoPlaySliderEnd"),
			showLabels: true
		});
		a.advancedAutoplaySettings = a.autoplayContainer.add(new Sys.Element({
			id: "advancedAutoplaySettings",
			tag: "div",
			cls: "interface-autoPlay_advancedSettings_container",
			transitionend: this.updateScrollerDimensions.bind(this)
		}));
		a.initAdvancedAutoplaySettings();
		a.numberOfAutoPlaysSetting.add(new Sys.Element({
			id: "nrAutoPlaySpinsSliderWrapper",
			tag: "li",
			"class": "interface-settingsSection_dynamicSliderPosition_slider"
		})).add(a.nrAutoPlaySpins.getContainer());
		a.stopIfAutoplayingBonusGameWon = new Interface.utils.ToggleSwitch({
			id: "stopIfAutoplayingBonusGameWon",
			title: Services.languageManager.getText(a.AUTOPLAYING_BONUS_GAME_LABEL),
			callback: a.onSettingsControllerChanged.bind(a, "stopAutoplayIfAutoplayingBonusGameWon")
		});
		b = a.stopIfAutoplayingBonusGameWon.getContainer();
		a.stopIfAutoplayingBonusGameWonOriginalDisplay = b.el.style.display;
		b.el.style.display = "none";
		a.autoplayContainer.add(b);
		a.quickSpinContainer = a.container.add(new Sys.Element({
			id: "spinSettings_quickSpinSettings",
			tag: "div",
			cls: a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
		}));
		a.quickSpin = new Interface.utils.ToggleSwitch({
			id: "quickSpinOnOff",
			title: Services.languageManager.getText(Language.Keys.setting_quickSpinGame),
			callback: a.onSettingsControllerChanged.bind(a, "quickSpin")
		});
		a.quickSpinContainer.add(a.quickSpin.getContainer());
		a.spinButtonPositionContainer = a.container.add(new Sys.Element({
			id: "spinSettings_spinButtonPositionSettings",
			tag: "div",
			cls: a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
		}));
		a.spinButtonPosition = new Interface.utils.ToggleSwitch({
			id: "spinButtonPositionLeftRight",
			title: Services.languageManager.getText(Language.Keys.setting_leftHandMode),
			callback: a.onSettingsControllerChanged.bind(a, "leftHandMode")
		});
		a.spinButtonPositionContainer.add(a.spinButtonPosition.getContainer());
		a.addContainerToSettings();
		a.subComponents = [a.quickSpin, a.nrAutoPlaySpins, a.spinButtonPosition];
		a.update();
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	addContainerToSettings: function() {
		var a = this;
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.spinSettings_uc),
			content: a.container
		});
		a.fireEvent("view:addToNavigator", "settingsMenu", {
			order: 2
		})
	},
	initAdvancedAutoplaySettings: function() {
		var b = this,
			d = b.advancedAutoplaySettings,
			a = Services.languageManager,
			c;
		b.advancedSettings = {};
		Sys.iterate(b.ADVANCED_AUTOPLAY_SETTINGS, function(f, e) {
			if (f === "stopAutoplayIfBalanceDecreasedBy") {
				c = Services.moneyManager.getBetCents()
			} else {
				c = undefined
			}
			if (e.type === "interactiveContainer") {
				b.advancedSettings[f] = new Interface.utils.InteractiveContainer({
					title: a.getText(e.labelOCTKey),
					info: a.hasText(e.infoOCTKey) ? a.getText(e.infoOCTKey) : "",
					buttonText: a.hasText(e.buttonTextOCTKey) ? a.getText(e.buttonTextOCTKey) : "",
					id: "advancedSetting-" + f,
					cls: b.SECTION_CSS + " " + b.SECTION_SEPARATOR_URI,
					callback: b.onSettingsControllerChanged.bind(b, f),
					minValue: c
				})
			} else {
				if (e.type === "ToggleSwitch") {
					b.advancedSettings[f] = new Interface.utils.ToggleSwitch({
						title: a.getText(e.titleOCTKey),
						id: "advanceSetting-" + f,
						cls: b.SECTION_CSS + " " + b.SECTION_SEPARATOR_URI,
						callback: b.onSettingsControllerChanged.bind(b, f)
					})
				} else {
					if (e.type === "settingGroupTitle") {
						b.advancedSettings[f] = new Interface.utils.GroupTitle({
							title: a.getText(e.labelOCTKey),
							id: "advanceSetting-" + f,
							cls: b.SECTION_CSS,
							CSS: {
								disabled: ""
							}
						})
					}
				}
			}
			d.add(b.advancedSettings[f].getContainer())
		})
	},
	showAdvancedSettings: function() {
		this.advancedAutoplaySettings.el.style["max-height"] = "16rem"
	},
	hideAdvancedSettings: function() {
		this.advancedAutoplaySettings.el.style["max-height"] = "0"
	},
	enableAdvancedSettings: function() {
		var a = this;
		Sys.iterate(a.advancedSettings, function(c, d) {
			var b = a.model.readData("freeRoundsActive");
			if (!b || (b && a.FREEROUND_ACTIVE_CONTROLS.contains(c))) {
				d.enable()
			}
		})
	},
	disableAdvancedSettings: function() {
		var a = this;
		Sys.iterate(a.advancedSettings, function(b, c) {
			c.disable()
		})
	},
	openAdvancedSetting: function(a) {
		var b = this.advancedSettings[a];
		if (Sys.isDefined(b)) {
			b.click()
		} else {}
	},
	onSettingsControllerChanged: function(b, a) {
		this.fireEvent("view:userAction", b, a)
	},
	enable: function() {
		var a = this;
		a.model.storeData("disabled", false);
		a.callFunctionOnSubComponents("enable");
		Sys.each(a.lockedControllers, function(b) {
			b.disable()
		});
		if (a.nrAutoPlaySpins.getValue() !== a.model.getAutoplaySpinsArray()[0]) {
			a.stopIfAutoplayingBonusGameWon.enable();
			a.enableAdvancedSettings()
		}
	},
	disable: function() {
		var a = this;
		a.callFunctionOnSubComponents("disable");
		a.stopIfAutoplayingBonusGameWon.disable();
		a.disableAdvancedSettings();
		a.spinButtonPosition.enable();
		a.model.storeData("disabled", true)
	},
	update: function() {
		var c = this,
			b = c.model.readData.bind(c.model),
			a = !b("disabled"),
			d = b("autoPlayNrSpins");
		c.nrAutoPlaySpins.setValue(d);
		c.advancedSettings.stopAutoplayIfFreeSpinWon.toggle(b("stopAutoplayIfFreeSpinWon"));
		c.stopIfAutoplayingBonusGameWon.toggle(b("stopAutoplayIfAutoplayingBonusGameWon"));
		c.quickSpin.toggle(b("quickSpin"));
		c.spinButtonPosition.toggle(b("leftHandMode"));
		if (d === c.model.getAutoplaySpinsArray()[0]) {
			c.stopIfAutoplayingBonusGameWon.toggle(false);
			c.stopIfAutoplayingBonusGameWon.disable();
			Sys.iterate(c.ADVANCED_AUTOPLAY_SETTINGS, function(f, e) {
				c.advancedSettings[f].setValue(e.defaultValue)
			})
		} else {
			if (a && !c.stopIfAutoplayingBonusGameWon.isEnabled()) {
				c.stopIfAutoplayingBonusGameWon.enable()
			}
		}
	},
	showStopIfAutoplayingBonusGameWon: function() {
		this.stopIfAutoplayingBonusGameWon.getContainer().el.style.display = this.stopIfAutoplayingBonusGameWonOriginalDisplay
	},
	removeSetting: function(a) {
		var b = this;
		if (a === "quickSpin") {
			b.container.remove(b.quickSpinContainer)
		} else {
			if (a === "autoPlayNrSpins") {
				b.container.remove(b.autoplayContainer)
			}
		}
	},
	lockSetting: function(a) {
		var c = this,
			b;
		if (a === "autoPlayNrSpins") {
			b = c.nrAutoPlaySpins;
			c.nrOfSpinsText.el.style.opacity = "0.5"
		} else {
			if (a === "quickSpin") {
				b = c.quickSpin
			}
		}
		if (b) {
			b.disable();
			if (!c.lockedControllers.contains(b)) {
				c.lockedControllers.push(b)
			}
		}
	},
	unlockSetting: function(a) {
		var c = this,
			b;
		if (a === "autoPlayNrSpins") {
			b = c.nrAutoPlaySpins;
			c.nrOfSpinsText.el.style.opacity = ""
		} else {
			if (a === "quickSpin") {
				b = c.quickSpin
			}
		}
		if (b) {
			if (!c.model.readData("disabled")) {
				b.enable()
			}
			if (c.lockedControllers.contains(b)) {
				c.lockedControllers.splice(c.lockedControllers.indexOf(b), 1)
			}
		}
	},
	resetAutoPlay: function() {},
	reduceCounter: function() {},
	sortControls: function(b) {
		var c = this,
			a = b || [],
			d = c.advancedSettings.stopAutoplayIfBalanceDecreasedBy.container;
		if (c.model.readData("freeRoundsActive")) {
			a.forEach(function(e) {
				c.advancedAutoplaySettings.addBefore(e, d)
			})
		} else {
			a.forEach(function(e) {
				c.advancedAutoplaySettings.add(e, d)
			})
		}
	},
	toggleFreeRoundControls: function(b) {
		var c = this,
			a = b || [],
			d = [];
		Sys.iterate(c.advancedSettings, function(e, f) {
			if (!a.contains(e)) {
				if (c.model.readData("freeRoundsActive")) {
					f.disable()
				} else {
					f.enable()
				}
			} else {
				d.push(c.advancedAutoplaySettings.remove(f.container))
			}
		});
		c.sortControls(d)
	},
	onFreeRoundsStateChange: function(b) {
		var c = this,
			a = c.FREEROUND_ACTIVE_CONTROLS;
		c.model.storeData("freeRoundsActive", b);
		c.toggleFreeRoundControls(a)
	}
};
Interface.SpinSettingsView = Sys.extend(Interface.SettingsSectionView, Interface.SpinSettingsView, "Interface.SpinSettingsView");
Sys.ns("Interface");
Interface.AutoplaySettings = {
	constructor: function() {
		Interface.AutoplaySettings.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["userInput", "animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Interface.AutoplaySettingsModel,
			view: Interface.AutoplaySettingsView,
			controller: Interface.AutoplaySettingsController
		}
	}
};
Interface.AutoplaySettings = Sys.extend(Interface.SpinSettingsBase, Interface.AutoplaySettings, "Interface.AutoplaySettings");
Sys.ns("Interface");
Interface.AutoplaySettingsController = {
	constructor: function() {
		Interface.AutoplaySettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.AutoplaySettingsController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
			"notify:autoPlayer.reduceCounter": a.view.reduceCounter.bind(a.view),
			"notify:autoPlayer.starting": a.view.onAutoplayStarting.bind(a.view),
			"notify:freeRounds.started": a.view.onFreeRoundsStateChange.bind(a.view, true),
			"notify:freeRounds.ended": a.view.onFreeRoundsStateChange.bind(a.view, false),
			"request:autoplaySettings.close": a.onHideRequest,
			"request:closeOpenWindows": a.onHideRequest,
			"request:autoplaySettings.toggle": a.toggle,
			"request:enableBasicGamePanel": a.view.enableKeypadButton.bind(a.view, "keypadDisabled"),
			"request:disableBasicGamePanel": a.view.disableKeypadButton.bind(a.view, "keypadDisabled"),
			"notify:gameModeChanged": a.onGameModeChanged,
			"view:startAutoPlay": a.onStartAutoPlay,
			"view:stopAutoPlay": a.onStopAutoPlay,
			"view:autoPlayActive": a.onAutoPlayActive
		})
	},
	onStartAutoPlay: function() {
		var a = this;
		if (a.canStartAutoplay()) {
			a.fireEvent("request:autoPlayer.start")
		} else {
			a.resetAutoPlay();
			a.showWarningDialog()
		}
	},
	onEnteringIdleState: function() {
		var a = this;
		Interface.AutoplaySettingsController.superclass.onEnteringIdleState.apply(a, arguments);
		if (a.model.readData("autoPlayNrSpins") === 0) {
			a.view.resetAutoPlay();
			a.model.storeData("autoPlayActive", false)
		}
	},
	onShowRequest: function() {
		var a = this;
		if (!a.model.readData("disabled")) {
			a.fireEvent("request:gameSettings.close");
			Interface.AutoplaySettingsController.superclass.onShowRequest.apply(this, arguments)
		}
	},
	onAutoPlayActive: function() {
		this.model.storeData("autoPlayActive", true);
		this.view.update()
	},
	onStopAutoPlay: function() {
		this.fireEvent("request:autoPlayer.stop")
	},
	toggle: function() {
		if (this.model.readData("showing")) {
			this.onHideRequest()
		} else {
			this.onShowRequest()
		}
	},
	onSettingDisabled: function(a) {
		this.view.hideSetting(a)
	},
	onSettingEnabled: function(a) {
		this.view.showSetting(a)
	},
	onSettingChanged: function(a, b) {
		Interface.AutoplaySettingsController.superclass.onSettingChanged.apply(this, arguments);
		this.view.advancedListChanged(a, b)
	},
	onSettingLocked: function(a) {
		if (a === "autoPlayNrSpins") {
			this.onHideRequest();
			this.disable("autoplayLocked");
			this.view.disableKeypadButton("autoplayLocked")
		}
	},
	onSettingUnlocked: function(a) {
		if (a === "autoPlayNrSpins") {
			this.enable("autoplayLocked");
			this.view.enableKeypadButton("autoplayLocked")
		}
	},
	onGameModeChanged: function(a) {
		if (a === "BASIC") {
			this.view.showKeypadButton("gameModeNotBasic")
		} else {
			this.view.hideKeypadButton("gameModeNotBasic")
		}
	},
	showStopIfFreeSpinsWon: function() {
		var a = this;
		a.fireEvent("request:settingsManager.enableSetting", "stopAutoplayIfFreeSpinWon")
	},
	showStopIfAutoplayingBonusGameWon: function() {
		this.fireEvent("request:settingsManager.enableSetting", "stopAutoplayIfAutoplayingBonusGameWon")
	},
	resetAutoPlay: function() {
		this.view.resetAutoPlay();
		this.model.storeData("autoPlayActive", false);
		this.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0)
	}
};
Interface.AutoplaySettingsController = Sys.extend(Interface.SpinSettingsBaseController, Interface.AutoplaySettingsController, "Interface.AutoplaySettingsController");
Sys.ns("Interface");
Interface.AutoplaySettingsView = {
	MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button interface-autoplaySettings_icon_uri interface-autoplaySettings-menuButton",
	KEYPAD_BUTTON_CONFIG: {
		dimensions: {
			x: 437,
			y: 613,
			width: 143,
			height: 72
		},
		buttonImages: {
			up: "autoPlayButtonUp",
			down: "autoPlayButtonDown",
			hover: "autoPlayButtonOver",
			disabled: "autoPlayButtonDisabled"
		},
		buttonLabel: {
			width: 107,
			height: 54,
			text: Language.Keys.btn_autoplay,
			font: "24px NetentStandardUI",
			lineHeight: 24,
			alignment: "center",
			color: "#000000",
			breakOn: "<br>"
		}
	},
	ADVANCED_TOGGLE_CSS: {
		base: "interface-standAloneSettingsSectionToggle_base",
		disabled: "interface-standAloneSettingsSectionToggle_disabled",
		button_wrapper: "interface-standAloneSettingsSectionToggle_wrapper",
		label: "interface-standAloneSettingsSectionToggle_label interface-spinSettings_autoPlayAdvancedToggle_label",
		button_handle: "interface-standAloneSettingsSectionToggle_handle",
		button_background: "interface-standAloneSettingsSectionToggle_background",
		open: "advancedOpen",
		closed: "advancedClosed"
	},
	RESTRICTED_CONFIG_CONTROLS: [],
	FREEROUND_ACTIVE_CONTROLS: ["stopAutoplayOnAnyWin", "stopAutoplayIfFreeSpinWon", "stopIfAutoplayingBonusGameWon"],
	ADVANCED_CONFIG_CONTROLS: [{
		id: "stopAutoplayOnAnyWin",
		label: Language.Keys.autoplay_setting_onAnyWin,
		type: "checkbox"
	}, {
		id: "stopAutoplayIfFreeSpinWon",
		label: Language.Keys.autoplay_setting_ifFreeSpinsIsStarted,
		type: "checkbox",
		disabled: true
	}, {
		id: "stopAutoplayIfAutoplayingBonusGameWon",
		label: Language.Keys.autoplay_setting_ifFBonusIsStarted,
		type: "checkbox",
		disabled: true
	}, {
		id: "stopAutoplayIfWinExceeds",
		label: Language.Keys.autoplay_setting_ifWinExeeds,
		type: "checkbox",
		withInput: {
			label: undefined
		}
	}, {
		id: "stopAutoplayIfBalanceIncreasedBy",
		label: Language.Keys.autoplay_setting_ifCashIncreasesBy,
		type: "checkbox",
		withInput: {
			label: undefined
		}
	}, {
		id: "stopAutoplayIfBalanceDecreasedBy",
		label: Language.Keys.autoplay_setting_ifCashDecreasesBy,
		type: "checkbox",
		withInput: {
			label: undefined
		}
	}],
	ARROW_LEFT_VALUE: "0.54rem",
	RENDER_TARGET: "gameWrapper",
	DISABLE_BUTTON_DURING_SPIN: false,
	ORDER: 3,
	TITLE: Language.Keys.autoplay,
	constructor: function() {
		Interface.AutoplaySettingsView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var b = this,
			a;
		Interface.AutoplaySettingsView.superclass.init.apply(b, arguments);
		b.selectedAutoplayTarget = undefined;
		b.isActive = false;
		b.keypadPendingDisable = [];
		if (b.model.readData("isRestrictedModeEnabled") === true) {
			a = Sys.find(b.ADVANCED_CONFIG_CONTROLS, function(c) {
				return c.id === "stopAutoplayIfBalanceDecreasedBy"
			});
			b.RESTRICTED_CONFIG_CONTROLS.push(a);
			if (b.ADVANCED_CONFIG_CONTROLS.indexOf(a) >= 0) {
				b.ADVANCED_CONFIG_CONTROLS.splice(b.ADVANCED_CONFIG_CONTROLS.indexOf(a), 1)
			}
		}
	},
	setUpContent: function() {
		var a = this;
		Interface.AutoplaySettingsView.superclass.setUpContent.apply(a, arguments);
		a.setupAutoPlayContainer(a.container)
	},
	initAnimations: function() {
		this.setUpKeypadButton()
	},
	setupAutoPlayContainer: function() {
		var a = this;
		a.autoplaySettingsWrapper = a.container.add(new Sys.Element({
			id: "autoplaySettings",
			tag: "div",
			cls: "interface-spinSettings_autoplaySettings_wrapper"
		}));
		if (a.model.readData("isRestrictedModeEnabled") === true) {
			a.setupRestrictedAutoPlayContainer()
		}
		a.setupAdvancedAutoPlayContainer();
		a.setUpAutoplaySpinsSelector();
		a.setUpAutoplayStopControls()
	},
	toggleAdvancedSettings: function() {
		this.advancedSettingsWrapper.toggleClass("advancedSettingsOpen")
	},
	setupAdvancedAutoPlayContainer: function() {
		var c = this,
			a = new Sys.Element({
				id: "advancedAutoplaySettings",
				tag: "div",
				cls: "interface-spinSettings_autoplayAdvancedSettings_wrapper"
			}),
			b = Services.moneyManager.getCurrencyIsoName();
		c.ADVANCED_CONFIG_CONTROLS.forEach(function(d) {
			if (Sys.isDefined(d.withInput)) {
				d.withInput.label = b
			}
		});
		c.advancedToggle = new Interface.utils.ToggleSwitch({
			id: "advancedAutoplaySettingsToggle",
			title: Services.languageManager.getText(Language.Keys.autoplay_advancedSettings),
			CSS: c.ADVANCED_TOGGLE_CSS,
			enabled: true,
			callback: c.toggleAdvancedSettings.bind(c)
		});
		a.add(c.advancedToggle.getContainer());
		a.add(c.setupResetButton());
		a.add(c.setupStopAutoPlaySection());
		a.add(c.getDivider());
		c.advancedSettingsWrapper = a;
		c.container.addAsFirst(a);
		c.ADVANCED_CONFIG_CONTROLS.forEach(function(d) {
			c.fireEvent("view:userAction", d.id, false);
			if (Sys.isDefined(d.disabled)) {
				c.hideSetting(d.id);
				c.fireEvent("view:disableSetting", d.id)
			}
		})
	},
	setupRestrictedAutoPlayContainer: function() {
		var c = this,
			a = new Sys.Element({
				id: "restrictedAutoplaySettings",
				tag: "div",
				cls: "interface-spinSettings_autoplayAdvancedSettings_wrapper"
			}),
			b = Services.moneyManager.getCurrencyIsoName();
		c.RESTRICTED_CONFIG_CONTROLS.forEach(function(d) {
			if (Sys.isDefined(d.withInput)) {
				d.withInput.label = b
			}
		});
		c.restrictedWrapper = a.add(c.setupRestrictedStopAutoPlaySection());
		a.add(c.getDivider());
		c.container.addAsFirst(a);
		c.RESTRICTED_CONFIG_CONTROLS.forEach(function(d) {
			c.fireEvent("view:userAction", d.id, false);
			if (Sys.isDefined(d.disabled)) {
				c.hideSetting(d.id);
				c.fireEvent("view:disableSetting", d.id)
			}
		})
	},
	setupStopAutoPlaySection: function() {
		var a = this,
			c = new Sys.Element({
				id: "advancedSettings",
				tag: "div",
				cls: "interface-spinSettings_autoplayAdvancedSettings_settingsListWrapper"
			}),
			b = new Interface.utils.DOMControlList({
				id: "autoplaySettingsStoppedList",
				controls: a.ADVANCED_CONFIG_CONTROLS,
				callback: a.advancedListChanged.bind(a)
			});
		c.add(new Sys.Element({
			id: "advancedSettingsListHeader",
			tag: "div",
			cls: "interface-spinSettings_autoplayAdvancedSettings_settingsListHeader",
			textContent: Services.languageManager.getText(Language.Keys.autoplay_stopAutoPlay)
		}));
		a.advancedList = b;
		c.add(b.getContainer());
		return c
	},
	setupRestrictedStopAutoPlaySection: function() {
		var b = this,
			a, d = new Sys.Element({
				id: "restrictedSettings",
				tag: "div"
			}),
			c = new Interface.utils.DOMControlList({
				id: "autoplaySettingsRestrictedStoppedList",
				controls: b.RESTRICTED_CONFIG_CONTROLS,
				callback: b.advancedListChanged.bind(b)
			});
		b.restrictedAdvancedList = c;
		a = b.restrictedAdvancedList.getControl("stopAutoplayIfBalanceDecreasedBy")[0];
		a.checkBox.setValue(true, true);
		a.checkBox.lock("autoplay");
		d.add(c.getContainer());
		d.add(new Sys.Element({
			id: "restrictedSettings_info",
			tag: "div",
			cls: "interface-spinSettings_autoplayStopControls_info",
			textContent: Services.languageManager.getText(Language.Keys.autoplay_setting_ifCashDecreasesByInfo)
		}));
		return d
	},
	advancedListChanged: function(b, d) {
		var c = this,
			a = false;
		c.fireEvent("view:userAction", b, d);
		c.ADVANCED_CONFIG_CONTROLS.forEach(function(e) {
			if (Services.settingsManager.getSetting(e.id) !== false) {
				a = true
			}
		});
		c.RESTRICTED_CONFIG_CONTROLS.forEach(function(e) {
			if (Services.settingsManager.getSetting(e.id) !== false) {
				a = true
			}
		});
		if (a) {
			c.advancedToggle.getContainer().addCls("sectionActive");
			c.showResetButton()
		} else {
			c.advancedToggle.getContainer().removeCls("sectionActive");
			c.hideResetButton()
		}
	},
	setupResetButton: function() {
		var a = this;
		a.resetButton = new Interface.utils.DOMButton({
			id: "autoplaySettingsReset",
			textContent: Services.languageManager.getText(Language.Keys.reset),
			clickCallback: a.resetSettings.bind(a),
			baseCSS: "interface-desktopControls_Button_small interface-interface-desktopControls_Button_small_uri interface-spinSettings_autoplayStopControls_resetButton"
		});
		a.hideResetButton();
		return a.resetButton.getContainer()
	},
	showResetButton: function() {
		this.resetButton.show(this.MODULE_NAME)
	},
	hideResetButton: function() {
		this.resetButton.hide(this.MODULE_NAME)
	},
	hideSetting: function(a) {
		this.advancedList.hide(a)
	},
	showSetting: function(a) {
		this.advancedList.show(a)
	},
	resetSettings: function() {
		var a = this;
		a.ADVANCED_CONFIG_CONTROLS.forEach(function(b) {
			a.advancedList.update(b.id, false);
			a.advancedListChanged(b.id, false)
		});
		a.RESTRICTED_CONFIG_CONTROLS.forEach(function(b) {
			a.restrictedAdvancedList.update(b.id, false);
			a.advancedListChanged(b.id, false)
		});
		a.resetAutoPlay();
		a.fireEvent("view:stopAutoPlay")
	},
	setUpAutoplaySpinsSelector: function() {
		var b = this,
			d = "[Off]",
			c = new Sys.Element({
				id: "autoplaySelectorWrapper",
				tag: "div",
				cls: "interface-spinSettings_autoplaySelector_wrapper"
			}),
			a = {
				id: "autoplaySelector",
				values: b.model.getAutoplaySpinsArray(),
				CSS: {
					base: "interface-spinSettings_autoplaySelector_base",
					buttonBase: "interface-spinSettings_autoplaySelector_buttonBase",
					buttonUp: "interface-DOMOptionScroller_buttonUp_uri",
					buttonDown: "interface-DOMOptionScroller_buttonDown_uri",
					valuesHolder: "interface-spinSettings_autoplaySelector_valuesHolder",
					value: "interface-spinSettings_autoplaySelector_value interface-DOMOptionScroller_value_uri interface-spinSettings_button",
					wrapper: "interface-spinSettings_autoplaySelector_valueWrapper"
				},
				callback: function(e) {
					b.fireEvent("view:userAction", "autoPlayNrSpins", Sys.utils.toInt(e));
					b.disableAdvancedControls();
					b.disableRestrictedControls();
					b.fireEvent("view:startAutoPlay")
				},
				scrollOffsetModifier: 3,
				valueWidth: 50,
				replaceTextByIndex: [{
					index: 0,
					text: d,
					skip: true
				}]
			};
		c.add(new Sys.Element({
			id: "topLabel",
			tag: "div",
			cls: "interface-spinSettings_autoplaySelector_label",
			textContent: Services.languageManager.getText(Language.Keys.autoplay_numberSpins)
		}));
		b.selector = new Interface.utils.DOMOptionScroller(a);
		c.add(b.selector.getContainer());
		c.add(new Sys.Element({
			id: "topLabel",
			tag: "div",
			cls: "interface-spinSettings_autoplaySelector_label",
			textContent: Services.languageManager.getText(Language.Keys.autoplay_panelStartText)
		}));
		b.autoplaySettingsWrapper.add(c)
	},
	onAutoplayStarting: function() {
		this.fireEvent("view:autoPlayActive")
	},
	selectorCallbackFunction: function(a) {
		var b = this;
		if (a.element === b.selectedAutoplayTarget) {
			return false
		} else {
			if (!Sys.isDefined(b.selectedAutoplayTarget)) {
				a.element.style.opacity = "0.7";
				b.selectedAutoplayTarget = a.element;
				return true
			} else {
				if (a !== b.selectedAutoplayTarget) {
					b.selectedAutoplayTarget.style.opacity = "1";
					a.element.style.opacity = "0.7";
					b.selectedAutoplayTarget = a.element;
					return true
				}
			}
		}
		return false
	},
	deSelectAutoPlayTarget: function() {
		if (Sys.isDefined(this.selectedAutoplayTarget)) {
			this.selectedAutoplayTarget.style.opacity = "1";
			this.selectedAutoplayTarget = undefined
		}
	},
	setUpAutoplayStopControls: function() {
		var a = this,
			c = new Sys.Element({
				id: "autoplayStopControls",
				tag: "div",
				cls: "interface-spinSettings_autoplayStopControls_wrapper"
			}),
			b = new Sys.Element({
				id: "autoplayStopControlsHeader",
				tag: "div",
				cls: "interface-spinSettings_autoplayStopControls_header",
				textContent: Services.languageManager.getText(Language.Keys.spinsLeftText, [Services.languageManager.getText(Language.Keys.autoSpins)])
			});
		a.spinsLeftCounter = new Sys.Element({
			id: "autoplayStopControlsSpinsCounter",
			tag: "div",
			cls: "interface-spinSettings_autoplaySelector_value interface-DOMOptionScroller_value_uri",
			textContent: "0"
		});
		a.stopButton = new Interface.utils.DOMButton({
			id: "autoplayStopControlsStopButton",
			baseCSS: "interface-desktopControls_Button interface-spinSettings_autoplayStopControls_stopButton interface-interface-desktopControls_Button_uri",
			textContent: Services.languageManager.getText(Language.Keys.autoplay_stopText),
			clickCallback: a.fireEvent.bind(a, "view:stopAutoPlay")
		});
		c.add(b);
		c.add(a.spinsLeftCounter);
		c.add(a.stopButton.getContainer());
		a.container.add(c)
	},
	setUpKeypadButton: function() {
		var b = this,
			a = Sys.applyProperties({
				clickCallback: b.onButtonClick.bind(b)
			}, b.KEYPAD_BUTTON_CONFIG);
		a.buttonLabel.depth = Layering.Game.Slots.Keypad.autoPlay.label;
		if (Sys.isDefined(a.buttonLayoutParameters)) {
			a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.autoPlay.button
		} else {
			a.dimensions.depth = Layering.Game.Slots.Keypad.autoPlay.button
		}
		b.keypadButton = new Interface.utils.CanvasButton(a);
		b.keypadPendingDisable.forEach(b.keypadButton.disable.bind(b.keypadButton));
		delete b.keypadPendingDisable
	},
	update: function() {
		var b = this,
			a = b.model.readData("autoPlayNrSpins"),
			c = b.model.readData("autoPlayActive");
		if (c && a > 0) {
			b.spinsLeftCounter.el.textContent = a;
			b.container.addCls("autoplayActive");
			b.menuButton.getContainer().el.textContent = a;
			b.menuButton.getContainer().addCls("autoplayActive");
			b.menuButton.addProperty("active", "autoplayActive");
			b.isActive = true
		} else {
			b.resetAutoPlay()
		}
	},
	reduceCounter: function(c) {
		var b = this,
			a = c !== 0 ? c : "";
		b.spinsLeftCounter.el.textContent = a;
		b.menuButton.getContainer().el.textContent = a
	},
	resetAutoPlay: function() {
		var a = this;
		if (a.isActive) {
			a.container.removeCls("autoplayActive");
			a.menuButton.removeProperty("active", "autoplayActive");
			a.menuButton.getContainer().removeCls("autoplayActive");
			a.menuButton.getContainer().el.textContent = "";
			a.isActive = false;
			a.deSelectAutoPlayTarget()
		}
		a.enableRestrictedControls();
		a.enableAdvancedControls()
	},
	enableKeypadButton: function(c) {
		var b = this,
			a;
		if (Sys.isDefined(b.keypadButton)) {
			b.keypadButton.enable(c)
		} else {
			a = b.keypadPendingDisable.indexOf(c);
			if (a >= 0) {
				b.keypadPendingDisable.splice(a, 1)
			}
		}
	},
	disableKeypadButton: function(b) {
		var a = this;
		if (Sys.isDefined(a.keypadButton)) {
			a.keypadButton.disable(b)
		} else {
			if (!a.keypadPendingDisable.contains(b)) {
				a.keypadPendingDisable.push(b)
			}
		}
	},
	showKeypadButton: function(a) {
		if (Sys.isDefined(this.keypadButton)) {
			this.keypadButton.show(a)
		}
	},
	hideKeypadButton: function(a) {
		if (Sys.isDefined(this.keypadButton)) {
			this.keypadButton.hide(a)
		}
	},
	toggleFreeRoundControls: function(b) {
		var c = this,
			a = b || [];
		Sys.each(c.ADVANCED_CONFIG_CONTROLS, function(d) {
			if (!a.contains(d.id)) {
				if (c.model.readData("freeRoundsActive")) {
					c.advancedList.disable(d.id)
				} else {
					c.advancedList.enable(d.id)
				}
			}
		})
	},
	onFreeRoundsStateChange: function(b) {
		var c = this,
			a = c.FREEROUND_ACTIVE_CONTROLS;
		c.model.storeData("freeRoundsActive", b);
		c.toggleFreeRoundControls(a);
		c.toggleRestrictedControls()
	},
	toggleRestrictedControls: function() {
		var b = this,
			c = b.model.readData("freeRoundsActive"),
			a;
		if (b.model.readData("isRestrictedModeEnabled")) {
			a = b.restrictedAdvancedList.getControl("stopAutoplayIfBalanceDecreasedBy")[0];
			if (c) {
				b.model.storeData("isRestrictedMode", false);
				a.checkBox.unlock("autoplay");
				a.checkBox.setValue(false, false);
				b.restrictedAdvancedList.disable("stopAutoplayIfBalanceDecreasedBy");
				a.checkBox.lock("autoplay");
				b.restrictedAdvancedList.hide("stopAutoplayIfBalanceDecreasedBy");
				b.restrictedWrapper.addCSSClass("hide")
			} else {
				b.model.storeData("isRestrictedMode", true);
				b.restrictedAdvancedList.enable("stopAutoplayIfBalanceDecreasedBy");
				a.checkBox.unlock("autoplay");
				a.checkBox.setValue(true, true);
				b.restrictedAdvancedList.show("stopAutoplayIfBalanceDecreasedBy");
				b.restrictedWrapper.removeCSSClass("hide")
			}
		}
	},
	disableAdvancedControls: function() {
		var a = this;
		a.ADVANCED_CONFIG_CONTROLS.forEach(function(b) {
			if (Sys.isDefined(b.withInput)) {
				a.advancedList.disable(b.id)
			}
		})
	},
	enableAdvancedControls: function() {
		var a = this;
		a.ADVANCED_CONFIG_CONTROLS.forEach(function(d) {
			var c = a.model.readData("freeRoundsActive"),
				b = !c && Sys.isDefined(d.withInput),
				e = c && d.withInput && a.FREEROUND_ACTIVE_CONTROLS.contains(d.id);
			if (b || e) {
				a.advancedList.enable(d.id)
			}
		})
	},
	disableRestrictedControls: function() {
		var a = this;
		a.RESTRICTED_CONFIG_CONTROLS.forEach(function(b) {
			a.restrictedAdvancedList.disable(b.id)
		})
	},
	enableRestrictedControls: function() {
		var a = this;
		if (!a.model.readData("freeRoundsActive")) {
			a.RESTRICTED_CONFIG_CONTROLS.forEach(function(b) {
				a.restrictedAdvancedList.enable(b.id)
			})
		}
	}
};
Interface.AutoplaySettingsView = Sys.extend(Interface.StandAloneSettingsSectionView, Interface.AutoplaySettingsView, "Interface.AutoplaySettingsView");
Sys.ns("Interface");
Interface.AutoplaySettingsModel = {
	constructor: function() {
		Interface.AutoplaySettingsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var c = this,
			b, a = [{
				key: "stopAutoplayOnAnyWin",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}, {
				key: "stopAutoplayIfBalanceIncreasedBy",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}, {
				key: "stopAutoplayIfWinExceeds",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}, {
				key: "stopAutoplayIfBalanceDecreasedBy",
				defaultValue: false,
				settingsManager: true,
				localStorage: false
			}];
		b = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
		c.storeData("isRestrictedModeEnabled", b);
		Interface.AutoplaySettingsModel.superclass.setupData.apply(c, arguments);
		a.forEach(c.initData, c)
	}
};
Interface.AutoplaySettingsModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.AutoplaySettingsModel, "Interface.AutoplaySettingsModel");
Sys.ns("Interface");
Interface.GameSettings = {
	constructor: function() {
		Interface.GameSettings.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.GameSettingsController,
			model: Interface.GameSettingsModel,
			view: Interface.GameSettingsBaseView
		}
	}
};
Interface.GameSettings = Sys.extend(Interface.SettingsSection, Interface.GameSettings, "Interface.GameSettings");
Sys.ns("Interface");
Interface.GameSettingsController = {
	LOCAL_STORAGE_SETTINGS: ["showFeatureSplash", "quickSpin", "showIntroMovie", "spacebarToSpin"],
	constructor: function() {
		Interface.GameSettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:settingsManager.settingChanged": a.view.update.bind(a.view),
			"notify:settingsManager.settingDisabled": a.view.hideSetting.bind(a.view),
			"notify:settingsManager.settingEnabled": a.view.showSetting.bind(a.view),
			"notify:settingsManager.settingLocked": a.view.disableSetting.bind(a.view),
			"notify:settingsManager.settingUnlocked": a.view.enableSetting.bind(a.view),
			"notify:stateHandler.leavingIdleState": a.hide,
			"request:gameSettings.close": a.onHideRequest,
			"request:closeOpenWindows": a.onHideRequest,
			"request:gameSettings.toggle": a.onToggle,
			"view:gameHistoryClicked": a.onGameHistoryClicked
		});
		Interface.GameSettingsController.superclass.setupEvents.apply(a, arguments)
	},
	onUserAction: function(b, d) {
		var c = this,
			a = false;
		if (c.LOCAL_STORAGE_SETTINGS.contains(b)) {
			a = true
		}
		this.fireEvent("request:settingsManager.storeData", b, d, a)
	},
	onShowRequest: function() {
		var a = this;
		a.fireEvent("request:autoplaySettings.close");
		Interface.GameSettingsController.superclass.onShowRequest.apply(a, arguments)
	},
	onGameHistoryClicked: function() {
		var a = this.model;
		if (!a.readData("historyRemoved") && !a.readData("historyDisabled")) {
			Environment.openNewBrowserTab(Resources.readData("historyUrl"), "gameHistory")
		}
	},
	onToggle: function() {
		var a = this;
		if (a.model.readData("showing")) {
			a.hide()
		} else {
			a.show()
		}
	}
};
Interface.GameSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.GameSettingsController, "Interface.GameSettingsController");
Sys.ns("Interface");
Interface.GameSettingsModel = {
	constructor: function() {
		Interface.GameSettingsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var c = this,
			a = [{
				key: "showFeatureSplash",
				defaultValue: true,
				settingsManager: true,
				localStorage: true
			}, {
				key: "quickSpin",
				defaultValue: false,
				settingsManager: true,
				localStorage: true
			}, {
				key: "showIntroMovie",
				defaultValue: true,
				settingsManager: true,
				localStorage: true
			}, {
				key: "spacebarToSpin",
				defaultValue: false,
				settingsManager: true,
				localStorage: true
			}],
			b = Resources.readData("gameServerInitResponse");
		a.forEach(c.initData, c);
		if (b.playforfun) {
			c.storeData("historyDisabled", true)
		} else {
			if (Sys.isDefined(b.historybutton) && !b.historybutton) {
				c.storeData("historyRemoved", true)
			}
		}
	}
};
Interface.GameSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.GameSettingsModel, "Interface.GameSettingsModel");
Sys.ns("Interface");
Interface.GameSettingsDesktopView = {
	MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button interface-gameSettings_icon_uri",
	DISABLE_BUTTON_DURING_SPIN: false,
	SETTINGS_CONTROLS: [{
		id: "quickSpin",
		label: Language.Keys.setting_quickSpinGame,
		type: "checkbox"
	}, {
		id: "showFeatureSplash",
		label: Language.Keys.setting_introScreeGame,
		type: "checkbox"
	}, {
		id: "showIntroMovie",
		label: Language.Keys.setting_introGame,
		type: "checkbox"
	}, {
		id: "spacebarToSpin",
		label: Language.Keys.setting_spaceSpin,
		type: "checkbox"
	}],
	TITLE: Language.Keys.gameSettingsPanelLabel,
	ARROW_LEFT_VALUE: "0.05rem",
	ORDER: 1,
	constructor: function() {
		Interface.GameSettingsDesktopView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var b = this,
			a = b.model;
		Interface.GameSettingsDesktopView.superclass.setUpContent.apply(b, arguments);
		b.settingsList = new Interface.utils.DOMControlList({
			id: "gameSettingsSettingsList",
			controls: b.SETTINGS_CONTROLS,
			callback: b.fireEvent.bind(b, "view:userAction")
		});
		b.SETTINGS_CONTROLS.forEach(function(c) {
			b.settingsList.update(c.id, b.model.readData(c.id))
		});
		b.container.add(b.settingsList.getContainer());
		if (!(a.readData("historyRemoved") || a.readData("historyDisabled"))) {
			b.container.add(b.createGameHistoryButton())
		}
	},
	update: function(a, b) {
		this.settingsList.update(a, b)
	},
	hideSetting: function(a) {
		this.settingsList.hide(a)
	},
	showSetting: function(a) {
		this.settingsList.show(a)
	},
	disableSetting: function(a) {
		this.settingsList.disable(a)
	},
	enableSetting: function(a) {
		this.settingsList.enable(a)
	},
	createGameHistoryButton: function() {
		var a = this;
		a.historyButton = new Interface.utils.DOMButton({
			id: "gameHistoryButton",
			baseCSS: "interface-desktopControls_Button_small interface-desktopGameHistoryButton preventUserSelect interface-interface-desktopControls_Button_small_uri",
			clickCallback: a.fireEvent.bind(a, "view:gameHistoryClicked"),
			textContent: Services.languageManager.getText(Language.Keys.gameHistory)
		});
		return a.historyButton.getContainer()
	}
};
Interface.GameSettingsDesktopView = Sys.extend(Interface.StandAloneSettingsSectionView, Interface.GameSettingsDesktopView, "Interface.GameSettingsDesktopView");
Sys.ns("Interface");
Interface.SoundSettings = {
	constructor: function() {
		Interface.SoundSettings.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["userInput", "orientation"],
			desktop: [{
				userInput: {
					inputEvents: ["start", "end", "cancel", "move", "hover"],
					listenToUserInput: true
				}
			}]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SoundSettingsController,
			model: Interface.SoundSettingsModel,
			view: Interface.SoundSettingsBaseView
		}
	}
};
Interface.SoundSettings = Sys.extend(Interface.SettingsSection, Interface.SoundSettings, "Interface.SoundSettings");
Sys.ns("Interface");
Interface.SoundSettingsController = {
	constructor: function() {
		Interface.SoundSettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:soundSettings.enableVibrationSetting": a.onEnableVibrationSetting,
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"notify:audioPlayer.loadingSound": a.view.startSoundLoading.bind(a.view),
			"notify:audioPlayer.soundLoaded": a.view.soundLoadedStopLoader.bind(a.view),
			"view:toggleSound": a.toggleSound
		});
		Interface.SoundSettingsController.superclass.setupEvents.apply(a, arguments)
	},
	onUserAction: function(a, b) {
		switch (a) {
			case "audioOn":
				Services.settingsManager.storeSetting("volume", b ? this.model.getPreviousVolume() : 0, true);
				break;
			case "volume":
				Services.settingsManager.storeSetting("volume", b, true);
				break;
			case "vibrationOn":
				Services.settingsManager.storeSetting("vibration", b, true);
				break;
			default:
		}
	},
	onEnableVibrationSetting: function() {
		this.view.addVibrationToggle()
	},
	onUserInputHover: function(a) {
		this.view.onUserInputHover(a)
	},
	onSettingChanged: function(a, b) {
		if (a === "volume") {
			this.view.update(b);
			if (b > 0) {
				this.model.storeData("previousVolume", b)
			}
		} else {
			if (a === "vibration") {
				this.view.updateVibration(b)
			}
		}
	}
};
Interface.SoundSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.SoundSettingsController, "Interface.SoundSettingsController");
Sys.ns("Interface");
Interface.SoundSettingsModel = {
	constructor: function() {
		Interface.SoundSettingsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.initData({
			key: "volume",
			defaultValue: Platform.resourceBundle.preloadAudio ? 1 : 0,
			settingsManager: true,
			localStorage: Platform.resourceBundle.preloadAudio
		});
		a.initData({
			key: "vibration",
			defaultValue: false,
			settingsManager: true,
			localStorage: true
		});
		a.storeData("previousVolume", 1)
	},
	getPreviousVolume: function() {
		var a = this.readData("previousVolume");
		if (!Sys.isDefined(a)) {
			a = 1
		}
		return a
	}
};
Interface.SoundSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.SoundSettingsModel, "Interface.SoundSettingsModel");
Sys.ns("Interface");
Interface.SoundSettingsBaseView = {
	BASE_CSS: "tab interface-soundSettings_base",
	PORTRAIT_CSS: "interface-soundSettings_portrait",
	LANDSCAPE_CSS: "interface-soundSettings_landscape",
	SECTION_CSS: "utils_empty interface-settingsSection_subSection",
	LOAD_ANIMATION_CSS: "interface-smallSpinner_uri",
	constructor: function() {
		Interface.SoundSettingsBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "userSettings",
			tag: "div",
			cls: a.BASE_CSS
		});
		a.audioOnOffContainer = a.container.add(new Sys.Element({
			id: "soundSettings_soundSettings",
			tag: "div",
			cls: a.SECTION_CSS
		}));
		a.audioOnOff = new Interface.utils.ToggleSwitch({
			id: "audioOnOff",
			title: Services.languageManager.getText(Language.Keys.setting_gameSound),
			callback: a.onSettingsControllerChanged.bind(a, "audioOn")
		});
		a.audioOnOffContainer.add(a.audioOnOff.getContainer());
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.soundSettings_uc),
			content: a.container
		});
		a.fireEvent("view:addToNavigator", "settingsMenu", {
			order: 1
		});
		a.subComponents = [a.audioOnOff];
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	addVibrationToggle: function() {
		var a = this;
		a.vibrationOnOffContainer = a.container.add(new Sys.Element({
			id: "soundSettings_soundSettings",
			tag: "div",
			cls: a.SECTION_CSS
		}));
		a.vibrationOnOff = new Interface.utils.ToggleSwitch({
			id: "vibrationOnOff",
			title: Services.languageManager.getText(Language.Keys.setting_gameVibration),
			callback: a.onSettingsControllerChanged.bind(a, "vibrationOn")
		});
		a.vibrationOnOffContainer.add(a.vibrationOnOff.getContainer());
		a.subComponents.push(a.vibrationOnOff);
		a.vibrationOnOff.enable();
		a.updateVibration(Services.settingsManager.getSetting("vibration"))
	},
	onSettingsControllerChanged: function(b, a) {
		this.fireEvent("view:userAction", b, a)
	},
	enable: function() {
		this.callFunctionOnSubComponents("enable")
	},
	disable: function() {
		this.callFunctionOnSubComponents("disable")
	},
	update: function(a) {
		this.audioOnOff.toggle(a > 0)
	},
	updateVibration: function(a) {
		this.vibrationOnOff.toggle(a)
	},
	startSoundLoading: function() {
		var a = this;
		a.audioOnOff.displayLoadAnimation();
		a.disable();
		a.update(Services.settingsManager.getSetting("volume"))
	},
	soundLoadedStopLoader: function() {
		this.enable();
		this.update(Services.settingsManager.getSetting("volume"));
		this.audioOnOff.hideLoadAnimation()
	}
};
Interface.SoundSettingsBaseView = Sys.extend(Interface.SettingsSectionView, Interface.SoundSettingsBaseView, "Interface.SoundSettingsBaseView");
Sys.ns("Interface");
Interface.SoundSettingsDesktopView = {
	WRAPPER_CSS: "interface-soundSettingsDesktop_sliderWrapper",
	BASE_CSS: "interface-soundSettingsDesktop_sliderBase interface-standAloneSettingsSectionMiddle_uri",
	BUTTON_CSS: "interface-desktopSettingsMenu_button interface-soundSettings_audioOn_icon_uri",
	BUTTON_OFF_CSS: "interface-soundSettings_audioOff_icon_uri",
	LOAD_ANIMATION_CSS: "interface-soundSettingsDesktop_spinner interface-smallSpinner_uri hidden",
	CLOSE_ANIMATION_CSS: "interface-soundSettingsDesktop_closeTransition",
	constructor: function() {
		Interface.SoundSettingsDesktopView.superclass.constructor.apply(this, arguments)
	},
	onUserInputStart: function(a) {},
	onUserInputMove: function() {},
	onUserInputEnd: function(a) {},
	onUserInputHover: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(a.container.el, b) || Sys.UserInputUtils.isCoordinateTarget(a.menuButton.el, b)) {
			a.menuButton.addCls("hover");
			a.open()
		} else {
			a.menuButton.removeCls("hover");
			a.close()
		}
	},
	show: function() {
		this.open()
	},
	hide: function() {
		this.close()
	},
	open: function() {
		var a = this;
		a.wrapper.removeCls(a.CLOSE_ANIMATION_CSS);
		a.isOpen = true;
		if (!a.model.readData("disabled")) {
			a.volume.enable()
		}
	},
	close: function() {
		var a = this;
		a.wrapper.addCls(a.CLOSE_ANIMATION_CSS);
		if (a.volume) {
			a.volume.disable()
		}
		a.isOpen = false
	},
	setUpContent: function() {
		var a = this;
		a.wrapper = new Sys.Element({
			id: "soundSettingsWrapper",
			tag: "div",
			cls: a.WRAPPER_CSS,
			renderTo: "gameWrapper"
		});
		a.container = a.wrapper.add(new Sys.Element({
			id: "soundSettings",
			tag: "div",
			cls: a.BASE_CSS
		}));
		a.menuButton = new Sys.Element({
			id: "soundSettingsButton",
			tag: "div",
			cls: a.BUTTON_CSS
		});
		a.abstractButton = new Interface.AbstractButton({
			dimensions: a.menuButton.el,
			clickCallback: a.toggle.bind(a)
		});
		a.volume = new Interface.utils.VerticalSlider({
			id: "soundVolumeSlider",
			minValue: 0,
			maxValue: 1,
			valueStep: 0.05,
			startValue: Services.settingsManager.getSetting("volume"),
			callback: a.fireEvent.bind(a, "view:userAction", "volume"),
			ascendingGrowth: true,
			showDisplay: false,
			callbackOnlyOnEndEvent: false
		});
		a.loadAnimation = a.container.add(new Sys.Element({
			id: "soundSettings_loadAnimation",
			tag: "div",
			cls: a.LOAD_ANIMATION_CSS
		}));
		a.container.add(a.volume.getContainer());
		a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
			order: 1,
			element: a.menuButton
		});
		a.update(Services.settingsManager.getSetting("volume"));
		a.hide()
	},
	toggle: function() {
		this.fireEvent("view:userAction", "audioOn", Services.settingsManager.getSetting("volume") === 0)
	},
	enable: function() {
		var a = this;
		a.abstractButton.enable("sectionDisabled");
		a.volume.enable()
	},
	disable: function() {
		var a = this;
		a.abstractButton.disable("sectionDisabled");
		a.volume.disable()
	},
	startSoundLoading: function() {
		this.disable();
		this.loadAnimation.el.style.display = "block"
	},
	soundLoadedStopLoader: function() {
		this.enable();
		this.loadAnimation.el.style.display = "none"
	},
	update: function(b) {
		var a = this;
		if (!a.volume.enabled) {
			a.enable()
		}
		a.menuButton.removeCls(a.BUTTON_OFF_CSS);
		if (!(b > 0)) {
			a.menuButton.addCls(a.BUTTON_OFF_CSS)
		}
		a.volume.moveSlider(b)
	},
	removeSetting: function() {}
};
Interface.SoundSettingsDesktopView = Sys.extend(Core.View, Interface.SoundSettingsDesktopView, "Interface.SoundSettingsDesktopView");
Sys.ns("Core");
Core.Trigger = {
	constructor: function() {
		Core.Trigger.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.TriggerModel,
			controller: Core.TriggerController
		}
	}
};
Core.Trigger = Sys.extend(Core.Module, Core.Trigger, "Core.Trigger");
Resources.storeData("triggerScripts", {});
Sys.ns("Core");
Core.TriggerController = {
	DEBUG: false,
	constructor: function() {
		Core.TriggerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Core.TriggerController.superclass.setupEvents.apply(a, arguments);
		a.on({
			pageVisibilityChanged_event: a.onPageVisibilityChanged,
			"notify:moduleLoader.finishedLoadingModules": a.onFinishedLoadingModules,
			"notify:audioPlayer.soundPlayable": a.onSoundReady
		})
	},
	onFinishedLoadingModules: function() {
		if (Platform.isWebAudioEnabled) {
			this.fireEvent("request:audioPlayer.disableEventInteractions")
		}
		this.fireEvent("notify:trigger.ready")
	},
	onSoundReady: function() {
		this.audioReady = true
	},
	onPageVisibilityChanged: function(a) {
		if (a) {
			Audio.Engine.setVolume(0)
		} else {
			Audio.Engine.setVolume(Services.settingsManager.getSetting("volume"))
		}
	},
	registerTrigger: function(d, a, c) {
		var b = this;
		b.addListener(d, function() {
			b.executeTrigger.apply(b, [d].concat(Array.prototype.slice.call(arguments)))
		});
		b.model.registerTrigger(d, a, c)
	},
	executeTrigger: function(h) {
		var d = this.model.getScriptsLinkedToTrigger(h),
			c = d.length,
			f = Array.prototype.slice.call(arguments, 1),
			b, e, g, a;
		if (!Platform.isWebAudioEnabled || !this.audioReady) {
			return
		}
		for (g = -1; ++g < c;) {
			e = d[g];
			b = this.determineExecutionEnvironment(h, e.type);
			e.script.apply(b.scope, f)
		}
	},
	listTriggers: function() {
		return Object.keys(this.model.getTriggers())
	},
	listLinkedTriggers: function() {
		return this.model.getLinkedTriggers()
	},
	getTriggerDescription: function(a) {
		return this.model.getTriggerDescription(a)
	},
	getScript: function(a) {
		return Resources.readData("triggerScripts")[a].script.toString()
	},
	getScriptsLinkedToTrigger: function(a) {
		return this.model.getScriptsLinkedToTrigger(a)
	},
	getScriptNamesLinkedToTrigger: function(a) {
		return this.model.getScriptNamesLinkedToTrigger(a)
	},
	linkScriptToTrigger: function(b, a) {
		this.model.linkScriptToTrigger(b, a)
	},
	unlinkScriptAndTrigger: function(b, a) {
		this.model.unlinkScriptAndTrigger(b, a)
	},
	determineExecutionEnvironment: function(c, b) {
		var a = {
			args: []
		};
		switch (b) {
			case "audio":
				a.scope = Audio.Engine;
				break;
			case "animation":
				a.scope = {};
				break;
			default:
				a.scope = [this.model.getTriggerScope(c)]
		}
		return a
	}
};
Core.TriggerController = Sys.extend(Core.Controller, Core.TriggerController, "Core.TriggerController");
Sys.ns("Core");
Core.TriggerModel = {
	constructor: function() {
		Core.TriggerModel.superclass.constructor.apply(this, arguments)
	},
	registerTrigger: function(a, c, b) {
		this.readData("triggers")[a] = {
			description: b,
			defaultScope: c
		}
	},
	getTriggers: function() {
		return this.readData("triggers")
	},
	hasTrigger: function(a) {
		return Sys.isDefined(this.readData("triggers")[a])
	},
	getLinkedTriggers: function() {
		return Object.keys(this.readData("scriptLookup"))
	},
	getTriggerDescription: function(b) {
		var a = this.readData("triggers")[b];
		if (Sys.isObj(a)) {
			return a.description
		}
		return undefined
	},
	getTriggerScope: function(b) {
		var a = this.readData("triggers")[b];
		if (Sys.isObj(a)) {
			return a.defaultScope
		}
		return undefined
	},
	getScriptNamesLinkedToTrigger: function(b) {
		var a = this.readData("scriptLookup")[b];
		if (!a) {
			a = []
		}
		return a
	},
	getScriptsLinkedToTrigger: function(c) {
		var e = Resources.readData("triggerScripts"),
			b = this.getScriptNamesLinkedToTrigger(c),
			a = [],
			d;
		for (d = -1; ++d < b.length;) {
			a.push(e[b[d]])
		}
		return a
	},
	linkScriptToTrigger: function(c, a) {
		var b = this.readData("scriptLookup");
		if (!Sys.isArray(b[a])) {
			b[a] = []
		}
		if (!b[a].contains(c)) {
			b[a].push(c)
		}
	},
	unlinkScriptAndTrigger: function(e, a) {
		var d = this.readData("scriptLookup"),
			c = d[a],
			b;
		if (Sys.isArray(c)) {
			b = c.indexOf(e);
			if (b >= 0) {
				c.splice(b, 1)
			}
		}
	},
	setupData: function() {
		this.storeData("triggers", {});
		this.storeData("scriptLookup", this.initializeScriptLookup())
	},
	initializeScriptLookup: function() {
		var b = Resources.readData("triggerScripts"),
			a = Object.keys(b),
			h = a.length,
			f = {},
			g, d, e, c;
		for (e = -1; ++e < h;) {
			g = a[e];
			d = b[g];
			for (c = -1; ++c < d.usedOn.length;) {
				if (!Sys.isDefined(f[d.usedOn[c]])) {
					f[d.usedOn[c]] = []
				}
				f[d.usedOn[c]].push(g)
			}
		}
		return f
	}
};
Core.TriggerModel = Sys.extend(Core.Model, Core.TriggerModel, "Core.TriggerModel");
(function(a) {
	var b = "buttonSounds";
	a.buttonUp = {
		usedOn: ["notify:button.up", "notify:spinButton.up"],
		type: "audio",
		script: function() {
			this.play(b, "buttonUp")
		}
	};
	a.buttonDown = {
		usedOn: ["notify:button.down", "notify:spinButton.down"],
		type: "audio",
		script: function() {
			this.play(b, "buttonDown")
		}
	};
	a.buttonHover = {
		usedOn: ["notify:button.hover", "notify:spinButton.hover", "notify:paytableClose.hover", "notify:paytableIndicator_0.hover", "notify:paytableIndicator_1.hover", "notify:paytableIndicator_2.hover", "notify:paytableNext.hover", "notify:paytablePrevious.hover"],
		type: "audio",
		script: function(c) {
			if (!c) {
				this.play(b, "buttonHover")
			}
		}
	};
	a.buttonClick = {
		usedOn: ["notify:button.click"],
		type: "audio",
		script: function() {
			this.play(b, "buttonClick")
		}
	};
	a.spinButtonClick = {
		usedOn: ["notify:spinButton.clicked"],
		type: "audio",
		script: function() {
			this.play(b, "spinButtonClick")
		}
	};
	a.sliderIncrease = {
		usedOn: [],
		type: "audio",
		script: function() {}
	};
	a.sliderDecrease = {
		usedOn: [],
		type: "audio",
		script: function() {}
	};
	a.paytableFlip = {
		usedOn: ["notify:paytableNext.click", "notify:paytablePrevious.click", "notify:paytableIndicator_0.click", "notify:paytableIndicator_1.click", "notify:paytableIndicator_2.click"],
		type: "audio",
		script: function() {}
	};
	a.paytableButtonDown = {
		usedOn: ["notify:paytableClose.down"],
		type: "audio",
		script: function() {}
	};
	a.paytableButtonUp = {
		usedOn: ["notify:paytableClose.up"],
		type: "audio",
		script: function() {}
	};
	a.paytableButtonClick = {
		usedOn: ["notify:paytableClose.click"],
		type: "audio",
		script: function() {}
	};
	Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function(a) {
	var c = "nearWin",
		d = "spinSounds",
		b = function(e) {
			var f = this.getGroup(e);
			if (Sys.isDefined(f)) {
				f.setVolume(1)
			}
		};
	a.reelSpin = {
		usedOn: ["notify:spin.spinAnimationStarted"],
		type: "audio",
		script: function(e) {
			b.call(this, d);
			this.play(d, "reelSpin")
		}
	};
	a.reelBounceStart = {
		usedOn: ["notify:spin.reelStopBouncingStarted"],
		type: "audio",
		script: function() {
			b.call(this, d);
			this.play(d, "reelBounce")
		}
	};
	a.reelStop = {
		usedOn: ["notify:spin.reelStopStarted"],
		type: "audio",
		script: function(e) {
			b.call(this, d);
			this.play(d, "reelStop")
		}
	};
	a.spinComplete = {
		usedOn: ["notify:spin.spinAnimationComplete"],
		type: "audio",
		script: function() {
			var e = this.getGroup(c),
				f = this.getGroup(d);
			if (Sys.isDefined(e)) {
				e.fadeOut({
					duration: 1
				})
			}
			if (Sys.isDefined(f)) {
				f.fadeOut({
					duration: 0.5
				})
			}
		}
	};
	a.quickStop = {
		usedOn: ["notify:quickStopper.quickStop"],
		type: "audio",
		script: function() {}
	};
	a.scatterHit = {
		usedOn: ["notify:reelStopAnimations.symbolsToAnimate"],
		type: "audio",
		script: function(f, e) {
			b.call(this, d);
			this.play(d, "scatterHit")
		}
	};
	a.nearWin = {
		usedOn: ["notify:spin.nearWinStarted"],
		type: "audio",
		script: function() {
			b.call(this, c);
			this.play(c, "nearWin")
		}
	};
	a.nearWinFail = {
		usedOn: [],
		type: "audio",
		script: function() {
			var e = this.getGroup(c);
			if (Sys.isDefined(e)) {
				e.fadeOut({
					duration: 1
				})
			}
		}
	};
	Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function(a) {
	var c = "winPresentation",
		d = "main",
		b;
	a.standardWinStartAudio = {
		usedOn: ["notify:standardWin.startPresentation"],
		type: "audio",
		script: function(e) {
			var f = this.getGroup(c);
			if (Sys.isDefined(f)) {
				f.fadeIn({
					duration: 0.1
				})
			}
			switch (e) {
				case "smallWin":
					a.smallWin.script.call(this);
					break;
				case "mediumWin":
					a.mediumWin.script.call(this);
					break;
				case "largeWin":
					a.largeWin.script.call(this);
					break;
				default:
			}
		}
	};
	a.countUpAborted = {
		usedOn: ["notify:standardWin.countupAborted"],
		type: "audio",
		script: function() {
			this.getGroup(d).fadeIn({
				duration: 0.5
			})
		}
	};
	a.stopWinSound = {
		usedOn: ["notify:standardWin.countupAborted", "notify:stateHandler.leavingStandardWinPresentationState"],
		type: "audio",
		script: function() {
			var e = this.getGroup(c);
			if (Sys.isDefined(e)) {
				e.fadeOut({
					duration: 0.5
				})
			}
		}
	};
	a.smallWin = {
		usedOn: [],
		type: "audio",
		script: function() {
			var f = Resources.readData("audioConfig").clips,
				e = f.main.smallWin;
			if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
				this.duck(this.getGroup(d), e.duck.ambienceGeneral)
			}
			this.play(c, "smallWin")
		}
	};
	a.mediumWin = {
		usedOn: [],
		type: "audio",
		script: function() {
			var f = Resources.readData("audioConfig").clips,
				e = f.main.mediumWin;
			if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
				this.duck(this.getGroup(d), e.duck.ambienceGeneral)
			}
			this.play(c, "mediumWin")
		}
	};
	a.largeWin = {
		usedOn: [],
		type: "audio",
		script: function() {
			var f = Resources.readData("audioConfig").clips,
				e = f.main.largeWin;
			if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
				this.duck(this.getGroup(d), e.duck.ambienceGeneral)
			}
			this.play(c, "largeWin")
		}
	};
	a.bigWinStart = {
		usedOn: ["notify:stateHandler.enteringBigWinState"],
		type: "audio",
		script: function() {
			var f = this,
				e, g = this.getGroup(c);
			if (Sys.isDefined(g)) {
				g.fadeIn({
					duration: 0.1
				})
			}
			b = true;
			a.ambienceGeneralStop.script.call(this);
			f.play(c, "bigWinStart");
			f.play(c, "bigWinLoop", {
				loop: true
			});
			e = f.startMetronome("bigWin", {
				bpm: 123
			});
			e.at(4, 4).stop(c);
			e.at(4, 4).play(c, "bigWinEnd", {
				offset: 0.6
			});
			e.at(4, 4).then(function() {
				f.stopMetronome("bigWin");
				b = false
			})
		}
	};
	a.bigWinLoop = {
		usedOn: ["notify:stateHandler.enteringBigWinState"],
		type: "audio",
		script: function() {}
	};
	a.bigWinCountUpEnd = {
		usedOn: ["notify:bigWin.showTotalInCountUp"],
		type: "audio",
		script: function() {
			if (b) {
				this.stop(c);
				this.play(c, "bigWinEnd", {
					offset: 2.7
				})
			}
		}
	};
	a.bigWinEnd = {
		usedOn: ["notify:stateHandler.leavingBigWinState"],
		type: "audio",
		script: function() {
			this.getGroup(c).fadeOut({
				duration: 2
			});
			a.ambienceGeneralStart.script.call(this)
		}
	};
	Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function(a) {
	var c = "main",
		b = false;
	a.globalSettings = {
		usedOn: ["notify:settingsManager.settingChanged"],
		type: "audio",
		script: function(d, e) {
			if (d === "volume") {
				this.setVolume(e)
			}
		}
	};
	a.volumeRestore = {
		usedOn: ["notify:stateHandler.leavingSetupGameState"],
		type: "audio",
		script: function() {
			var d = Services.settingsManager.getSetting("volume");
			this.setVolume(d)
		}
	};
	a.soundLoaded = {
		usedOn: ["notify:audioPlayer.soundLoaded"],
		type: "audio",
		script: function() {
			var d;
			if (Services.storage.readData("IntroMovie.showing") === true) {
				return
			}
			d = Services.storage.readData("playModeManager.modes");
			switch (d) {
				case "freespin":
					a.ambienceFreeSpinStart.script.call(this);
					break;
				case "basic":
					a.ambienceGeneralStart.script.call(this);
					break;
				default:
					break
			}
		}
	};
	a.ambienceGeneralStart = {
		usedOn: ["notify:stateHandler.leavingShowingIntroMovieState"],
		type: "audio",
		script: function() {
			var d = b ? "freeSpin" : "ambienceGeneral";
			this.stop(c);
			this.play(c, d, {
				loop: true
			})
		}
	};
	a.ambienceGeneralStop = {
		usedOn: ["notify:stateHandler.enteringShowingIntroMovieState"],
		type: "audio",
		script: function() {
			this.stop(c)
		}
	};
	a.ambienceFreeSpinStart = {
		usedOn: ["notify:stateHandler.enteringFreeSpinIntroState"],
		type: "audio",
		script: function() {
			b = true;
			a.ambienceGeneralStart.script.call(this)
		}
	};
	a.ambienceFreeSpinStop = {
		usedOn: ["notify:stateHandler.leavingFreeSpinOutroState"],
		type: "audio",
		script: function() {
			b = false;
			a.ambienceGeneralStart.script.call(this)
		}
	};
	a.freeSpinCountdown = {
		usedOn: ["notify:stateHandler.enteringCountDownFreespinsState"],
		type: "audio",
		script: function() {}
	};
	Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
Sys.ns("Core");
Core.SlowRequestAnimation = {
	constructor: function() {
		Core.SlowRequestAnimation.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.SlowRequestAnimationModel,
			view: Core.SlowRequestAnimationView,
			controller: Core.SlowRequestAnimationController
		}
	},
	getMixinDependencies: function() {
		return ["orientation"]
	}
};
Core.SlowRequestAnimation = Sys.extend(Core.Module, Core.SlowRequestAnimation, "Core.SlowRequestAnimation");
Sys.ns("Core");
Core.SlowRequestAnimationModel = {
	constructor: function() {
		Core.SlowRequestAnimationModel.superclass.constructor.apply(this, arguments);
		this.initModel()
	},
	initModel: function() {
		var a = this;
		a.storeData("timeConfig", {
			between: 300,
			slowConnectionTime: 10000,
			slowDialogTime: 30000
		});
		a.storeData("activeStack", []);
		a.storeData("requestConfig", a.getRequestConfig());
		a.storeData("dialogShowing", false);
		a.setState("idle")
	},
	updateActiveStack: function(d) {
		var c = this,
			a = this.readData("activeStack"),
			b = a.indexOf(d);
		if (b > -1) {
			a.splice(b, 1);
			c.storeData("activeStack", a)
		}
		return a
	},
	pushActive: function(c) {
		var b = this,
			a = b.readData("activeStack");
		a.push(c);
		b.storeData("activeStack", a)
	},
	getRequestConfig: function() {
		return ["spin", "drop", "freespin", "respin", "freespininit"]
	},
	removeSlowTimeout: function() {
		var a = this.readData("slowTimeout");
		if (a) {
			clearTimeout(a);
			this.removeData("slowTimeout")
		}
	},
	removeDialogTimeout: function() {
		var a = this.readData("dialogTimeout");
		if (a) {
			this.storeData("dialogShowing", false);
			clearTimeout(a);
			this.removeData("dialogTimeout")
		}
	},
	getSlowConnectionTimeout: function() {
		return this.readData("slowTimeout")
	},
	getDialogTimeout: function() {
		return this.readData("dialogTimeout")
	},
	storeDialogTimeout: function(a) {
		var b = this,
			c = b.readData("dialogTimeout");
		if (c) {
			clearTimeout(c);
			b.storeData("dialogTimeout", a)
		} else {
			b.storeData("dialogTimeout", a)
		}
	},
	storeSlowConnectionTimeout: function(a) {
		var b = this,
			c = b.readData("slowTimeout");
		if (c) {
			clearTimeout(c);
			b.storeData("slowTimeout", a)
		} else {
			b.storeData("slowTimeout", a)
		}
	}
};
Core.SlowRequestAnimationModel = Sys.extend(Core.Model, Core.SlowRequestAnimationModel, "Core.SlowRequestAnimationModel");
Sys.ns("Core");
Core.SlowRequestAnimationController = {
	constructor: function() {
		Core.SlowRequestAnimationController.superclass.constructor.apply(this, arguments);
		this.initController()
	},
	initController: function() {
		var a = this;
		a.on({
			"view:showDialog": a.onShowDialog,
			"view:dialogContinue": a.onDialogContinueOption,
			"view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
			"notify:serverManager.actionRequestSent": a.onServerRequest,
			"notify:serverManager.actionRequestError": a.tryToHideAnimation,
			"notify:serverManager.slowRequest": a.onSlowResponse,
			"notify:responseParser.responseParsed": a.onServerResponse,
			"request:slowRequestAnimation.show": a.showSpinnerAnimation,
			"request:slowRequestAnimation.hide": a.hideSpinnerAnimation
		})
	},
	onLoaderClose: function() {
		this.view.initView()
	},
	onShowDialog: function(a) {
		var b = this;
		b.fireEvent("request:dialogWindow.showDialog", a);
		b.model.storeData("dialogShowing", true)
	},
	animationRequested: function() {
		var a = this;
		if (a.model.isState("active")) {
			a.view.display({
				modal: false
			});
			a.model.setState("running")
		}
	},
	showSpinnerAnimation: function() {
		this.fireEvent("request:userInputManager.activateExclusivity", "slowRequestAnimation");
		this.view.addOverlay();
		this.view.showSpinner()
	},
	hideSpinnerAnimation: function() {
		this.fireEvent("request:userInputManager.deactivateExclusivity", "slowRequestAnimation");
		this.view.removeOverlay();
		this.view.hideSpinner()
	},
	onServerRequest: function(b) {
		var a = this;
		if (a.model.readData("requestConfig").contains(b) && a.model.isState("idle")) {
			a.model.setState("active");
			a.model.pushActive(b)
		}
	},
	onSlowResponse: function() {
		this.animationRequested()
	},
	onServerResponse: function(a) {
		if ((Sys.isDefined(a) && Sys.isDefined(a.clientaction))) {
			this.tryToHideAnimation(a.clientaction)
		}
	},
	tryToHideAnimation: function(d) {
		var c = this,
			b = c.model,
			a;
		if (b.isState("running") || b.isState("active")) {
			a = b.updateActiveStack(d);
			if (a.length > 0) {} else {
				if (c.model.readData("dialogShowing")) {
					c.fireEvent("request:dialogWindow.closeCurrentDialog")
				}
				c.view.hideWrapper();
				c.view.resetSlowMessage();
				c.view.resetDialogMessage(false);
				b.setState("idle")
			}
		}
	},
	onDialogContinueOption: function() {
		this.view.resetDialogMessage(true)
	}
};
Core.SlowRequestAnimationController = Sys.extend(Core.Controller, Core.SlowRequestAnimationController, "Core.SlowRequestAnimationController");
Sys.ns("Core.Slots");
Core.SlowRequestAnimationView = {
	BASE_CSS: "interface-slowRequestAnimation _base",
	PORTRAIT_CSS: "interface-slowRequestAnimation _portrait",
	LANDSCAPE_CSS: "interface-slowRequestAnimation _landscape",
	PIXEL_FACTOR: 0.01,
	constructor: function() {
		Core.SlowRequestAnimationView.superclass.constructor.apply(this, arguments)
	},
	initView: function() {
		var a = this;
		a.hasOverlay = false;
		a.setupElements()
	},
	removeOverlay: function() {
		var b = this,
			a = b.getLayoutConfig().background,
			c = b.getLayoutConfig().animation;
		b.background.el.style.top = a.top * b.PIXEL_FACTOR + "rem";
		b.background.el.style.left = a.left * b.PIXEL_FACTOR + "rem";
		b.background.el.style.width = a.width * b.PIXEL_FACTOR + "rem";
		b.background.el.style.height = a.height * b.PIXEL_FACTOR + "rem";
		b.background.el.style.borderRadius = "0";
		b.background.el.style.zIndex = 340;
		b.animation.el.style.top = c.top * b.PIXEL_FACTOR + "rem";
		b.animation.el.style.left = c.left * b.PIXEL_FACTOR + "rem";
		b.hasOverlay = false
	},
	addOverlay: function() {
		var b = this,
			a = b.getLayoutConfig().overlayConfig.background,
			c = b.getLayoutConfig().overlayConfig.animation;
		b.background.el.style.top = a.top * b.PIXEL_FACTOR + "rem";
		b.background.el.style.left = a.left * b.PIXEL_FACTOR + "rem";
		b.background.el.style.width = a.width * b.PIXEL_FACTOR + "rem";
		b.background.el.style.height = a.height * b.PIXEL_FACTOR + "rem";
		b.background.el.style.borderRadius = "0";
		b.background.el.style.zIndex = 340;
		b.animation.el.style.top = c.top * b.PIXEL_FACTOR + "rem";
		b.animation.el.style.left = c.left * b.PIXEL_FACTOR + "rem";
		b.hasOverlay = true
	},
	onPortrait: function() {
		var a = this;
		Mixins.orientation.view.methods.onPortrait.call(a);
		if (a.hasOverlay) {
			a.addOverlay()
		}
	},
	onLandscape: function() {
		var a = this;
		Mixins.orientation.view.methods.onLandscape.call(a);
		if (a.hasOverlay) {
			a.addOverlay()
		}
	},
	getLayoutConfig: function() {
		var a = {
			width: 960,
			height: 540
		};
		return {
			overlayConfig: {
				background: {
					top: 0 - Environment.getSpaceAboveGame(),
					left: 0,
					width: a.width,
					height: a.height + Environment.getSpaceBelowGame()
				},
				animation: {
					top: a.height / 2 - (Environment.scaleValue(180) / 2) + Environment.getSpaceAboveGame(),
					left: a.width / 2 - (Environment.scaleValue(210) / 2)
				}
			},
			wrapper: {
				top: 0,
				left: 0
			},
			background: {
				top: (a.height / 2) - (Environment.scaleValue(180) / 2),
				left: (a.width / 2) - (Environment.scaleValue(210) / 2),
				width: Environment.scaleValue(210),
				height: Environment.scaleValue(180)
			},
			animation: {
				top: (a.height / 2) - (Environment.scaleValue(180) / 2),
				left: (a.width / 2) - (Environment.scaleValue(376) / 2),
				width: Environment.scaleValue(210),
				height: Environment.scaleValue(180)
			},
			textArea: {
				top: Environment.scaleValue(130),
				left: 0,
				width: 0,
				height: Environment.scaleValue(80)
			},
			guiArea: {
				top: Environment.scaleValue(410),
				left: 0,
				width: 0,
				height: Environment.scaleValue(100)
			}
		}
	},
	setupBackgroundArea: function(c) {
		var b = this,
			a = c || b.getLayoutConfig();
		return new Sys.Element({
			tag: "div",
			id: "slowRequestAnimation",
			cls: "slowRequestAnimation background",
			style: "top:" + a.background.top * b.PIXEL_FACTOR + "rem;left:" + a.background.left * b.PIXEL_FACTOR + "rem;width:" + a.background.width * b.PIXEL_FACTOR + "rem;height:" + a.background.height * b.PIXEL_FACTOR + "rem;"
		})
	},
	getDialogConfig: function() {
		var a = this;
		return {
			slowDialog: {
				title: Services.languageManager.getText(Language.Keys.connectionQualityPoor),
				text: Services.languageManager.getText(Language.Keys.slowConnection),
				buttons: [{
					text: Services.languageManager.getText(Language.Keys.btn_casino),
					action: Environment.goToLobby.bind(Environment, "9")
				}, {
					text: Services.languageManager.getText(Language.Keys.btn_continue),
					action: a.fireEvent.bind(a, "view:dialogContinue")
				}]
			}
		}
	},
	setupAnimationArea: function(c) {
		var b = this,
			a = c || this.getLayoutConfig();
		return new Sys.Element({
			tag: "div",
			cls: "slowRequestAnimation loadAnimation animation slowRequestAnimation_uri",
			style: "width:" + a.animation.width * b.PIXEL_FACTOR + "rem;height:" + a.animation.height * b.PIXEL_FACTOR + "rem;"
		})
	},
	setupTextArea: function(c) {
		var b = this,
			d, a = c || this.getLayoutConfig();
		b.textSpan = new Sys.Element({
			tag: "span",
			textContent: Services.languageManager.getText(Language.Keys.slowConnection)
		});
		d = new Sys.Element({
			tag: "div",
			cls: "slowRequestAnimation text hide",
			style: "left:" + a.textArea.left * b.PIXEL_FACTOR + "rem;width:100%;min-height:" + a.textArea.height * b.PIXEL_FACTOR + "rem;"
		});
		d.add(b.textSpan);
		return d
	},
	setupElements: function() {
		var b = this,
			a = b.getLayoutConfig();
		b.wrapper = new Sys.Element({
			tag: "div",
			id: "slowRequestAnimation",
			cls: "slowRequestAnimation wrapper hide",
			style: "top:" + a.wrapper.top * b.PIXEL_FACTOR + "rem;left:" + a.wrapper.left * b.PIXEL_FACTOR + "rem;width: 100%;height: 100%;",
			renderTo: "gameWrapper"
		});
		b.background = b.setupBackgroundArea(a);
		b.animation = b.setupAnimationArea(a);
		b.textArea = b.setupTextArea(a);
		b.background.add(b.animation);
		b.wrapper.add(b.background);
		b.wrapper.add(b.textArea);
		b.container = b.wrapper;
		b.fireEvent("view:setSafeArea", "slowRequestAnimation", {
			element: b.container.getEl()
		})
	},
	setupRequestDialogTimeout: function() {
		var b = this,
			c, a = b.model.readData("timeConfig").slowDialogTime;
		c = setTimeout(function() {
			b.requestSlowDialog()
		}, a);
		b.model.storeDialogTimeout(c)
	},
	requestSlowDialog: function() {
		var b = this,
			a = b.getDialogConfig().slowDialog;
		if (b.model.isState("running")) {
			b.hideSpinner();
			b.hideText();
			b.fireEvent("view:showDialog", a)
		}
	},
	onShowSlowConnection: function() {
		this.showText()
	},
	display: function(a) {
		var c = this,
			d, b;
		if (a.modal) {
			c.wrapper.addCls("modal")
		}
		c.wrapper.removeCls("hide");
		if (!a.modal) {
			b = c.model.readData("timeConfig").slowConnectionTime;
			d = setTimeout(function() {
				c.onShowSlowConnection();
				c.setupRequestDialogTimeout()
			}, b);
			c.model.storeSlowConnectionTimeout(d)
		}
		return true
	},
	resetSlowMessage: function() {
		var a = this,
			b = a.model.getSlowConnectionTimeout();
		if (b) {
			a.model.removeSlowTimeout();
			a.hideText()
		}
	},
	resetDialogMessage: function(a) {
		var b = this,
			c = b.model.getDialogTimeout();
		if (c) {
			b.model.removeDialogTimeout();
			if (a && b.model.isState("running")) {
				b.showSpinner();
				b.showText();
				b.setupRequestDialogTimeout()
			}
		}
	},
	showSpinner: function() {
		this.wrapper.removeCls("hide")
	},
	hideSpinner: function() {
		this.hideWrapper()
	},
	hideWrapper: function() {
		this.wrapper.addCls("hide")
	},
	hideText: function() {
		this.textArea.addCls("hide")
	},
	showText: function() {
		this.textArea.removeCls("hide")
	}
};
Core.SlowRequestAnimationView = Sys.extend(Core.View, Core.SlowRequestAnimationView, "Core.SlowRequestAnimationView");
Sys.ns("Core");
Core.SlowRequestAnimationDesktopView = {
	constructor: function() {
		Core.SlowRequestAnimationDesktopView.superclass.constructor.apply(this, arguments)
	},
	setupRequestDialogTimeout: function() {}
};
Core.SlowRequestAnimationDesktopView = Sys.extend(Core.SlowRequestAnimationView, Core.SlowRequestAnimationDesktopView, "Core.SlowRequestAnimationDesktopView");
Sys.ns("Interface");
Interface.HomeButton = {
	constructor: function() {
		Interface.HomeButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation", {
			userInput: {
				listenToUserInput: true
			}
		}]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.HomeButtonController,
			model: Core.Model,
			view: Interface.HomeButtonBaseView
		}
	}
};
Interface.HomeButton = Sys.extend(Core.Module, Interface.HomeButton, "Interface.HomeButton");
Sys.ns("Interface");
Interface.HomeButtonController = {
	constructor: function() {
		Interface.HomeButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.HomeButtonController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
			"notify:settingsMenu.open": a.view.hide.bind(a.view),
			"notify:settingsMenu.closed": a.view.show.bind(a.view),
			"request:homeButton.hidePermanently": a.hidePermanently
		})
	},
	onLoaderClose: function() {
		var a = this;
		a.view.show();
		a.view.setFullscreenSafeArea()
	},
	hidePermanently: function() {
		this.model.storeData("hiddenPermanently", true);
		this.view.hide()
	},
	onUserInputStart: function(a) {
		if (this.view.isInputTarget(a)) {
			this.model.storeData("activeInputTarget", true)
		}
	},
	onUserInputEnd: function(c) {
		var b = this,
			a = Resources.readData("lobbyUrl");
		if (b.model.readData("activeInputTarget")) {
			if (b.view.isInputTarget(c)) {
				if (Sys.isDefined(a) && a !== "") {
					b.fireEvent("request:slowRequestAnimation.show")
				}
				Environment.goToLobby(0)
			}
		}
		b.model.storeData("activeInputTarget", false)
	}
};
Interface.HomeButtonController = Sys.extend(Core.Controller, Interface.HomeButtonController, "Interface.HomeButtonController");
Sys.ns("Interface");
Interface.HomeButtonBaseView = {
	BASE_BUTTON_CSS: "interface-homeButton_baseButton",
	PORTRAIT_CSS: "interface-homeButton_portraitBase",
	LANDSCAPE_CSS: "interface-homeButton_landscapeBase",
	URI_BUTTON: "interface-homeButton_button_uri",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.HomeButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	adaptToOrientation: function(a) {
		this.setStyle(a)
	},
	init: function() {
		var a = this;
		Interface.HomeButtonBaseView.superclass.init.apply(a, arguments);
		a.container = new Sys.Element({
			id: "homeButton",
			tag: "div",
			cls: a.BASE_BUTTON_CSS,
			renderTo: a.RENDER_TARGET,
			style: "display: none;"
		})
	},
	setFullscreenSafeArea: function() {
		var a = this;
		a.fireEvent("view:setSafeArea", "homeButton", {
			element: a.container.getEl()
		})
	},
	show: function() {
		var b = this,
			a = b.container;
		if (!b.model.readData("hiddenPermanently")) {
			a.el.style.display = "block";
			if (!a.hasCls(b.URI_BUTTON)) {
				a.addCls(b.URI_BUTTON)
			}
		}
	},
	hide: function() {
		this.container.el.style.display = "none"
	},
	isInputTarget: function(a) {
		return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	setStyle: function(a) {
		var c = this,
			d = a + "_CSS",
			b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
		if (Sys.isDefined(c[d])) {
			c.container.removeCls(c[b]);
			c.container.addCls(c[d])
		}
	}
};
Interface.HomeButtonBaseView = Sys.extend(Core.View, Interface.HomeButtonBaseView, "Interface.HomeButtonBaseView");
Sys.ns("Interface");
Interface.HomeButtonMobileView = {
	PORTRAIT_CSS: "interface-homeButton_portraitBase_mobile",
	LANDSCAPE_CSS: "interface-homeButton_landscapeBase_mobile",
	constructor: function() {
		Interface.HomeButtonMobileView.superclass.constructor.apply(this, arguments)
	}
};
Interface.HomeButtonMobileView = Sys.extend(Interface.HomeButtonBaseView, Interface.HomeButtonMobileView, "Interface.HomeButtonMobileView");
Sys.ns("Interface");
Interface.SoundOnOffButton = {
	constructor: function() {
		Interface.SoundOnOffButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation", {
			userInput: {
				listenToUserInput: true
			}
		}, {
			properties: {
				updateOnStartup: true
			}
		}]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SoundOnOffButtonController,
			model: Core.Model,
			view: Interface.SoundOnOffButtonBaseView
		}
	}
};
Interface.SoundOnOffButton = Sys.extend(Core.Module, Interface.SoundOnOffButton, "Interface.SoundOnOffButton");
Sys.ns("Interface");
Interface.SoundOnOffButtonController = {
	constructor: function() {
		Interface.SoundOnOffButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:audioPlayer.loadingSound": a.loadingSound,
			"notify:audioPlayer.soundLoaded": a.soundFinishedLoading,
			"notify:settingsMenu.open": a.onSettingsMenuOpened,
			"notify:settingsMenu.closed": a.onSettingsMenuClosed,
			"notify:settingsManager.settingChanged": a.onSettingChanged
		})
	},
	loadingSound: function() {
		this.model.storeData("soundIsLoading", true);
		this.addProperty("soundLoading", this.MODULE_NAME)
	},
	soundFinishedLoading: function() {
		this.model.storeData("soundIsLoading", false);
		this.removeProperty("soundLoading", this.MODULE_NAME)
	},
	onSettingsMenuOpened: function() {
		this.addProperty("hidden", "settingsMenuOpen")
	},
	onSettingsMenuClosed: function() {
		this.removeProperty("hidden", "settingsMenuOpen")
	},
	onUserInputStart: function(a) {
		if (this.model.readData("soundIsLoading")) {
			return
		}
		this.model.storeData("isInputTarget", this.view.isTarget(a))
	},
	onUserInputEnd: function(a) {
		if (this.model.readData("soundIsLoading")) {
			return
		}
		if (this.view.isTarget(a) && this.model.readData("isInputTarget")) {
			Services.settingsManager.storeSetting("volume", Services.settingsManager.getSetting("volume") > 0 ? 0 : 1)
		}
	},
	onSettingChanged: function(a) {
		if (a === "volume") {
			this.updateAppearance()
		}
	},
	updateAppearance: function() {
		this.view.update()
	}
};
Interface.SoundOnOffButtonController = Sys.extend(Core.Controller, Interface.SoundOnOffButtonController, "Interface.SoundOnOffButtonController");
Sys.ns("Interface");
Interface.SoundOnOffButtonBaseView = {
	BASE_BUTTON_CSS: "interface-soundOnOffButton_baseButton",
	PORTRAIT_CSS: "interface-soundOnOffButton_portrait",
	LANDSCAPE_CSS: "interface-soundOnOffButton_landscape",
	ON_URI: "interface-soundOnOffButton_on_uri",
	OFF_URI: "interface-soundOnOffButton_off_uri",
	LOADING_URI: "interface-smallSpinner_uri",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.SoundOnOffButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	adaptToOrientation: function(a) {
		this.setStyle(a)
	},
	init: function() {
		var a = this;
		Interface.SoundOnOffButtonBaseView.superclass.init.apply(a, arguments);
		a.container = new Sys.Element({
			id: "soundOnOffButton",
			tag: "div",
			cls: a.BASE_BUTTON_CSS,
			renderTo: a.RENDER_TARGET
		})
	},
	isTarget: function(a) {
		return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	setStyle: function(a) {
		var c = this,
			d = a + "_CSS",
			b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
		if (Sys.isDefined(c[d])) {
			c.container.removeCls(c[b]);
			c.container.addCls(c[d])
		}
	},
	update: function() {
		var c = this,
			b = c.model,
			a = c.container;
		if (b.hasProperty("hidden")) {
			a.el.style.display = "none"
		} else {
			a.el.style.display = "block"
		}
		a.removeCSSClass(c.ON_URI);
		a.removeCSSClass(c.OFF_URI);
		a.removeCSSClass(c.LOADING_URI);
		if (b.hasProperty("soundLoading")) {
			a.addCSSClass(c.LOADING_URI)
		} else {
			if (Services.settingsManager.getSetting("volume") > 0) {
				a.addCSSClass(c.ON_URI)
			} else {
				a.addCSSClass(c.OFF_URI)
			}
		}
	}
};
Interface.SoundOnOffButtonBaseView = Sys.extend(Core.View, Interface.SoundOnOffButtonBaseView, "Interface.SoundOnOffButtonBaseView");
Sys.ns("Interface");
Interface.SoundOnOffButtonMobileView = {
	PORTRAIT_CSS: "interface-soundOnOffButton_portrait_mobile",
	LANDSCAPE_CSS: "interface-soundOnOffButton_landscape_mobile",
	constructor: function() {
		Interface.SoundOnOffButtonMobileView.superclass.constructor.apply(this, arguments)
	}
};
Interface.SoundOnOffButtonMobileView = Sys.extend(Interface.SoundOnOffButtonBaseView, Interface.SoundOnOffButtonMobileView, "Interface.SoundOnOffButtonMobileView");
Sys.ns("Interface");
Interface.AutoPlayButton = {
	constructor: function() {
		Interface.AutoPlayButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["orientation", "userInput", "animation", "properties"],
			desktop: [{
				userInput: {
					inputEvents: ["start", "end", "cancel", "move", "hover"]
				}
			}, "properties", "animation"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.AutoPlayButtonController,
			model: Interface.AutoPlayButtonModel,
			view: Interface.AutoPlayButtonBaseView
		}
	}
};
Interface.AutoPlayButton = Sys.extend(Core.Module, Interface.AutoPlayButton, "Interface.AutoPlayButton");
Sys.ns("Interface");
Interface.AutoPlayButtonController = {
	constructor: function() {
		Interface.AutoPlayButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.AutoPlayButtonController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"notify:stateHandler.leavingIdleState": a.hide,
			"notify:stateHandler.enteringIdleState": a.show,
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"notify:settingsManager.settingDisabled": a.settingDisabled,
			"notify:settingsManager.settingLocked": a.settingLocked,
			"view:settingChangedLocally": a.onSettingChangedLocally
		})
	},
	onSettingChanged: function(a, c) {
		var b = this,
			d = b.model.readData("isFreerounds");
		if (a === "autoPlayNrSpins") {
			this.view.changeSetting(a, c);
			if (c !== 0 && this.model.readData("restrictedModeEnabled") && !d) {
				this.fireEvent("request:spinSettings.show")
			}
		}
	},
	onSettingChangedLocally: function(a, b) {
		this.fireEvent("request:settingsManager.storeData", a, b)
	},
	settingDisabled: function(a) {
		if (a === "autoPlayNrSpins") {
			this.view.disable()
		}
	},
	settingLocked: function(a) {
		if (a === "autoPlayNrSpins") {
			this.view.locked()
		}
	},
	onBeforeLoaderClose: function() {
		var a = this;
		if (a.view.dispatchAddToContainerRequest()) {
			a.view.show()
		} else {
			a.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "autoPlay")
		}
	}
};
Interface.AutoPlayButtonController = Sys.extend(Interface.SettingsSectionController, Interface.AutoPlayButtonController, "Interface.AutoPlayButtonController");
Sys.ns("Interface");
Interface.AutoPlayButtonModel = {
	DEFAULT_NUMBER_OF_ROUNDS: 50,
	constructor: function() {
		Interface.AutoPlayButtonModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var g = this,
			d = Resources.readData("gameServerInitResponseObject"),
			b = d.autoplay,
			a = g.DEFAULT_NUMBER_OF_ROUNDS,
			f = d.freeRoundsLeft,
			c, j, e, h;
		g.storeData("isFreerounds", Sys.isDefined(f) && f > 0);
		if (Sys.isDefined(b) && (g.validateSingleAutoPlayValue(b) || g.validateAutoplayArray(b))) {
			if (!Sys.isArray(b)) {
				c = b
			} else {
				c = b[0];
				for (e = 1; e < b.length; e++) {
					j = Math.abs(a - c) - Math.abs(a - b[e]);
					if (j > 0 || (j === 0 && b[e] > c)) {
						c = b[e]
					}
				}
			}
		} else {
			c = a
		}
		g.storeData("roundsToTrigger", c);
		h = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
		g.storeData("restrictedModeEnabled", h);
		if (h) {
			g.storeData("isRemovedAndDisabled", true)
		}
	},
	validateAutoplayArray: function(a) {
		var b = this,
			c = true,
			d = a.length;
		if (Sys.isArray(a) && d > 0 && d < 9) {
			Sys.each(a, function(f, e) {
				a[e] = Sys.utils.toInt(f);
				if (!b.validateSingleAutoPlayValue(a[e])) {
					c = false
				}
			})
		} else {
			c = false
		}
		return c
	},
	validateSingleAutoPlayValue: function(a) {
		var b = true,
			c = Sys.utils.toInt(a);
		if (Sys.isArray(a) || isNaN(c) || c < 5 || c > 1000) {
			b = false
		}
		return b
	}
};
Interface.AutoPlayButtonModel = Sys.extend(Core.Model, Interface.AutoPlayButtonModel, "Interface.AutoPlayButtonModel");
Sys.ns("Interface");
Interface.AutoPlayButtonBaseView = {
	BASE_CSS: "interface-autoPlayButton_baseContainer",
	PORTRAIT_CSS: "interface-autoPlayButton_portraitBase",
	LANDSCAPE_CSS: "interface-autoPlayButton_landscapeBase",
	PRESSED_CSS: "interface-autoPlayButton_pressedBase",
	TOGGLE_BASE_CSS: "interface-autoPlayToggle_base",
	TOGGLE_BUTTON_WRAPPER_CSS: "interface-autoPlayToggle_buttonWrapper",
	TOGGLE_BUTTON_BACKGROUND_CSS: "",
	TOGGLE_BUTTON_HANDLE_CSS: "",
	NUMBER_DISPLAY_CSS: "interface-autoPlayButton_numberDisplay",
	TARGET_CONTAINER: "quickSettingsMenu",
	constructor: function() {
		Interface.AutoPlayButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	changeSetting: function(b, d) {
		var c = this,
			a = true;
		if (b === "autoPlayNrSpins") {
			if (d === 0) {
				a = false;
				c.showNumberDisplay()
			}
			if (a !== c.button.isOn()) {
				c.sliderShown = a;
				c.button.toggle(a, true);
				if (a === true) {
					c.hideNumberDisplay()
				}
			}
		}
	},
	setUpContent: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "autoPlayButton",
			tag: "div",
			cls: a.BASE_CSS,
			style: "visibility:hidden;"
		});
		a.button = new Interface.utils.ToggleSwitch({
			id: "autoplayQuickSettingsButton",
			CSS: {
				base: a.TOGGLE_BASE_CSS,
				button_wrapper: a.TOGGLE_BUTTON_WRAPPER_CSS,
				button_background: a.TOGGLE_BUTTON_BACKGROUND_CSS,
				button_handle: a.TOGGLE_BUTTON_HANDLE_CSS
			},
			enabled: true,
			callback: a.onSwitchToggled.bind(a)
		});
		a.numberDisplay = new Sys.Element({
			tag: "div",
			"class": a.NUMBER_DISPLAY_CSS,
			textContent: a.model.readData("roundsToTrigger")
		});
		a.container.add(a.button.getContainer());
		a.container.add(a.numberDisplay)
	},
	dispatchAddToContainerRequest: function() {
		var a = this,
			b = a.model.readData("isFreerounds");
		if (a.model.readData("restrictedModeEnabled") && !b) {
			return false
		}
		a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {
			content: a.container
		});
		return true
	},
	onSwitchToggled: function(b) {
		var a = this;
		if (b) {
			a.fireEvent("view:settingChangedLocally", "autoPlayNrSpins", a.model.readData("roundsToTrigger"));
			a.hideNumberDisplay()
		} else {
			a.fireEvent("view:settingChangedLocally", "autoPlayNrSpins", 0);
			a.showNumberDisplay()
		}
	},
	show: function() {
		var a = this;
		a.container.el.style.visibility = "visible";
		a.button.enable()
	},
	hide: function() {
		var a = this;
		a.container.el.style.visibility = "hidden";
		a.button.disable()
	},
	press: function() {
		this.button.addCls(this.PRESSED_CSS)
	},
	release: function() {
		this.button.removeCls(this.PRESSED_CSS)
	},
	disable: function() {
		var a = this;
		a.fireEvent("view:removeFromContainer", a.TARGET_CONTAINER, {
			content: a.container
		})
	},
	locked: function() {
		this.disable()
	},
	showNumberDisplay: function() {
		this.numberDisplay.el.style.display = "block"
	},
	hideNumberDisplay: function() {
		this.numberDisplay.el.style.display = "none"
	},
	onUserInputStart: function(a) {
		this.wasInitialTarget = Sys.UserInputUtils.isCoordinateTarget(this.numberDisplay.el, a)
	},
	onUserInputMove: function() {},
	onUserInputEnd: function(a) {
		if (this.wasInitialTarget && Sys.UserInputUtils.isCoordinateTarget(this.numberDisplay.el, a)) {
			this.button.toggle()
		}
	},
	hideButton: function() {},
	showButton: function() {},
	enable: function() {}
};
Interface.AutoPlayButtonBaseView = Sys.extend(Core.View, Interface.AutoPlayButtonBaseView, "Interface.AutoPlayButtonBaseView");
Sys.ns("Interface");
Interface.QuickSpinButton = {
	constructor: function() {
		Interface.QuickSpinButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.QuickSpinButtonController,
			model: Interface.QuickSpinButtonModel,
			view: Interface.QuickSpinButtonBaseView
		}
	}
};
Interface.QuickSpinButton = Sys.extend(Core.Module, Interface.QuickSpinButton, "Interface.QuickSpinButton");
Sys.ns("Interface");
Interface.QuickSpinButtonController = {
	constructor: function() {
		Interface.QuickSpinButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Interface.QuickSpinButtonController.superclass.setupEvents.apply(a, arguments);
		a.on({
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"notify:stateHandler.leavingIdleState": a.view.hide.bind(a.view),
			"notify:stateHandler.enteringIdleState": a.view.show.bind(a.view),
			"notify:settingsManager.settingChanged": a.onSettingChanged,
			"notify:settingsManager.settingDisabled": a.settingDisabled,
			"view:settingChangedLocally": a.onSettingChangedLocally
		})
	},
	onSettingChanged: function(a, b) {
		if (a === "quickSpin") {
			this.view.changeSetting(a, b)
		}
	},
	onSettingChangedLocally: function(a, b) {
		this.fireEvent("request:settingsManager.storeData", a, b)
	},
	settingDisabled: function(a) {
		var b = this;
		if (a === "quickSpin") {
			b.model.storeData("isRemovedAndDisabled", true);
			b.view.disable()
		}
	},
	onBeforeLoaderClose: function() {
		var a = this;
		if (a.view.dispatchAddToContainerRequest()) {
			a.view.show()
		} else {
			a.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "quickSpin")
		}
	}
};
Interface.QuickSpinButtonController = Sys.extend(Interface.SettingsSectionController, Interface.QuickSpinButtonController, "Interface.QuickSpinButtonController");
Sys.ns("Interface");
Interface.QuickSpinButtonModel = {
	constructor: function() {
		Interface.QuickSpinButtonModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Services.localStorageManager.hasData("quickSpin") && Services.localStorageManager.readData("quickSpin") === "true";
		this.storeData("quickSpin", a);
		Services.settingsManager.storeSetting("quickSpin", a, false, false)
	}
};
Interface.QuickSpinButtonModel = Sys.extend(Core.Model, Interface.QuickSpinButtonModel, "Interface.QuickSpinButtonModel");
Sys.ns("Interface");
Interface.QuickSpinButtonBaseView = {
	BASE_CSS: "interface-quickSpinButton_baseContainer",
	PORTRAIT_CSS: "interface-quickSpinButton_portraitBase",
	LANDSCAPE_CSS: "interface-quickSpinButton_landscapeBase",
	PRESSED_CSS: "interface-quickSpinButton_pressedBase",
	TOGGLE_BASE_CSS: "interface-quickSpinToggle_base",
	TOGGLE_BUTTON_WRAPPER_CSS: "interface-quickSpinToggle_buttonWrapper",
	TOGGLE_BUTTON_BACKGROUND_CSS: "",
	TOGGLE_BUTTON_HANDLE_CSS: "",
	TARGET_CONTAINER: "quickSettingsMenu",
	constructor: function() {
		Interface.QuickSpinButtonBaseView.superclass.constructor.apply(this, arguments)
	},
	changeSetting: function(a, b) {
		if (a === "quickSpin" && b !== this.button.isOn()) {
			this.button.toggle(b, true)
		}
	},
	setUpContent: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "quickSpinButton",
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET,
			style: "visibility:hidden;"
		});
		a.button = new Interface.utils.ToggleSwitch({
			id: "quickSpinQuickSettingsButton",
			CSS: {
				base: a.TOGGLE_BASE_CSS,
				button_wrapper: a.TOGGLE_BUTTON_WRAPPER_CSS,
				button_background: a.TOGGLE_BUTTON_BACKGROUND_CSS,
				button_handle: a.TOGGLE_BUTTON_HANDLE_CSS
			},
			enabled: true,
			callback: a.onSwitchToggled.bind(a, "quickSpin")
		});
		a.container.add(a.button.getContainer());
		a.button.toggle(a.model.readData("quickSpin"))
	},
	dispatchAddToContainerRequest: function() {
		var a = this;
		if (!a.model.readData("isRemovedAndDisabled")) {
			a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {
				content: a.container
			});
			return true
		}
		return false
	},
	onSwitchToggled: function(a, b) {
		this.fireEvent("view:settingChangedLocally", a, b)
	},
	show: function() {
		this.button.enable();
		this.container.el.style.visibility = "visible"
	},
	hide: function() {
		this.container.el.style.visibility = "hidden";
		this.button.disable()
	},
	disable: function() {
		var a = this;
		a.fireEvent("view:removeFromContainer", a.TARGET_CONTAINER, {
			content: a.container
		})
	},
	press: function() {
		this.button.addCls(this.PRESSED_CSS)
	},
	release: function() {
		this.button.removeCls(this.PRESSED_CSS)
	}
};
Interface.QuickSpinButtonBaseView = Sys.extend(Core.View, Interface.QuickSpinButtonBaseView, "Interface.QuickSpinButtonBaseView");
Sys.ns("Interface");
Interface.BalanceDisplay = {
	constructor: function() {
		Interface.BalanceDisplay.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.BalanceDisplayController,
			view: Interface.BalanceDisplayBaseView
		}
	}
};
Interface.BalanceDisplay = Sys.extend(Core.Module, Interface.BalanceDisplay, "Interface.BalanceDisplay");
Sys.ns("Interface");
Interface.BalanceDisplayModel = {
	constructor: function() {
		Interface.BalanceDisplayModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {}
};
Interface.BalanceDisplayModel = Sys.extend(Core.Model, Interface.BalanceDisplayModel, "Interface.BalanceDisplayModel");
Sys.ns("Interface");
Interface.BalanceDisplayController = {
	constructor: function() {
		Interface.BalanceDisplayController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:balanceDisplay.appendChild": a.appendChild,
			"request:balanceDisplay.addClass": a.view.addClass.bind(a.view),
			"request:balanceDisplay.removeClass": a.view.removeClass.bind(a.view)
		})
	},
	appendChild: function(a) {
		this.view.addChild(a)
	}
};
Interface.BalanceDisplayController = Sys.extend(Core.Controller, Interface.BalanceDisplayController, "Interface.BalanceDisplayController");
Sys.ns("Interface");
Interface.BalanceDisplayBaseView = {
	BASE_CSS: "interface-balanceDisplay_base",
	PORTRAIT_CSS: "interface-balanceDisplay_portrait",
	LANDSCAPE_CSS: "interface-balanceDisplay_landscape",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.BalanceDisplayBaseView.superclass.constructor.apply(this, arguments)
	},
	adaptToOrientation: function(a) {
		this.setStyle(a)
	},
	init: function() {
		this.constructDOMElement()
	},
	constructDOMElement: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "gameFooter",
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET
		})
	},
	addClass: function(a) {
		this.container.addCls(a)
	},
	removeClass: function(a) {
		this.container.removeCls(a)
	},
	addChild: function(b) {
		var a = this;
		a.container.add(b)
	}
};
Interface.BalanceDisplayBaseView = Sys.extend(Core.View, Interface.BalanceDisplayBaseView, "Interface.BalanceDisplayBaseView");
Sys.ns("interface");
Interface.BalanceDisplayMobileView = {
	PORTRAIT_CSS: "interface-balanceDisplay_portrait_mobile",
	LANDSCAPE_CSS: "interface-balanceDisplay_landscape_mobile",
	constructor: function() {
		Interface.BalanceDisplayMobileView.superclass.constructor.apply(this, arguments)
	}
};
Interface.BalanceDisplayMobileView = Sys.extend(Interface.BalanceDisplayBaseView, Interface.BalanceDisplayMobileView, "Interface.BalanceDisplayMobileView");
Sys.ns("Interface");
Interface.BalanceDisplayDesktopView = {
	LANDSCAPE_CSS: "interface-balanceDisplay_landscape_desktop",
	constructor: function() {
		Interface.BalanceDisplayDesktopView.superclass.constructor.apply(this, arguments)
	}
};
Interface.BalanceDisplayDesktopView = Sys.extend(Interface.BalanceDisplayBaseView, Interface.BalanceDisplayDesktopView, "Interface.BalanceDisplayDesktopView");
Sys.ns("Interface");
Interface.SystemClock = {
	constructor: function() {
		Interface.SystemClock.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.SystemClockController,
			model: Interface.SystemClockModel,
			view: Interface.SystemClockBaseView
		}
	}
};
Interface.SystemClock = Sys.extend(Core.Module, Interface.SystemClock, "Interface.SystemClock");
Sys.ns("Interface");
Interface.SystemClockController = {
	constructor: function() {
		Interface.SystemClockController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:systemClock.enableInMode": a.view.show.bind(a.view),
			"request:systemClock.show": a.view.show.bind(a.view),
			"request:systemClock.hide": a.view.show.bind(a.hide)
		})
	}
};
Interface.SystemClockController = Sys.extend(Core.Controller, Interface.SystemClockController, "Interface.SystemClockController");
Sys.ns("Interface");
Interface.SystemClockModel = {
	constructor: function() {
		Interface.SystemClockModel.superclass.constructor.apply(this, arguments)
	},
	getTime: function() {
		var a = new Date();
		return {
			hours: a.getHours(),
			minutes: a.getMinutes()
		}
	}
};
Interface.SystemClockModel = Sys.extend(Core.Model, Interface.SystemClockModel, "Interface.SystemClockModel");
Sys.ns("Interface");
Interface.SystemClockBaseView = {
	BASE_CSS: "interface-systemClock_base",
	PORTRAIT_POSITION: {
		ABOVE_GAME: true,
		TOP: 0.05,
		LEFT: 0.5
	},
	LANDSCAPE_POSITION: {
		BOTTOM: 0,
		LEFT: 0.055
	},
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.SystemClockBaseView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Interface.SystemClockBaseView.superclass.init.apply(a, arguments);
		a.container = new Sys.Element({
			id: "systemClock",
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET,
			style: "display:none;"
		});
		a.hours = document.createElement("span");
		a.container.el.appendChild(a.hours);
		a.colon = document.createElement("span");
		a.colon.textContent = ":";
		a.container.el.appendChild(a.colon);
		a.minutes = document.createElement("span");
		a.container.el.appendChild(a.minutes);
		a.showColon = true
	},
	updateTime: function() {
		var c = this,
			d = c.model.getTime(),
			a = d.hours,
			b = d.minutes;
		if (a < 10) {
			a = "0" + a
		}
		if (b < 10) {
			b = "0" + b
		}
		c.hours.textContent = a;
		c.minutes.textContent = b;
		c.colon.style.visibility = c.showColon ? "visible" : "hidden";
		c.showColon = !c.showColon;
		c.ticker = setTimeout(function() {
			c.updateTime()
		}, 1000)
	},
	show: function() {
		this.container.el.style.display = "block";
		this.updateTime()
	},
	hide: function() {
		this.container.el.style.display = "none";
		clearTimeout(this.ticker)
	}
};
Interface.SystemClockBaseView = Sys.extend(Core.View, Interface.SystemClockBaseView, "Interface.SystemClockBaseView");
Sys.ns("Interface");
Interface.SystemClockTabletView = {
	PORTRAIT_POSITION: {
		BOTTOM: 0,
		LEFT: 0.055
	},
	constructor: function() {
		Interface.SystemClockTabletView.superclass.constructor.apply(this, arguments)
	}
};
Interface.SystemClockTabletView = Sys.extend(Interface.SystemClockBaseView, Interface.SystemClockTabletView, "Interface.SystemClockTabletView");
Sys.ns("Interface");
Interface.SystemClockDesktopView = {
	PORTRAIT_POSITION: undefined,
	LANDSCAPE_POSITION: undefined,
	constructor: function() {
		Interface.SystemClockDesktopView.superclass.constructor.apply(this, arguments)
	}
};
Interface.SystemClockDesktopView = Sys.extend(Interface.SystemClockBaseView, Interface.SystemClockDesktopView, "Interface.SystemClockDesktopView");
Sys.ns("Interface");
Interface.NetEntLogo = {
	constructor: function() {
		Interface.NetEntLogo.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.NetEntLogoController,
			view: Interface.NetEntLogoBaseView
		}
	}
};
Interface.NetEntLogo = Sys.extend(Core.Module, Interface.NetEntLogo, "Interface.NetEntLogo");
Sys.ns("Interface");
Interface.NetEntLogoController = {
	constructor: function() {
		Interface.NetEntLogoController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:netEntLogo.show": a.view.show.bind(a.view),
			"request:netEntLogo.hide": a.view.hide.bind(a.view)
		})
	}
};
Interface.NetEntLogoController = Sys.extend(Core.Controller, Interface.NetEntLogoController, "Interface.NetEntLogoController");
Sys.ns("Interface");
Interface.NetEntLogoBaseView = {
	BASE_CSS: "interface-netEntLogo_base interface-netEntLogo_uri",
	PORTRAIT_POSITION: {
		BELOW_GAME: true,
		BOTTOM: 0.01,
		LEFT: 0.5
	},
	LANDSCAPE_POSITION: {
		BOTTOM: 0,
		RIGHT: 0.04
	},
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		Interface.NetEntLogoBaseView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var a = this;
		Interface.NetEntLogoBaseView.superclass.init.apply(a, arguments);
		a.hidden = false;
		a.container = new Sys.Element({
			id: "netEntLogo",
			tag: "div",
			cls: a.BASE_CSS,
			renderTo: a.RENDER_TARGET
		})
	},
	show: function() {
		this.container.el.style.display = "block"
	},
	hide: function() {
		this.container.el.style.display = "none"
	}
};
Interface.NetEntLogoBaseView = Sys.extend(Core.View, Interface.NetEntLogoBaseView, "Interface.NetEntLogoBaseView");
Sys.ns("Interface");
Interface.NetEntLogoFullscreenCanvasView = {
	PORTRAIT_POSITION: {
		BOTTOM: 0.15,
		LEFT: 0.5
	},
	constructor: function() {
		Interface.NetEntLogoFullscreenCanvasView.superclass.constructor.apply(this, arguments)
	}
};
Interface.NetEntLogoFullscreenCanvasView = Sys.extend(Interface.NetEntLogoBaseView, Interface.NetEntLogoFullscreenCanvasView, "Interface.NetEntLogoFullscreenCanvasView");
Sys.ns("Interface");
Interface.QuickSettingsMenu = {
	constructor: function() {
		Interface.QuickSettingsMenu.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Interface.QuickSettingsMenuController,
			model: Interface.QuickSettingsMenuModel,
			view: Interface.QuickSettingsMenuBaseView
		}
	},
	getMixinDependencies: function() {
		return [{
			userInput: {
				listenToUserInput: true
			}
		}, "orientation", "properties"]
	}
};
Interface.QuickSettingsMenu = Sys.extend(Core.Module, Interface.QuickSettingsMenu, "Interface.QuickSettingsMenu");
Sys.ns("Interface");
Interface.QuickSettingsMenuController = {
	constructor: function() {
		Interface.QuickSettingsMenuController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.eventToUseWhenActive = {
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onLeavingBeforeLoaderCloseState,
			"notify:stateHandler.enteringIdleState": a.onEnteringIdleState.bind(a, true),
			"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
			"notify:spinButton.shown": a.show,
			"notify:spinButton.hidden": a.hide,
			"notify:spinButton.pressed": a.onSpinButtonPress,
			"notify:spinButton.released": a.onSpinButtonRelease.bind(a, true),
			"notify:settingsManager.settingChanged": a.onSettingsChanged
		};
		a.on({
			"request:quickSettingsMenu.addChild": a.addChild,
			"request:quickSettingsMenu.removeChild": a.removeChild,
			"request:quickSettingsMenu.externalActivate": a.onExternalActivate,
			"request:quickSettingsMenu.externalDeactivate": a.onExternalDeactivate,
			"request:quickSettingsMenu.movePosition": a.onMovePositionRequest,
			"request:quickSettingsMenu.removeAndDisableSetting": a.onRemoveAndDisableSetting,
			"notify:autoPlayer.starting": a.onExternalDeactivate.bind(a, "autoplay"),
			"notify:autoPlayer.stopped": a.onExternalActivate.bind(a, "autoplay")
		});
		a.on(a.eventToUseWhenActive)
	},
	onMovePositionRequest: function(a) {
		this.view.moveSettingPosition(a)
	},
	onLeavingBeforeLoaderCloseState: function() {
		this.model.storeData("activated", false);
		this.view.deactivate()
	},
	disableMenu: function() {
		var d = this,
			c = d.eventToUseWhenActive,
			e = Object.keys(c),
			b = e.length,
			a;
		for (a = -1; ++a < b;) {
			d.removeListener(e[a])
		}
		d.model.storeData("activated", false);
		d.hide()
	},
	enableMenu: function() {
		var a = this;
		if (!a.model.readData("activated")) {
			a.on(a.eventToUseWhenActive);
			a.model.storeData("activated", true);
			a.show()
		}
	},
	getChildCount: function() {
		return Object.keys(this.view.children).length
	},
	addChild: function(c, a) {
		var b = this;
		b.view.addChild(c, a);
		if (b.getChildCount() > 0) {
			b.enableMenu()
		}
	},
	removeChild: function(e, b) {
		var c = this,
			d = c.getChildCount(),
			a;
		c.view.removeChild(e, b);
		a = c.getChildCount();
		if (d !== a && a <= 0) {
			c.disableMenu()
		}
	},
	onExternalDeactivate: function(a) {
		this.addProperty("externalDeactivated", a);
		this.hide()
	},
	onExternalActivate: function(b) {
		var a = this;
		a.removeProperty("externalDeactivated", b);
		if (a.model.readData("status") !== "open") {
			a.show(true)
		}
	},
	onSpinButtonPress: function() {
		if (this.model.readData("activated")) {
			this.hide()
		}
	},
	onSpinButtonRelease: function(a) {
		if (this.model.readData("activated")) {
			this.show(a)
		}
	},
	onEnteringIdleState: function(a) {
		if (this.getChildCount() === 0) {
			this.disableMenu();
			return
		}
		this.model.storeData("activated", true);
		this.show(a)
	},
	onLeavingIdleState: function() {
		this.model.storeData("activated", false);
		this.hide()
	},
	hide: function() {
		var a = this;
		a.model.storeData("hidden", true);
		a.view.deactivate();
		if (a.model.readData("status") === "open") {
			a.view.close();
			a.model.storeData("status", "close");
			a.fireEvent("request:spinButton.removeProperty", "visibleOnInput", a.MODULE_NAME)
		}
	},
	show: function(a) {
		var b = this;
		if (!b.model.hasProperty("externalDeactivated")) {
			b.model.storeData("hidden", false);
			if (b.model.readData("activated")) {
				b.view.activate(a)
			}
		}
	},
	onUserInputStart: function(a) {
		if (this.view.isInputTarget(a) && this.model.readData("activated")) {
			this.model.storeData("activeInputTarget", true)
		}
	},
	onUserInputMove: function(a) {},
	onUserInputEnd: function(c) {
		var b = this,
			a = b.model.readData("status");
		if (a === "open" && (b.view.isInputTarget(c) || !b.view.isContainer(c))) {
			b.view.close();
			b.model.storeData("status", "close");
			b.fireEvent("request:spinButton.removeProperty", "visibleOnInput", b.MODULE_NAME)
		} else {
			if (b.view.isInputTarget(c) && b.model.readData("activeInputTarget")) {
				b.view.open();
				b.model.storeData("status", "open");
				b.fireEvent("notify:quickSettingsMenu." + b.model.readState);
				b.fireEvent("request:spinButton.addProperty", "visibleOnInput", b.MODULE_NAME)
			}
		}
		b.model.storeData("activeInputTarget", false)
	},
	onSettingsChanged: function(a, b) {
		if (a === "leftHandMode") {
			this.view.positionMenu(b)
		}
	},
	onRemoveAndDisableSetting: function(a) {
		this.view.removeAndDisableSetting(a)
	}
};
Interface.QuickSettingsMenuController = Sys.extend(Core.Controller, Interface.QuickSettingsMenuController, "Interface.QuickSettingsMenuController");
Sys.ns("Interface");
Interface.QuickSettingsMenuModel = {
	PROPERTIES: {
		externalDeactivated: []
	},
	constructor: function() {
		Interface.QuickSettingsMenuModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Services.localStorageManager.hasData("leftHandMode") && Services.localStorageManager.readData("leftHandMode") === "true";
		b.storeData("children", {});
		b.storeData("disableDuringSpin", []);
		b.storeData("status", "close");
		b.storeData("leftHandMode", a)
	}
};
Interface.QuickSettingsMenuModel = Sys.extend(Core.Model, Interface.QuickSettingsMenuModel, "Interface.QuickSettingsMenuModel");
Sys.ns("Interface");
Interface.QuickSettingsMenuBaseView = {
	BASE_CSS: "interface-quickSettingsMenu_base",
	PORTRAIT_CSS: "interface-quickSettingsMenu_portrait",
	LANDSCAPE_CSS: "interface-quickSettingsMenu_landscape",
	LANDSCAPE_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
	PORTRAIT_BG_URI: "interface-quickSettingsMenu_sliderBg_portrait_uri",
	LANDSCAPE_FRONT_CSS: "interface-quickSettingsMenu_front_landscape",
	PORTRAIT_FRONT_CSS: "interface-quickSettingsMenu_front_portrait",
	LANDSCAPE_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
	PORTRAIT_BACK_CSS: "interface-quickSettingsMenu_back_portrait",
	SLIDER_BUTTON_URI: "interface-quickSettingsMenu_sliderButton_uri",
	ICON_BASE_CSS: "interface-quickSettingsMenu_icon_base",
	LANDSCAPE_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
	PORTRAIT_ICON_CSS: "interface-quickSettingsMenu_icon_portrait",
	ICON_CLOSE_CSS: "interface-quickSettingsMenu_icon_close",
	ICON_OPEN_CSS: "interface-quickSettingsMenu_icon_open",
	ICON_URI: "interface-quickSettingsMenu_icon_uri",
	BASE_SLIDE_CSS: "interface-quickSettingsMenu_portraitSlide",
	LANDSCAPE_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
	PORTRAIT_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_portrait",
	AUTOPLAY_SLIDE_CLOSE: "interface-quickSettingsMenu_autoPlaySlide_close",
	AUTOPLAY_SLIDE_OPEN: "interface-quickSettingsMenu_autoPlaySlide_open",
	LANDSCAPE_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
	PORTRAIT_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_portrait",
	QUICKSPIN_SLIDE_CLOSE: "interface-quickSettingsMenu_quickSpinSlide_close",
	QUICKSPIN_SLIDE_OPEN: "interface-quickSettingsMenu_quickSpinSlide_open",
	BASE_CHILDREN_CSS: "interface-quickSettingsMenu_children_base",
	LANDSCAPE_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
	PORTRAIT_CHILDREN_CSS: "interface-quickSettingsMenu_children_portrait_base",
	CHILD_CSS: "interface-quickSettingsMenu_child_base",
	PORTRAIT_CHILD_CSS: "interface-quickSettingsMenu_child_portrait",
	LANDSCAPE_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
	HANDLE_CSS: "interface-quickSettingsMenu_handle",
	LANDSCAPE_HANDLE_CSS: {
		open: "interface-quickSettingsMenu_handle_open_landscape",
		close: "interface-quickSettingsMenu_handle_close_landscape"
	},
	PORTRAIT_HANDLE_CSS: {
		open: "interface-quickSettingsMenu_handle_portrait",
		close: "interface-quickSettingsMenu_handle_portrait"
	},
	MENU_LEFT_SIDE_CSS: "interface-quickSettingsMenu_left",
	HANDLE_LEFT_SIDE_CSS: "interface-quickSettingsMenu_handle_left",
	PORTRAIT_POSITION: {
		BELOW_GAME: true,
		TOP: 0.4,
		MIN_TOP: 825,
		LEFT: 0.3994
	},
	PORTRAIT_SIZE: {
		HEIGHT: 0.55,
		WIDTH: 0.28
	},
	LANDSCAPE_CLOSEDSIZE: "0.00rem",
	LANDSCAPE_FRONTSTARTPOS: "-0.64rem",
	LANDSCAPE_FRONTENDPOS: "-0.24rem",
	LANDSAPE_BACKSTARTPOS: "0.00rem",
	LANDSCAPE_BACKENDPOS: "0.50rem",
	LANDSCAPE_OPENSIZE: "2.70rem",
	RENDER_TARGET: "gameWrapper",
	PIXEL_FACTOR: 0.01,
	constructor: function() {
		Interface.QuickSettingsMenuBaseView.superclass.constructor.apply(this, arguments)
	},
	moveSettingPosition: function(a) {
		var b = this;
		if (Sys.isDefined(a)) {
			if (Sys.isString(a.orientation) && a.orientation.toLowerCase() === "portrait") {
				if (Sys.isDefined(a.vertical)) {
					b.PORTRAIT_POSITION.TOP = b.PORTRAIT_POSITION.TOP + a.vertical
				}
				if (Environment.getViewportOrientation() === "LANDSCAPE") {
					b.onLandscape()
				} else {
					b.onPortrait()
				}
			}
		}
	},
	open: function() {
		var b = this,
			a = Environment.getViewportOrientation();
		b["open" + a](a);
		b.icon.replaceCSSClass(b.ICON_CLOSE_CSS, b.ICON_OPEN_CSS)
	},
	openLANDSCAPE: function() {
		var d = this,
			a = d.model.readData("status"),
			c = d.getNewStatus(a),
			e = d.LANDSCAPE_HANDLE_CSS,
			b = d.animations.LANDSCAPE;
		d.back.el.style.display = "block";
		d.childrenContainer.el.style.display = "block";
		if (a !== c) {
			d.handle.replaceCSSClass(e[a], e[c])
		}
		Sys.iterate(d.children, function(f) {
			b.openChild.run(d.children[f].el)
		});
		b.open.run(d.container.el);
		b.openFront.run(d.front.el);
		b.openBack.run(d.back.el);
		if (Sys.isIphone4Or4s) {
			d.container.el.style.display = "none";
			d.container.el.style.display = "block"
		}
	},
	openPORTRAIT: function() {
		var a = this;
		a.childrenContainer.el.style.display = "none";
		a.front.el.style.left = "";
		Sys.iterate(a.children, function(b) {
			a.children[b].el.style.opacity = 1
		});
		a.autoPlaySlide.replaceCSSClass(a.AUTOPLAY_SLIDE_CLOSE, a.AUTOPLAY_SLIDE_OPEN);
		a.quickSpinSlide.replaceCSSClass(a.QUICKSPIN_SLIDE_CLOSE, a.QUICKSPIN_SLIDE_OPEN)
	},
	getNewStatus: function(a) {
		if (Environment.getViewportOrientation() === this.currentOrientation) {
			return (a === "close") ? "open" : "close"
		}
		return a
	},
	close: function() {
		var b = this,
			a = Environment.getViewportOrientation();
		b["close" + a](a);
		b.icon.replaceCSSClass(b.ICON_OPEN_CSS, b.ICON_CLOSE_CSS)
	},
	closeLANDSCAPE: function() {
		var d = this,
			a = d.model.readData("status"),
			c = (a === "close") ? "open" : "close",
			b = d.animations.LANDSCAPE;
		d.handle.replaceCSSClass(d.LANDSCAPE_HANDLE_CSS[a], d.LANDSCAPE_HANDLE_CSS[c]);
		Sys.iterate(d.children, function(e) {
			b.closeChild.run(d.children[e].el)
		});
		b.close.run(d.container.el);
		b.closeFront.run(d.front.el);
		b.closeBack.run(d.back.el);
		if (Sys.isIphone4Or4s) {
			d.container.el.style.display = "none";
			d.container.el.style.display = "block"
		}
	},
	closePORTRAIT: function() {
		var a = this;
		a.autoPlaySlide.replaceCSSClass(a.AUTOPLAY_SLIDE_OPEN, a.AUTOPLAY_SLIDE_CLOSE);
		a.quickSpinSlide.replaceCSSClass(a.QUICKSPIN_SLIDE_OPEN, a.QUICKSPIN_SLIDE_CLOSE)
	},
	activate: function(c) {
		var b = this,
			a = Environment.getViewportOrientation();
		if (b.model.readData("hidden")) {
			return
		}
		if (!b.model.readData("animationReady")) {
			b.setupAnimations()
		}
		b.container.el.style.display = "block";
		b.childrenContainer.el.style.display = "none";
		b.back.el.style.display = "none";
		b.handle.el.style.display = "block";
		if (c) {
			b.animations[a].activate.run(b.container.el)
		}
	},
	deactivate: function() {
		var b = this,
			a = Sys.utils.pollyFill("animation");
		b.childrenContainer.el.style.display = "none";
		b.handle.el.style.display = "none";
		b.container.el.style.display = "none";
		b.container.el.style[a] = "none";
		b.front.el.style[a] = "none"
	},
	isInputTarget: function(a) {
		return Sys.UserInputUtils.isCoordinateTarget(this.handle.el, a)
	},
	isContainer: function(a) {
		return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
	},
	init: function() {
		var a = this;
		Interface.QuickSettingsMenuBaseView.superclass.init.apply(a, arguments);
		a.setupDOMStructure();
		a.children = {}
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"model:childAdded": a.addChild,
			"model:childRemoved": a.removeChild,
			"model:childActivated": a.activateChild,
			"model:childDeactivated": a.deactivateChild
		})
	},
	addChild: function(e, b) {
		var d = this,
			a = Environment.getViewportOrientation(),
			c = b.content;
		c.addCls(d.CHILD_CSS);
		c.addCls(d[a + "_CHILD_CSS"]);
		d.append(e, c, a);
		d.children[e] = c
	},
	append: function(d, c, a) {
		var b = this;
		if (a === "LANDSCAPE") {
			b.childrenContainer.add(c)
		} else {
			if (d === "autoPlayButton") {
				b.autoPlaySlide.add(c)
			} else {
				if (d === "quickSpinButton") {
					b.quickSpinSlide.add(c)
				}
			}
		}
	},
	removeChild: function(d, b) {
		var c = this,
			a = Environment.getViewportOrientation();
		if (a === "LANDSCAPE") {
			c.childrenContainer.remove(b.content)
		} else {
			if (d === "autoPlayButton") {
				c.autoPlaySlide.remove(b.content)
			} else {
				if (d === "quickSpinButton") {
					c.quickSpinSlide.remove(b.content)
				}
			}
		}
		delete c.children[d]
	},
	onPortrait: function() {
		var d = this,
			b = d.model.readData("status"),
			c = Sys.utils.pollyFill("animation"),
			a = Sys.isDefined(d.animations) && d.model.readData("activated");
		if (Environment.getViewportOrientation() !== this.currentOrientation) {
			d.adaptToOrientation("PORTRAIT");
			if (a) {
				d.container.el.style[c] = "none";
				d.animations.PORTRAIT.activate.run(d.container.el)
			}
			Sys.iterate(d.children, function(e) {
				d.children[e].el.style[c] = "none"
			});
			d[b + "PORTRAIT"]();
			d.currentOrientation = "PORTRAIT"
		}
		d.front.el.style.left = "";
		d.setPosition("PORTRAIT");
		d.container.el.style.top = (Sys.utils.toInt(d.container.el.style.top) + 70) * d.PIXEL_FACTOR + "rem";
		d.setHandlePostion()
	},
	onLandscape: function() {
		var d = this,
			b = d.model.readData("status"),
			c = Sys.utils.pollyFill("animation"),
			a = Sys.isDefined(d.animations) && d.model.readData("activated");
		if (Environment.getViewportOrientation() !== this.currentOrientation) {
			d.adaptToOrientation("LANDSCAPE");
			if (a) {
				d.container.el.style[c] = "none";
				if (b === "close") {
					d.animations.LANDSCAPE.activate.run(d.container.el);
					d.back.el.style.display = "none"
				} else {
					d.childrenContainer.el.style.display = "block";
					d.open()
				}
				d.animations.LANDSCAPE[b + "Front"].run(d.front.el);
				d.animations.LANDSCAPE[b + "Back"].run(d.back.el)
			}
			this.currentOrientation = "LANDSCAPE"
		}
	},
	adaptToOrientation: function(b) {
		var d = this,
			c = (b === "LANDSCAPE") ? "PORTRAIT" : "LANDSCAPE",
			a = d.model.readData("status");
		d.setStyle(b);
		d.resetPosition();
		Sys.iterate(d.updateOnOrientation, function(e, f) {
			d[e].replaceCSSClass(d[c + f], d[b + f])
		});
		d.handle.replaceCSSClass(d[c + "_HANDLE_CSS"][a], d[b + "_HANDLE_CSS"][a]);
		d.moveChildren(d[c + "_CHILD_CSS"], d[b + "_CHILD_CSS"], b);
		if (d.model.readData("activated") === true) {
			d.activate()
		} else {
			d.deactivate()
		}
	},
	setHandlePostion: function() {
		var b = this,
			a = b.handle.el.style,
			c = b.container.el.style;
		a.top = c.top;
		a.bottom = c.bottom;
		a.left = c.left;
		a.right = c.right
	},
	moveChildren: function(c, d, a) {
		var b = this;
		Sys.iterate(b.children, function(e) {
			b.children[e].replaceCSSClass(c, d);
			if (a === "LANDSCAPE") {
				b.childrenContainer.add(b.children[e])
			} else {
				if (e === "autoPlayButton") {
					b.autoPlaySlide.add(b.children[e])
				} else {
					if (e === "quickSpinButton") {
						b.quickSpinSlide.add(b.children[e])
					}
				}
			}
		})
	},
	resetPosition: function() {
		var e = this,
			f = e.container.el.style,
			a = e.handle.el.style,
			d = e.front.el.style,
			c = Sys.utils.pollyFill("animation"),
			g = ["top", "left", "bottom", "right", "width", "height", "opacity"],
			b;
		f[c] = "none";
		d[c] = "none";
		for (b = -1; ++b < g.length;) {
			f[g[b]] = "";
			a[g[b]] = ""
		}
	},
	setupDOMStructure: function() {
		var b = this,
			a = Environment.getViewportOrientation();
		b.container = new Sys.Element({
			tag: "div",
			cls: b.BASE_CSS + " " + b.LANDSCAPE_BG_URI,
			renderTo: b.RENDER_TARGET
		});
		b.handle = new Sys.Element({
			tag: "div",
			cls: b.HANDLE_CSS + " " + b[a + "_HANDLE_CSS"].close,
			renderTo: b.RENDER_TARGET
		});
		b.front = new Sys.Element({
			tag: "div",
			cls: b[a + "_FRONT_CSS"] + " " + b.SLIDER_BUTTON_URI
		});
		b.back = new Sys.Element({
			tag: "div",
			cls: b[a + "_BACK_CSS"] + " " + b.LANDSCAPE_BG_URI
		});
		b.icon = new Sys.Element({
			tag: "div",
			cls: b.ICON_BASE_CSS + " " + b[a + "_ICON_CSS"] + " " + b.ICON_CLOSE_CSS + " " + b.ICON_URI
		});
		b.childrenContainer = new Sys.Element({
			tag: "div",
			cls: b.BASE_CHILDREN_CSS + " " + b[a + "_CHILDREN_CSS"]
		});
		b.autoPlaySlide = new Sys.Element({
			tag: "div",
			cls: b.BASE_SLIDE_CSS + " " + b[a + "_AUTOPLAY_SLIDE_CSS"] + " " + b.AUTOPLAY_SLIDE_CLOSE + " " + b.PORTRAIT_BG_URI
		});
		b.quickSpinSlide = new Sys.Element({
			tag: "div",
			cls: b.BASE_SLIDE_CSS + " " + b[a + "_QUICKSPIN_SLIDE_CSS"] + " " + b.QUICKSPIN_SLIDE_CLOSE + " " + b.PORTRAIT_BG_URI
		});
		b.updateOnOrientation = {
			front: "_FRONT_CSS",
			back: "_BACK_CSS",
			icon: "_ICON_CSS",
			autoPlaySlide: "_AUTOPLAY_SLIDE_CSS",
			quickSpinSlide: "_QUICKSPIN_SLIDE_CSS",
			childrenContainer: "_CHILDREN_CSS"
		};
		b.container.add(b.front);
		b.front.add(b.icon);
		b.container.add(b.back);
		b.container.add(b.childrenContainer);
		b.container.add(b.autoPlaySlide);
		b.container.add(b.quickSpinSlide);
		b.positionMenu(b.model.readData("leftHandMode"))
	},
	setupAnimations: function() {
		var a = this;
		a.animations = {};
		a.setupLandscapeAnimations();
		a.setupPortraitAnimation();
		a.model.storeData("animationReady", true)
	},
	setupLandscapeAnimations: function() {
		var m = this,
			h = m.LANDSCAPE_CLOSEDSIZE,
			k = m.LANDSCAPE_FRONTSTARTPOS,
			d = m.LANDSCAPE_FRONTENDPOS,
			o = m.LANDSAPE_BACKSTARTPOS,
			l = m.LANDSCAPE_BACKENDPOS,
			g = m.LANDSCAPE_OPENSIZE,
			f = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_openFrontLandscape",
				frames: {
					"0%": {
						left: k
					},
					"100%": {
						left: d
					}
				},
				duration: 50,
				delay: 4,
				fillMode: "both"
			}),
			p = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_closeFrontLandscape",
				frames: {
					"0%": {
						left: d
					},
					"100%": {
						left: k
					}
				},
				duration: 124,
				delay: 126,
				fillMode: "both"
			}),
			c = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_openBackLandscape",
				frames: {
					"0%": {
						width: o
					},
					"100%": {
						width: l
					}
				},
				duration: 5,
				delay: 45,
				fillMode: "both"
			}),
			e = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_closeBackLandscape",
				frames: {
					"0%": {
						width: l
					},
					"100%": {
						width: o
					}
				},
				duration: 20,
				delay: 109,
				fillMode: "both"
			}),
			q = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_openAnimationLandscape",
				frames: {
					"0%": {
						width: h
					},
					"100%": {
						width: g
					}
				},
				duration: 250,
				fillMode: "both"
			}),
			n = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_closeAnimationLandscape",
				frames: {
					"0%": {
						width: g
					},
					"100%": {
						width: h
					}
				},
				duration: 250,
				fillMode: "both"
			}),
			j = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_activateLandscape",
				frames: {
					"0%": {
						width: "0.00rem"
					},
					"100%": {
						width: h
					}
				},
				duration: 100,
				fillMode: "both"
			}),
			a = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_itemInLandscape",
				frames: {
					"0%": {
						opacity: 0,
						visibility: "visible"
					},
					"100%": {
						opacity: 1
					}
				},
				duration: 150,
				delay: 200,
				fillMode: "both"
			}),
			b = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_itemOutLandscape",
				frames: {
					"0%": {
						opacity: 1
					},
					"100%": {
						opacity: 0,
						visibility: "hidden"
					}
				},
				duration: 50,
				fillMode: "both"
			});
		m.animations.LANDSCAPE = {
			open: q,
			close: n,
			openChild: a,
			closeChild: b,
			activate: j,
			openFront: f,
			closeFront: p,
			openBack: c,
			closeBack: e
		}
	},
	setupPortraitAnimation: function() {
		var a = this,
			b = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_activatePortrait",
				frames: {
					"0%": {
						height: "0.00rem"
					},
					"100%": {
						height: "1.60rem"
					}
				},
				duration: 200,
				fillMode: "both"
			});
		a.animations.PORTRAIT = {
			activate: b
		}
	},
	positionMenu: function(b) {
		var c = this,
			d = c.handle,
			a = c.container;
		if (b) {
			d.addCSSClass(c.HANDLE_LEFT_SIDE_CSS);
			a.addCSSClass(c.MENU_LEFT_SIDE_CSS)
		} else {
			d.removeCSSClass(c.HANDLE_LEFT_SIDE_CSS);
			a.removeCSSClass(c.MENU_LEFT_SIDE_CSS)
		}
	},
	removeSettingSlide: function(a) {
		this.container.remove(a)
	},
	removeAndDisableSetting: function(a) {
		var b = this;
		a += "Slide";
		if (b.hasOwnProperty(a)) {
			b.removeSettingSlide(b[a])
		}
	}
};
Interface.QuickSettingsMenuBaseView = Sys.extend(Core.View, Interface.QuickSettingsMenuBaseView, "Interface.QuickSettingsMenuBaseView");
Sys.ns("Interface");
Interface.QuickSettingsMenuTabletView = {
	BASE_CSS: "interface-quickSettingsMenu_base",
	PORTRAIT_CSS: "interface-quickSettingsMenu_landscape",
	LANDSCAPE_CSS: "interface-quickSettingsMenu_landscape_tablet",
	LANDSCAPE_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
	PORTRAIT_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
	LANDSCAPE_FRONT_CSS: "interface-quickSettingsMenu_front_landscape_tablet",
	PORTRAIT_FRONT_CSS: "interface-quickSettingsMenu_front_landscape",
	LANDSCAPE_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
	PORTRAIT_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
	HANDLE_CSS: "interface-quickSettingsMenu_handle",
	SLIDER_BUTTON_URI: "interface-quickSettingsMenu_sliderButton_uri",
	ICON_BASE_CSS: "interface-quickSettingsMenu_icon_base",
	LANDSCAPE_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
	PORTRAIT_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
	ICON_CLOSE_CSS: "interface-quickSettingsMenu_icon_close",
	ICON_OPEN_CSS: "interface-quickSettingsMenu_icon_open",
	ICON_URI: "interface-quickSettingsMenu_icon_uri",
	BASE_SLIDE_CSS: "interface-quickSettingsMenu_portraitSlide",
	LANDSCAPE_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
	PORTRAIT_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
	AUTOPLAY_SLIDE_CLOSE: "interface-quickSettingsMenu_autoPlaySlide_close",
	AUTOPLAY_SLIDE_OPEN: "interface-quickSettingsMenu_autoPlaySlide_open",
	LANDSCAPE_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
	PORTRAIT_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
	QUICKSPIN_SLIDE_CLOSE: "interface-quickSettingsMenu_quickSpinSlide_close",
	QUICKSPIN_SLIDE_OPEN: "interface-quickSettingsMenu_quickSpinSlide_open",
	BASE_CHILDREN_CSS: "interface-quickSettingsMenu_children_base",
	LANDSCAPE_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
	PORTRAIT_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
	CHILD_CSS: "interface-quickSettingsMenu_child_base",
	PORTRAIT_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
	LANDSCAPE_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
	LANDSCAPE_HANDLE_CSS: {
		open: "interface-quickSettingsMenu_handle_open_landscape_tablet",
		close: "interface-quickSettingsMenu_handle_close_landscape"
	},
	PORTRAIT_HANDLE_CSS: {
		open: "interface-quickSettingsMenu_handle_open_landscape",
		close: "interface-quickSettingsMenu_handle_close_landscape"
	},
	LANDSCAPE_FRONTSTARTPOS: "-1.06rem",
	LANDSAPE_BACKSTARTPOS: "-0.40rem",
	moveChildren: function() {},
	append: function(c, b) {
		var a = this;
		a.childrenContainer.add(b)
	},
	updateStyle: function() {
		var a = this;
		a.resetPosition()
	},
	setHandlePostion: function() {},
	openPORTRAIT: function() {
		var c = this,
			a = c.model.readData("status"),
			b = c.getNewStatus(a);
		c.back.el.style.display = "block";
		c.childrenContainer.el.style.display = "block";
		Sys.iterate(c.children, function(d) {
			c.animations.PORTRAIT.openChild.run(c.children[d].el)
		});
		c.handle.replaceCSSClass(c.PORTRAIT_HANDLE_CSS[a], c.PORTRAIT_HANDLE_CSS[b]);
		c.animations.PORTRAIT.open.run(c.container.el);
		c.animations.PORTRAIT.openFront.run(c.front.el);
		c.animations.PORTRAIT.openBack.run(c.back.el)
	},
	closePORTRAIT: function(c) {
		var d = this,
			a = d.model.readData("status"),
			b = (a === "close") ? "open" : "close";
		Sys.iterate(d.children, function(e) {
			d.animations.PORTRAIT.closeChild.run(d.children[e].el)
		});
		d.handle.replaceCSSClass(d.PORTRAIT_HANDLE_CSS[a], d.PORTRAIT_HANDLE_CSS[b]);
		d.animations[c].close.run(d.container.el);
		d.animations[c].closeFront.run(d.front.el);
		d.animations[c].closeBack.run(d.back.el)
	},
	onPortrait: function() {
		var d = this,
			b = d.model.readData("status"),
			c = Sys.utils.pollyFill("animation"),
			a = Sys.isDefined(d.animations) && d.model.readData("activated");
		if (Environment.getViewportOrientation() !== this.currentOrientation) {
			d.adaptToOrientation("PORTRAIT");
			if (a) {
				d.container.el.style[c] = "none";
				if (b === "close") {
					d.animations.PORTRAIT.activate.run(d.container.el);
					d.back.el.style.display = "none"
				} else {
					d.childrenContainer.el.style.display = "block";
					d.open()
				}
				d.animations.PORTRAIT[b + "Front"].run(d.front.el);
				d.animations.PORTRAIT[b + "Back"].run(d.back.el)
			}
			d.currentOrientation = "PORTRAIT"
		}
	},
	setupPortraitAnimation: function() {
		var j = this,
			f = "0.00rem",
			h = "-0.64rem",
			d = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_openFrontPortrait",
				frames: {
					"0%": {
						left: h
					},
					"100%": {
						left: "-0.24rem"
					}
				},
				duration: 50,
				delay: 4,
				fillMode: "both"
			}),
			l = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_closeFrontPortrait",
				frames: {
					"0%": {
						left: "-0.24rem"
					},
					"100%": {
						left: h
					}
				},
				duration: 124,
				delay: 126,
				fillMode: "both"
			}),
			c = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_openBackPortrait",
				frames: {
					"0%": {
						width: "0.00rem"
					},
					"100%": {
						width: "0.50rem"
					}
				},
				duration: 5,
				delay: 40,
				fillMode: "both"
			}),
			e = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_closeBackPortrait",
				frames: {
					"0%": {
						width: "0.50rem"
					},
					"100%": {
						width: "0.00rem"
					}
				},
				duration: 20,
				delay: 111,
				fillMode: "both"
			}),
			m = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_openAnimationPortrait",
				frames: {
					"0%": {
						width: f
					},
					"100%": {
						width: "2.70rem"
					}
				},
				duration: 250,
				fillMode: "both"
			}),
			k = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_closeAnimationPortrait",
				frames: {
					"0%": {
						width: "2.70rem"
					},
					"100%": {
						width: f
					}
				},
				duration: 250,
				fillMode: "both"
			}),
			g = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_activatePortrait",
				frames: {
					"0%": {
						width: "0.00rem"
					},
					"100%": {
						width: f
					}
				},
				duration: 100,
				fillMode: "both"
			}),
			a = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_itemInPortrait",
				frames: {
					"0%": {
						opacity: 0
					},
					"100%": {
						opacity: 1
					}
				},
				duration: 100,
				delay: 125,
				fillMode: "both"
			}),
			b = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_itemOutLPortrait",
				frames: {
					"0%": {
						opacity: 1
					},
					"100%": {
						opacity: 0
					}
				},
				duration: 50,
				fillMode: "both"
			});
		j.animations.PORTRAIT = {
			open: m,
			close: k,
			openChild: a,
			closeChild: b,
			activate: g,
			openFront: d,
			closeFront: l,
			openBack: c,
			closeBack: e
		}
	}
};
Interface.QuickSettingsMenuTabletView = Sys.extend(Interface.QuickSettingsMenuBaseView, Interface.QuickSettingsMenuTabletView, "Interface.QuickSettingsMenuTabletView");
Sys.ns("Interface");
Interface.QuickSettingsMenuFullscreenCanvasView = {
	PORTRAIT_POSITION: {
		BOTTOM: 0.246,
		MIN_BOTTOM: 100,
		LEFT: 0.3997
	},
	setupPortraitAnimation: function() {
		var a = this,
			b = new Interface.utils.CSSAnimation({
				name: "interface-quickSettingsMenu_activatePortrait",
				frames: {
					"0%": {
						height: "3.20rem"
					},
					"100%": {
						height: "1.60rem"
					}
				},
				duration: 200,
				fillMode: "both"
			});
		a.animations.PORTRAIT = {
			activate: b
		}
	}
};
Interface.QuickSettingsMenuFullscreenCanvasView = Sys.extend(Interface.QuickSettingsMenuBaseView, Interface.QuickSettingsMenuFullscreenCanvasView, "Interface.QuickSettingsMenuFullscreenCanvasView");
Sys.ns("Animation");
Animation.BufferedReelModel = function(a) {
	var b = this;
	Sys.applyProperties(b, a);
	b.slotLength = b.symbolLength + b.symbolSpacing;
	b.visibleSymbolsCount = Math.ceil(b.visibleWindowLength / b.slotLength) + 1;
	if (b.symbolSpacing < 0) {
		b.leadingSymbolsCount = Math.ceil(b.symbolLength / b.slotLength);
		b.visibleSymbolsCount += b.leadingSymbolsCount
	} else {
		b.leadingSymbolsCount = 0
	}
	b.symbolBufferMaxLength = b.calculateSymbolBufferSize();
	b.recalculateStartDuration();
	b.reset()
};
Animation.BufferedReelModel.prototype = {
	calculateSymbolBufferSize: function() {
		var b = this,
			c = 0,
			a;
		for (a = 0; a < b.endBounceSupportPointOffsets.length; a++) {
			c = Math.max(c, Math.abs(b.endBounceSupportPointOffsets[a]))
		}
		if (b.startBounceSupportPointOffset < 0) {
			c = Math.max(c, Math.abs(b.startBounceSupportPointOffset))
		} else {
			if (b.startBounceSupportPointOffset > b.visibleWindowLength) {
				c = Math.max(c, b.startBounceSupportPointOffset - b.visibleWindowLength)
			}
		}
		return b.visibleSymbolsCount + Math.ceil(c / b.slotLength)
	},
	refresh: function(a) {
		var b = this;
		Sys.applyProperties(b, a);
		b.slotLength = b.symbolLength + b.symbolSpacing;
		b.visibleSymbolsCount = Math.ceil(b.visibleWindowLength / b.slotLength) + 1;
		if (b.symbolSpacing < 0) {
			b.leadingSymbolsCount = Math.ceil(b.symbolLength / b.slotLength);
			b.visibleSymbolsCount += b.leadingSymbolsCount
		} else {
			b.leadingSymbolsCount = 0
		}
		b.windowToBufferOffset = b.symbolLength;
		if (b.getState() === "stopping") {
			b.targetOffset = b.getDistanceToStopPosition();
			b.stopDuration = Math.round(b.timeToMoveOneSlot * (b.targetOffset / b.slotLength));
			b.usedDuration = 0
		}
	},
	reset: function() {
		var a = this;
		a.symbolBuffer = [];
		a.targetOffset = 0;
		a.usedDuration = 0;
		a.stopDuration = 0;
		a.startedStoppingAt = null;
		a.spinStartedAt = 0;
		a.currentBounce = a.endBounceSupportPointOffsets.length;
		a.hasCompletedSpin = true;
		a.hasCompletedBounce = true;
		a.outcomeVisibleOnReel = true;
		a.state = "stopping";
		a.moveToInitialPosition()
	},
	moveToInitialPosition: function() {
		var a = this;
		a.windowToBufferOffset = 0;
		a.moveDistance(a.symbolBufferMaxLength * a.slotLength + a.outcomeOffset)
	},
	setInitialOutcome: function(a) {
		var b = this;
		b.moveDistance(b.symbolBufferMaxLength * b.slotLength);
		b.nextOutcomeSymbols = a;
		b.outcomeSymbolsInserted = 0;
		b.moveDistance(b.numberOfOutcomeSymbols * b.slotLength);
		b.moveDistance(b.getDistanceToStopPosition())
	},
	updateOutcome: function(b, c) {
		var a = this.getFirstOutcomeSymbolIndex() + b;
		if (b >= 0 && b < this.numberOfOutcomeSymbols && !isNaN(a) && a >= 0) {
			this.symbolBuffer[a].symbol = c
		}
	},
	setBufferOffset: function(c) {
		var a = this,
			b = Math.round((c - a.windowToBufferOffset) / a.slotLength);
		if (b > 0) {
			a.addSymbolsToBuffer(b, true)
		}
		a.windowToBufferOffset = c
	},
	getFirstOutcomeSymbolIndex: function() {
		var c = this,
			b, a = false;
		for (b = -1; ++b < c.symbolBuffer.length;) {
			if (c.symbolBuffer[b].isOutcomeSymbol) {
				a = true
			} else {
				if (a) {
					return b - c.numberOfOutcomeSymbols
				}
			}
		}
		return NaN
	},
	storeSpinOutcome: function(a) {
		this.nextOutcomeSymbols = a
	},
	start: function() {
		var a = this;
		a.spinStartedAt = Date.now();
		a.startedStoppingAt = null;
		a.usedDuration = 0;
		a.targetOffset = a.visibleWindowLength + a.slotLength * a.leadingSymbolsCount;
		a.state = "starting";
		a.hasCompletedSpin = false;
		a.hasCompletedBounce = false;
		a.hasBeenToldToStop = false
	},
	stop: function() {
		this.hasBeenToldToStop = true
	},
	getDistanceToStopPosition: function() {
		var a = this,
			c = a.getFirstOutcomeSymbolIndex() * a.slotLength,
			b = Sys.Math.absoluteDifference(c, a.windowToBufferOffset);
		if (c > a.windowToBufferOffset) {
			b *= -1
		}
		return b + a.outcomeOffset
	},
	move: function(a) {
		this.moveDistance(this.getDistance(a))
	},
	moveDistance: function(d) {
		var c = this,
			b, a;
		c.windowToBufferOffset -= d;
		if (c.windowToBufferOffset < c.slotLength * c.leadingSymbolsCount) {
			b = Math.ceil(Math.abs(c.windowToBufferOffset) / c.slotLength);
			a = c.addSymbolsToBuffer(b, c.state === "stopping");
			c.windowToBufferOffset += b * c.slotLength;
			if (c.containsOutcome(a) && c.state === "spinning") {
				c.handleOutcomeEnteredReelEvent()
			}
		}
	},
	presentOutcome: function() {
		var a = this,
			b;
		a.hasCompletedSpin = true;
		a.state = "presenting";
		b = a.getDistanceToStopPosition();
		while (isNaN(b)) {
			a.moveDistance(a.slotLength);
			b = a.getDistanceToStopPosition()
		}
		a.moveDistance(b);
		a.state = "stopping"
	},
	addSymbolsToBuffer: function(d, c) {
		var b = this,
			a = b.symbolRetrievalFunction(d, c);
		b.symbolBuffer = a.concat(b.symbolBuffer.splice(0, b.symbolBufferMaxLength - d));
		return a
	},
	containsOutcome: function(b) {
		var a;
		for (a = -1; ++a < b.length;) {
			if (b[a].isOutcomeSymbol) {
				return true
			}
		}
		return false
	},
	handleOutcomeEnteredReelEvent: function() {
		var a = this;
		a.startedStoppingAt = Date.now();
		a.usedDuration = 0;
		a.currentBounce = 0;
		a.state = "stopping";
		a.targetOffset = a.getDistanceToStopPosition();
		a.stopDuration = Math.round(a.timeToMoveOneSlot * (a.targetOffset / a.slotLength));
		a.outcomeVisibleOnReel = false
	},
	getDistance: function(b) {
		var a = this;
		if (a.state === "starting") {
			return a.getStartingDistance(b)
		} else {
			if (a.state === "stopping") {
				return a.getStoppingDistance(b)
			}
		}
		return a.getSpinningDistance(b)
	},
	getStartingDistance: function(b) {
		var a = this,
			c = a.getInterpolatedDistance(a.targetOffset, a.startBounceSupportPointOffset, a.usedDuration, b, a.startDuration);
		a.usedDuration += b;
		if (c.progressAfterTime === 1) {
			a.state = "spinning";
			a.reelStartCompleteCallback()
		}
		return c.distance
	},
	getStoppingDistance: function(b) {
		var a = this,
			d, c;
		if (!a.hasCompletedSpin) {
			d = a.getInterpolatedDistance(a.targetOffset, a.targetOffset / 2, a.usedDuration, b, a.stopDuration);
			c = d.distance;
			a.usedDuration += b;
			if (d.progressAfterTime === 1) {
				a.hasCompletedSpin = true;
				a.usedDuration = 0;
				a.reelBounceStartCallback()
			}
			return c
		} else {
			if (a.currentBounce < a.endBounceSupportPointOffsets.length) {
				d = a.getInterpolatedDistance(0, a.endBounceSupportPointOffsets[a.currentBounce], a.usedDuration, b, a.endBounceDurations[a.currentBounce]);
				c = d.distance;
				a.usedDuration += b;
				if (d.progressAfterTime === 1) {
					a.currentBounce++;
					a.usedDuration = 0
				}
				return c
			}
		}
		if (!a.hasCompletedBounce) {
			a.hasCompletedBounce = true;
			a.reelStoppedCallback()
		}
		return 0
	},
	getInterpolatedDistance: function(j, f, c, d, h) {
		var a = Math.min(1, c / h),
			b = Animation.utils.getInterpolationValue(0, j, a, {
				type: "bezier",
				support: f
			}),
			e = Math.min(1, (c + d) / h),
			g = Animation.utils.getInterpolationValue(0, j, e, {
				type: "bezier",
				support: f
			});
		return {
			distance: g - b,
			progressAfterTime: e
		}
	},
	getSpinningDistance: function(b) {
		var a = b / this.timeToMoveOneSlot;
		return Math.round(a * this.slotLength)
	},
	getSymbolsToRender: function() {
		var e = this,
			c = [],
			g = Math.floor(e.windowToBufferOffset / e.slotLength) - e.leadingSymbolsCount,
			a, d, b, f;
		g = Math.max(0, g);
		a = Math.min(e.visibleSymbolsCount, e.symbolBuffer.length - g);
		for (d = -1; ++d < a;) {
			b = g + d;
			f = e.symbolBuffer[b];
			f.position = b * e.slotLength - Math.round(e.windowToBufferOffset);
			c.push(f);
			if (!e.outcomeVisibleOnReel) {
				e.reelStartedStoppingCallback();
				e.outcomeVisibleOnReel = true
			}
		}
		return c
	},
	getState: function() {
		return this.state
	},
	getStartTime: function() {
		return this.spinStartedAt
	},
	getStartedStoppingTime: function() {
		return this.startedStoppingAt
	},
	getStopDuration: function() {
		return this.stopDuration
	},
	isStopping: function() {
		return this.hasBeenToldToStop
	},
	isSpinning: function() {
		return this.state === "spinning"
	},
	setTimeToMoveOneSlot: function(a) {
		this.timeToMoveOneSlot = a;
		this.recalculateStartDuration()
	},
	recalculateStartDuration: function() {
		var a = this;
		a.startDuration = a.timeToMoveOneSlot * ((a.visibleWindowLength + Math.abs(a.startBounceSupportPointOffset) * 2) / a.slotLength)
	}
};
Sys.ns("Integration");
Integration.PluginMenu = {
	constructor: function() {
		Integration.PluginMenu.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Integration.PluginMenuController,
			view: Integration.PluginMenuBaseView,
			model: Integration.PluginMenuModel
		}
	}
};
Integration.PluginMenu = Sys.extend(Core.Module, Integration.PluginMenu, "Integration.PluginMenu");
Sys.ns("Integration");
Integration.PluginMenuController = {
	MAX_HEIGHT: 428,
	constructor: function() {
		Integration.PluginMenuController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var b = this,
			a = {
				"notify:stateHandler.enteringBeforeLoaderCloseState": b.view.setupContent.bind(b.view),
				"notify:settingsMenu.open": b.view.hideButton.bind(b.view),
				"notify:settingsMenu.closed": b.view.showButton.bind(b.view),
				"request:pluginMenu.init": b.initParams,
				"request:pluginMenu.activate": b.activate,
				"request:pluginMenu.deactivate": b.deactivate,
				"request:pluginMenu.notification": b.onNotification,
				"request:settingsButton.enable": b.view.enableButton.bind(b.view),
				"request:settingsButton.disable": b.view.disableButton.bind(b.view),
				"notify:stateHandler.enteringIdleState": b.view.enableButton.bind(b.view),
				"notify:stateHandler.leavingIdleState": b.view.disableButton.bind(b.view),
				"view:buttonClicked": b.onButtonClicked
			};
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveStart"] = b.onUserInputStart;
		a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveEnd"] = b.onUserInputEnd;
		b.on(a)
	},
	initParams: function(b, a) {
		var c = this;
		if (b !== "" && b !== "default") {
			c.view.buttonImageExternalUrl = b
		}
		c.view.height = a < c.MAX_HEIGHT ? a : c.MAX_HEIGHT
	},
	onButtonClicked: function() {
		var a = this;
		if (a.model.readData("pluginMenuActivated") === false) {
			a.activate()
		} else {
			a.deactivate()
		}
	},
	activate: function() {
		var a = this;
		a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
		a.fireEvent("request:quickSettingsMenu.externalDeactivate", a.MODULE_NAME);
		a.fireEvent("request:spinButton.hide", a.MODULE_NAME);
		a.view.activatePluginMenu();
		a.model.storeData("pluginMenuActivated", true);
		a.fireEvent("notify:pluginMenu.activated")
	},
	deactivate: function() {
		var a = this;
		a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
		a.fireEvent("request:quickSettingsMenu.externalActivate", a.MODULE_NAME);
		a.fireEvent("request:spinButton.show", a.MODULE_NAME);
		a.view.deactivatePluginMenu();
		a.model.storeData("pluginMenuActivated", false);
		a.fireEvent("notify:pluginMenu.deactivated")
	},
	onUserInputStart: function(c) {
		var a = this,
			b = !Sys.UserInputUtils.isCoordinateTarget(a.view.pluginIframe, c);
		a.model.storeData("clickedOutsideIframe", b)
	},
	onUserInputEnd: function(c) {
		var b = this,
			a = !Sys.UserInputUtils.isCoordinateTarget(b.view.pluginIframe, c);
		if (b.model.readData("clickedOutsideIframe") && a) {
			b.deactivate()
		}
	},
	onNotification: function(a) {
		var b = this;
		b.view.changeToNotificationImage(a)
	}
};
Integration.PluginMenuController = Sys.extend(Core.Controller, Integration.PluginMenuController, "Integration.PluginMenuController");
Sys.ns("Integration");
Integration.PluginMenuBaseView = {
	HEIGHT: 0,
	BUTTON_EXTERNAL_IMAGE_URL: "",
	BUTTON_DEFAULT_IMAGE_CSS: "integration-pluginMenu_button_uri",
	BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS: "integration-pluginMenu_button_notification_uri",
	BASE_BUTTON_CSS: "integration-pluginMenuButton_baseButton",
	PORTRAIT_CSS: "integration-pluginMenuButton_portraitBase",
	LANDSCAPE_CSS: "integration-pluginMenuButton_landscapeBase",
	DARK_OVERLAY_BASE_CSS: "integration-pluginMenuDarkOverlay_baseOverlay",
	DARK_OVERLAY_PORTRAIT_CSS: "integration-pluginMenuDarkOverlay_portraitBase",
	DARK_OVERLAY_LANDSCAPE_CSS: "integration-pluginMenuDarkOverlay_landscapeBase",
	RENDER_TARGET: "gameWrapper",
	constructor: function() {
		var a = this;
		Integration.PluginMenuBaseView.superclass.constructor.apply(this, arguments);
		a.height = a.HEIGHT;
		a.buttonImageExternalUrl = a.BUTTON_EXTERNAL_IMAGE_URL
	},
	setupContent: function() {
		var a = this;
		a.createDarkOverlay();
		a.createMenuButton();
		a.pluginIframe = document.getElementById("netEntExtendPlugin");
		if (a.height !== 0) {
			document.getElementById("gameWrapper").classList.add("pluginMenu");
			a.showButton()
		}
	},
	createDarkOverlay: function() {
		var a = this;
		a.darkOverlay = new Sys.Element({
			tag: "div",
			id: "pluginMenuDarkOverlay",
			cls: a.DARK_OVERLAY_BASE_CSS,
			style: "display:none",
			renderTo: a.RENDER_TARGET
		})
	},
	createMenuButton: function() {
		var a = this;
		a.menuButton = new Interface.utils.DOMButton({
			id: "pluginMenuButton",
			baseCSS: a.BASE_BUTTON_CSS + " " + a.BUTTON_DEFAULT_IMAGE_CSS,
			renderTo: a.RENDER_TARGET,
			clickCallback: a.onButtonClick.bind(a)
		});
		a.disableButton();
		a.hideButton();
		a.menuButtonSysElement = a.menuButton.getContainer();
		if (a.buttonImageExternalUrl !== "") {
			a.menuButtonSysElement.el.style["background-image"] = "url(" + a.buttonImageExternalUrl + ")"
		}
	},
	onButtonClick: function() {
		this.fireEvent("view:buttonClicked");
		this.changeToNormalImage()
	},
	activatePluginMenu: function() {
		this.darkOverlay.el.style.display = "block";
		this.pluginIframe.height = this.height + "px"
	},
	deactivatePluginMenu: function() {
		this.darkOverlay.el.style.display = "none";
		this.pluginIframe.height = "0px"
	},
	setStyle: function(d) {
		var e = this,
			c = d + "_CSS",
			f = d === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS",
			b = "DARK_OVERLAY_" + d + "_CSS",
			a = "DARK_OVERLAY_" + d === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
		if (Sys.isDefined(e.menuButtonSysElement) && Sys.isDefined(e[c])) {
			e.menuButtonSysElement.removeCls(e[f]);
			e.menuButtonSysElement.addCls(e[c])
		}
		if (Sys.isDefined(e.darkOverlay) && Sys.isDefined(e[b])) {
			e.darkOverlay.removeCls(e[a]);
			e.darkOverlay.addCls(e[b])
		}
	},
	showButton: function() {
		if (this.height !== 0) {
			this.menuButton.show(this.MODULE_NAME)
		}
	},
	hideButton: function() {
		this.menuButton.hide(this.MODULE_NAME)
	},
	enableButton: function() {
		this.menuButton.enable(this.MODULE_NAME)
	},
	disableButton: function() {
		this.menuButton.disable(this.MODULE_NAME)
	},
	adaptToOrientation: function(a) {
		this.setStyle(a)
	},
	changeToNotificationImage: function(a) {
		var b = this;
		if (a !== "" && a !== "default") {
			b.menuButtonSysElement.el.style["background-image"] = "url(" + a + ")"
		} else {
			b.menuButtonSysElement.removeCls(b.BUTTON_DEFAULT_IMAGE_CSS);
			b.menuButtonSysElement.addCls(b.BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS)
		}
	},
	changeToNormalImage: function() {
		var a = this;
		if (a.buttonImageExternalUrl !== "") {
			a.menuButtonSysElement.el.style["background-image"] = "url(" + a.buttonImageExternalUrl + ")"
		} else {
			a.menuButtonSysElement.removeCls(a.BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS);
			a.menuButtonSysElement.addCls(a.BUTTON_DEFAULT_IMAGE_CSS)
		}
	}
};
Integration.PluginMenuBaseView = Sys.extend(Core.View, Integration.PluginMenuBaseView, "Integration.PluginMenuBaseView");
Sys.ns("Integration");
Integration.PluginMenuMobileView = {
	PORTRAIT_CSS: "integration-pluginMenuButton_portraitBase_mobile",
	LANDSCAPE_CSS: "integration-pluginMenuButton_landscapeBase_mobile",
	DARK_OVERLAY_PORTRAIT_CSS: "integration-pluginMenuDarkOverlay_portraitBase_mobile",
	DARK_OVERLAY_LANDSCAPE_CSS: "integration-pluginMenuDarkOverlay_landscapeBase_mobile",
	constructor: function() {
		Integration.PluginMenuMobileView.superclass.constructor.apply(this, arguments)
	}
};
Integration.PluginMenuMobileView = Sys.extend(Integration.PluginMenuBaseView, Integration.PluginMenuMobileView, "Integration.PluginMenuMobileView");
Sys.ns("Integration");
Integration.PluginMenuModel = {
	constructor: function() {
		Integration.PluginMenuModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.storeData("pluginMenuActivated", false)
	}
};
Integration.PluginMenuModel = Sys.extend(Core.Model, Integration.PluginMenuModel, "Integration.PluginMenuModel");
if (Sys.isAndroidDevice && !Sys.isChrome) {}
if (Sys.isAndroidDevice) {
	Sys.override(Interface.SettingsWindowBaseView, {
		open: function() {
			Game.stage.view.animationManager.pauseAnimation();
			this.container.el.style.display = "block";
			this.fireEvent("view:opened")
		},
		close: function() {
			Game.stage.view.animationManager.continueAnimation();
			this.container.el.style.display = "none";
			this.fireEvent("view:closed")
		}
	});
	Sys.override(Core.ResourceLoaderController, {
		fetchAudioElementSource: function(e) {
			var d = this,
				f = document.createElement("audio"),
				c, b, a;
			c = function() {
				a();
				d.fetchedResource(e, f)
			};
			b = function() {
				a();
				d.failedToLoadResource(e)
			};
			a = function() {
				f.removeEventListener("canplaythrough", c, false);
				f.removeEventListener("error", b, false)
			};
			f.addEventListener("canplaythrough", c, false);
			f.addEventListener("error", b, false);
			f.src = e.url;
			f.load()
		}
	})
}
if (Sys.isiPhoneIOS8) {
	if (Sys.isDefined(Interface.HomeButtonController)) {
		Sys.override(Interface.HomeButtonController, {
			onUserInputEnd: function(c) {
				var b = this,
					a = Resources.readData("lobbyUrl");
				if (b.model.readData("activeInputTarget")) {
					if (b.view.isInputTarget(c)) {
						if (Sys.isDefined(a) && a !== "") {
							b.fireEvent("request:slowRequestAnimation.show")
						}
						setTimeout(function() {
							Environment.goToLobby(0)
						}, 100)
					}
				}
			}
		})
	}
	if (Sys.isDefined(Interface.SettingsWindowMobileView)) {
		Sys.override(Interface.SettingsWindowMobileView, {
			setHeight: function(b) {
				var a;
				if (b === "PORTRAIT") {
					a = Environment.getGameHeight() + Environment.getSpaceBelowGame();
					if (Sys.isIphone4Or4s) {
						a = 1161
					}
					this.container.el.style.height = a + "px"
				} else {
					this.container.el.style.height = ""
				}
			}
		})
	}
}
Sys.ns("Game.Slots");
Game.Slots.BlurredSymbols = {
	constructor: function() {
		Game.Slots.BlurredSymbols.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			setupGame: {
				queue: [function(a) {
					a.stateHandler.pushState(a.states.blurImages)
				}]
			},
			blurImages: {
				state: {
					name: "BlurImage",
					execute: function(a) {},
					waitEvents: {
						"notify:blurredSymbols.blurredImagesCompleted": false
					}
				}
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.BlurredSymbolsModel,
			view: Core.View,
			controller: Game.Slots.BlurredSymbolsController
		}
	}
};
Game.Slots.BlurredSymbols = Sys.extend(Core.Module, Game.Slots.BlurredSymbols, "Game.Slots.BlurredSymbols");
Sys.ns("Game.Slots");
Game.Slots.BlurredSymbolsController = {
	constructor: function() {
		Game.Slots.BlurredSymbolsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringBlurImageState": a.blurSymbols
		})
	},
	blurSymbols: function() {
		this.model.createBlurredImages();
		this.fireEvent("notify:blurredSymbols.blurredImagesCompleted")
	}
};
Game.Slots.BlurredSymbolsController = Sys.extend(Core.Controller, Game.Slots.BlurredSymbolsController, "Game.Slots.BlurredSymbolsController");
Sys.ns("Game.Slots");
Game.Slots.BlurredSymbolsModel = {
	constructor: function() {
		Game.Slots.BlurredSymbolsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = Resources.readData("config");
		this.storeData("reelConfig", a.reel);
		this.storeData("layeringConfig", a.layering)
	},
	createBlurredImages: function() {
		var h = this,
			j = Resources.readData("animationImages"),
			e = h.readData("reelConfig"),
			l = e.blurredSymbols,
			a = e.blurredSymbolHeights,
			k, f = Environment.getVirtualToWindowScale(3),
			c, m, g = {},
			b, d;
		for (d = 0; d < l.length; d++) {
			b = l[d];
			if (Sys.isNumber(a)) {
				k = a
			} else {
				if (Sys.isDefined(a[b])) {
					k = a[b]
				} else {
					k = a.standard
				}
			}
			k *= f;
			c = j[b];
			if (c) {
				m = Animation.utils.stackBlur.stackBlurImage(c, k, 15, true);
				g[b + "-BLURRED"] = m
			}
		}
		Game.stage.view.animationManager.addImages(g)
	}
};
Game.Slots.BlurredSymbolsModel = Sys.extend(Core.Model, Game.Slots.BlurredSymbolsModel, "Game.Slots.BlurredSymbolsModel");
Sys.ns("Game");
Game.Logo = {
	constructor: function() {
		Game.Logo.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			view: Game.LogoView,
			controller: Game.LogoController
		}
	}
};
Game.Logo = Sys.extend(Core.Module, Game.Logo, "Game.Logo");
Sys.ns("Game");
Game.LogoController = {
	constructor: function() {
		Game.LogoController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:logo.hide": a.hide,
			"request:logo.show": a.show,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	hide: function() {
		this.view.hide()
	},
	show: function() {
		this.view.show()
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	}
};
Game.LogoController = Sys.extend(Core.Controller, Game.LogoController, "Game.LogoController");
Sys.ns("Game");
Game.LogoView = {
	IMAGE: "logo",
	OFFSET_LEFT: 0,
	OFFSET_TOP: 0,
	SIZE_WIDTH: 418,
	SIZE_HEIGHT: 89,
	constructor: function() {
		var a = {
			OFFSET_LEFT: this.OFFSET_LEFT,
			OFFSET_TOP: this.OFFSET_TOP,
			SIZE_WIDTH: this.SIZE_WIDTH,
			SIZE_HEIGHT: this.SIZE_HEIGHT
		};
		Game.LogoView.superclass.constructor.apply(this, arguments);
		this.CONFIG = this.CONFIG || {};
		this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
		Sys.applyProperties(this.CONFIG.DEFAULT, a)
	},
	hide: function() {
		this.item.stop()
	},
	show: function() {
		this.item.play()
	},
	initAnimations: function() {
		var c = this,
			a = c.getRenderingAttributes(),
			d = new Animation.CanvasAnimationList({}),
			b = new Animation.CanvasAnimationItem({
				left: a.left,
				top: a.top,
				width: a.width,
				height: a.height,
				depth: Layering.Game.Logo.image,
				image: c.IMAGE
			});
		d.add(b);
		c.list = d;
		c.item = b;
		Game.stage.view.addToRenderLoop(d)
	},
	getRenderingAttributes: function() {
		var c = this.getScaleFactor(),
			b = Environment.getStageResolution(),
			a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
		return {
			left: ((b.width - a.SIZE_WIDTH * c) / 2) + a.OFFSET_LEFT * c,
			top: a.OFFSET_TOP * c,
			width: a.SIZE_WIDTH * c,
			height: a.SIZE_HEIGHT * c
		}
	},
	getScaleFactor: function() {
		return Resources.readData("config").mobileResourceToVirtualScale || 1
	},
	refresh: function() {
		var a = this.getRenderingAttributes(),
			b = this.item;
		if (Animation.utils.isAnimationItem(b)) {
			b.setImage(Game.stage.getOrientationSpecificImage(this.IMAGE));
			b.setLeft(a.left);
			b.setTop(a.top);
			b.setWidth(a.width);
			b.setHeight(a.height)
		}
	}
};
Game.LogoView = Sys.extend(Core.View, Game.LogoView, "Game.LogoView");
Sys.ns("Game");
Game.LogoFullscreenCanvasView = {
	CONFIG: {
		PORTRAIT: {
			OFFSET_LEFT: 0,
			OFFSET_TOP: 120,
			SIZE_WIDTH: 167,
			SIZE_HEIGHT: 36
		},
		LANDSCAPE: {
			OFFSET_LEFT: 0,
			OFFSET_TOP: 0,
			SIZE_WIDTH: 418,
			SIZE_HEIGHT: 89
		}
	}
};
Game.LogoFullscreenCanvasView = Sys.extend(Game.LogoView, Game.LogoFullscreenCanvasView, "Game.LogoFullscreenCanvasView");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinIntro = {
	constructor: function() {
		Game.Slots.FreeSpinIntro.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "trigger"]
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				freeSpinIntro: {
					state: {
						name: "FreeSpinIntro",
						execute: function() {},
						waitEvents: {
							"notify:freeSpinIntro.closed": false
						}
					}
				},
				stopped: {
					queue: [function(c) {
						if (a.readData("showFreeSpinIntro")) {
							c.stateHandler.pushState(c.states.freeSpinIntro)
						}
					}]
				},
				beforeLoaderClose: {
					queue: [function(c) {
						if (a.readData("showFreeSpinIntro")) {
							c.stateHandler.pushState(c.states.freeSpinIntro)
						}
					}]
				}
			};
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.FreeSpinIntroModel,
			controller: Game.Slots.FreeSpinIntroController,
			view: Game.Slots.FreeSpinIntroView
		}
	}
};
Game.Slots.FreeSpinIntro = Sys.extend(Core.Module, Game.Slots.FreeSpinIntro, "Game.Slots.FreeSpinIntro");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinIntroModel = {
	constructor: function() {
		Game.Slots.FreeSpinIntroModel.superclass.constructor.apply(this, arguments)
	},
	DEFAULT_REELSET: "freespin",
	processServerResponse: function(e) {
		var b = this,
			d = (e.restore === true) && e.currentGameState === "freespin",
			c = e.currentGameState !== "freespin" && e.nextaction === "freespin",
			a = Sys.isDefined(e.freespins) ? e.freespins.left : 0;
		b.storeData("freeSpinsWon", a);
		b.storeData("showFreeSpinIntro", d || c);
		b.storeData("isRestoreState", d)
	},
	getInitReelInfo: function(a) {
		return Sys.utils.parseReelInfo(a, this.DEFAULT_REELSET)
	},
	setupData: function() {
		Game.Slots.FreeSpinIntroModel.superclass.setupData.apply(this, arguments);
		Services.storage.storeData("freeSpins.canStart", false)
	}
};
Game.Slots.FreeSpinIntroModel = Sys.extend(Core.Model, Game.Slots.FreeSpinIntroModel, "Game.Slots.FreeSpinIntroModel");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinIntroView = {
	SPLASH_BACKGROUND_IMAGE: "freespinIntroBackground",
	SPLASH_CONGRATULATIONS: {
		fontSize: 30,
		fontFamily: "Arial",
		key: Language.Keys.congratulations_uc,
		x: 664,
		y: 100,
		operations: [{
			fillStyle: "#000000",
			drawType: "fill"
		}]
	},
	SPLASH_YOU_WON: {
		fontSize: 30,
		fontFamily: "Arial",
		key: Language.Keys.youWin,
		x: 664,
		y: 200,
		operations: [{
			fillStyle: "#000000",
			drawType: "fill"
		}]
	},
	SPLASH_FREE_SPINS: {
		fontSize: 30,
		fontFamily: "Arial",
		key: Language.Keys.freeSpins,
		centerX: 664,
		centerY: 500,
		width: 400,
		height: 100,
		operations: [{
			fillStyle: "#000000",
			drawType: "fill"
		}]
	},
	SPLASH_FREE_SPINS_WON: {
		fontSize: 60,
		fontFamily: "Arial",
		centerX: 664,
		centerY: 350,
		width: 200,
		height: 200,
		operations: [{
			fillStyle: "#FFFFFF",
			drawType: "fill"
		}]
	},
	SPLASH_BUTTON_CONTINUE: {
		fontSize: 30,
		fontFamily: "Arial",
		key: Language.Keys.startFreespins,
		loadingKey: Language.Keys.loadingDots,
		restoreKey: Language.Keys.continue_uc,
		centerX: 664,
		centerY: 640,
		width: 400,
		height: 200,
		maxWidth: 400,
		operations: [{
			fillStyle: "#FFFFFF",
			drawType: "fill"
		}]
	},
	MOVIE_BUTTON_CONTINUE: {
		fontSize: 30,
		fontFamily: "Arial",
		key: Language.Keys.skipIntro,
		centerX: 664,
		centerY: 640,
		width: 400,
		height: 200,
		maxWidth: 400,
		operations: [{
			fillStyle: "#FFFFFF",
			drawType: "fill"
		}]
	},
	constructor: function() {
		var a = this;
		Game.Slots.FreeSpinIntroView.superclass.constructor.apply(a, arguments);
		a.interactable = false;
		a.scale = Environment.getVirtualToWindowScale(3);
		a.hasMovie = false
	},
	show: function() {
		var a = this;
		a.setNumberOfFreespinsWon(a.model.readData("freeSpinsWon"));
		a.showSplash()
	},
	continueRequest: function() {
		var b = this,
			a = b.model.readData("isRestoreState");
		if (b.playing === "splash") {
			b.hideSplash();
			if (b.hasMovie && !a) {
				b.showMovie()
			} else {
				b.close()
			}
		} else {
			if (b.playing === "movie") {
				b.hideMovie();
				b.close()
			}
		}
	},
	close: function() {
		this.fireEvent("view:closed")
	},
	refresh: function() {
		var b = this,
			a = b.model.readData("isVisible");
		if (b.splashList) {
			Game.stage.view.removeFromRenderLoop(b.splashList)
		}
		if (b.movieList) {
			Game.stage.view.removeFromRenderLoop(b.movieList)
		}
		b.initAnimations();
		if (a) {
			b.show()
		}
	},
	enableContinueButton: function() {
		this.interactable = true;
		this.setButtonContinueText()
	},
	inputTargetsButton: function(f) {
		var e = this,
			c = e.activeButtonConfig,
			b = e.scaleValue(c.width),
			d = e.scaleValue(c.height),
			a = e.scaleValue(c.centerX) - (b / 2),
			g = e.scaleValue(c.centerY) - (d / 2);
		return (e.interactable && f.x >= a && f.x <= a + b && f.y >= g && f.y <= g + d)
	},
	showSplash: function() {
		var a = this;
		a.activeButtonConfig = this.getOrientationSpecificConfig(a.SPLASH_BUTTON_CONTINUE);
		a.playing = "splash";
		a.splashList.restore();
		a.splashList.play()
	},
	hideSplash: function() {
		this.splashList.stop();
		this.playing = "";
		this.fireEvent("view:splashClosed")
	},
	showMovie: function() {
		var a = this;
		a.activeButtonConfig = this.getOrientationSpecificConfig(a.MOVIE_BUTTON_CONTINUE);
		a.playing = "movie";
		a.movieList.restore();
		a.movieList.play();
		a.fireEvent("view:movieStarted")
	},
	hideMovie: function() {
		var a = this;
		a.movieList.restore();
		a.movieList.stop();
		a.playing = ""
	},
	initAnimations: function() {
		var a = this,
			b = a.createSplashAnimations(),
			c = a.createMovieAnimations();
		Game.stage.view.addToRenderLoop(b);
		b.stop();
		a.splashList = b;
		if (Sys.isDefined(c)) {
			a.hasMovie = true;
			Game.stage.view.addToRenderLoop(c);
			c.stop();
			a.movieList = c
		}
	},
	createSplashAnimations: function() {
		var c = this,
			b = {},
			e = c.getLayeringValues(),
			a = this.getOrientationSpecificConfig(c.SPLASH_BUTTON_CONTINUE),
			d = new Animation.CanvasAnimationList({});
		b.background = c.createSplashBackgroundItem(e.background);
		b.congratulations = c.createSplashCongratulationsItem(e.text);
		b.freeSpinsWon = c.createSplashFreespinsWonItem(e.text);
		b.freeSpins = c.createSplashFreespinsItem(e.text);
		b.button = c.createButtonItem(a, e.text, c.getButtonText(a));
		d.add(b.background);
		d.add(b.congratulations);
		d.add(b.freeSpinsWon);
		d.add(b.freeSpins);
		d.add(b.button);
		c.splashItems = b;
		return d
	},
	getButtonText: function(c) {
		var b = this.model.readData("isRestoreState"),
			a = this.model.readData("allLoadComplete"),
			d;
		if (!a) {
			d = c.loadingKey
		} else {
			if (b) {
				d = c.restoreKey
			} else {
				d = c.key
			}
		}
		return Services.languageManager.getText(d)
	},
	createMovieAnimations: function() {},
	createSplashBackgroundItem: function(a) {
		return new Animation.CanvasAnimationItem({
			fullScreen: true,
			depth: a,
			image: Game.stage.getOrientationSpecificImage(this.SPLASH_BACKGROUND_IMAGE)
		})
	},
	createSplashCongratulationsItem: function(f) {
		var j = this,
			a = Environment.getStageResolution(),
			d = document.createElement("canvas"),
			c = d.getContext("2d"),
			e = this.getOrientationSpecificConfig(j.SPLASH_CONGRATULATIONS),
			b = Services.languageManager.getText(e.key),
			g = this.getOrientationSpecificConfig(j.SPLASH_YOU_WON),
			h = Services.languageManager.getText(g.key);
		d.width = a.width;
		d.height = a.height;
		b = (e.uppercase === true) ? b.toUpperCase() : b;
		Animation.utils.text.performOperations(b, e.fontSize + "px " + e.fontFamily, e.x, e.y, e.operations, c);
		h = (e.uppercase === true) ? h.toUpperCase() : h;
		Animation.utils.text.performOperations(h, g.fontSize + "px " + g.fontFamily, g.x, g.y, g.operations, c);
		return new Animation.CanvasAnimationItem({
			fullScreen: true,
			depth: f,
			image: d
		})
	},
	createSplashFreespinsWonItem: function(a) {
		return this.createTextItem(this.getOrientationSpecificConfig(this.SPLASH_FREE_SPINS_WON), a)
	},
	createSplashFreespinsItem: function(a) {
		return this.createTextItem(this.getOrientationSpecificConfig(this.SPLASH_FREE_SPINS), a)
	},
	createButtonItem: function(b, f, e) {
		var d = this.createTextItem(b, f),
			c = d.prop.customProps.context,
			a;
		e = (b.uppercase === true) ? e.toUpperCase() : e;
		a = this.getAutoSizedFont(e, b.fontSize, b.fontFamily, 0, b.maxWidth, c);
		Animation.utils.text.performOperations(e, a, Math.round(b.width / 2), Math.round(b.height / 2), b.operations, c);
		return d
	},
	getAutoSizedFont: function(f, d, a, e, c, b) {
		return d + "px " + a
	},
	createTextItem: function(c, f) {
		var b = document.createElement("canvas"),
			d = b.getContext("2d"),
			e = c.width,
			a = c.height;
		b.width = e;
		b.height = a;
		d.textAlign = "center";
		d.textBaseline = "middle";
		return new Animation.CanvasAnimationItem({
			width: e,
			height: a,
			top: c.centerY - Math.round(a / 2),
			left: c.centerX - Math.round(e / 2),
			depth: f,
			image: b,
			customProps: {
				context: d
			}
		})
	},
	setNumberOfFreespinsWon: function(b) {
		var a = this.getOrientationSpecificConfig(this.SPLASH_FREE_SPINS_WON),
			c = (b === 1) ? "FREE SPIN" : "FREE SPINS";
		this.updateTextContext(a, this.splashItems.freeSpinsWon.prop.customProps.context, b.toString());
		this.updateTextContext(this.getOrientationSpecificConfig(this.SPLASH_FREE_SPINS), this.splashItems.freeSpins.prop.customProps.context, c)
	},
	setButtonContinueText: function() {
		var a = this.getOrientationSpecificConfig(this.SPLASH_BUTTON_CONTINUE);
		this.updateTextContext(a, this.splashItems.button.prop.customProps.context, this.getButtonText(a))
	},
	updateTextContext: function(b, c, d) {
		var a;
		c.clearRect(0, 0, b.width, b.height);
		c.textAlign = "center";
		c.textBaseline = "middle";
		d = (b.uppercase === true) ? d.toUpperCase() : d;
		a = this.getAutoSizedFont(d, b.fontSize, b.fontFamily, 0, b.maxWidth, c);
		Animation.utils.text.performOperations(d, a, Math.round(b.width / 2), Math.round(b.height / 2), b.operations, c, b.maxWidth)
	},
	getLayeringValues: function() {
		return Layering.Game.Slots.FreeSpinIntro
	},
	scaleValue: function(a) {
		return Math.round(this.scale * a)
	},
	getOrientationSpecificConfig: function(b) {
		var a = Services.orientation.getOrientation();
		if (Sys.isDefined(b[a]) || Sys.isDefined(b.DEFAULT) || Sys.isDefined(b.BASE)) {
			return Environment.getOrientationSpecificConfig(b, true)
		}
		return b
	}
};
Game.Slots.FreeSpinIntroView = Sys.extend(Core.View, Game.Slots.FreeSpinIntroView, "Game.Slots.FreeSpinIntroView");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinIntroController = {
	AUTO_CLOSE_TIME: 3500,
	constructor: function() {
		Game.Slots.FreeSpinIntroController.superclass.constructor.apply(this, arguments);
		this.model.storeData("allLoadComplete", false)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:closed": a.onClosed,
			"view:splashClosed": a.onSplashClosed,
			"request:freeSpins.start": a.view.continueRequest.bind(a.view),
			"view:animationComplete": a.view.continueRequest.bind(a.view),
			"view:movieStarted": a.onMovieStarted,
			"notify:stateHandler.enteringFreeSpinIntroState": a.start,
			"notify:responseParser.freeSpinInitResponseParsed": a.onFreespinInitResponseParsed,
			"notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:freeSpinIntro.closed", this, "When the free spin intro is closed.");
		Services.trigger.registerTrigger("notify:freeSpinIntro.splashClosed", this, "When the free spin intro splash is closed.")
	},
	onSplashClosed: function() {
		var a = this;
		a.fireEvent("request:spin.activateInitReelset", "freespin", "base");
		a.fireEvent("request:background.changeImage", "freespinBackground");
		a.fireEvent("request:coinsField.showProgressiveWin", true);
		a.fireEvent("request:audioPlayer.stop", "introFreeSpin");
		a.fireEvent("notify:freeSpinIntro.splashClosed");
		Services.storage.storeData("freeSpins.canStart", false)
	},
	start: function() {
		var a = this;
		a.model.storeData("freeSpinInitialized", false);
		a.show();
		a.fireEvent("request:closeOpenWindows");
		a.fireEvent("request:disableBasicGamePanel", "freespinSplash");
		a.requestFreeSpinInit()
	},
	requestFreeSpinInit: function() {
		this.fireEvent("request:serverManager.sendAction", "initfreespin", "notify:responseParser.freeSpinInitResponseParsed")
	},
	onFreespinInitResponseParsed: function(c) {
		var b = this,
			a = b.model.getInitReelInfo(c);
		b.fireEvent("request:spin.updateInitReelInfo", b.model.DEFAULT_REELSET, a);
		b.fireEvent("request:playModeManager.removeMode", "basic");
		b.fireEvent("request:playModeManager.addMode", "freespin");
		b.fireEvent("notify:freeSpin.freeSpinInitCompleted");
		b.fireEvent("notify:freeSpinIntro.freeSpinInitCompleted");
		b.model.storeData("freeSpinInitialized", true);
		b.onAllLoadComplete()
	},
	onAllLoadComplete: function() {
		var a = this;
		a.model.storeData("allLoadComplete", true);
		a.fireEvent("notify:gameModeChanged", "FREESPIN");
		a.startListeningToUserInput();
		a.view.enableContinueButton();
		a.resumeAutoClose()
	},
	show: function() {
		var a = this;
		a.model.storeData("isVisible", true);
		a.view.show();
		a.stopAutoplay();
		a.fireEvent("request:audioPlayer.play", {
			name: "introFreeSpin",
			id: "introFreeSpin"
		});
		a.fireEvent("request:ambienceManager.ambiencePauseSwitch", true);
		a.fireEvent("request:coinsField.showProgressiveWin", true);
		Services.storage.storeData("freeSpins.canStart", true)
	},
	stopAutoplay: function() {
		if (Services.settingsManager.getSetting("autoPlayNrSpins") > 0 && Services.settingsManager.getSetting("stopAutoplayIfFreeSpinWon")) {
			this.fireEvent("request:autoPlayer.stop")
		}
	},
	resumeAutoClose: function() {
		var a = this;
		if ((Services.settingsManager.getSetting("autoPlayNrSpins") > 0) && !(Services.settingsManager.getSetting("stopAutoplayIfFreeSpinWon"))) {
			a.autoCloseTimeOut = setTimeout(function() {
				a.autoCloseSplash()
			}, a.AUTO_CLOSE_TIME)
		}
	},
	autoCloseSplash: function() {
		var a = this;
		clearTimeout(a.autoCloseTimeOut);
		if (a.model.readData("freeSpinInitialized")) {
			a.view.continueRequest()
		} else {
			a.autoCloseTimeOut = setTimeout(a.autoCloseSplash, a.AUTO_CLOSE_TIME)
		}
	},
	onClosed: function() {
		var a = this;
		a.model.storeData("isVisible", false);
		a.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: "ambienceFreeSpin",
			id: "ambienceFreeSpin",
			loop: true
		});
		clearTimeout(a.autoCloseTimeOut);
		a.fireEvent("request:audioPlayer.stop", "introFreeSpin");
		a.stopListeningToUserInput();
		a.fireEvent("request:spinButton.show", a.MODULE_NAME);
		a.fireEvent("request:ambienceManager.ambiencePauseSwitch", false);
		a.fireEvent("notify:freeSpinIntro.closed", a.model.readData("freeSpinsWon"))
	},
	onMovieStarted: function() {
		var a = this;
		a.fireEvent("notify:freeSpinIntro.movieStarted")
	},
	onUserInputEnd: function(a) {
		if (this.view.inputTargetsButton(Sys.UserInputUtils.getCoordinatesRelativeToElement(a, Game.stage.getGameContainer()))) {
			this.view.continueRequest()
		}
	},
	onModulesFinishedLoading: function() {
		this.fireEvent("request:spinSettings.showStopIfFreeSpinsWon")
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	}
};
Game.Slots.FreeSpinIntroController = Sys.extend(Core.Controller, Game.Slots.FreeSpinIntroController, "Game.Slots.FreeSpinIntroController");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinOutro = {
	constructor: function() {
		Game.Slots.FreeSpinOutro.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "trigger"]
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				freeSpinOutro: {
					state: {
						name: "FreeSpinOutro",
						execute: function(c) {},
						waitEvents: {
							"notify:freeSpinOutro.closed": false
						}
					}
				},
				stopped: {
					queue: [function(c) {
						if (a.isState("animationRequested")) {
							c.stateHandler.pushState(c.states.freeSpinOutro)
						}
					}]
				},
				beforeLoaderClose: {
					queue: [function(c) {
						if (a.readData("animationRequested")) {
							c.stateHandler.pushState(c.states.freeSpinOutro)
						}
					}]
				}
			};
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.FreeSpinOutroModel,
			controller: Game.Slots.FreeSpinOutroController,
			view: Game.Slots.FreeSpinOutroView
		}
	}
};
Game.Slots.FreeSpinOutro = Sys.extend(Core.Module, Game.Slots.FreeSpinOutro, "Game.Slots.FreeSpinOutro");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinOutroModel = {
	constructor: function() {
		Game.Slots.FreeSpinOutroModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = Sys.isDefined(b.wins) ? b.wins.coinsTotal : 0;
		if (b.currentGameState === "freespin" && b.gamestate.current === "basic") {
			this.setState("animationRequested");
			this.storeData("coinsWon", a);
			this.storeData("previousReelset", b.rs.i0.id)
		} else {
			this.setState("idle")
		}
	}
};
Game.Slots.FreeSpinOutroModel = Sys.extend(Core.Model, Game.Slots.FreeSpinOutroModel, "Game.Slots.FreeSpinOutroModel");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinOutroView = {
	constructor: function() {
		Game.Slots.FreeSpinOutroView.superclass.constructor.apply(this, arguments)
	},
	show: function() {
		var b = this.model.readData("coinsWon"),
			a = this.animationList.items.indexOf(this.animationItems.congratulations);
		this.animationItems.coinWin.prop.coinsWon = b;
		if (b > 0) {
			if (a < 0) {
				this.animationList.add(this.animationItems.congratulations)
			}
		} else {
			if (a > 0) {
				this.animationList.items.splice(a, 1)
			}
		}
		if (!this.animated) {
			Game.stage.view.addToRenderLoop(this.animationList);
			this.animated = true
		} else {
			this.animationList.play()
		}
	},
	close: function() {
		this.animationList.stop();
		this.fireEvent("view:closed")
	},
	initAnimations: function() {
		var g = this,
			e = Layering.Game.Slots.FreeSpinOutro,
			h = {},
			b = Environment.getStageResolution(),
			c = g.createTextImages(),
			d = c.congratulation,
			j = c.coinsWon,
			k = c.button,
			a = b.height / 3 - d.height - j.height / 2,
			f = (b.height / 3) * 2 - k.height / 2;
		g.animationList = new Animation.List({});
		h.background = new Animation.Item({
			fullScreen: true,
			depth: e.background,
			executeBefore: function(l) {
				l.fillStyle = "#000000";
				l.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
			}
		});
		h.congratulations = new Animation.CanvasAnimationItem({
			width: d.width,
			height: d.height,
			top: a,
			left: 0,
			depth: e.text,
			executeBefore: function(l) {
				l.drawImage(g.inMemCanvas, d.x, d.y, d.width, d.height, this.pivot.x, this.pivot.y, this.width, this.height)
			}
		});
		a += d.height;
		h.coinsWonText = new Animation.CanvasAnimationItem({
			width: j.width,
			height: j.height,
			top: a,
			left: 0,
			depth: e.text,
			executeBefore: function(l) {
				l.drawImage(g.inMemCanvas, j.x, j.y, j.width, j.height, this.pivot.x, this.pivot.y, this.width, this.height)
			}
		});
		a += j.height;
		h.coinWin = new Animation.CanvasAnimationItem({
			width: d.width,
			height: d.height,
			top: a,
			left: b.width / 2,
			depth: e.text,
			coinsWon: 0,
			executeBefore: function(l) {
				l.fillStyle = "#ffffff";
				l.textBaseline = "middle";
				l.textAlign = "center";
				l.font = "32px Arial";
				l.fillText(this.coinsWon, this.pivot.x, this.pivot.y, b.width - 200)
			}
		});
		h.button = new Animation.CanvasAnimationItem({
			width: k.width,
			height: k.height,
			top: f,
			left: (b.width - k.width) / 2,
			depth: e.button,
			executeBefore: function(l) {
				l.drawImage(g.inMemCanvas, k.x, k.y, k.width, k.height, this.pivot.x, this.pivot.y, this.width, this.height)
			}
		});
		g.model.storeData("buttonLayoutProperties", [{
			x: h.button.prop.left,
			y: h.button.prop.top,
			width: h.button.prop.width,
			height: h.button.prop.height
		}]);
		g.animationList.add(h.background);
		g.animationList.add(h.congratulations);
		g.animationList.add(h.coinsWonText);
		g.animationList.add(h.coinWin);
		g.animationList.add(h.button);
		g.animationItems = h;
		g.animated = false
	},
	createTextImages: function() {
		var c = document.createElement("canvas"),
			j = c.getContext("2d"),
			a = Environment.getStageResolution(),
			e = Math.round(a.width / 2),
			g = Services.languageManager.getText(Language.Keys.congratulations),
			d = Services.languageManager.getText(Language.Keys.coinsWonColon),
			b = Services.languageManager.getText(Language.Keys["continue"]),
			h, f;
		c.width = a.width;
		c.height = a.height;
		j.fillStyle = "#ffffff";
		j.textBaseline = "middle";
		j.textAlign = "center";
		j.font = "32px Arial";
		j.fillText(g, e, 25, a.width - 200);
		j.fillText(d, e, 75, a.width - 200);
		h = j.measureText(b).width;
		f = Math.round(h / 2);
		j.fillRect(0, 150, h + 20, 50);
		j.fillStyle = "#000000";
		j.fillText(b, f + 10, 175);
		this.inMemCanvas = c;
		return {
			congratulation: {
				x: 0,
				y: 0,
				width: a.width,
				height: 50
			},
			coinsWon: {
				x: 0,
				y: 50,
				width: a.width,
				height: 75
			},
			button: {
				x: 0,
				y: 150,
				width: h + 20,
				height: 50
			}
		}
	},
	inputTargetsButton: function(c) {
		var b = document.getElementById("canvasAnimationManager"),
			a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, b);
		return Sys.UserInputUtils.isUserInputInSegment(a, this.model.readData("buttonLayoutProperties"))
	}
};
Game.Slots.FreeSpinOutroView = Sys.extend(Core.View, Game.Slots.FreeSpinOutroView, "Game.Slots.FreeSpinOutroView");
Sys.ns("Game.Slots");
Game.Slots.FreeSpinOutroController = {
	AUTO_CLOSE_TIME: 6000,
	DEFAULT_AFTER_REELSET: "basic",
	LISTEN_TO_USER_INPUT_WHEN_START: true,
	UPDATE_COINS_FIELD_WHEN_START: true,
	constructor: function() {
		Game.Slots.FreeSpinOutroController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:closed": a.onClosed,
			"notify:stateHandler.enteringFreeSpinOutroState": a.show,
			"request:freeSpinOutro.close": a.close,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:freeSpinOutro.closed", this, "When the free spin intro splash is closed.")
	},
	show: function() {
		var a = this;
		if (a.LISTEN_TO_USER_INPUT_WHEN_START) {
			a.startListeningToUserInput()
		}
		a.view.show();
		a.fireEvent("request:ambienceManager.ambienceStopActive");
		a.playOutroSound();
		if (a.UPDATE_COINS_FIELD_WHEN_START) {
			a.fireEvent("request:coinsField.showNormalWin")
		}
		a.fireEvent("request:playModeManager.removeMode", "freespin");
		a.fireEvent("request:playModeManager.addMode", "basic");
		a.fireEvent("request:closeOpenWindows");
		if (Services.settingsManager.getSetting("autoPlayNrSpins") > 0) {
			a.autoCloseTimeOut = setTimeout(function() {
				a.close()
			}, a.AUTO_CLOSE_TIME)
		}
	},
	playOutroSound: function() {
		this.fireEvent("request:audioPlayer.play", {
			name: "outroFreeSpin"
		})
	},
	close: function() {
		var a = this;
		clearTimeout(a.autoCloseTimeOut);
		a.fireEvent("request:spin.activateReelset", a.DEFAULT_AFTER_REELSET, "base");
		a.view.close();
		a.stopListeningToUserInput();
		a.fireEvent("notify:gameModeChanged", "BASIC");
		a.fireEvent("request:enableBasicGamePanel", "freespinSplash")
	},
	onClosed: function() {
		var a = this;
		a.fireEvent("request:background.restoreImage");
		a.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: "ambienceGeneral",
			id: "ambienceGeneral",
			loop: true
		});
		a.fireEvent("notify:freeSpinOutro.closed")
	},
	onUserInputEnd: function(a) {
		if (this.view.inputTargetsButton(a)) {
			this.close()
		}
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	}
};
Game.Slots.FreeSpinOutroController = Sys.extend(Core.Controller, Game.Slots.FreeSpinOutroController, "Game.Slots.FreeSpinOutroController");
Sys.ns("Game.Slots");
Game.Slots.CountDownFreespins = {
	constructor: function() {
		Game.Slots.CountDownFreespins.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["userInput"]
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				stopped: {
					queue: [function(c) {
						if (a.isState("countDownAnimationRequested")) {
							c.stateHandler.pushState(c.states.countDownFreespins)
						}
					}]
				},
				beforeLoaderClose: {
					queue: [function(c) {
						if (a.isState("countDownAnimationRequested")) {
							c.stateHandler.pushState(c.states.countDownFreespins)
						} else {
							if (a.isState("countDownLoopAnimationRequested")) {
								c.stateHandler.pushState(c.states.countDownFreespinsRestore)
							}
						}
					}]
				},
				countDownFreespins: {
					state: {
						name: "CountDownFreespins",
						execute: function() {},
						waitEvents: {
							"notify:countDownFreespin:splashClosed": false
						}
					}
				},
				countDownFreespinsRestore: {
					state: {
						name: "CountDownFreespinsRestore",
						execute: function() {},
						waitEvents: {
							"notify:countDownFreespin:restoreSplashActive": false
						}
					}
				}
			};
		return b
	},
	getDefaultMVCClasses: function() {
		return {
			model: Game.Slots.CountDownFreespinsModel,
			view: Game.Slots.CountDownFreespinsView,
			controller: Game.Slots.CountDownFreespinsController
		}
	}
};
Game.Slots.CountDownFreespins = Sys.extend(Core.Module, Game.Slots.CountDownFreespins, "Game.Slots.CountDownFreespins");
Sys.ns("Game.Slots");
Game.Slots.CountDownFreespinsController = {
	constructor: function() {
		Game.Slots.CountDownFreespinsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringCountDownFreespinsState": a.onEnteringCountDownFreespinsState,
			"notify:stateHandler.enteringCountDownFreespinsRestoreState": a.onEnteringCountDownFreespinsRestoreState,
			"notify:stateHandler.leavingCountDownFreespinsState": a.onLeavingCountDownFreespinsState,
			"notify:responseParser.responseParsed": a.checkIfCountDown,
			"view:splashClosed": a.fireEvent.bind(a, "notify:countDownFreespin:splashClosed"),
			"notify:stateHandler.leavingStoppedState": a.view.closeLoopSplash.bind(a.view),
			"notify:spinButton.clicked": a.handleUserInput,
			"notify:spinButton.clickedWhileHidden": a.handleUserInput,
			"request:abortPresentation": a.handleUserInput,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		});
		a.splashClosedEvent = "notify:countDownFreespin:splashClosed"
	},
	onEnteringCountDownFreespinsState: function() {
		var a = this;
		a.model.storeData("isVisible", true);
		a.view.showSplash();
		a.fireEvent("request:coinsField.showFreeSpinsLeft");
		a.model.storeData("showing", true);
		a.startListeningToUserInput()
	},
	onEnteringCountDownFreespinsRestoreState: function() {
		this.view.showLoopSplash();
		this.fireEvent("request:coinsField.showFreeSpinsLeft");
		this.fireEvent("notify:countDownFreespin:restoreSplashActive")
	},
	onLeavingCountDownFreespinsState: function() {
		this.stopListeningToUserInput();
		this.model.storeData("isVisible", false)
	},
	checkIfCountDown: function(b) {
		var a = this;
		if (b.clientaction === "init" && b.currentGameState === "freespin" && b.nextaction === "freespin") {
			a.model.storeData("remainingFreeSpins", b.freespins.left);
			a.model.setState("countDownLoopAnimationRequested")
		} else {
			if (b.currentGameState === "freespin" && b.nextaction === "freespin") {
				a.model.storeData("remainingFreeSpins", b.freespins.left);
				a.model.setState("countDownAnimationRequested")
			} else {
				a.model.setState("idle")
			}
		}
	},
	onUserInputStart: function(a) {
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
			this.handleUserInput()
		}
	},
	handleUserInput: function() {
		this.model.storeData("showing", false);
		this.stopListeningToUserInput();
		this.view.closeSplash()
	},
	onGameSizeChanged: function() {
		if (Sys.isFunc(this.view.refresh)) {
			this.view.refresh()
		}
	}
};
Game.Slots.CountDownFreespinsController = Sys.extend(Core.Controller, Game.Slots.CountDownFreespinsController, "Game.Slots.CountDownFreespinsController");
Sys.ns("Game.Slots");
Game.Slots.CountDownFreespinsModel = {
	SHOW_DURATION: 2000,
	constructor: function() {
		Game.Slots.CountDownFreespinsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.storeData("depth", Layering.Game.Slots.FreeSpinCountDown);
		this.storeData("duration", this.SHOW_DURATION)
	}
};
Game.Slots.CountDownFreespinsModel = Sys.extend(Core.Model, Game.Slots.CountDownFreespinsModel, "Game.Slots.CountDownFreespinsModel");
Sys.ns("Game.Slots");
Game.Slots.CountDownFreespinsView = {
	constructor: function() {
		Game.Slots.CountDownFreespinsView.superclass.constructor.apply(this, arguments);
		this.setupSplash()
	},
	SPLASH_CONFIG: {
		BASE: {
			width: 400,
			height: 400,
			topDenominator: 2
		}
	},
	setupSplash: function() {
		var a = this,
			e = a.model.readData("duration"),
			f = a.model.readData("depth").text,
			g = Environment.getStageResolution(),
			c, d = Environment.getOrientationSpecificConfig(a.SPLASH_CONFIG, true),
			b = {
				width: d.width,
				height: d.height,
				top: g.height / d.topDenominator,
				left: g.width / 2,
				depth: f,
				customProps: {
					message: "<freespins left value>"
				},
				executeBefore: function(h) {
					var l = this.pivot.x,
						k = this.pivot.y,
						j = this.customProps.message;
					h.save();
					h.fillStyle = "#fff4da";
					h.font = "96px Arial";
					h.textBaseline = "middle";
					h.textAlign = "center";
					h.strokeStyle = "#008c95";
					h.lineWidth = 3;
					h.shadowColor = "rgba( 0, 0, 0, 0.7 )";
					h.shadowOffsetY = "5";
					h.fillText(j, l, k, this.width);
					h.shadowOffsetY = "0";
					h.strokeText(j, l, k, this.width);
					h.restore()
				},
				operations: {
					fade: []
				}
			};
		c = Sys.clone(b);
		b.operations.fade = [{
			time: 0,
			value: 1
		}, {
			time: e,
			value: 1
		}];
		a.item = new Animation.CanvasAnimationItem(b);
		c.operations.fade = [{
			time: 0,
			value: 1
		}, {
			time: e,
			value: 1,
			goTo: 0
		}];
		a.loopItem = new Animation.CanvasAnimationItem(c);
		a.list = new Animation.CanvasAnimationList({
			endEvent: {
				event: "view:splashClosed",
				scope: a
			}
		});
		a.loopList = new Animation.CanvasAnimationList();
		a.list.add(a.item);
		a.loopList.add(a.loopItem)
	},
	showSplash: function() {
		var a = this;
		a.list.restore();
		a.item.prop.customProps.message = a.model.readData("remainingFreeSpins");
		Game.stage.view.addToRenderLoop(a.list)
	},
	showLoopSplash: function() {
		var a = this;
		a.loopList.restore();
		a.loopItem.prop.customProps.message = a.model.readData("remainingFreeSpins");
		Game.stage.view.addToRenderLoop(a.loopList)
	},
	closeSplash: function() {
		if (this.list.isRunning()) {
			Game.stage.view.removeFromRenderLoop(this.list);
			this.fireEvent("view:splashClosed")
		}
	},
	closeLoopSplash: function() {
		if (this.loopList.isRunning()) {
			Game.stage.view.removeFromRenderLoop(this.loopList)
		}
	},
	updateItem: function(a) {
		var c, b;
		if (Animation.utils.isAnimationItem(a)) {
			c = Environment.getStageResolution();
			b = Environment.getOrientationSpecificConfig(this.SPLASH_CONFIG, true);
			a.setWidth(b.width);
			a.setHeight(b.height);
			a.setTop(c.height / b.topDenominator);
			a.setLeft(Math.round(c.width / 2))
		}
	},
	refresh: function() {
		var b = this,
			a = b.model.readData("isVisible");
		b.updateItem(b.item);
		b.updateItem(b.loopItem);
		if (a) {
			b.showSplash()
		}
	}
};
Game.Slots.CountDownFreespinsView = Sys.extend(Core.View, Game.Slots.CountDownFreespinsView, "Game.Slots.CountDownFreespinsView");
Sys.ns("Core");
Core.Fullscreen = {
	getDefaultMVCClasses: function() {
		var a;
		if (Platform.hasFullscreenAPI === true) {
			a = Core.FullscreenView
		} else {
			if (Platform.isIOSDevice === true) {
				a = Core.FullscreenViewIOS
			}
		}
		if (Environment.isIniFrame || !Sys.isDefined(a)) {
			return {
				controller: Core.Controller
			}
		}
		return {
			controller: Core.FullscreenController,
			model: Core.FullscreenModel,
			view: a
		}
	}
};
Core.Fullscreen = Sys.extend(Core.Module, Core.Fullscreen, "Core.Fullscreen");
Sys.ns("Core");
Core.FullscreenController = {
	setupEvents: function() {
		if (Platform.hasFullscreenAPI === true) {
			this.setupFullscreenAPIEvents()
		} else {
			if (Platform.isIOSDevice && Platform.isMobileDevice && Sys.isSafari) {
				this.setupIOSEvents()
			}
		}
	},
	handleInput: function(a) {
		var b = this;
		if (!b.view.isFullscreen() && !b.model.isInSafeArea(a)) {
			b.view.request()
		}
	},
	setSafeArea: function(b, a) {
		this.model.setSafeArea(b, a)
	},
	removeSafeArea: function(a) {
		this.model.removeSafeArea(a)
	},
	setupFullscreenAPIEvents: function() {
		var a = this;
		a.on({
			"notify:userInputManager.userInputEnded": a.handleInput,
			"request:fullscreen.request": a.view.request.bind(a.view),
			"request:fullscreen.exit": a.view.exit.bind(a.view),
			"request:fullscreen.setSafeArea": a.setSafeArea,
			"request:fullscreen.removeSafeArea": a.removeSafeArea
		})
	},
	setupIOSEvents: function() {
		var a = this;
		a.on({
			"notify:viewport.scaled": a.view.onViewportScaled.bind(a.view),
			"notify:userInputManager.userInputEnded": a.view.onUserInputEnded.bind(a.view),
			"notify:orientation.changed": a.view.onOrientationChange.bind(a.view),
			"view:allowPropagation": a.fireEvent.bind(a, "request:userInputManager.allowPropagation"),
			"view:disallowPropagation": a.fireEvent.bind(a, "request:userInputManager.disAllowPropagation")
		})
	}
};
Core.FullscreenController = Sys.extend(Core.Controller, Core.FullscreenController, "Core.FullscreenController");
Sys.ns("Core");
Core.FullscreenModel = {
	constructor: function() {
		Core.FullscreenModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		this.storeData("safeAreas", {})
	},
	setSafeArea: function(c, a) {
		var b = this.readData("safeAreas");
		b = b || {};
		b[c] = a;
		this.storeData("safeAreas", b)
	},
	removeSafeArea: function(b) {
		var a = this.readData("safeAreas");
		a = a || {};
		a[b] = undefined;
		this.storeData("safeAreas", a)
	},
	isInSafeArea: function(j) {
		var e = this.readData("safeAreas"),
			f, a, k, c, h, g, b, d;
		if (Sys.isDefined(j) && Sys.isDefined(e)) {
			f = Object.keys(e);
			a = f.length;
			k = Sys.UserInputUtils.getCoordinatesRelativeToElement(j, Game.stage.getGameContainer());
			c = Environment.getVirtualToWindowScale(3);
			h = k.x * c;
			g = k.y * c;
			for (d = -1; ++d < a;) {
				b = e[f[d]];
				if (Sys.isDefined(b.element)) {
					if (Sys.UserInputUtils.isCoordinateTarget(b.element, j)) {
						return true
					}
				} else {
					if (!Sys.isDefined(b.height)) {
						if (Math.sqrt(Math.pow((h - b.x), 2) + Math.pow((g - b.y), 2)) < b.width) {
							return true
						}
					} else {
						if ((h >= b.x && h <= b.x + b.width && g >= b.y && g <= b.y + b.height)) {
							return true
						}
					}
				}
			}
		}
		return false
	}
};
Core.FullscreenModel = Sys.extend(Core.Model, Core.FullscreenModel, "Core.FullscreenModel");
Sys.ns("Core");
Core.FullscreenView = {
	init: function() {
		var k = this,
			a = {},
			g = ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
			f = [
				["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
				["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
				["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
				["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
				["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
			],
			c = f.length,
			b, h, e, d;
		for (e = 0; e < c; e++) {
			h = f[e];
			if (h[1] in document) {
				for (d = 0, b = h.length; d < b; d++) {
					a[g[d]] = h[d]
				}
				break
			}
		}
		k.fullscreenAPI = a;
		Core.FullscreenView.superclass.init.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		document.addEventListener(a.fullscreenAPI.fullscreenchange, function() {
			clearTimeout(a._fullscreenTimeout);
			a._fullscreenTimeout = setTimeout(function() {
				a.fireEvent("request:viewport.resize")
			}, 250)
		}, false)
	},
	request: function() {
		var a = false;
		if (!a) {
			document.documentElement[this.fullscreenAPI.requestFullscreen]()
		}
	},
	exit: function() {
		document[this.fullscreenAPI.exitFullscreen]()
	},
	isFullscreen: function() {
		return Boolean(document[this.fullscreenAPI.fullscreenElement])
	}
};
Core.FullscreenView = Sys.extend(Core.View, Core.FullscreenView, "Core.FullscreenView");
Sys.ns("Interface.utils");
Interface.utils.PIXIScrollContainer = {
	SCROLL_SPEED: 300,
	constructor: function(b) {
		var a = this;
		if (Sys.isDefined) {
			a.maxHeight = b
		} else {
			a.maxHeight = 0
		}
		Interface.utils.PIXIScrollContainer.superclass.constructor.apply(a, arguments);
		a.initScrollContainer()
	},
	initScrollContainer: function() {
		var a = this;
		a.isScrollContainer = true;
		a.contentHeight = 0;
		a.contentWidth = 0;
		a.scrollBarContentMargin = 0;
		a.scrollBarSize = 10;
		a.scrollBarColor = 11184810;
		a.scrollBarAlpha = 1;
		a.scrollSliderColor = 2105376;
		a.scrollSliderAlpha = 1;
		a.touchStartPositionY = 0;
		a.bottomPadding = 0;
		a.scrollBar = new PIXI.Container();
		a.scrollBar.isScrollBar = true;
		a.scrollBarGraphics = new PIXI.Graphics();
		a.scrollBarGraphics.beginFill(a.scrollBarColor, a.scrollBarAlpha);
		a.scrollBarGraphics.drawCircle(0, a.scrollBarSize, a.scrollBarSize);
		a.scrollBarGraphics.endFill();
		a.scrollBar.addChild(a.scrollBarGraphics);
		a.scrollBar.visible = false;
		a.scrollBar.interactive = true;
		a.scrollSlider = new PIXI.Container();
		a.scrollSlider.isScrollSlider = true;
		a.scrollSliderGraphics = new PIXI.Graphics();
		a.scrollSliderGraphics.beginFill(a.scrollSliderColor, a.scrollSliderAlpha);
		a.scrollSliderGraphics.drawCircle(0, a.scrollBarSize, a.scrollBarSize);
		a.scrollSliderGraphics.drawRect(-a.scrollBarSize, a.scrollBarSize, a.scrollBarSize * 2, a.maxHeight - a.scrollBarSize * 2);
		a.scrollSliderGraphics.drawCircle(0, a.maxHeight - a.scrollBarSize * 2, a.scrollBarSize);
		a.scrollSliderGraphics.endFill();
		a.scrollSlider.addChild(a.scrollSliderGraphics);
		a.scrollSlider.visible = false;
		a.scrollSlider.interactive = true;
		a.mask = new PIXI.Graphics();
		a.mask.beginFill();
		a.mask.drawRect(0, 0, 1, a.maxHeight);
		a.mask.endFill();
		a.mask.isMask = true;
		a.addChild(a.mask);
		a.addChild(a.scrollSlider);
		a.addChild(a.scrollBar);
		a.setupEvents();
		a.interactive = true
	},
	setupEvents: function() {
		var a = this;
		a.addEventListener("notify:userInputManager.userInputScroll", a.mouseWheel.bind(a));
		a.scrollBar.on("touchstart", a.touchStartScrollBar.bind(a));
		a.scrollBar.on("touchmove", a.touchMoveScrollBar.bind(a));
		a.scrollBar.on("touchend", a.touchEndScrollBar.bind(a));
		a.scrollSlider.on("touchstart", a.touchStartScrollBar.bind(a));
		a.scrollSlider.on("touchend", a.touchEndScrollBar.bind(a));
		window.addEventListener("click", a.mouseUp.bind(a));
		a.scrollBar.on("mousemove", a.mouseMove.bind(a));
		a.scrollBar.on("mousedown", a.mouseDown.bind(a));
		a.scrollSlider.on("mousemove", a.mouseMove.bind(a));
		a.scrollSlider.on("mousedown", a.mouseDown.bind(a))
	},
	updateScrollContainer: function() {
		var d = this,
			c, b, a = false;
		b = d.forcedHeight || d.getChildrenMaxHeight();
		c = d.forcedWidth || d.getChildrenMaxWidth();
		b += d.bottomPadding;
		if (b > d.maxHeight) {
			a = true
		}
		if (a) {
			d.scrollBar.visible = true;
			d.scrollBar.updateTransform();
			d.scrollSlider.visible = true;
			d.scrollSlider.updateTransform()
		}
		d.scrollBarGraphics.clear();
		d.scrollSliderGraphics.clear();
		if (!Sys.isDefined(d.scrollBar.sprite)) {
			d.scrollBarGraphics.beginFill(d.scrollBarColor, d.scrollBarAlpha);
			d.scrollBarGraphics.drawCircle(0, d.scrollBarSize, d.scrollBarSize);
			d.scrollBarGraphics.endFill();
			d.scrollBar.position.x = c - d.scrollBar.width + d.scrollBarContentMargin
		} else {
			d.scrollBar.position.x = c - d.scrollBar.width + d.scrollBarContentMargin
		}
		d.scrollSliderGraphics.beginFill(d.scrollSliderColor, d.scrollSliderAlpha);
		d.scrollSliderGraphics.drawCircle(0, d.scrollBarSize, d.scrollBarSize);
		d.scrollSliderGraphics.drawRect(-d.scrollBarSize, d.scrollBarSize, d.scrollBarSize * 2, d.maxHeight - d.scrollBarSize * 2);
		d.scrollSliderGraphics.drawCircle(0, d.maxHeight - d.scrollBarSize, d.scrollBarSize);
		d.scrollSliderGraphics.endFill();
		d.contentHeight = b;
		d.contentWidth = c + d.scrollBarContentMargin;
		d.scrollSlider.position.x = c - d.scrollBar.width + d.scrollBarContentMargin;
		d.mask.width = c + d.scrollBarContentMargin;
		d.mask.height = d.maxHeight;
		d.children.sort(function(f, e) {
			if (f.isScrollBar) {
				return true
			} else {
				return f.isScrollSlider && !e.isScrollBar
			}
		})
	},
	updateContent: function(d) {
		if (!this.isActive()) {
			return
		}
		var b = this,
			c = (b.contentHeight - b.maxHeight) / (b.maxHeight - b.scrollBar.height) * d;
		for (var a = 0; a < b.children.length; ++a) {
			if (!Sys.isDefined(b.children[a].isScrollBar) && !Sys.isDefined(b.children[a].isScrollSlider) && !Sys.isDefined(b.children[a].isMask)) {
				b.children[a].position.y = b.children[a].offsetY - c
			}
		}
	},
	updateScrollBarByMousePosition: function(c) {
		if (!this.isActive() || !this.scrollActive) {
			return
		}
		var b = this,
			a = document.getElementsByTagName("canvas")[0];
		b.moveScrollBar(b.getMousePosition(a, c).y);
		b.updateContent(b.scrollBar.position.y)
	},
	updateScrollBarByScrollPosition: function(f) {
		if (!this.isActive()) {
			return
		}
		var d = this,
			a = document.getElementsByTagName("canvas")[0],
			h = d.getMousePosition(a, f),
			b = d.scrollContainerToGlobalPosition(0, d.scrollBar.position.y).y,
			c = d.SCROLL_SPEED / d.contentHeight,
			g = f.deltaY || f.detail / 3 * 100;
		h = d.globalToScrollContainerPosition(h.x, h.y);
		if (h.x > 0 && h.x < d.contentWidth && h.y > 0 && h.y < d.maxHeight) {
			d.moveScrollBar(b + g * c);
			d.updateContent(d.scrollBar.position.y)
		}
	},
	updateScrollBarByTouch: function(d) {
		var c = this,
			b = c.scrollContainerToGlobalPosition(0, c.scrollBar.position.y).y,
			a = c.touchStartPositionY - d.data.global.y;
		c.touchStartPositionY -= a;
		c.moveScrollBar(b + a / 5);
		c.updateContent(c.scrollBar.position.y)
	},
	moveScrollBar: function(d) {
		var c = this,
			e = c.globalToScrollContainerPosition(0, d).y,
			b = c.scrollActive ? -c.scrollBar.height / 2 : 0,
			a = c.scrollActive ? 0 : -c.scrollBar.height / 2;
		if (d <= c.position.y + c.maxHeight - c.scrollBar.height / 2 + a && d >= c.position.y + c.scrollBar.height / 2 + a) {
			c.scrollBar.position.y = e + b
		} else {
			if (d > c.position.y + c.maxHeight - c.scrollBar.height / 2 + a) {
				c.scrollBar.position.y = c.maxHeight - c.scrollBar.height
			} else {
				if (d < c.position.y + c.scrollBar.height / 2 + a) {
					c.scrollBar.position.y = 0
				}
			}
		}
	},
	isActive: function() {
		if (!this.visible) {
			return false
		}
		if (Sys.isDefined(this.parent)) {
			return this.parent.visible
		}
		return true
	},
	addChild: function(c, a) {
		if (!Sys.isDefined(a)) {
			a = true
		}
		var b = this;
		Interface.utils.PIXIScrollContainer.superclass.addChild.apply(b, [c]);
		c.offsetY = c.position.y;
		if (a) {
			b.updateScrollContainer()
		}
	},
	useScrollBarSprite: function(a) {
		this.scrollBar.addChild(a);
		this.scrollBar.sprite = a;
		a.anchor.x = 0.5
	},
	mouseMove: function(a) {
		this.updateScrollBarByMousePosition(a)
	},
	touchStartScrollBar: function(a) {
		this.scrollActive = true;
		this.updateScrollBarByMousePosition(a);
		a.stopPropagation()
	},
	touchMoveScrollBar: function(a) {
		this.updateScrollBarByMousePosition(a);
		if (this.scrollActive) {
			a.stopPropagation()
		}
	},
	touchEndScrollBar: function(a) {
		this.scrollActive = false;
		a.stopPropagation()
	},
	touchStart: function(a) {
		this.scrollActive = false;
		this.touchStartPositionY = a.data.global.y
	},
	touchMove: function(a) {
		this.updateScrollBarByTouch(a)
	},
	touchEnd: function(a) {
		this.scrollActive = false
	},
	mouseDown: function(a) {
		this.scrollActive = true;
		this.updateScrollBarByMousePosition(a)
	},
	mouseUp: function() {
		this.scrollActive = false
	},
	mouseWheel: function(b, a) {
		this.updateScrollBarByScrollPosition(a)
	},
	getMousePosition: function(a, c) {
		var b = a.getBoundingClientRect();
		if (c.clientX) {
			return {
				x: Math.floor((c.clientX - b.left) / (b.right - b.left) * a.width),
				y: Math.floor((c.clientY - b.top) / (b.bottom - b.top) * a.height)
			}
		} else {
			if (c.data.originalEvent.clientX) {
				return {
					x: Math.floor((c.data.originalEvent.clientX - b.left) / (b.right - b.left) * a.width),
					y: Math.floor((c.data.originalEvent.clientY - b.top) / (b.bottom - b.top) * a.height)
				}
			} else {
				return {
					x: Math.floor((c.data.originalEvent.touches[0].pageX - b.left) / (b.right - b.left) * a.width / 0.75),
					y: Math.floor((c.data.originalEvent.touches[0].pageY - b.top) / (b.bottom - b.top) * a.height / 0.75)
				}
			}
		}
	},
	globalToScrollContainerPosition: function(a, b) {
		return new PIXI.Point(a - this.position.x, b - this.position.y)
	},
	scrollContainerToGlobalPosition: function(a, b) {
		return new PIXI.Point(a + this.position.x, b + this.position.y)
	},
	setScrollBarSize: function(a) {
		this.scrollBarSize = a;
		this.updateScrollContainer()
	},
	setMaxHeight: function(a) {
		this.maxHeight = a;
		this.updateScrollContainer()
	},
	setScrollBarContentMargin: function(a) {
		this.scrollBarContentMargin = a;
		this.updateScrollContainer()
	},
	setScrollBarColor: function(a) {
		this.scrollBarColor = a;
		this.updateScrollContainer()
	},
	setScrollSliderColor: function(a) {
		this.scrollSliderColor = a;
		this.updateScrollContainer()
	},
	forceWidth: function(a) {
		this.forcedWidth = a;
		this.updateScrollContainer()
	},
	forceHeight: function(a) {
		this.forcedHeight = a;
		this.updateScrollContainer()
	},
	setBottomPadding: function(a) {
		this.bottomPadding = a;
		this.updateScrollContainer()
	},
	getChildrenMaxHeight: function(b, a) {
		if (!Sys.isDefined(b)) {
			b = this
		}
		if (Sys.isDefined(b.children) && b.children.length !== 0 && !this.isScrollContainerOwnProperty(b)) {
			if (!Sys.isDefined(a)) {
				a = 0
			}
			var f = this,
				e = b.children;
			for (var d = 0; d < e.length; ++d) {
				a = this.getChildrenMaxHeight(e[d], a);
				var c = !b.isScrollContainer ? b.position.y : 0;
				if (c + e[d].position.y + e[d].height > a && !f.isScrollContainerOwnProperty(e[d]) && !e[d].noHeight) {
					a = c + e[d].position.y + e[d].height
				}
			}
		}
		return a
	},
	getChildrenMaxWidth: function(a, f) {
		if (!Sys.isDefined(a)) {
			a = this
		}
		if (Sys.isDefined(a.children) && a.children.length !== 0 && !this.isScrollContainerOwnProperty(a)) {
			if (!Sys.isDefined(f)) {
				f = 0
			}
			var e = this,
				d = a.children;
			for (var c = 0; c < d.length; ++c) {
				f = this.getChildrenMaxWidth(d[c], f);
				var b = !a.isScrollContainer ? a.position.x : 0;
				if (b + d[c].position.x + d[c].width > f && !e.isScrollContainerOwnProperty(d[c]) && !d[c].noWidth) {
					f = b + d[c].position.x + d[c].width
				}
			}
		}
		return f
	},
	addEventListener: function(g, f) {
		var e = this,
			a = Resources.readData("config"),
			d = Sys.isDefined(a) && Sys.isDefined(a.eventHandler) ? a.eventHandler : EventHandler,
			c;
		d.addListener(e, g);
		c = d.EVENTS[g];
		for (var b = 0; b < c.length; ++b) {
			if (c[b] === e) {
				c[b].handlers = {};
				c[b].handlers[g] = f
			}
		}
	},
	isScrollContainerOwnProperty: function(a) {
		return a.isScrollBar || a.isScrollSlider || a.isMask
	},
	excludeFromWidthMeasure: function(a) {
		for (var b = 0; b < a.length; ++b) {
			a[b].noWidth = true
		}
	},
	excludeFromHeightMeasure: function(a) {
		for (var b = 0; b < a.length; ++b) {
			a[b].noHeight = true
		}
	}
};
Interface.utils.PIXIScrollContainer = Sys.extend(PIXI.Container, Interface.utils.PIXIScrollContainer, "Interface.utils.PIXIScrollContainer");
Sys.ns("Game");
Game.PIXIFactory = {
	createTextureFromSpineAtlas: function(a) {
		return PIXI.Texture.fromFrame(a)
	},
	createSprite: function(d, a, b) {
		var c = new PIXI.Sprite(d);
		c.position = Sys.isDefined(a) ? new PIXI.Point(a.x, a.y) : new PIXI.Point(0, 0);
		c.anchor = Sys.isDefined(b) ? new PIXI.Point(b.x, b.y) : new PIXI.Point(0, 0);
		return c
	},
	createContainer: function(a, c) {
		var b = new PIXI.Container();
		b.position = Sys.isDefined(a) ? new PIXI.Point(a.x, a.y) : new PIXI.Point(0, 0);
		b.pivot = Sys.isDefined(c) ? new PIXI.Point(c.x, c.y) : new PIXI.Point(0, 0);
		return b
	},
	createTexture: function(a) {
		var b;
		b = Sys.isDefined(Resources.readData("animationImages")[a]) ? Resources.readData("animationImages")[a] : PIXI.Texture.EMPTY;
		return b
	},
	createSpriteWithTexture: function(b, a, c) {
		var e, d;
		e = this.createTexture(b);
		d = this.createSprite(e, a, c);
		return d
	},
	createAndAddSprite: function(c, b, a, d) {
		var e = this.createSpriteWithTexture(c, a, d);
		b.addChild(e);
		return e
	},
	createAndAddContainer: function(d, a, c) {
		var b = this.createContainer(a, c);
		d.addChild(b);
		return b
	},
	createAndAddText: function(f, e, c, b, d) {
		if (e.font) {
			Sys.applyProperties(e, Game.PIXIUtils.parseFont(e.font));
			delete e.font
		}
		var a = new PIXI.Text(f, e);
		a.resolution = 2;
		a.position = Sys.isDefined(b) ? new PIXI.Point(b.x, b.y) : new PIXI.Point(0, 0);
		a.anchor = Sys.isDefined(d) ? new PIXI.Point(d.x, d.y) : new PIXI.Point(0, 0);
		c.addChild(a);
		return a
	},
	createAndAddBitmapText: function(f, e, c, b, d) {
		var a = new PIXI.extras.BitmapText(f, e);
		a.position = Sys.isDefined(b) ? new PIXI.Point(b.x, b.y) : new PIXI.Point(0, 0);
		a.anchor = Sys.isDefined(d) ? new PIXI.Point(d.x, d.y) : new PIXI.Point(0, 0);
		c.addChild(a);
		return a
	},
	createVideoElement: function(d, b, g, f) {
		var c = document.createElement("video"),
			e = Resources.readData("videos");
		c.src = e[d];
		c.preload = "auto";
		c.loop = Sys.isDefined(b) ? b : true;
		c.autoplay = Sys.isDefined(g) ? g : false;
		c.type = Sys.isDefined(f) ? f : undefined;
		c.hidden = true;
		if (Platform.isEdgeBrowser) {
			c.id = d;
			c.style.display = "none";
			var a = (document.getElementById("videosHolder")) ? document.getElementById("videosHolder") : document.createElement("div");
			a.id = "videosHolder";
			a.style.position = "absolute";
			a.style.top = "5000px";
			a.style.left = "5000px";
			a.style.display = "block";
			document.body.appendChild(a);
			a.appendChild(c)
		}
		return c
	},
	createAndAddVideo: function(e, b, a, c) {
		var f = PIXI.Texture.fromVideo(e, PIXI.SCALE_MODES.DEFAULT),
			d = this.createSprite(f, a, c);
		b.addChild(d);
		var g = f.baseTexture.source;
		g.pause();
		return d
	},
	playMSEdgeVideo: function(a) {
		var c = "50px",
			b = "0px";
		if (document.getElementById("viewport")) {
			c = document.getElementById("viewport").style.left;
			b = document.getElementById("viewport").style.top
		}
		document.getElementById("videosHolder").style.left = c;
		document.getElementById("videosHolder").style.top = b;
		document.getElementById(a).style.display = "block";
		document.getElementById(a).currentTime = 0;
		document.getElementById(a).play()
	},
	pauseMSEdgeVideo: function(a) {
		document.getElementById("videosHolder").style.left = "5000px";
		document.getElementById("videosHolder").style.top = "5000px";
		document.getElementById(a).style.display = "none";
		document.getElementById(a).pause()
	},
	resetMSEdgeVideo: function(a) {
		document.getElementById("videosHolder").style.left = "5000px";
		document.getElementById("videosHolder").style.top = "5000px";
		document.getElementById(a).style.display = "none"
	},
	createSpineAnimation: function(b, a) {
		var d = Resources.readData("spines")[b],
			c = new PIXI.spine.Spine(d);
		c.position = Sys.isDefined(a) ? new PIXI.Point(a.x, a.y) : new PIXI.Point(0, 0);
		return c
	},
	createAndAddSpineAnimation: function(c, b, a) {
		var d = this.createSpineAnimation(c, a);
		b.addChild(d);
		return d
	},
	createReelAreaGraphic: function(e, h, f, d) {
		var c = Game.stage.model.getCurrentReelGroupConfiguration().reelFrame,
			b = new PIXI.Graphics(),
			g = e ? e : 16711680,
			a = h ? h : 0.3;
		b.beginFill(g, a);
		b.drawRect(c.left, c.top, c.width + (f || 0), c.height + (d || 0));
		b.endFill();
		return b
	}
};
Sys.ns("Game");
Game.PIXIUtils = {
	_tempPoint: new PIXI.Point(),
	hitTestDisplayObject: function(a, c) {
		var b = false;
		if (c.hitArea) {
			c.worldTransform.applyInverse(a, this._tempPoint);
			b = c.hitArea.contains(this._tempPoint.x, this._tempPoint.y)
		} else {
			if (c.containsPoint) {
				b = c.containsPoint(a)
			}
		}
		return b
	},
	resetSpineAnimation: function(a) {
		a.lastTime = null;
		a.skeleton.setToSetupPose();
		a.state.clearTracks()
	},
	mapValue: function(a, b, d, e, c) {
		return (a - b) * (c - e) / (d - b) + e
	},
	parseFont: function(a) {
		var e = {};
		if (a.indexOf("italic") > 1) {
			e.fontStyle = "italic"
		} else {
			if (a.indexOf("oblique") > -1) {
				e.fontStyle = "oblique"
			} else {
				e.fontStyle = "normal"
			}
		}
		if (a.indexOf("small-caps") > -1) {
			e.fontVariant = "small-caps"
		} else {
			e.fontVariant = "normal"
		}
		var d = a.split(" ");
		var c;
		var b = -1;
		e.fontSize = 26;
		for (c = 0; c < d.length; ++c) {
			if (d[c].match(/(px|pt|em|%)/)) {
				b = c;
				e.fontSize = d[c];
				break
			}
		}
		e.fontWeight = "normal";
		for (c = 0; c < b; ++c) {
			if (d[c].match(/(bold|bolder|lighter|100|200|300|400|500|600|700|800|900)/)) {
				e.fontWeight = d[c];
				break
			}
		}
		if (b > -1 && b < d.length - 1) {
			e.fontFamily = "";
			for (c = b + 1; c < d.length; ++c) {
				e.fontFamily += d[c] + " "
			}
			e.fontFamily = e.fontFamily.slice(0, -1)
		} else {
			e.fontFamily = "Arial"
		}
		return e
	},
	getTextWidth: function(k, a) {
		var d;
		if (a.hasOwnProperty("font")) {
			d = a.font
		} else {
			var e = a.fontStyle ? a.fontStyle + " " : "",
				f = a.fontVariant ? a.fontVariant + " " : "",
				j = a.fontWeight ? a.fontWeight + " " : "",
				l = a.fontSize ? a.fontSize + " " : "",
				h = a.fontFamily ? a.fontFamily + " " : "";
			d = e + f + j + l + h
		}
		var c = this.textCanvas || (this.textCanvas = document.createElement("canvas"));
		var b = c.getContext("2d");
		b.font = d;
		var g = b.measureText(k);
		return g.width
	}
};
/*! pixi-particles 2.0.0 */
if (!Array.prototype.shuffle) {
	Object.defineProperty(Array.prototype, "shuffle", {
		enumerable: false,
		writable: false,
		value: function() {
			for (var b, a, c = this.length; c; b = Math.floor(Math.random() * c), a = this[--c], this[c] = this[b], this[b] = a) {}
			return this
		}
	})
}
if (!Array.prototype.random) {
	Object.defineProperty(Array.prototype, "random", {
		enumerable: false,
		writable: false,
		value: function() {
			return this[Math.floor(Math.random() * this.length)]
		}
	})
}(function() {
	var b = typeof window !== "undefined" ? window : GLOBAL;
	var a = {};
	if (typeof module !== "undefined" && module.exports) {
		if (typeof PIXI === "undefined") {
			require("pixi.js")
		}
		module.exports = a
	} else {
		if (typeof PIXI === "undefined") {
			if (true) {
				throw "pixi-particles requires pixi.js to be loaded first"
			} else {
				throw "Requires pixi.js"
			}
		}
	}
	b.PIXI.particles = b.PIXI.particles || a
}());
(function(g, f) {
	var b = g.BLEND_MODES || g.blendModes;
	var c = g.Texture;
	var e = {};
	var a = e.DEG_TO_RADS = Math.PI / 180;
	var d = e.EMPTY_TEXTURE = c.EMPTY;
	d.on = d.destroy = d.once = d.emit = function() {};
	e.rotatePoint = function(m, l) {
		if (!m) {
			return
		}
		m *= a;
		var j = Math.sin(m);
		var n = Math.cos(m);
		var k = l.x * n - l.y * j;
		var h = l.x * j + l.y * n;
		l.x = k;
		l.y = h
	};
	e.combineRGBComponents = function(k, j, h) {
		return k << 16 | j << 8 | h
	};
	e.normalize = function(h) {
		var j = 1 / e.length(h);
		h.x *= j;
		h.y *= j
	};
	e.scaleBy = function(h, j) {
		h.x *= j;
		h.y *= j
	};
	e.length = function(h) {
		return Math.sqrt(h.x * h.x + h.y * h.y)
	};
	e.hexToRGB = function(j, h) {
		if (h) {
			h.length = 0
		} else {
			h = []
		}
		if (j.charAt(0) == "#") {
			j = j.substr(1)
		} else {
			if (j.indexOf("0x") === 0) {
				j = j.substr(2)
			}
		}
		var k;
		if (j.length == 8) {
			k = j.substr(0, 2);
			j = j.substr(2)
		}
		h.push(parseInt(j.substr(0, 2), 16));
		h.push(parseInt(j.substr(2, 2), 16));
		h.push(parseInt(j.substr(4, 2), 16));
		if (k) {
			h.push(parseInt(k, 16))
		}
		return h
	};
	e.generateEase = function(k) {
		var l = k.length;
		var j = 1 / l;
		var h = function(p) {
			var n, o;
			var m = (l * p) | 0;
			n = (p - (m * j)) * l;
			o = k[m] || k[l - 1];
			return (o.s + n * (2 * (1 - n) * (o.cp - o.s) + n * (o.e - o.s)))
		};
		return h
	};
	e.getBlendMode = function(h) {
		if (!h) {
			return b.NORMAL
		}
		h = h.toUpperCase();
		while (h.indexOf(" ") >= 0) {
			h = h.replace(" ", "_")
		}
		return b[h] || b.NORMAL
	};
	g.particles.ParticleUtils = e
}(PIXI));
(function(f, e) {
	var d = f.particles.ParticleUtils;
	var b = f.Sprite;
	var a = function(g) {
		b.call(this);
		this.emitter = g;
		this.anchor.x = this.anchor.y = 0.5;
		this.velocity = new f.Point();
		this.maxLife = 0;
		this.age = 0;
		this.ease = null;
		this.extraData = null;
		this.startAlpha = 0;
		this.endAlpha = 0;
		this.startSpeed = 0;
		this.endSpeed = 0;
		this.acceleration = new f.Point();
		this.maxSpeed = NaN;
		this.startScale = 0;
		this.endScale = 0;
		this.startColor = null;
		this._sR = 0;
		this._sG = 0;
		this._sB = 0;
		this.endColor = null;
		this._eR = 0;
		this._eG = 0;
		this._eB = 0;
		this._doAlpha = false;
		this._doScale = false;
		this._doSpeed = false;
		this._doAcceleration = false;
		this._doColor = false;
		this._doNormalMovement = false;
		this._oneOverLife = 0;
		this.next = null;
		this.prev = null;
		this.init = this.init;
		this.Particle_init = this.Particle_init;
		this.update = this.update;
		this.Particle_update = this.Particle_update;
		this.applyArt = this.applyArt;
		this.kill = this.kill
	};
	var c = a.prototype = Object.create(b.prototype);
	c.init = c.Particle_init = function() {
		this.age = 0;
		this.velocity.x = this.startSpeed;
		this.velocity.y = 0;
		d.rotatePoint(this.rotation, this.velocity);
		if (this.noRotation) {
			this.rotation = 0
		} else {
			this.rotation *= d.DEG_TO_RADS
		}
		this.rotationSpeed *= d.DEG_TO_RADS;
		this.alpha = this.startAlpha;
		this.scale.x = this.scale.y = this.startScale;
		if (this.startColor) {
			this._sR = this.startColor[0];
			this._sG = this.startColor[1];
			this._sB = this.startColor[2];
			if (this.endColor) {
				this._eR = this.endColor[0];
				this._eG = this.endColor[1];
				this._eB = this.endColor[2]
			}
		}
		this._doAlpha = this.startAlpha != this.endAlpha;
		this._doSpeed = this.startSpeed != this.endSpeed;
		this._doScale = this.startScale != this.endScale;
		this._doColor = !!this.endColor;
		this._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;
		this._doNormalMovement = this._doSpeed || this.startSpeed !== 0 || this._doAcceleration;
		this._oneOverLife = 1 / this.maxLife;
		this.tint = d.combineRGBComponents(this._sR, this._sG, this._sB);
		this.visible = true
	};
	c.applyArt = function(g) {
		this.texture = g || d.EMPTY_TEXTURE
	};
	c.update = c.Particle_update = function(p) {
		this.age += p;
		if (this.age >= this.maxLife) {
			this.kill();
			return -1
		}
		var j = this.age * this._oneOverLife;
		if (this.ease) {
			if (this.ease.length == 4) {
				j = this.ease(j, 0, 1, 1)
			} else {
				j = this.ease(j)
			}
		}
		if (this._doAlpha) {
			this.alpha = (this.endAlpha - this.startAlpha) * j + this.startAlpha
		}
		if (this._doScale) {
			var o = (this.endScale - this.startScale) * j + this.startScale;
			this.scale.x = this.scale.y = o
		}
		if (this._doNormalMovement) {
			if (this._doSpeed) {
				var n = (this.endSpeed - this.startSpeed) * j + this.startSpeed;
				d.normalize(this.velocity);
				d.scaleBy(this.velocity, n)
			} else {
				if (this._doAcceleration) {
					this.velocity.x += this.acceleration.x * p;
					this.velocity.y += this.acceleration.y * p;
					if (this.maxSpeed) {
						var k = d.length(this.velocity);
						if (k > this.maxSpeed) {
							d.scaleBy(this.velocity, this.maxSpeed / k)
						}
					}
				}
			}
			this.position.x += this.velocity.x * p;
			this.position.y += this.velocity.y * p
		}
		if (this._doColor) {
			var m = (this._eR - this._sR) * j + this._sR;
			var l = (this._eG - this._sG) * j + this._sG;
			var h = (this._eB - this._sB) * j + this._sB;
			this.tint = d.combineRGBComponents(m, l, h)
		}
		if (this.rotationSpeed !== 0) {
			this.rotation += this.rotationSpeed * p
		} else {
			if (this.acceleration && !this.noRotation) {
				this.rotation = Math.atan2(this.velocity.y, this.velocity.x)
			}
		}
		return j
	};
	c.kill = function() {
		this.emitter.recycle(this)
	};
	c.Sprite_Destroy = b.prototype.destroy;
	c.destroy = function() {
		if (this.parent) {
			this.parent.removeChild(this)
		}
		if (this.Sprite_Destroy) {
			this.Sprite_Destroy()
		}
		this.emitter = this.velocity = this.startColor = this.endColor = this.ease = this.next = this.prev = null
	};
	a.parseArt = function(h) {
		var g;
		for (g = h.length; g >= 0; --g) {
			if (typeof h[g] == "string") {
				h[g] = f.Texture.fromImage(h[g])
			}
		}
		if (true) {
			for (g = h.length - 1; g > 0; --g) {
				if (h[g].baseTexture != h[g - 1].baseTexture) {
					if (window.console) {
						break
					}
				}
			}
		}
		return h
	};
	a.parseData = function(g) {
		return g
	};
	f.particles.Particle = a
}(PIXI));
(function(h, g) {
	var e = h.particles.ParticleUtils,
		a = h.particles.Particle,
		c = h.particles.ParticleContainer || h.ParticleContainer;
	var b = function(l, j, k) {
		this._particleConstructor = a;
		this.particleImages = null;
		this.startAlpha = 1;
		this.endAlpha = 1;
		this.startSpeed = 0;
		this.endSpeed = 0;
		this.minimumSpeedMultiplier = 1;
		this.acceleration = null;
		this.maxSpeed = NaN;
		this.startScale = 1;
		this.endScale = 1;
		this.minimumScaleMultiplier = 1;
		this.startColor = null;
		this.endColor = null;
		this.minLifetime = 0;
		this.maxLifetime = 0;
		this.minStartRotation = 0;
		this.maxStartRotation = 0;
		this.noRotation = false;
		this.minRotationSpeed = 0;
		this.maxRotationSpeed = 0;
		this.particleBlendMode = 0;
		this.customEase = null;
		this.extraData = null;
		this._frequency = 1;
		this.maxParticles = 1000;
		this.emitterLifetime = -1;
		this.spawnPos = null;
		this.spawnType = null;
		this._spawnFunc = null;
		this.spawnRect = null;
		this.spawnCircle = null;
		this.particlesPerWave = 1;
		this.particleSpacing = 0;
		this.angleStart = 0;
		this.rotation = 0;
		this.ownerPos = null;
		this._prevEmitterPos = null;
		this._prevPosIsValid = false;
		this._posChanged = false;
		this._parentIsPC = false;
		this._parent = null;
		this.addAtBack = false;
		this.particleCount = 0;
		this._emit = false;
		this._spawnTimer = 0;
		this._emitterLife = -1;
		this._activeParticlesFirst = null;
		this._activeParticlesLast = null;
		this._poolFirst = null;
		this._origConfig = null;
		this._origArt = null;
		this.parent = l;
		if (j && k) {
			this.init(j, k)
		}
		this.recycle = this.recycle;
		this.update = this.update;
		this.rotate = this.rotate;
		this.updateSpawnPos = this.updateSpawnPos;
		this.updateOwnerPos = this.updateOwnerPos
	};
	var d = b.prototype = {};
	var f = new h.Point();
	Object.defineProperty(d, "frequency", {
		get: function() {
			return this._frequency
		},
		set: function(j) {
			if (typeof j == "number" && j > 0) {
				this._frequency = j
			} else {
				this._frequency = 1
			}
		}
	});
	Object.defineProperty(d, "particleConstructor", {
		get: function() {
			return this._particleConstructor
		},
		set: function(j) {
			if (j != this._particleConstructor) {
				this._particleConstructor = j;
				this.cleanup();
				for (var k = this._poolFirst; k; k = k.next) {
					k.destroy()
				}
				this._poolFirst = null;
				if (this._origConfig && this._origArt) {
					this.init(this._origArt, this._origConfig)
				}
			}
		}
	});
	Object.defineProperty(d, "parent", {
		get: function() {
			return this._parent
		},
		set: function(j) {
			if (this._parentIsPC) {
				for (var k = this._poolFirst; k; k = k.next) {
					if (k.parent) {
						k.parent.removeChild(k)
					}
				}
			}
			this.cleanup();
			this._parent = j;
			this._parentIsPC = c && j && j instanceof c
		}
	});
	d.init = function(n, j) {
		if (!n || !j) {
			return
		}
		this.cleanup();
		this._origConfig = j;
		this._origArt = n;
		n = Array.isArray(n) ? n.slice() : [n];
		var o = this._particleConstructor;
		this.particleImages = o.parseArt ? o.parseArt(n) : n;
		if (j.alpha) {
			this.startAlpha = j.alpha.start;
			this.endAlpha = j.alpha.end
		} else {
			this.startAlpha = this.endAlpha = 1
		}
		if (j.speed) {
			this.startSpeed = j.speed.start;
			this.endSpeed = j.speed.end;
			this.minimumSpeedMultiplier = j.speed.minimumSpeedMultiplier || 1
		} else {
			this.minimumSpeedMultiplier = 1;
			this.startSpeed = this.endSpeed = 0
		}
		var l = j.acceleration;
		if (l && (l.x || l.y)) {
			this.endSpeed = this.startSpeed;
			this.acceleration = new h.Point(l.x, l.y);
			this.maxSpeed = j.maxSpeed || NaN
		} else {
			this.acceleration = new h.Point()
		}
		if (j.scale) {
			this.startScale = j.scale.start;
			this.endScale = j.scale.end;
			this.minimumScaleMultiplier = j.scale.minimumScaleMultiplier || 1
		} else {
			this.startScale = this.endScale = this.minimumScaleMultiplier = 1
		}
		if (j.color) {
			this.startColor = e.hexToRGB(j.color.start);
			if (j.color.start != j.color.end) {
				this.endColor = e.hexToRGB(j.color.end)
			} else {
				this.endColor = null
			}
		}
		if (j.startRotation) {
			this.minStartRotation = j.startRotation.min;
			this.maxStartRotation = j.startRotation.max
		} else {
			this.minStartRotation = this.maxStartRotation = 0
		}
		if (j.noRotation && (this.minStartRotation || this.maxStartRotation)) {
			this.noRotation = !!j.noRotation
		} else {
			this.noRotation = false
		}
		if (j.rotationSpeed) {
			this.minRotationSpeed = j.rotationSpeed.min;
			this.maxRotationSpeed = j.rotationSpeed.max
		} else {
			this.minRotationSpeed = this.maxRotationSpeed = 0
		}
		this.minLifetime = j.lifetime.min;
		this.maxLifetime = j.lifetime.max;
		this.particleBlendMode = e.getBlendMode(j.blendMode);
		if (j.ease) {
			this.customEase = typeof j.ease == "function" ? j.ease : e.generateEase(j.ease)
		} else {
			this.customEase = null
		}
		if (o.parseData) {
			this.extraData = o.parseData(j.extraData)
		} else {
			this.extraData = j.extraData || null
		}
		this.spawnRect = this.spawnCircle = null;
		this.particlesPerWave = 1;
		this.particleSpacing = 0;
		this.angleStart = 0;
		var m;
		switch (j.spawnType) {
			case "rect":
				this.spawnType = "rect";
				this._spawnFunc = this._spawnRect;
				var k = j.spawnRect;
				this.spawnRect = new h.Rectangle(k.x, k.y, k.w, k.h);
				break;
			case "circle":
				this.spawnType = "circle";
				this._spawnFunc = this._spawnCircle;
				m = j.spawnCircle;
				this.spawnCircle = new h.Circle(m.x, m.y, m.r);
				break;
			case "ring":
				this.spawnType = "ring";
				this._spawnFunc = this._spawnRing;
				m = j.spawnCircle;
				this.spawnCircle = new h.Circle(m.x, m.y, m.r);
				this.spawnCircle.minRadius = m.minR;
				break;
			case "burst":
				this.spawnType = "burst";
				this._spawnFunc = this._spawnBurst;
				this.particlesPerWave = j.particlesPerWave;
				this.particleSpacing = j.particleSpacing;
				this.angleStart = j.angleStart ? j.angleStart : 0;
				break;
			case "point":
				this.spawnType = "point";
				this._spawnFunc = this._spawnPoint;
				break;
			default:
				this.spawnType = "point";
				this._spawnFunc = this._spawnPoint;
				break
		}
		this.frequency = j.frequency;
		this.emitterLifetime = j.emitterLifetime || -1;
		this.maxParticles = j.maxParticles > 0 ? j.maxParticles : 1000;
		this.addAtBack = !!j.addAtBack;
		this.rotation = 0;
		this.ownerPos = new h.Point();
		this.spawnPos = new h.Point(j.pos.x, j.pos.y);
		this._prevEmitterPos = this.spawnPos.clone();
		this._prevPosIsValid = false;
		this._spawnTimer = 0;
		this.emit = j.emit === g ? true : !!j.emit
	};
	d.recycle = function(j) {
		if (j.next) {
			j.next.prev = j.prev
		}
		if (j.prev) {
			j.prev.next = j.next
		}
		if (j == this._activeParticlesLast) {
			this._activeParticlesLast = j.prev
		}
		if (j == this._activeParticlesFirst) {
			this._activeParticlesFirst = j.next
		}
		j.prev = null;
		j.next = this._poolFirst;
		this._poolFirst = j;
		if (this._parentIsPC) {
			j.alpha = 0;
			j.visible = false
		} else {
			if (j.parent) {
				j.parent.removeChild(j)
			}
		}--this.particleCount
	};
	d.rotate = function(j) {
		if (this.rotation == j) {
			return
		}
		var k = j - this.rotation;
		this.rotation = j;
		e.rotatePoint(k, this.spawnPos);
		this._posChanged = true
	};
	d.updateSpawnPos = function(j, k) {
		this._posChanged = true;
		this.spawnPos.x = j;
		this.spawnPos.y = k
	};
	d.updateOwnerPos = function(j, k) {
		this._posChanged = true;
		this.ownerPos.x = j;
		this.ownerPos.y = k
	};
	d.resetPositionTracking = function() {
		this._prevPosIsValid = false
	};
	Object.defineProperty(d, "emit", {
		get: function() {
			return this._emit
		},
		set: function(j) {
			this._emit = !!j;
			this._emitterLife = this.emitterLifetime
		}
	});
	d.update = function(A) {
		if (!this._parent) {
			return
		}
		var q, w, r;
		for (w = this._activeParticlesFirst; w; w = r) {
			r = w.next;
			w.update(A)
		}
		var y, x;
		if (this._prevPosIsValid) {
			y = this._prevEmitterPos.x;
			x = this._prevEmitterPos.y
		}
		var l = this.ownerPos.x + this.spawnPos.x;
		var j = this.ownerPos.y + this.spawnPos.y;
		if (this.emit) {
			this._spawnTimer -= A;
			while (this._spawnTimer <= 0) {
				if (this._emitterLife > 0) {
					this._emitterLife -= this._frequency;
					if (this._emitterLife <= 0) {
						this._spawnTimer = 0;
						this._emitterLife = 0;
						this.emit = false;
						break
					}
				}
				if (this.particleCount >= this.maxParticles) {
					this._spawnTimer += this._frequency;
					continue
				}
				var o;
				if (this.minLifetime == this.maxLifetime) {
					o = this.minLifetime
				} else {
					o = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime
				}
				if (-this._spawnTimer < o) {
					var v, s;
					if (this._prevPosIsValid && this._posChanged) {
						var n = 1 + this._spawnTimer / A;
						v = (l - y) * n + y;
						s = (j - x) * n + x
					} else {
						v = l;
						s = j
					}
					q = 0;
					for (var u = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); q < u; ++q) {
						var k, z;
						if (this._poolFirst) {
							k = this._poolFirst;
							this._poolFirst = this._poolFirst.next;
							k.next = null
						} else {
							k = new this.particleConstructor(this)
						}
						if (this.particleImages.length > 1) {
							k.applyArt(this.particleImages.random())
						} else {
							k.applyArt(this.particleImages[0])
						}
						k.startAlpha = this.startAlpha;
						k.endAlpha = this.endAlpha;
						if (this.minimumSpeedMultiplier != 1) {
							z = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;
							k.startSpeed = this.startSpeed * z;
							k.endSpeed = this.endSpeed * z
						} else {
							k.startSpeed = this.startSpeed;
							k.endSpeed = this.endSpeed
						}
						k.acceleration.x = this.acceleration.x;
						k.acceleration.y = this.acceleration.y;
						k.maxSpeed = this.maxSpeed;
						if (this.minimumScaleMultiplier != 1) {
							z = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;
							k.startScale = this.startScale * z;
							k.endScale = this.endScale * z
						} else {
							k.startScale = this.startScale;
							k.endScale = this.endScale
						}
						k.startColor = this.startColor;
						k.endColor = this.endColor;
						if (this.minRotationSpeed == this.maxRotationSpeed) {
							k.rotationSpeed = this.minRotationSpeed
						} else {
							k.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed
						}
						k.noRotation = this.noRotation;
						k.maxLife = o;
						k.blendMode = this.particleBlendMode;
						k.ease = this.customEase;
						k.extraData = this.extraData;
						this._spawnFunc(k, v, s, q);
						k.init();
						k.update(-this._spawnTimer);
						if (!this._parentIsPC || !k.parent) {
							if (this.addAtBack) {
								this._parent.addChildAt(k, 0)
							} else {
								this._parent.addChild(k)
							}
						} else {
							var m = this._parent.children;
							if (m[0] == k) {
								m.shift()
							} else {
								if (m[m.length - 1] == k) {
									m.pop()
								} else {
									var t = m.indexOf(k);
									m.splice(t, 1)
								}
							}
							if (this.addAtBack) {
								m.unshift(k)
							} else {
								m.push(k)
							}
						}
						if (this._activeParticlesLast) {
							this._activeParticlesLast.next = k;
							k.prev = this._activeParticlesLast;
							this._activeParticlesLast = k
						} else {
							this._activeParticlesLast = this._activeParticlesFirst = k
						}++this.particleCount
					}
				}
				this._spawnTimer += this._frequency
			}
		}
		if (this._posChanged) {
			this._prevEmitterPos.x = l;
			this._prevEmitterPos.y = j;
			this._prevPosIsValid = true;
			this._posChanged = false
		}
	};
	d._spawnPoint = function(m, k, j, l) {
		if (this.minStartRotation == this.maxStartRotation) {
			m.rotation = this.minStartRotation + this.rotation
		} else {
			m.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation
		}
		m.position.x = k;
		m.position.y = j
	};
	d._spawnRect = function(m, k, j, l) {
		if (this.minStartRotation == this.maxStartRotation) {
			m.rotation = this.minStartRotation + this.rotation
		} else {
			m.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation
		}
		f.x = Math.random() * this.spawnRect.width + this.spawnRect.x;
		f.y = Math.random() * this.spawnRect.height + this.spawnRect.y;
		if (this.rotation !== 0) {
			e.rotatePoint(this.rotation, f)
		}
		m.position.x = k + f.x;
		m.position.y = j + f.y
	};
	d._spawnCircle = function(m, k, j, l) {
		if (this.minStartRotation == this.maxStartRotation) {
			m.rotation = this.minStartRotation + this.rotation
		} else {
			m.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation
		}
		f.x = Math.random() * this.spawnCircle.radius;
		f.y = 0;
		e.rotatePoint(Math.random() * 360, f);
		f.x += this.spawnCircle.x;
		f.y += this.spawnCircle.y;
		if (this.rotation !== 0) {
			e.rotatePoint(this.rotation, f)
		}
		m.position.x = k + f.x;
		m.position.y = j + f.y
	};
	d._spawnRing = function(n, k, j, l) {
		var m = this.spawnCircle;
		if (this.minStartRotation == this.maxStartRotation) {
			n.rotation = this.minStartRotation + this.rotation
		} else {
			n.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation
		}
		if (m.minRadius == m.radius) {
			f.x = Math.random() * (m.radius - m.minRadius) + m.minRadius
		} else {
			f.x = m.radius
		}
		f.y = 0;
		var o = Math.random() * 360;
		n.rotation += o;
		e.rotatePoint(o, f);
		f.x += this.spawnCircle.x;
		f.y += this.spawnCircle.y;
		if (this.rotation !== 0) {
			e.rotatePoint(this.rotation, f)
		}
		n.position.x = k + f.x;
		n.position.y = j + f.y
	};
	d._spawnBurst = function(m, k, j, l) {
		if (this.particleSpacing === 0) {
			m.rotation = Math.random() * 360
		} else {
			m.rotation = this.angleStart + (this.particleSpacing * l) + this.rotation
		}
		m.position.x = k;
		m.position.y = j
	};
	d.cleanup = function() {
		var k, j;
		for (k = this._activeParticlesFirst; k; k = j) {
			j = k.next;
			this.recycle(k);
			if (k.parent) {
				k.parent.removeChild(k)
			}
		}
		this._activeParticlesFirst = this._activeParticlesLast = null;
		this.particleCount = 0
	};
	d.destroy = function() {
		this.cleanup();
		var j;
		for (var k = this._poolFirst; k; k = j) {
			j = k.next;
			k.destroy()
		}
		this._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos = this.startColor = this.endColor = this.customEase = null
	};
	h.particles.Emitter = b
}(PIXI));
(function(PIXI, undefined) {
	var ParticleUtils = PIXI.particles.ParticleUtils,
		Particle = PIXI.particles.Particle;
	var PathParticle = function(emitter) {
		Particle.call(this, emitter);
		this.path = null;
		this.initialRotation = 0;
		this.initialPosition = new PIXI.Point();
		this.movement = 0
	};
	var s = Particle.prototype;
	var p = PathParticle.prototype = Object.create(s);
	var helperPoint = new PIXI.Point();
	p.init = function() {
		this.initialRotation = this.rotation;
		this.Particle_init();
		this.path = this.extraData.path;
		this._doNormalMovement = !this.path;
		this.movement = 0;
		this.initialPosition.x = this.position.x;
		this.initialPosition.y = this.position.y
	};
	var MATH_FUNCS = ["pow", "sqrt", "abs", "floor", "round", "ceil", "E", "PI", "sin", "cos", "tan", "asin", "acos", "atan", "atan2", "log"];
	var WHITELISTER = "[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]";
	for (var index = MATH_FUNCS.length - 1; index >= 0; --index) {
		WHITELISTER += "|" + MATH_FUNCS[index]
	}
	WHITELISTER = new RegExp(WHITELISTER, "g");
	var parsePath = function(pathString) {
		var rtn;
		var matches = pathString.match(WHITELISTER);
		for (var i = matches.length - 1; i >= 0; --i) {
			if (MATH_FUNCS.indexOf(matches[i]) >= 0) {
				matches[i] = "Math." + matches[i]
			}
		}
		pathString = matches.join("");
		eval("rtn = function(x){ return " + pathString + "; };");
		return rtn
	};
	p.update = function(delta) {
		var lerp = this.Particle_update(delta);
		if (lerp >= 0 && this.path) {
			var speed = (this.endSpeed - this.startSpeed) * lerp + this.startSpeed;
			this.movement += speed * delta;
			helperPoint.x = this.movement;
			helperPoint.y = this.path(this.movement);
			ParticleUtils.rotatePoint(this.initialRotation, helperPoint);
			this.position.x = this.initialPosition.x + helperPoint.x;
			this.position.y = this.initialPosition.y + helperPoint.y
		}
	};
	p.Particle_destroy = Particle.prototype.destroy;
	p.destroy = function() {
		this.Particle_destroy();
		this.path = this.initialPosition = null
	};
	PathParticle.parseArt = function(art) {
		return Particle.parseArt(art)
	};
	PathParticle.parseData = function(extraData) {
		var output = {};
		if (extraData && extraData.path) {
			try {
				output.path = parsePath(extraData.path)
			} catch (e) {
				if (true) {
					output.path = null
				}
			}
		} else {
			if (true) {
				output.path = null
			}
		}
		return output
	};
	PIXI.particles.PathParticle = PathParticle
}(PIXI));
(function(h, g) {
	var f = h.particles.ParticleUtils,
		a = h.particles.Particle,
		c = h.Texture;
	var b = function(j) {
		a.call(this, j);
		this.textures = null;
		this.duration = 0;
		this.framerate = 0;
		this.elapsed = 0;
		this.loop = false
	};
	var d = a.prototype;
	var e = b.prototype = Object.create(d);
	e.init = function() {
		this.Particle_init();
		this.elapsed = 0;
		if (this.framerate < 0) {
			this.duration = this.maxLife;
			this.framerate = this.textures.length / this.duration
		}
	};
	e.applyArt = function(j) {
		this.textures = j.textures;
		this.framerate = j.framerate;
		this.duration = j.duration;
		this.loop = j.loop
	};
	e.update = function(k) {
		if (this.Particle_update(k) >= 0) {
			this.elapsed += k;
			if (this.elapsed > this.duration) {
				if (this.loop) {
					this.elapsed = this.elapsed % this.duration
				} else {
					this.elapsed = this.duration - 0.000001
				}
			}
			var j = (this.elapsed * this.framerate + 1e-7) | 0;
			this.texture = this.textures[j] || f.EMPTY_TEXTURE
		}
	};
	e.Particle_destroy = a.prototype.destroy;
	e.destroy = function() {
		this.Particle_destroy();
		this.textures = null
	};
	b.parseArt = function(l) {
		var o, n, k = [],
			m, q, r, p;
		for (o = 0; o < l.length; ++o) {
			n = l[o];
			l[o] = k = {};
			k.textures = p = [];
			q = n.textures;
			for (m = 0; m < q.length; ++m) {
				r = q[m];
				if (typeof r == "string") {
					p.push(c.fromImage(r))
				} else {
					if (r instanceof c) {
						p.push(r)
					} else {
						var s = r.count || 1;
						if (typeof r.texture == "string") {
							r = c.fromImage(r.texture)
						} else {
							r = r.texture
						}
						for (; s > 0; --s) {
							p.push(r)
						}
					}
				}
			}
			if (n.framerate == "matchLife") {
				k.framerate = -1;
				k.duration = 0;
				k.loop = false
			} else {
				k.loop = !!n.loop;
				k.framerate = n.framerate > 0 ? n.framerate : 60;
				k.duration = p.length / k.framerate
			}
		}
		return l
	};
	h.particles.AnimatedParticle = b
}(PIXI));
(function(a) {}());
/*! pixi-particles 1.6.8 */
(function(PIXI, undefined) {
	var ParticleUtils = PIXI.particles.ParticleUtils,
		Particle = PIXI.particles.Particle;
	var PathParticle = function(emitter) {
		Particle.call(this, emitter);
		this.path = null;
		this.initialRotation = 0;
		this.initialPosition = new PIXI.Point();
		this.movement = 0
	};
	var s = Particle.prototype;
	var p = PathParticle.prototype = Object.create(s);
	var helperPoint = new PIXI.Point();
	p.init = function() {
		this.initialRotation = this.rotation;
		this.Particle_init();
		this.path = this.extraData.path;
		this._doNormalMovement = !this.path;
		this.movement = 0;
		this.initialPosition.x = this.position.x;
		this.initialPosition.y = this.position.y
	};
	var MATH_FUNCS = ["pow", "sqrt", "abs", "floor", "round", "ceil", "E", "PI", "sin", "cos", "tan", "asin", "acos", "atan", "atan2", "log"];
	var WHITELISTER = "[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]";
	for (var index = MATH_FUNCS.length - 1; index >= 0; --index) {
		WHITELISTER += "|" + MATH_FUNCS[index]
	}
	WHITELISTER = new RegExp(WHITELISTER, "g");
	var parsePath = function(pathString) {
		var rtn;
		var matches = pathString.match(WHITELISTER);
		for (var i = matches.length - 1; i >= 0; --i) {
			if (MATH_FUNCS.indexOf(matches[i]) >= 0) {
				matches[i] = "Math." + matches[i]
			}
		}
		pathString = matches.join("");
		eval("rtn = function(x){ return " + pathString + "; };");
		return rtn
	};
	p.update = function(delta) {
		var lerp = this.Particle_update(delta);
		if (lerp >= 0 && this.path) {
			var speed = (this.endSpeed - this.startSpeed) * lerp + this.startSpeed;
			this.movement += speed * delta;
			helperPoint.x = this.movement;
			helperPoint.y = this.path(this.movement);
			ParticleUtils.rotatePoint(this.initialRotation, helperPoint);
			this.position.x = this.initialPosition.x + helperPoint.x;
			this.position.y = this.initialPosition.y + helperPoint.y
		}
	};
	p.Particle_destroy = Particle.prototype.destroy;
	p.destroy = function() {
		this.Particle_destroy();
		this.path = this.initialPosition = null
	};
	PathParticle.parseArt = function(art) {
		return Particle.parseArt(art)
	};
	PathParticle.parseData = function(extraData) {
		var output = {};
		if (extraData && extraData.path) {
			try {
				output.path = parsePath(extraData.path)
			} catch (e) {
				if (true) {
					output.path = null
				}
			}
		} else {
			if (true) {
				output.path = null
			}
		}
		return output
	};
	PIXI.particles.PathParticle = PathParticle
}(PIXI));
/*! pixi-particles 1.6.8 */
(function(b, c) {
	var h = b.particles.ParticleUtils,
		d = b.particles.Particle,
		e = b.Texture;
	var g = h.useAPI3;
	var f = function(k) {
		d.call(this, k);
		this.textures = null;
		this.duration = 0;
		this.framerate = 0;
		this.elapsed = 0;
		this.loop = false
	};
	var j = d.prototype;
	var a = f.prototype = Object.create(j);
	a.init = function() {
		this.Particle_init();
		this.elapsed = 0;
		if (this.framerate < 0) {
			this.duration = this.maxLife;
			this.framerate = this.textures.length / this.duration
		}
	};
	a.applyArt = function(k) {
		this.textures = k.textures;
		this.framerate = k.framerate;
		this.duration = k.duration;
		this.loop = k.loop
	};
	a.update = function(l) {
		if (this.Particle_update(l) >= 0) {
			this.elapsed += l;
			if (this.elapsed > this.duration) {
				if (this.loop) {
					this.elapsed = this.elapsed % this.duration
				} else {
					this.elapsed = this.duration - 0.000001
				}
			}
			var k = (this.elapsed * this.framerate + 1e-7) | 0;
			if (g) {
				this.texture = this.textures[k] || h.EMPTY_TEXTURE
			} else {
				this.setTexture(this.textures[k] || h.EMPTY_TEXTURE)
			}
		}
	};
	a.Particle_destroy = d.prototype.destroy;
	a.destroy = function() {
		this.Particle_destroy();
		this.textures = null
	};
	f.parseArt = function(l) {
		var o, n, k = [],
			m, q, r, p;
		for (o = 0; o < l.length; ++o) {
			n = l[o];
			l[o] = k = {};
			k.textures = p = [];
			q = n.textures;
			for (m = 0; m < q.length; ++m) {
				r = q[m];
				if (typeof r == "string") {
					p.push(e.fromImage(r))
				} else {
					if (r instanceof e) {
						p.push(r)
					} else {
						var s = r.count || 1;
						if (typeof r.texture == "string") {
							r = e.fromImage(r.texture)
						} else {
							r = r.texture
						}
						for (; s > 0; --s) {
							p.push(r)
						}
					}
				}
			}
			if (n.framerate == "matchLife") {
				k.framerate = -1;
				k.duration = 0;
				k.loop = false
			} else {
				k.loop = !!n.loop;
				k.framerate = n.framerate > 0 ? n.framerate : 60;
				k.duration = p.length / k.framerate
			}
		}
		return l
	};
	b.particles.AnimatedParticle = f
}(PIXI));
Sys.ns("Game");
Game.PIXIParticleFactory = {
	createAndAddParticleEmitter: function(l, k, g, h, e) {
		var o = Resources.readData("emitters");
		var j = o[l];
		if (Sys.isDefined(e)) {
			var m = Sys.isArray(e) ? e.length : e,
				n = [],
				d, b = m.toString().length,
				f;
			for (f = 0; f < m; f++) {
				d = Sys.utils.repeatString("0", (b - f.toString().length)) + f;
				n.push(PIXI.Texture.fromFrame(g + d + ".png"))
			}
			g = n;
			if (!Sys.isArray(e)) {
				e = Sys.utils.initArray(m, 33.333)
			}
		}
		var a = new PIXI.particles.Emitter(k, g, j);
		if (Sys.isDefined(e)) {
			a.particleConstructor = PIXI.particles.Particle;
			a.frameTimes = e
		}
		var c = new Animation.Holder({
			id: "emitterHolder" + l,
			target: a,
			loop: true,
			addToAnimationLoop: h,
			onUpdate: function(p) {
				a.update(p * 0.001)
			}
		});
		return c
	}
};
Sys.ns("Animation");
Animation.Holder = {
	constructor: function(a) {
		var c = this,
			b = {
				id: undefined,
				target: undefined,
				prop: undefined,
				animation: {
					keyFrames: [],
					step: 0,
					complete: false
				},
				running: false,
				playbackSpeed: undefined,
				loop: false,
				readyToLoop: false,
				onStart: undefined,
				onEnd: undefined,
				onUpdate: undefined,
				children: [],
				parent: undefined,
				localTime: 0,
				delay: 0,
				startTimeOffset: undefined,
				addToAnimationLoop: false
			};
		a = Sys.applyProperties(b, a);
		a = c.parseConfig(a);
		c = Sys.applyProperties(c, a);
		if (a.addToAnimationLoop) {
			Game.stage.view.animationManager.addToAnimationLoop(c)
		}
	},
	parseConfig: function(a) {
		var b = {
				animation: {
					keyFrames: [],
					step: 0,
					complete: false
				}
			},
			d = function(j, h) {
				return (j.time - h.time)
			},
			e;
		Sys.iterate(a, function(h, j) {
			if (h === "animate") {
				if (Sys.isObj(j)) {
					Sys.iterate(j, function(l, k) {
						e = {
							time: Sys.utils.toInt(l)
						};
						if (Sys.isObj(k)) {
							if (Sys.isDefined(k.value)) {
								e = Sys.applyProperties(e, k)
							} else {
								e.value = k
							}
						} else {
							e.value = k
						}
						b.animation.keyFrames.push(e)
					});
					b.animation.keyFrames.sort(d)
				} else {
					if (Sys.isArray(j)) {
						b.animation.keyFrames = j
					} else {}
				}
			} else {
				b[h] = j
			}
		});
		if (!Sys.isDefined(b.target) && Sys.isDefined(b.parent) && Sys.isDefined(b.parent.target)) {
			b.target = b.parent.target
		}
		if (!Sys.isDefined(b.id) && Sys.isDefined(b.target) && Sys.isDefined(b.target.id)) {
			var g = Sys.isDefined(b.prop) ? b.prop : "";
			b.id = b.target.id + ":" + g + "Animation"
		}
		if (Sys.isDefined(b.children) && b.children.length > 0) {
			var f = [],
				c = this;
			b.children.forEach(function(j) {
				var h;
				if (Sys.isDefined(j.localTime)) {
					h = j
				} else {
					j.parent = {
						target: a.target
					};
					h = new Animation.Holder(j)
				}
				h.parent = c;
				f.push(h)
			});
			b.children = f
		}
		return b
	},
	run: function(c) {
		var a = this,
			b = c.timeStep;
		if (a.localTime === 0 && Sys.isDefined(a.startTimeOffset)) {
			b += a.startTimeOffset
		}
		if (Sys.isDefined(a.playbackSpeed)) {
			b *= a.playbackSpeed
		}
		a.localTime += b;
		if (a.localTime >= a.delay) {
			a.doAnimation(b);
			a.children.forEach(function(d) {
				if (d.running) {
					d.run({
						timeStep: b,
						time: c.time
					});
					if (d.running) {
						a.running = true;
						if (!d.loop && !d.readyToLoop) {
							a.readyToLoop = false
						}
					}
				}
			});
			if (Sys.isDefined(a.onUpdate)) {
				a.onUpdate(b)
			}
		}
		if (a.loop && a.readyToLoop) {
			a.restoreOnLoop()
		} else {
			if (!a.running) {
				if (Sys.isDefined(a.onEnd)) {
					a.onEnd()
				}
				a.restore()
			}
		}
	},
	doAnimation: function(a) {
		var d = this,
			c = d.animation.keyFrames.length;
		if (c < 2 || !Sys.isDefined(d.target)) {
			d.readyToLoop = true;
			d.running = false;
			return
		}
		var b = d.performAction(a);
		if (!b) {
			d.running = false;
			d.readyToLoop = true
		}
	},
	play: function(c, a) {
		var d = this,
			b = Sys.isDefined(a) ? a : true;
		d.running = true;
		d.handleItems("play", c);
		if (d.localTime === 0 && Sys.isDefined(d.onStart)) {
			d.onStart()
		}
		if (b) {
			d.runParent()
		}
	},
	runParent: function() {
		var a = this;
		if (Sys.isDefined(a.parent)) {
			a.parent.running = true;
			a.parent.runParent()
		}
	},
	pause: function(a) {
		this.running = false;
		this.handleItems("pause", a)
	},
	stop: function(c, a) {
		var d = this,
			b = Sys.isDefined(a) ? a : true;
		d.running = false;
		d.handleItems("stop", c);
		if (b) {
			d.restore(c, true)
		}
	},
	restore: function(c, a) {
		var d = this,
			b = Sys.isDefined(a) ? a : true;
		d.localTime = 0;
		d.readyToLoop = false;
		d.restoreAnimation();
		d.handleItems("restore", c);
		if (d.running && b) {
			d.play(c, true)
		}
	},
	restoreOnLoop: function(c, a) {
		var d = this,
			b = Sys.isDefined(a) ? a : true;
		if (b || !d.loop) {
			d.running = true;
			d.readyToLoop = false;
			d.restoreAnimation();
			d.handleItems("restoreOnLoop")
		}
	},
	restoreAnimation: function() {
		this.animation.time = 0;
		this.animation.step = 0;
		this.animation.keyFrames.forEach(function(a) {
			if (Sys.isDefined(a.callback)) {
				a.callbackCompleted = false
			}
		})
	},
	updateOperation: function(a) {
		var b = this,
			c = {};
		c.animate = a;
		c = b.parseConfig(c);
		b.animation = c.animation;
		b.restore()
	},
	handleItems: function(c, b) {
		var a = (Sys.isDefined(b) && Sys.isArray(b)) ? b : this.children;
		a.forEach(function(d) {
			d[c](true, false)
		})
	},
	setParent: function(a) {
		this.parent = a;
		a.children.push(this);
		if (!Sys.isDefined(this.target)) {
			this.target = a.target
		}
	},
	addChild: function(a) {
		var b = this;
		if (Sys.isArray(a)) {
			a.forEach(function(c) {
				c.setParent(b)
			})
		} else {
			if (Sys.isObj(a)) {
				a.setParent(b)
			}
		}
	},
	findChild: function(e, c) {
		var b = Sys.isDefined(c) ? c : "id",
			d = false,
			a = function(g) {
				var f = false,
					h = false;
				g.forEach(function(j) {
					if (Sys.isDefined(j[b]) && j[b] === e) {
						f = j
					}
					if (Sys.isDefined(j.children)) {
						h = a(j.children);
						if (Sys.isObj(h)) {
							f = h
						}
					}
				});
				return f
			};
		if (this[b] === e) {
			return this
		}
		if (Sys.isDefined(this.children)) {
			d = a(this.children)
		}
		return d
	},
	performAction: function(j) {
		var g = this,
			c = g.animation,
			d = c.keyFrames,
			b = d.length,
			a = g.increaseAnimationTime(j),
			f = d[c.step],
			h = d[c.step + 1],
			e = true;
		g.handleCallback(f);
		if (h.time <= a) {
			g.progressKeyFrame();
			f = d[c.step];
			if (c.step === b - 1) {
				h = f;
				e = false
			} else {
				h = d[c.step + 1]
			}
		}
		g.calculate(c.time, f, h);
		return e
	},
	progressKeyFrame: function(e) {
		var c = this,
			d = c.animation,
			b = d.keyFrames,
			a;
		d.step = Sys.isDefined(e) ? e : d.step + 1;
		a = b[d.step];
		c.handleCallback(a);
		if (Sys.isDefined(a.goTo)) {
			c.doGoTo(a)
		}
		if (d.step !== b.length - 1) {
			if (d.time >= b[d.step + 1].time) {
				c.progressKeyFrame()
			}
		} else {
			if (c.loop) {
				d.time -= b[d.step].time;
				c.progressKeyFrame(0)
			}
		}
	},
	doGoTo: function(b) {
		var a = this;
		a.animation.time = a.animation.keyFrames[b.goTo].time;
		a.animation.step = b.goTo
	},
	calculate: function(d, b, a) {
		var c = this,
			f = c.calculateTime(d, b, a),
			h = b.value,
			g = a.value,
			e;
		if (Sys.isObj(h)) {
			Sys.iterate(h, function(j, k) {
				e = Sys.isDefined(c.prop) ? c.target[c.prop] : c.target;
				e[j] = Animation.utils.getInterpolationValue(k, g[j], f, b.ease)
			})
		} else {
			c.target[c.prop] = Animation.utils.getInterpolationValue(h, g, f, b.ease)
		}
	},
	handleCallback: function(b) {
		var c = b.callback,
			a;
		if (Sys.isDefined(c) && !b.callbackCompleted) {
			if (c.fireImmediately) {
				if (Sys.isString(c.func)) {
					c.scope.fireEvent(c.func, c.args)
				} else {
					if (Sys.isFunc(c.func)) {
						c.func.apply(c.scope, c.args)
					}
				}
			} else {
				a = Game.stage.view.animationManager.callbackContainer;
				a.push(c)
			}
			b.callbackCompleted = true
		}
	},
	calculateTime: function(d, b, a) {
		var e = d - b.time,
			c = a.time - b.time;
		return c !== 0 ? e / c : 1
	},
	increaseAnimationTime: function(a) {
		if (!Sys.isDefined(this.animation.time)) {
			this.animation.time = a
		} else {
			this.animation.time += a
		}
		return this.animation.time
	},
	animate: function(a, b) {
		this.updateOperation(a);
		if (b) {
			this.play()
		}
	}
};
Animation.Holder = Sys.extend(Sys.Observable, Animation.Holder, "Animation.Holder");
Sys.ns("Animation");
Animation.PixiAnimationManager = {
	PIXI_RENDERER_OPTIONS: {
		antialias: false,
		resolution: 1,
		transparent: false
	},
	constructor: function(a) {
		var b = this;
		Animation.PixiAnimationManager.superclass.constructor.call(b);
		b.canvasList = {};
		b._preRenderCallbacks = [];
		b._postRenderCallbacks = [];
		b.addPreRenderCallback(b.animate, 0);
		b.deviceOptions = {};
		b.gpuOptions = {};
		b.initRenderer(a);
		b.currentTime = 0;
		b.timeFromStart = 0;
		b.paused = false;
		b.currentStepTime = 0;
		b.setupImages(a.images, "notify:animationManager.allImagesLoaded");
		b.callbackContainer = [];
		b.isRunning = false;
		b.selectRenderFunction()
	},
	start: function(b) {
		var a = this;
		a.isRunning = true;
		a.currentTime = 0;
		a.lastTimeStepOccured = Date.now();
		a.paused = false;
		a.requestNextAnimationStep()
	},
	switchScenes: function(a) {
		this.currentScene = a
	},
	clearScene: function(a) {
		if (Sys.isDefined(a)) {
			this.scenes[a].lists = []
		}
	},
	addToRenderLoop: function(c, b) {
		var a = Sys.isDefined(b) ? b : this.currentScene;
		if (!this.isInScene(c, a)) {
			this.scenes[a].lists.push(c);
			if (c.id === "reelsMainList") {
				this.getLayer("reel").addChild(c.pixiItem)
			} else {}
		} else {
			c.prop.running = true
		}
	},
	isInScene: function(c, d) {
		var b = Sys.isDefined(d) ? d : this.currentScene,
			a = this.scenes[b];
		return (a.lists.contains(c) || a.listsToAdd.contains(c) || a.nonActiveLists.contains(c))
	},
	removeList: function(g, h) {
		var e = this,
			c = Sys.isDefined(h) ? h : e.currentScene,
			d = e.scenes[c],
			a = d.lists.indexOf(g),
			b = d.listsToAdd.indexOf(g),
			f = d.nonActiveLists.indexOf(g);
		if (a > -1) {
			d.lists[a].prop.running = false
		} else {
			if (f > -1) {
				d.nonActiveLists[f].prop.running = false
			} else {
				if (b > -1) {
					d.listsToAdd.splice(b, 1)
				}
			}
		}
	},
	restore: function(c) {
		var a, b = this;
		if (Sys.isDefined(c.canvas)) {
			a = b.canvasList[c.canvas]
		} else {
			a = b.canvasList[b.defaultCanvas]
		}
		if (c.prop.reset) {
			a.restore();
			a.globalAlpha = 1
		}
		if (Sys.isDefined(c.prop.globalCompositeOperation)) {
			a.globalCompositeOperation = "source-over"
		}
		a.fillStyle = "";
		a.strokeStyle = "";
		a.shadowColor = "";
		a.strokeStyle = "";
		a.shadowBlur = ""
	},
	pauseAnimation: function() {
		this.paused = true;
		clearTimeout(this.renderTimeout)
	},
	continueAnimation: function() {
		this.paused = false;
		this.run()
	},
	shouldRenderNextFrame: function() {
		return (!this.paused)
	},
	run: function() {
		var a = this;
		a._preRenderCallbacks.forEach(function(b) {
			b.call(a)
		});
		if (a.callbackContainer.length > 0) {
			a.fireCallbacks();
			a.callbackContainer.length = 0
		}
		if (a.shouldRenderNextFrame()) {
			a.lastTimeStepOccured = a.updateTime();
			a._postRenderCallbacks.forEach(function(b) {
				b.call(a)
			});
			a.requestNextAnimationStep()
		} else {
			a.isRunning = false
		}
	},
	fireCallbacks: function() {
		var d = this,
			c = d.callbackContainer.length,
			b, a;
		for (b = -1; ++b < c;) {
			a = d.callbackContainer[b];
			if (Sys.isString(a.func)) {
				a.scope.fireEvent(a.func, a.args)
			} else {
				if (Sys.isFunc(a.func)) {
					a.func.apply(a.scope, a.args)
				}
			}
		}
	},
	calculate: function() {
		var b = this,
			a = this.scenes[this.currentScene];
		if (Sys.isDefined(a)) {
			a.run({
				timeStep: b.currentStepTime,
				time: b.currentTime
			})
		} else {}
	},
	requestNextAnimationStep: function() {
		var a = this;
		a.animationFunction.call(window, function() {
			a.run()
		})
	},
	updateTime: function() {
		var b = this,
			a = Date.now(),
			c = a - b.lastTimeStepOccured;
		if (c > 250) {
			c = 1000 / 60
		}
		b.currentStepTime = c | 0;
		b.currentTime += b.currentStepTime;
		return a
	},
	selectRenderFunction: function() {
		var a = this;
		this.animationFunction = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(b) {
			clearTimeout(a.renderTimeout);
			a.renderTimeout = setTimeout(b, Math.round(1000 / 60))
		}
	},
	setupScenes: function(b) {
		var c = Sys.isDefined(b) ? b : [],
			a = {};
		c.push("base");
		Sys.each(c, function(d) {
			a[d] = new Animation.CanvasAnimationScene({})
		});
		this.scenes = a;
		this.scenes.base.play();
		this.currentScene = "base"
	},
	setupImages: function(d, h) {
		var e = this,
			g = Sys.isDefined(d.files) ? d.files : d,
			b = Resources.readData("animationImages") || {},
			a = Resources.readData("spines") || {},
			f = Resources.readData("bitmapFonts") || {},
			c = Resources.readData("spriteConfigurations") || {};
		e.imageReadyEvent = h;
		e.imagesRemaining = [];
		e.remainingImages = 0;
		e.imageConfig = d;
		Sys.iterate(g, function(j, l) {
			var k = new Image();
			k.onload = function() {
				e.remainingImages--;
				e.imagesLoaded()
			};
			k.src = l;
			b[j] = k;
			e.imagesRemaining.push(k);
			e.remainingImages++
		});
		Resources.storeData("animationImages", b)
	},
	assetsLoadedCompleteHandler: function(b, e) {
		var f = this,
			a = Resources.readData("spines") || {},
			d = Resources.readData("emitters") || {},
			c = f.imageConfig;
		if (e) {
			Sys.iterate(c.spineConfigurations, function(g, h) {
				a[g] = e[g].spineData
			});
			Sys.iterate(c.emitterConfigurations, function(h, g) {
				d[h] = e[h].data
			})
		}
		Resources.storeData("spines", a);
		Resources.storeData("images", undefined);
		Game.stage.model.storeData("images", undefined);
		f.imageConfig = undefined;
		f.fireEvent(f.imageReadyEvent)
	},
	setupPixiAssets: function() {
		var g = this,
			h = Resources.readData("animationImages"),
			m = Resources.readData("spines") || {},
			a = Resources.readData("emitters") || {},
			c = Resources.readData("spriteSheets") || {},
			f = Resources.readData("bitmapFonts") || {},
			l = Resources.readData("spriteConfigurations") || {},
			j = [],
			b = g.imageConfig,
			e = !Platform.isDesktopDevice ? 0.75 : 1,
			k = {};
		Sys.iterate(h, function(q, r) {
			var n = g.getCustomResolution(q, e),
				p = new PIXI.BaseTexture(r, 0, n.scale);
			q = n.name;
			p.imageUrl = q;
			PIXI.utils.BaseTextureCache[p.imageUrl] = p;
			var o = new PIXI.Texture(p);
			PIXI.utils.TextureCache[q] = o;
			k[q] = o
		});
		Resources.storeData("animationImages", k);
		if (Sys.isDefined(b.spineConfigurations)) {
			Sys.iterate(b.spineConfigurations, function(n, o) {
				j.push({
					name: n,
					src: o
				});
				m[n] = o
			});
			Resources.storeData("spines", m)
		}
		if (Sys.isDefined(b.emitterConfigurations)) {
			Sys.iterate(b.emitterConfigurations, function(n, o) {
				j.push({
					name: n,
					src: o
				});
				a[n] = o
			});
			Resources.storeData("emitters", a)
		}
		if (Sys.isDefined(b.spriteSheetConfigurations)) {
			Sys.iterate(b.spriteSheetConfigurations, function(o, n) {
				j.push({
					name: o,
					src: n
				});
				c[o] = n
			});
			Resources.storeData("spriteSheets", c)
		}
		if (Sys.isDefined(b.bitmapFontConfigurations)) {
			Sys.iterate(b.bitmapFontConfigurations, function(n, o) {
				j.push({
					name: n,
					src: o
				});
				f[n] = o
			});
			Resources.storeData("bitmapFonts", f)
		}
		if (j.length > 0) {
			g.loader = new PIXI.loaders.Loader();
			g.loader.once("complete", g.assetsLoadedCompleteHandler.bind(g));
			for (var d = 0; d < j.length; d++) {
				g.loader.add(j[d].name, j[d].src)
			}
			g.loader.load()
		} else {
			g.assetsLoadedCompleteHandler()
		}
		if (Sys.isDefined(b.spriteConfigurations)) {
			Sys.iterate(b.spriteConfigurations, function(n, o) {
				l[n] = o
			})
		}
		g.spriteConfigurations = l;
		Resources.storeData("spriteConfigurations", l)
	},
	getCustomResolution: function(b, c) {
		var a = /@(.+)x/.exec(b);
		if (a) {
			return {
				scale: parseFloat(a[1]),
				name: b.slice(0, a.index)
			}
		}
		return {
			scale: c,
			name: b
		}
	},
	imagesLoaded: function() {
		if (this.remainingImages < 1) {
			this.canImagesBeUsed()
		}
	},
	canImagesBeUsed: function() {
		var d = this,
			b = d.imagesRemaining,
			a = b.length,
			c;
		for (c = -1; ++c < a;) {
			if (b[c].width > 0 && b[c].height > 0) {
				b.splice(c, 1);
				--c;
				--a
			}
		}
		clearTimeout(d.tryToDrawImagesTimeout);
		if (b.length > 1) {
			d.tryToDrawImagesTimeout = setTimeout(function() {
				d.canImagesBeUsed()
			}, 50)
		} else {
			d.setupPixiAssets();
			d.fireEvent("notify:animationManager.animationLoopInitialized")
		}
	},
	onResize: function() {
		var a = this,
			b = Environment.getVirtualToWindowScale(3);
		a.rootDisplayObject.scale = new PIXI.Point(b, b)
	},
	getLayer: function(a) {
		return Sys.isDefined(this.layers[a]) ? this.layers[a] : null
	},
	createLayers: function(a) {
		var b = this;
		if (Sys.isDefined(a.layers)) {
			b.layers = {};
			a.layers.forEach(function(c) {
				b.layers[c] = new PIXI.Container();
				b.layers[c].name = c;
				b.rootDisplayObject.addChild(b.layers[c])
			})
		} else {
			b.layers = {
				background: new PIXI.Container(),
				tickerTape: new PIXI.Container(),
				reelBackground: new PIXI.Container(),
				reel: new PIXI.Container(),
				noWinSymbols: new PIXI.Container(),
				winSymbolFrames: new PIXI.Container(),
				winPresentationLayer: new PIXI.Container(),
				winSymbols: new PIXI.Container(),
				betLines: new PIXI.Container(),
				betLineIndicators: new PIXI.Container(),
				winAnims: new PIXI.Container(),
				countUp: new PIXI.Container(),
				bigWin: new PIXI.Container(),
				winCoinNumbers: new PIXI.Container(),
				userInterface: new PIXI.Container(),
				countDownFreeSpins: new PIXI.Container(),
				splashScreens: new PIXI.Container(),
				paytableBackground: new PIXI.Container(),
				logo: new PIXI.Container(),
				introMovie: new PIXI.Container(),
				quickStopper: new PIXI.Container()
			};
			Sys.iterate(b.layers, function(c, d) {
				d.name = c;
				b.rootDisplayObject.addChild(d)
			})
		}
	},
	setupDeviceOptions: function() {
		this.addDeviceOptions({})
	},
	addDeviceOptions: function(a) {
		for (var b in a) {
			if (a.hasOwnProperty(b)) {
				this.deviceOptions[b] = a[b]
			}
		}
	},
	setupGpuOptions: function() {
		this.addGpuOptions({
			"Mali-4": {
				forceCanvas: true
			}
		})
	},
	addGpuOptions: function(b) {
		for (var a in b) {
			if (b.hasOwnProperty(a)) {
				this.gpuOptions[a] = b[a]
			}
		}
	},
	getDeviceOptions: function() {
		var f = this.deviceOptions,
			e = navigator.userAgent,
			b = {};
		for (var d in f) {
			if (f.hasOwnProperty(d)) {
				if (e.includes(d)) {
					var a = f[d];
					for (var c in a) {
						if (a.hasOwnProperty(c)) {
							b[c] = a[c]
						}
					}
				}
			}
		}
		return b
	},
	getGpuOptions: function() {
		var j, a, f, g, h, c = this.gpuOptions,
			d = {};
		j = document.createElement("canvas");
		j.setAttribute("width", "1");
		j.setAttribute("height", "1");
		document.body.appendChild(j);
		a = document.getElementsByTagName("canvas");
		f = a[0].getContext("webgl", {
			stencil: true
		});
		a[0].parentNode.removeChild(a[0]);
		if (!f) {
			return d
		}
		g = f.getExtension("WEBGL_debug_renderer_info");
		if (g !== null) {
			h = f.getParameter(g.UNMASKED_RENDERER_WEBGL)
		} else {
			return d
		}
		for (var b in c) {
			if (c.hasOwnProperty(b)) {
				if (h.includes(b)) {
					var k = c[b];
					for (var e in k) {
						if (k.hasOwnProperty(e)) {
							d[e] = k[e]
						}
					}
				}
			}
		}
		return d
	},
	initRenderer: function(b) {
		var g = this,
			d = new PIXI.Container(),
			f, h = "Error",
			j = Resources.readData("queryData"),
			e = (Platform.isEdgeBrowser || Platform.isIEBrowser) && Platform.isDesktopDevice,
			a, c;
		this.setupGpuOptions();
		this.setupDeviceOptions();
		c = this.getGpuOptions();
		if (Sys.isDefined(c.forceCanvas)) {
			e = c.forceCanvas
		}
		a = this.getDeviceOptions();
		if (Sys.isDefined(a.forceCanvas)) {
			e = a.forceCanvas
		}
		e = Sys.isDefined(j.forcecanvasrendering) ? j.forcecanvasrendering : e;
		if (Sys.isDefined(e) && e === true) {
			f = new PIXI.CanvasRenderer(b.width, b.height, g.PIXI_RENDERER_OPTIONS);
			h = "Canvas"
		} else {
			f = PIXI.autoDetectRenderer(b.width, b.height, g.PIXI_RENDERER_OPTIONS);
			h = "Auto - ";
			if (Sys.isDefined(f.filterManager)) {
				h += "WebGL"
			} else {
				h += "Canvas"
			}
		}
		f.view.id = "canvasAnimationManager";
		f.plugins.interaction.autoPreventDefault = false;
		b.parent.appendChild(f.view);
		g.stage = d;
		g.rootDisplayObject = new PIXI.Container();
		g.stage.addChild(g.rootDisplayObject);
		g.renderer = f;
		g.renderDisplay = h;
		g.createLayers(b);
		g.onResize();
		g.animationBuffer = [];
		g.addPreRenderCallback(g.renderer.render.bind(g.renderer, g.stage))
	},
	animate: function() {
		var a = this;
		a.animationBuffer.forEach(function(b) {
			if (b.running) {
				b.run({
					timeStep: a.currentStepTime,
					time: a.currentTime
				})
			}
		})
	},
	addToAnimationLoop: function(a) {
		if (Sys.isArray(a)) {
			this.addHoldersToLoop(a)
		} else {
			this.addHolderToLoop(a)
		}
	},
	removeFromAnimationLoop: function(b) {
		var c = this,
			a;
		if (Sys.isArray(b)) {
			b.forEach(function(d) {
				a = c.animationBuffer.indexOf(d);
				if (a !== -1) {
					c.animationBuffer.splice(a, 1)
				}
			})
		} else {
			a = c.animationBuffer.indexOf(b);
			if (a !== -1) {
				c.animationBuffer.splice(a, 1)
			}
		}
	},
	forceCanvasRedraw: function() {
		var a = this.renderer.view;
		a.width++;
		a.width--
	},
	addHoldersToLoop: function(b) {
		var a = this;
		b.forEach(function(c) {
			a.addHolderToLoop(c)
		})
	},
	addHolderToLoop: function(a) {
		if (!this.isInAnimationLoop(a)) {
			this.animationBuffer.push(a)
		}
	},
	isInAnimationLoop: function(a) {
		return this.animationBuffer.indexOf(a) !== -1
	},
	addPreRenderCallback: function(a, b) {
		this._addRenderCallback(this._preRenderCallbacks, a, b)
	},
	removePreRenderCallback: function(a) {
		this._removeRenderCallback(this._preRenderCallbacks, a)
	},
	addPostRenderCallback: function(a, b) {
		this._addRenderCallback(this._postRenderCallbacks, a, b)
	},
	removePostRenderCallback: function(a) {
		this._removeRenderCallback(this._postRenderCallbacks, a)
	},
	_addRenderCallback: function(c, a, b) {
		if (!Sys.isFunc(a)) {
			return
		}
		if (Sys.isDefined(b)) {
			c.splice(b, 0, a)
		} else {
			c.push(a)
		}
	},
	_removeRenderCallback: function(b, a) {
		b.splice(b.indexOf(a), 1)
	}
};
Animation.PixiAnimationManager = Sys.extend(Sys.Observable, Animation.PixiAnimationManager, "Animation.PixiAnimationManager");
Sys.override(Animation.PixiAnimationManager, {
	initRenderer: function(c) {
		var d = this,
			b = new PIXI.Container(),
			e, a = Resources.readData("queryData"),
			f = (Platform.isEdgeBrowser || Platform.isIEBrowser) && Platform.isDesktopDevice;
		f = Sys.isDefined(a.forcecanvasrendering) ? a.forcecanvasrendering : f;
		if (c.width === 540) {
			c.width = 740
		}
		if (Sys.isDefined(f) && f === true) {
			e = new PIXI.CanvasRenderer(c.width, c.height, d.PIXI_RENDERER_OPTIONS);
			renderDisplay = "Canvas"
		} else {
			e = PIXI.autoDetectRenderer(c.width, c.height, d.PIXI_RENDERER_OPTIONS);
			renderDisplay = "Auto - ";
			if (Sys.isDefined(e.filterManager)) {
				renderDisplay += "WebGL"
			} else {
				renderDisplay += "Canvas"
			}
		}
		e.view.id = "canvasAnimationManager";
		e.plugins.interaction.autoPreventDefault = false;
		c.parent.appendChild(e.view);
		d.stage = b;
		d.rootDisplayObject = new PIXI.Container();
		d.stage.addChild(d.rootDisplayObject);
		d.renderer = e;
		d.renderDisplay = renderDisplay;
		d.createLayers(c);
		d.onResize();
		d.animationBuffer = [];
		d.addPreRenderCallback(d.renderer.render.bind(d.renderer, d.stage))
	},
	updateActiveRenderContextSize: function(a) {
		var b = this;
		if (a.width === 540) {
			b.renderer.resize(740, a.height)
		} else {
			b.renderer.resize(a.width, a.height)
		}
	},
	createLayers: function(b) {
		var d = this;
		if (Sys.isDefined(b.layers && b.layers.length)) {
			d.layers = {};
			b.layers.forEach(function(f) {
				d.layers[f] = new PIXI.Container();
				d.layers[f].name = f;
				d.rootDisplayObject.addChild(d.layers[f])
			})
		} else {
			if (Sys.isDefined(b.layeredLayers)) {
				d.layers = {};
				for (var c = 0; c < b.layeredLayers.length; c++) {
					var e = new PIXI.Container();
					for (var a = 0; a < b.layeredLayers[c].length; a++) {
						d.layers[b.layeredLayers[c][a]] = new PIXI.Container();
						d.layers[b.layeredLayers[c][a]].name = b.layeredLayers[c][a];
						e.addChild(d.layers[b.layeredLayers[c][a]])
					}
					d.rootDisplayObject.addChild(e)
				}
			} else {
				d.layers = {
					background: new PIXI.Container(),
					tickerTape: new PIXI.Container(),
					reelBackground: new PIXI.Container(),
					reel: new PIXI.Container(),
					foreground: new PIXI.Container(),
					noWinSymbols: new PIXI.Container(),
					winSymbolFrames: new PIXI.Container(),
					winPresentationLayer: new PIXI.Container(),
					winSymbols: new PIXI.Container(),
					betLines: new PIXI.Container(),
					betLineIndicators: new PIXI.Container(),
					winAnims: new PIXI.Container(),
					countUp: new PIXI.Container(),
					bigWin: new PIXI.Container(),
					winCoinNumbers: new PIXI.Container(),
					userInterface: new PIXI.Container(),
					countDownFreeSpins: new PIXI.Container(),
					splashScreens: new PIXI.Container(),
					paytableBackground: new PIXI.Container(),
					logo: new PIXI.Container(),
					introMovie: new PIXI.Container(),
					quickStopper: new PIXI.Container()
				};
				Sys.iterate(d.layers, function(f, g) {
					g.name = f;
					d.rootDisplayObject.addChild(g)
				})
			}
		}
	},
	setupImages: function(d, h) {
		var e = this,
			g = Sys.isDefined(d.files) ? d.files : d,
			b = Resources.readData("animationImages") || {},
			a = Resources.readData("spines") || {},
			f = Resources.readData("bitmapFonts") || {},
			c = Resources.readData("spriteConfigurations") || {};
		e.imageReadyEvent = h;
		e.imagesRemaining = [];
		e.remainingImages = 0;
		e.imageConfig = d;
		Sys.iterate(g, function(j, l) {
			var k = new Image();
			k.onload = function() {
				e.remainingImages--;
				e.imagesLoaded()
			};
			k.src = l;
			b[j] = k;
			e.imagesRemaining.push(k);
			e.remainingImages++
		});
		e.images = b;
		Resources.storeData("animationImages", b)
	},
	getGroupLayer: function(a) {
		var b = this;
		return b.rootDisplayObject.getChildAt(a)
	},
	getRootLayer: function() {
		var a = this;
		return a.rootDisplayObject
	},
	updateTime: function() {
		var b = this,
			a = Date.now(),
			c = a - b.lastTimeStepOccured;
		if (c > 250) {
			c = 1000 / 60
		}
		b.currentStepTime = c;
		b.currentTime += b.currentStepTime;
		return a
	}
});
Sys.ns("Animation");
Animation.BufferedReel = {
	constructor: function(a) {
		var b = this;
		Animation.BufferedReel.superclass.constructor.call(b, {});
		a = b.applyDefaultsToConfig(a);
		b.id = a.id;
		b.pixiContainer = new PIXI.Container();
		b.pixiContainer.id = b.id;
		b.pixiContainer.position = new PIXI.Point(a.left, a.top);
		b.running = true;
		Game.stage.view.animationManager.addToAnimationLoop(b);
		b.symbolWidths = a.symbolWidths;
		b.symbolHeights = a.symbolHeights;
		b.blurredSymbolWidths = a.blurredSymbolWidths;
		b.blurredSymbolHeights = a.blurredSymbolHeights;
		b.maxBlurredSymbolHeight = 0;
		Sys.iterate(a.blurredSymbolHeights, function(d, c) {
			b.maxBlurredSymbolHeight = Math.max(b.maxBlurredSymbolHeight, c)
		});
		b.maxBlurredSymbolWidth = 0;
		Sys.iterate(a.blurredSymbolWidths, function(d, c) {
			b.maxBlurredSymbolWidth = Math.max(b.maxBlurredSymbolWidth, c)
		});
		b.depthDistribution = a.depthDistribution;
		b.symbolSpecificDepthModifiers = a.symbolSpecificDepthModifiers;
		b.webGLBlur = a.webGLBlur || false;
		b.orientation = a.orientation;
		b.reelAreaLength = a.visibleLength;
		b.spinDirection = a.spinDirection;
		b.maxTimeStep = a.timeToMoveOneSlot * 0.75;
		b.hasSignaledReelStop = true;
		b.model = b.createModel(a);
		b.initBlurredReels();
		b.createSymbolSprites();
		b.symbolsWithSpecialEffects = {}
	},
	initBlurredReels: function() {
		var a = this;
		if (a.webGLBlur) {
			a.blurFilter = new PIXI.filters.BlurYFilter();
			a.pixiContainer.filters = [a.blurFilter]
		}
	},
	applyDefaultsToConfig: function(a) {
		var b = {
			id: "UnidentifiedReelList",
			symbolWidths: 150,
			symbolHeights: 150,
			blurredSymbolWidths: undefined,
			blurredSymbolHeights: undefined,
			symbolCenterToCenter: 150,
			depthDistribution: {
				type: "increasing",
				step: 1
			},
			symbolSpecificDepthModifiers: {},
			numberOfOutcomeSymbols: 3,
			orientation: "vertical",
			visibleLength: undefined,
			outcomeOffset: 0,
			spinDirection: "positive",
			timeToMoveOneSlot: 1000,
			startBounceSupportPointOffset: undefined,
			endBounceSupportPointOffsets: [],
			endBounceDurations: [],
			symbolRetrievalFunction: function() {},
			reelStartCompleteCallback: function() {},
			reelStartedStoppingCallback: function() {},
			reelBounceStartCallback: function() {},
			reelStoppedCallback: function() {}
		};
		Sys.applyProperties(b, a);
		if (Sys.isNumber(b.symbolWidths)) {
			b.symbolWidths = {
				standard: b.symbolWidths
			}
		}
		if (Sys.isNumber(b.symbolHeights)) {
			b.symbolHeights = {
				standard: b.symbolHeights
			}
		}
		if (!Sys.isDefined(b.blurredSymbolWidths)) {
			b.blurredSymbolWidths = b.symbolWidths
		} else {
			if (Sys.isNumber(b.blurredSymbolWidths)) {
				b.blurredSymbolWidths = {
					standard: b.blurredSymbolWidths
				}
			}
		}
		if (!Sys.isDefined(b.blurredSymbolHeights)) {
			b.blurredSymbolHeights = b.symbolHeights
		} else {
			if (Sys.isNumber(b.blurredSymbolHeights)) {
				b.blurredSymbolHeights = {
					standard: b.blurredSymbolHeights
				}
			}
		}
		if (!Sys.isDefined(b.visibleLength)) {
			b.visibleLength = b.numberOfOutcomeSymbols * b.symbolCenterToCenter
		}
		if (!Sys.isDefined(b.startBounceSupportPointOffset)) {
			b.startBounceSupportPointOffset = -2 * b.symbolCenterToCenter
		}
		return b
	},
	getSymbolLayout: function() {
		var d = this,
			c = [],
			b, a, e = 0;
		if (d.indexOfFirstOutcomeItem) {
			e = d.indexOfFirstOutcomeItem
		}
		for (a = 0; a < d.model.numberOfOutcomeSymbols; ++a) {
			b = d.pixiContainer.children[e + a];
			c.push({
				left: b.position.x,
				top: b.position.y,
				width: b.width,
				height: b.height
			})
		}
		return c
	},
	createModel: function(a) {
		var d = this,
			c = a.orientation === "vertical",
			b = c ? d.maxBlurredSymbolHeight : d.maxBlurredSymbolWidth,
			e = a.symbolCenterToCenter - b;
		return new PIXIAnimation.BufferedReelModel({
			id: a.id,
			symbolLength: b,
			symbolSpacing: e,
			numberOfOutcomeSymbols: a.numberOfOutcomeSymbols,
			visibleWindowLength: a.visibleLength,
			outcomeOffset: a.outcomeOffset,
			startBounceSupportPointOffset: a.startBounceSupportPointOffset,
			endBounceSupportPointOffsets: a.endBounceSupportPointOffsets,
			endBounceDurations: a.endBounceDurations,
			timeToMoveOneSlot: a.timeToMoveOneSlot,
			symbolRetrievalFunction: a.symbolRetrievalFunction,
			reelStartCompleteCallback: a.reelStartCompleteCallback,
			reelStartedStoppingCallback: a.reelStartedStoppingCallback,
			reelBounceStartCallback: a.reelBounceStartCallback,
			reelStoppedCallback: a.reelStoppedCallback,
			symbolCenterToCenter: a.symbolCenterToCenter
		})
	},
	reset: function() {
		this.model.reset()
	},
	createSymbolSprites: function() {
		var c = this,
			a = c.model.visibleSymbolsCount,
			d, b;
		for (b = 0; b < a; b++) {
			d = Game.PIXIFactory.createAndAddSprite("empty texture to be replaced later", c.pixiContainer, {
				x: 0,
				y: 0
			}, {
				x: 0.5,
				y: 0.5
			});
			d.id = "BufferedReelSymbol_" + b;
			if (c.orientation === "vertical") {
				d.x = c.symbolWidths.standard * 0.5
			} else {
				d.y = c.symbolHeights.standard * 0.5
			}
		}
	},
	calculateDepthDistributionArray: function() {
		var f = this,
			g = f.model.visibleSymbolsCount,
			e = f.depthDistribution.type,
			d = f.depthDistribution.step,
			c, h, a = Math.floor(g / 2),
			b = [];
		for (c = 0; c < g; c++) {
			if (e === "increasing") {
				h = c
			} else {
				if (e === "decreasing") {
					h = g - c
				} else {
					if (e === "curve-out") {
						h = Math.abs(a - Math.abs(a - c))
					} else {
						if (e === "curve-in") {
							h = Math.abs(a - c)
						}
					}
				}
			}
			b.push(h * d)
		}
		return b
	},
	startSpin: function() {
		this.model.start()
	},
	stopSpin: function(a) {
		this.model.storeSpinOutcome(a.symbols);
		this.model.stop()
	},
	isStopping: function() {
		return this.model.isStopping()
	},
	presentOutcome: function() {
		this.model.presentOutcome()
	},
	setAllReelSymbols: function(a) {
		this.model.setInitialOutcome(a.symbols)
	},
	setReelSymbol: function(b, a) {
		this.model.updateOutcome(a, b)
	},
	setSymbols: function(b) {
		var c = -1,
			a = this.model.numberOfOutcomeSymbols;
		for (; ++c < a;) {
			if (Sys.isDefined(b[c])) {
				this.model.updateOutcome(c, b[c])
			}
		}
	},
	run: function(e) {
		var c = this,
			d = Math.min(e.timeStep, c.maxTimeStep),
			a, b, f;
		f = c.model.move(d);
		if (c.model.state === "starting") {
			b = f;
			c.dispatchReachedIdleSpeedEvent = true;
			c.fireEvent("notify:reelList.reelMovedInStartingState", b, c.id)
		} else {
			if (c.model.state === "spinning") {
				if (c.dispatchReachedIdleSpeedEvent === true) {
					c.dispatchReachedIdleSpeedEvent = false;
					b = f;
					c.fireEvent("notify:reelList.reelReachedIdleSpeed", b, c.id)
				}
			}
		}
		a = c.model.getSymbolsToRender();
		c.getReelItemsForRendering(a)
	},
	getReelItemsForRendering: function(a) {
		var l = this,
			g = l.shouldUseMotionBlur(),
			f, o, d, n, b, e, c = g ? l.blurredSymbolWidths : l.symbolWidths,
			p = g ? l.blurredSymbolHeights : l.symbolHeights,
			k, h, m, j = a.length;
		if (l.webGLBlur) {
			l.blurFilter.blur = l.model.blurFactor
		}
		l.indexOfFirstOutcomeItem = l.pixiContainer.children.length - 1;
		for (f = -1; ++f < j;) {
			if (a[f].isOutcomeSymbol && f < l.indexOfFirstOutcomeItem) {
				l.indexOfFirstOutcomeItem = f
			}
			o = l.pixiContainer.children[f];
			d = a[f].symbol;
			b = Sys.isDefined(c[d]) ? d : "standard";
			e = Sys.isDefined(p[d]) ? d : "standard";
			n = a[f].position;
			k = c[b];
			h = p[e];
			m = l.orientation === "vertical" ? h : k;
			if (!l.webGLBlur && g) {
				d += "-BLURRED"
			} else {
				if (l.shouldUseSpecialEffect(d)) {
					d += "-SPECIAL_EFFECT"
				}
			}
			if (l.orientation === "vertical") {
				o.position.y = n
			} else {
				o.position.x = n
			}
			o = Sys.applyProperties(o, {
				width: k,
				height: m,
				x: l.symbolWidths.standard / 2
			});
			o.texture = Resources.readData("animationImages")[d];
			o.id = d
		}
	},
	shouldUseMotionBlur: function() {
		return this.model.isSpinning()
	},
	getReelPositionDepthOffsets: function(a) {
		var c = this,
			b = c.depthDistributionArray;
		if (c.depthDistribution === "increasing" || c.depthDistribution === "decreasing") {
			return b
		} else {
			return b.slice(Math.floor((b.length - a) / 2))
		}
	},
	hideSymbols: function(a) {
		this.setPlayingStateForSymbols(a, false)
	},
	showSymbols: function(a) {
		this.setPlayingStateForSymbols(a, true)
	},
	setPlayingStateForSymbols: function(b, d) {
		var a, c;
		if (Sys.isArray(b)) {
			a = b.length;
			for (c = -1; ++c < a;) {
				this.setPlayingStateForSymbol(b[c], d)
			}
		} else {
			this.setPlayingStateForSymbol(b, d)
		}
	},
	setPlayingStateForSymbol: function(b, c) {
		var a = this.pixiContainer.children;
		b += this.indexOfFirstOutcomeItem;
		if (Sys.isNumber(b) && Sys.isDefined(a[b])) {
			a[b].visible = c
		}
	},
	shouldUseSpecialEffect: function(a) {
		return this.symbolsWithSpecialEffects[a] === true
	},
	getSlotLength: function() {
		return this.model.slotLength
	},
	getVisibleSymbolsCount: function() {
		return this.model.visibleSymbolsCount
	},
	getBufferOffset: function() {
		return this.model.windowToBufferOffset
	},
	setBufferOffset: function(a) {
		this.model.setBufferOffset(a)
	},
	getTimeToMoveOneSlot: function() {
		return this.model.timeToMoveOneSlot
	},
	setTimeToMoveOneSlot: function(a) {
		this.maxTimeStep = Math.round(a * 0.75);
		this.model.setTimeToMoveOneSlot(a)
	},
	correctMisalignedOutcomeOnDeviceRotate: function() {}
};
Animation.BufferedReel = Sys.extend(Sys.Observable, Animation.BufferedReel, "Animation.BufferedReel");
Sys.ns("PIXIAnimation");
PIXIAnimation.BufferedReelModel = {
	getInterpolatedDistance: function(j, f, c, d, h) {
		var a = Math.min(1, c / h),
			b = Animation.utils.getInterpolationValue(0, j, a, {
				func: Animation.utils.powerOneSupportPoint,
				cfg: f
			}),
			e = Math.min(1, (c + d) / h),
			g = Animation.utils.getInterpolationValue(0, j, e, {
				func: Animation.utils.powerOneSupportPoint,
				cfg: f
			});
		return {
			distance: g - b,
			progressAfterTime: e
		}
	},
	getSymbolsToRender: function() {
		var f = this,
			d = [],
			h = Math.floor(f.windowToBufferOffset / f.slotLength) - f.leadingSymbolsCount,
			b, e, c, g, a = Sys.isDefined(f.symbolCenterToCenter) ? f.symbolCenterToCenter * 0.5 : 0;
		h = Math.max(0, h);
		h = h > 1 ? 1 : h;
		b = Math.min(f.visibleSymbolsCount, f.symbolBuffer.length - h);
		for (e = -1; ++e < b;) {
			c = h + e;
			g = f.symbolBuffer[c];
			g.position = c * f.slotLength - Math.round(f.windowToBufferOffset) + a;
			d.push(g);
			if (!f.outcomeVisibleOnReel) {
				f.reelStartedStoppingCallback();
				f.outcomeVisibleOnReel = true
			}
		}
		return d
	}
};
PIXIAnimation.BufferedReelModel = Sys.extend(Animation.BufferedReelModel, PIXIAnimation.BufferedReelModel, "PIXIAnimation.BufferedReelModel");
Sys.ns("Animation");
Animation.utils = {
	randomBetween: function(b, a) {
		return b + (a - b) * Math.random()
	},
	toNthDecimalPlace: function(a, d) {
		var c = Sys.isDefined(d) ? d : 1,
			b = Math.pow(10, c);
		return Math.round(a * b) / b
	},
	rk4: function(f, g, p, h) {
		var n = f,
			e = g,
			s = p(n, e, 0),
			m = f + 0.5 * e * h,
			d = g + 0.5 * s * h,
			r = p(m, d, h / 2),
			l = f + 0.5 * d * h,
			c = g + 0.5 * r * h,
			q = p(l, c, h / 2),
			k = f + c * h,
			b = g + q * h,
			o = p(k, b, h),
			j = f + (h / 6) * (e + 2 * d + 2 * c + b),
			t = g + (h / 6) * (s + 2 * r + 2 * q + o);
		return [j, t]
	},
	goToTime: function(g, f, k, m) {
		var n = this,
			o = Sys.isDefined(k) ? k : true,
			h = Sys.isDefined(m) ? m : false,
			c, b, j, a, e, d, l = function() {
				c = g.prop;
				Sys.iterate(c.operations, function(q, p) {
					if (!o || (o && p.timeBuffer < f)) {
						Animation.utils.setTimeBuffer(g, q, f)
					}
					if (h) {
						Sys.each(p, function(r) {
							if (Sys.isDefined(r.fireEvent) && r.time <= f) {
								r.fireEvent.fired = true
							}
							if (Sys.isDefined(r.events)) {
								j = f - b.time;
								a = r.time - b.time;
								e = a !== 0 ? j / a : 1;
								d = Math.round(Animation.utils.getInterpolationValue(b.value, r.value, e));
								Sys.each(r.events, function(s) {
									if (s.onFrame <= d) {
										s.fired = true
									}
								})
							}
							b = r
						})
					}
				})
			};
		l();
		if (Sys.isDefined(g.items)) {
			Sys.each(g.items, function(p) {
				n.goToTime(p, f, o, h)
			})
		}
	},
	fireEventOnFrame: function(c, b) {
		var a = Game.stage.view.animationManager.renderLoopEndEvents;
		Sys.each(b.events, function(d) {
			if (c >= d.onFrame && !d.fired) {
				a.push(d);
				d.fired = true
			}
		})
	},
	addEndEvent: function(e, d) {
		var g = e.prop,
			b = g.operations,
			a = 0,
			c, f;
		Sys.iterate(b, function(h, j) {
			f = j[j.length - 1];
			if (a < f.time) {
				a = f.time;
				c = f
			}
		});
		if (Sys.isDefined(c)) {
			if (!Sys.isDefined(c.fireEvent)) {
				c.fireEvent = d
			}
		}
	},
	getInterpolationValue: function(f, e, b, c, d) {
		if (b > 1) {
			b = 1
		} else {
			if (b < 0) {
				b = 0
			}
		}
		if (Sys.isDefined(c)) {
			if (Sys.isFunc(c)) {
				return c(f, e, b)
			} else {
				var a = Sys.isDefined(c.cfg) ? c.cfg : undefined;
				return c.func(f, e, b, d, a)
			}
		}
		return f + b * (e - f)
	},
	noInterpolation: function(c, b, a) {
		return a === 1 ? b : c
	},
	powerOneIn: function(c, b, a) {
		return ((1 - a) * (1 - a)) * c + 2 * a * (1 - a) * c + (a * a) * b
	},
	powerOneOut: function(c, b, a) {
		return ((1 - a) * (1 - a)) * c + 2 * a * (1 - a) * b + (a * a) * b
	},
	powerTwoIn: function(c, b, a) {
		return Math.pow(1 - a, 3) * c + 3 * a * Math.pow(1 - a, 2) * c + 3 * Math.pow(a, 2) * (1 - a) * c + Math.pow(a, 3) * b
	},
	powerTwoOut: function(c, b, a) {
		return Math.pow(1 - a, 3) * c + 3 * a * Math.pow(1 - a, 2) * b + 3 * Math.pow(a, 2) * (1 - a) * b + Math.pow(a, 3) * b
	},
	powerNIn: function(h, j, c, a, g) {
		var e = Sys.utils.initArray(g + 1, h),
			f, b, d;
		e.push(j);
		b = e.length;
		for (d = 1; d < b; d++) {
			for (f = 0; f < (b - d); f++) {
				e[f] = (1 - c) * e[f] + c * e[f + 1]
			}
		}
		return e[0]
	},
	powerNOut: function(h, j, c, a, g) {
		var e = Sys.utils.initArray(g + 1, j),
			f, b, d;
		e.unshift(h);
		b = e.length;
		for (d = 1; d < b; d++) {
			for (f = 0; f < (b - d); f++) {
				e[f] = (1 - c) * e[f] + c * e[f + 1]
			}
		}
		return e[0]
	},
	powerOneSupportPoint: function(f, e, c, d, b) {
		var a = b;
		if (Sys.isDefined(d) && Sys.isObj(b)) {
			a = b[d]
		}
		return ((1 - c) * (1 - c)) * f + 2 * c * (1 - c) * a + (c * c) * e
	},
	backOut: function(g, f, d, e, a) {
		var b = Sys.isDefined(a) ? a : 1,
			c = (d -= 1) * d * ((b + 1) * d + b) + 1;
		return ((f - g) * c) + g
	}
};
Sys.ns("Animation.utils");
Animation.utils.AnimationPool = {
	registerSpineAnimation: function(k, c, f, l, a) {
		var e = this,
			g, d = a || {},
			b = l || 0,
			j = d.increment || 1,
			h = d.maxWarningCount || undefined;
		Sys.utils.ObjectPool.registerObjectForPooling(k, e, e.createSpineAnimation, [c, f], b, j, h)
	},
	registerHolderAnimation: function(k, e, c, l, a) {
		var g = this,
			f = a || {},
			b = l || 0,
			d = c || [],
			j = f.increment || 1,
			h = f.maxWarningCount || undefined;
		Sys.utils.ObjectPool.registerObjectForPooling(k, g, e, d, b, j, h)
	},
	getAnimation: function(a) {
		return Sys.utils.ObjectPool.getObjectFromPool(a)
	},
	returnAnimationToPool: function(a) {
		Sys.utils.ObjectPool.returnObjectToPool(a)
	},
	getAndPlaySpineAnimation: function(h, j, a) {
		var g = this,
			c = g.getAnimation(h),
			b, f = a || {},
			e = Sys.isDefined(f.visible) ? f.visible : true,
			d = Sys.isDefined(f.loop) ? f.loop : false;
		Game.PIXIUtils.resetSpineAnimation(c);
		if (Sys.isDefined(f.position)) {
			c.position.x = f.position.x;
			c.position.y = f.position.y
		}
		c.visible = e;
		b = c.state.setAnimationByName(0, j, d);
		if (Sys.isDefined(f.alpha)) {
			c.alpha = f.alpha
		}
		if (Sys.isDefined(f.complete)) {
			b.onComplete = f.complete
		}
		return c
	},
	createSpineAnimation: function(b, a) {
		var c = Game.PIXIFactory.createAndAddSpineAnimation(b, a);
		c.visible = false;
		return c
	}
};
Sys.ns("Game");
Game.ReelGroup = {
	createReelLists: function(m, d, h, k) {
		var l = this,
			g = 0,
			f, e = l.symbolBuffer,
			j, b, c = [],
			a = h.standard || h.config;
		l.reelLists = [];
		l.slotLengthGroups = {};
		l.reels = new PIXI.Container();
		l.reels.id = "reelsMainContainer";
		l.reels.visible = false;
		Game.stage.view.animationManager.getLayer("reel").addChild(l.reels);
		for (; g < d; g++) {
			f = Sys.applyProperties({}, a);
			if (Sys.isDefined(h[g])) {
				Sys.applyProperties(f, h[g])
			}
			f.id = m + "_" + g;
			f.symbolRetrievalFunction = e.getSymbols.bind(e, g);
			Sys.applyProperties(f, l.getReelSpecificCallbacks(g, k));
			if (typeof(PIXIAnimation) !== "undefined" && Sys.isDefined(PIXIAnimation.BufferedReelList)) {
				j = new PIXIAnimation.BufferedReelList(f)
			} else {
				j = new Animation.BufferedReel(f)
			}
			b = j.getSlotLength();
			if (!Sys.isDefined(l.slotLengthGroups[b])) {
				l.slotLengthGroups[b] = []
			}
			l.slotLengthGroups[b].push(j);
			c.push(j.getVisibleSymbolsCount());
			l.reelLists.push(j);
			l.reels.addChild(j.pixiContainer)
		}
		l.addReelMask(a);
		l.symbolBuffer.setVisibleSymbolsCounts(c)
	},
	addReelMask: function(a) {
		var b = new PIXI.Graphics();
		b.beginFill(16711680, 0.8);
		b.drawRect(0, a.top, 1280, a.visibleLength);
		b.endFill();
		this.reels.addChild(b);
		this.reels.mask = b
	},
	hide: function() {
		Sys.each(this.reelLists, function(a) {
			a.hide()
		})
	},
	hideReel: function(b) {
		var a = this.reelLists[b];
		if (Sys.isDefined(a)) {
			a.hide()
		}
	},
	showReel: function(b) {
		var a = this.reelLists[b];
		if (Sys.isDefined(a)) {
			a.show()
		}
	},
	activate: function(a) {
		var b = this;
		if (Sys.isDefined(b.activeReelSet)) {
			b.deactivate(b.activeReelSet)
		}
		b.reels.visible = true;
		b.symbolBuffer.activateReelSet(a);
		b.activeReelSet = a;
		b.updateSpinTimings(a)
	},
	deactivate: function(a) {
		var b = this;
		if (a === b.activeReelSet) {
			b.reels.visible = false;
			b.activeReelSet = undefined
		}
	}
};
Sys.override(Core.Slots.ReelGroup, Game.ReelGroup);
Sys.ns("Core.Slots");
Core.Slots.SymbolBuffer = {
	SYMBOL_CONSTANTS: {
		any: -1,
		fakeReel: -2,
		lowWin: -3
	},
	constructor: function(a, d, c) {
		var b = this;
		Core.Slots.SymbolBuffer.superclass.constructor.apply(b, arguments);
		b.pipeCount = a;
		b.clearBuffer();
		b.currentReelSet = undefined;
		b.setUpWorkspace(c);
		b.createFillers(d)
	},
	clearBuffer: function() {
		this.buffer = Sys.utils.init2dMatrix(this.pipeCount, 0)
	},
	setUpWorkspace: function(c) {
		var b = this,
			a = b.pipeCount;
		b.workspace = {
			pipeCount: a,
			currentReelSet: b.currentReelSet,
			currentOutcome: undefined,
			outcomeInsertedOnReel: Sys.utils.initArray(a, false),
			heldReels: [],
			linkedReels: Sys.utils.initArray(a, false),
			symbolsBeforeOutcome: Sys.utils.initArray(a, Infinity),
			symbolConstants: b.SYMBOL_CONSTANTS,
			announce: c.fillerEventCallback
		}
	},
	createFillers: function(b) {
		var c = this,
			a;
		c.fillers = [];
		Sys.each(b, function(d) {
			a = Sys.utils.getClassFromString(d);
			c.fillers.push(new a(c.workspace))
		})
	},
	getSymbols: function(b, a, d) {
		var c = this;
		if (c.buffer[b].length < a) {
			c.fill(a - c.buffer[b].length, b, d)
		}
		return c.buffer[b].splice(-a, a)
	},
	fill: function(a, d, f) {
		var e = this,
			b = [],
			c;
		for (c = -1; ++c < e.pipeCount;) {
			if (c < d || e.workspace.heldReels.contains(c) || (c !== d && f)) {
				b.push([])
			} else {
				b.push(Sys.utils.initArray(a, e.SYMBOL_CONSTANTS.any))
			}
		}
		e.fillBuffer(b, f === true)
	},
	fillBuffer: function(g, c) {
		var m = this,
			b = m.fillers,
			d = b.length,
			l = m.pipeCount,
			k = m.workspace.symbolsBeforeOutcome,
			f, h, e, a;
		for (h = -1; ++h < d;) {
			a = b[h].fill(g, c);
			if (!a) {
				break
			}
		}
		for (h = -1; ++h < l;) {
			f = g[h].length;
			if (k[h] >= f) {
				k[h] -= f
			} else {
				k[h] = 0
			}
			m.buffer[h] = g[h].reverse().concat(m.buffer[h])
		}
	},
	cleanUp: function() {
		var c = this,
			d = c.fillers,
			a = d.length,
			b;
		for (b = -1; ++b < a;) {
			d[b].cleanUp()
		}
		c.cleanUpWorkspace()
	},
	cleanUpWorkspace: function() {
		var a = this.workspace,
			b = a.pipeCount;
		a.currentOutcome = undefined;
		a.outcomeInsertedOnReel = Sys.utils.initArray(b, false);
		a.heldReels.length = 0;
		a.linkedReels = Sys.utils.initArray(b, false);
		a.symbolsBeforeOutcome = Sys.utils.initArray(b, Infinity)
	},
	activateReelSet: function(b) {
		var a = this;
		if (b !== a.currentReelSet) {
			a.currentReelSet = b;
			a.workspace.currentReelSet = b;
			Sys.each(a.fillers, function(c) {
				c.setReelSet(b)
			})
		}
	},
	setOutcome: function(a, b) {
		this.workspace.currentOutcome = a;
		Sys.each(this.fillers, function(c) {
			c.processOutcome(a, b)
		})
	},
	setStopDistance: function(a) {
		this.fillers.forEach(function(b) {
			b.updateStoppingDistances(a)
		});
		this.workspace.symbolsBeforeOutcome = a
	},
	getStopDistance: function() {
		return this.workspace.symbolsBeforeOutcome
	},
	setVisibleSymbolsCounts: function(a) {
		this.workspace.visibleSymbolsCounts = a
	},
	getIndexOfLastStoppingReel: function() {
		return Math.max(this.workspace.outcomeInsertedOnReel.indexOf(false) - 1, -1)
	},
	setHeldReels: function(b) {
		var a = this.workspace;
		a.heldReels = b;
		a.heldReels.forEach(function(c) {
			a.outcomeInsertedOnReel[c] = true
		})
	}
};
Core.Slots.SymbolBuffer = Sys.extend(Sys.Observable, Core.Slots.SymbolBuffer, "Core.Slots.SymbolBuffer");
Sys.ns("Core.Slots");
Core.Slots.SimpleOutcomeFiller = {
	constructor: function(a) {
		Core.Slots.SimpleOutcomeFiller.superclass.constructor.apply(this, arguments);
		this.workspace = a;
		this.cleanUp()
	},
	fill: function(g, e) {
		var l = this,
			h, d = l.workspace,
			k, b = d.currentOutcome,
			f = 0,
			j, a, c;
		if (!Sys.isDefined(b)) {
			return l.slotsLeftInBuffer(g)
		}
		for (h = -1; ++h < g.length;) {
			j = g[h];
			if (!l.slotsLeftInPipe(j, [d.symbolConstants.any])) {
				continue
			}
			k = d.symbolsBeforeOutcome[h];
			if (k >= j.length || !l.hasInsertedPreviousOutcome(h)) {
				break
			}
			if (d.outcomeInsertedOnReel[h]) {
				continue
			}
			a = b[h].symbols.slice(0);
			c = l.findOutcomeStart(l.analyzePipeBuffer(j, e, [d.symbolConstants.any]), a.length, Math.max(f, k));
			if (c >= 0) {
				l.fillSlots(l.wrapSymbols(a.reverse()), j, c);
				d.outcomeInsertedOnReel[h] = true;
				f = c
			}
		}
		return !e ? l.evenBuffer(g) : l.slotsLeftInBuffer(g)
	},
	hasInsertedPreviousOutcome: function(a) {
		return a === 0 || this.workspace.outcomeInsertedOnReel[a - 1]
	},
	findOutcomeStart: function(e, g, d) {
		var b, f, a, c;
		for (c = -1; ++c < e.length;) {
			b = e[c];
			if (b.start >= d) {
				f = b.start;
				a = b.length
			} else {
				f = d;
				a = b.length - (d - b.start)
			}
			if (a >= g) {
				return f
			}
		}
		return -1
	},
	wrapSymbol: function(a) {
		return {
			symbol: a,
			isOutcomeSymbol: true
		}
	}
};
Core.Slots.SimpleOutcomeFiller = Sys.extend(Core.Slots.Filler, Core.Slots.SimpleOutcomeFiller, "Core.Slots.SimpleOutcomeFiller");
Sys.override(Core.Orientation, {
	getOrientation: function() {
		if (Sys.isDefined(Environment.deviceOrientation)) {
			return Environment.deviceOrientation
		}
		if (Platform.isDesktopDevice || Platform.isTabletDevice) {
			return "LANDSCAPE"
		}
		if (Platform.isIOSDevice === true || Platform.isAndroidStockBrowser) {
			if (window.orientation) {
				if (Math.abs(window.orientation) === 90) {
					return "LANDSCAPE"
				}
				return "PORTRAIT"
			}
		}
		if (window.innerHeight <= window.innerWidth) {
			return "LANDSCAPE"
		} else {
			return "PORTRAIT"
		}
	}
});
Sys.override(Game.StageModel, {
	setupData: function() {
		var b = this,
			a = Resources.readData("config");
		b.storeData("images", Resources.readData("images"));
		b.storeData("sprites", a.sprites);
		b.storeData("reelConfig", a.reel);
		b.storeData("reelGroups", a.reelGroups);
		b.storeData("scenes", a.scenes);
		b.storeData("layers", Layering.RenderLayers || a.layers);
		b.switchScenes("base")
	}
});
Sys.override(Game.StageView, {
	setupAnimationManager: function() {
		var b = this,
			a = Environment.getResolution();
		b.animationManager = new Animation.PixiAnimationManager({
			parent: document.getElementById("gameElements"),
			images: b.model.readData("images"),
			sprites: b.model.readData("sprites"),
			top: "0px",
			left: "0px",
			height: a.height,
			width: a.width,
			scenes: b.model.readData("scenes"),
			layers: b.model.readData("layers")
		})
	}
});
Sys.ns("Interface.utils");
Interface.utils.PIXIControl = {
	constructor: function() {
		Interface.utils.PIXIControl.superclass.constructor.apply(this, arguments)
	},
	moveToPosition: function(b) {
		var a = b.position;
		var c = b.anchorPoint ? b.anchorPoint : new PIXI.Point();
		this.moveTo(a, c)
	},
	moveTo: function(a, b) {
		var c = b ? b : new PIXI.Point();
		this.x = a.x - this.width * c.x;
		this.y = a.y - this.height * c.y
	}
};
Interface.utils.PIXIControl = Sys.extend(PIXI.Container, Interface.utils.PIXIControl, "Interface.utils.PIXIControl");
Sys.ns("Interface.utils");
Interface.utils.PIXIInteractive = {
	DEFAULT_ID: "interactive",
	UP: "up",
	DOWN: "down",
	OVER: "over",
	OUT: "out",
	MOVE: "move",
	constructor: function() {
		Interface.utils.PIXIInteractive.superclass.constructor.apply(this, arguments);
		this.eventHandler = EventHandler;
		this._enabled = this._enabled !== false;
		this.interactive = true;
		this.setCurrentState(this.UP)
	},
	setEnabled: function(a) {
		if (this._enabled === a) {
			return
		}
		this._enabled = a
	},
	getEnabled: function() {
		return this._enabled
	},
	setCurrentState: function(a) {
		if (this._currentState === a) {
			return
		}
		this._currentState = a
	},
	mousedown: function(a) {
		this.handleEvent(this.DOWN, a)
	},
	mouseup: function(a) {
		var b = this.checkInteractionTarget(a.data);
		if (this._enabled && this._internalPressed && b) {
			this.executeCallback("click", a)
		}
		this.setStateFromEvent(this.UP, a)
	},
	mousemove: function(a) {
		var b = this.checkInteractionTarget(a.data);
		if (this.moveCallback && this._enabled && b) {
			this.handleEvent(this.MOVE, a)
		}
	},
	mouseover: function(a) {
		this.handleEvent(this.OVER, a)
	},
	mouseout: function(a) {
		this.handleEvent(this.OUT, a)
	},
	mouseupoutside: function(a) {
		this.handleEvent(this.UP, a)
	},
	touchstart: function(a) {
		this.handleEvent(this.DOWN, a)
	},
	touchend: function(a) {
		this.handleEvent(this.UP, a)
	},
	touchmove: function(a) {
		if (this._currentState !== this.UP) {
			var b = Game.PIXIUtils.hitTestDisplayObject(a.data.global, this);
			if (!b && !Platform.isDesktopDevice) {
				this.touchend(a)
			}
		}
	},
	touchendoutside: function(a) {
		this.handleEvent(this.UP, a)
	},
	tap: function(a) {
		var b = this.checkInteractionTarget(a.data);
		if (this._enabled && b) {
			this.executeCallback("click", a)
		}
	},
	handleEvent: function(a, b) {
		var c = this.checkInteractionTarget(b.data);
		if (c) {
			if (this._enabled) {
				this.executeCallback(a, b)
			}
			this.setStateFromEvent(a, b)
		}
	},
	fireEvent: function() {
		if (arguments.length === 0) {
			return
		}
		this.eventHandler.dispatchEvent.apply(this.eventHandler, arguments)
	},
	checkInteractionTarget: function(a) {
		if (Sys.isDefined(a.originalEvent) === false || a.originalEvent === null) {
			return false
		}
		var b = Sys.isDefined(a.originalEvent.target.id);
		return ((b && a.originalEvent.target.id === "canvasAnimationManager"))
	},
	executeCallback: function(a, b) {
		var c = (a + "Callback");
		if (this[c]) {
			this[c](b)
		}
	},
	setStateFromEvent: function(b, c) {
		if (b === this.DOWN) {
			this.setCurrentState(this.DOWN);
			this._internalPressed = true
		} else {
			if (b === this.UP) {
				this._internalPressed = false;
				this._externalPressed = false;
				if (this._internalOver) {
					this.setCurrentState(this.OVER)
				} else {
					this.setCurrentState(this.UP)
				}
			} else {
				if (b === this.OVER) {
					this._internalOver = true;
					if (this._internalPressed) {
						this.setCurrentState(this.DOWN)
					} else {
						this._externalPressed = false;
						var a = c.data.originalEvent;
						if (a.buttons === 1 || a.buttons === 3) {
							this._externalPressed = true
						}
						if (this._externalPressed === false) {
							this.setCurrentState(this.OVER)
						}
					}
				} else {
					if (this._internalOver) {
						this._internalOver = false
					}
					if (this._externalPressed) {
						this._externalPressed = false
					}
					this.setCurrentState(this.UP)
				}
			}
		}
		this.shouldUpdateGraphics = true;
		this.shouldUpdateLabel = true
	}
};
Interface.utils.PIXIInteractive = Sys.extend(Interface.utils.PIXIControl, Interface.utils.PIXIInteractive, "Interface.utils.PIXIInteractive");
Sys.ns("Interface.utils");
Interface.utils.PIXIBox = {
	HORIZONTAL: "horizontal",
	VERTICAL: "vertical",
	ALIGN_TOP: "top",
	ALIGN_LEFT: "left",
	ALIGN_CENTER: "center",
	ALIGN_BOTTOM: "bottom",
	ALIGN_RIGHT: "right",
	DEFAULT_GAP: 4,
	constructor: function(a) {
		Interface.utils.PIXIBox.superclass.constructor.apply(this, arguments);
		this._layout = (a === undefined) ? this.HORIZONTAL : a;
		this._gap = this.DEFAULT_GAP;
		this._verticalAlign = this.ALIGN_TOP;
		this._horizontalAlign = this.ALIGN_LEFT;
		this._explicitWidth = NaN;
		this._explicitHeight = NaN;
		this.shouldUpdateLayout = false
	},
	addChildAt: function(b, a) {
		b = Interface.utils.PIXIBox.superclass.addChildAt.apply(this, arguments);
		this.shouldUpdateLayout = true;
		return b
	},
	removeChildAt: function(a) {
		var b = Interface.utils.PIXIBox.superclass.removeChildAt.apply(this, arguments);
		this.shouldUpdateLayout = true;
		return b
	},
	getExcessSpace: function(f) {
		var d = this.getBoxWidth(),
			a = this.getBoxHeight(),
			c = f ? a : d,
			e = this.children.length;
		for (var b = 0; b < e; b++) {
			var g = this.children[b];
			c -= f ? g.height : g.width
		}
		c = c - this._gap * (e - 1);
		return (c < 0) ? 0 : c
	},
	updateLayout: function() {
		var k = this.isVertical(),
			e = this.getVerticalAlignValue(),
			d = this.getHorizontalAlignValue(),
			b = this.getExcessSpace(k),
			h = b,
			a = this.getBoxWidth(),
			l = this.getBoxHeight();
		h *= (k) ? e : d;
		var g = this.children.length;
		for (var f = 0; f < g; f++) {
			var c = this.children[f];
			if (k) {
				c.y = Math.floor(h);
				c.x = (a - c.width) * e
			} else {
				c.x = Math.floor(h);
				c.y = (l - c.height) * d
			}
			var j = k ? c.height : c.width;
			h += j + this.getCurrentGap(f, g)
		}
		this.shouldUpdateLayout = false
	},
	getCurrentGap: function(b, a) {
		return this._gap
	},
	updateTransform: function() {
		if (this.shouldUpdateLayout) {
			this.updateLayout()
		}
		Interface.utils.PIXIBox.superclass.updateTransform.apply(this, arguments)
	},
	setGap: function(a) {
		if (this._gap === a) {
			return
		}
		this._gap = a;
		this.shouldUpdateLayout = true
	},
	setHorizontalAlign: function(a) {
		if (this._horizontalAlign === a) {
			return
		}
		this._horizontalAlign = a;
		this.shouldUpdateLayout = true
	},
	setVerticalAlign: function(a) {
		if (this._verticalAlign === a) {
			return
		}
		this._verticalAlign = a;
		this.shouldUpdateLayout = true
	},
	getHorizontalAlignValue: function() {
		if (this._horizontalAlign === "center") {
			return 0.5
		} else {
			if (this._horizontalAlign === "right") {
				return 1
			}
		}
		return 0
	},
	getVerticalAlignValue: function() {
		if (this._verticalAlign === "middle") {
			return 0.5
		} else {
			if (this._verticalAlign === "bottom") {
				return 1
			}
		}
		return 0
	},
	isVertical: function() {
		return (this._layout === this.VERTICAL)
	},
	setExplicitWidth: function(a) {
		if (this._explicitWidth === a) {
			return
		}
		this._explicitWidth = a;
		this.shouldUpdateLayout = true
	},
	setExplicitHeight: function(a) {
		if (this._explicitHeight === a) {
			return
		}
		this._explicitHeight = a;
		this.shouldUpdateLayout = true
	},
	getBoxWidth: function() {
		return (isNaN(this._explicitWidth)) ? this.width : this._explicitWidth
	},
	getBoxHeight: function() {
		return (isNaN(this._explicitHeight)) ? this.height : this._explicitHeight
	}
};
Interface.utils.PIXIBox = Sys.extend(Interface.utils.PIXIControl, Interface.utils.PIXIBox, "Interface.utils.PIXIBox");
Sys.ns("Interface.utils");
Interface.utils.PIXIHBox = {
	constructor: function() {
		Interface.utils.PIXIHBox.superclass.constructor.apply(this, ["horizontal"])
	}
};
Interface.utils.PIXIHBox = Sys.extend(Interface.utils.PIXIBox, Interface.utils.PIXIHBox, "Interface.utils.PIXIHBox");
Sys.ns("Interface.utils");
Interface.utils.PIXIVBox = {
	constructor: function() {
		Interface.utils.PIXIVBox.superclass.constructor.apply(this, ["vertical"])
	}
};
Interface.utils.PIXIVBox = Sys.extend(Interface.utils.PIXIBox, Interface.utils.PIXIVBox, "Interface.utils.PIXIVBox");
Sys.ns("Interface.utils");
Interface.utils.PIXIButton = {
	DEFAULT_ID: "button",
	SOUND_UP: "buttonUp",
	SOUND_DOWN: "buttonDown",
	SOUND_CLICK: "buttonClick",
	SOUND_OVER: "buttonHover",
	LABEL_RESOLUTION: 2,
	constructor: function(c, d, a, b, e) {
		Interface.utils.PIXIButton.superclass.constructor.apply(this, arguments);
		this.ID = Sys.isDefined(e) ? e : this.DEFAULT_ID;
		this._graphicReferences = {
			up: c,
			down: d,
			over: a,
			disabled: b
		};
		this._labelStyleReferences = {
			up: undefined,
			down: undefined,
			over: undefined,
			disabled: undefined
		};
		this._pooledGraphics = {};
		this.shouldUpdateDimensions = false;
		this.shouldUpdateLabel = false;
		this.shouldUpdateGraphics = false;
		this.updateGraphics();
		this.updateHitArea();
		if (Sys.isDefined(Services.trigger)) {
			this.registerTriggers()
		}
		this.soundEnabled = true
	},
	getCurrentLabelStyle: function() {
		var a;
		if (this._enabled) {
			a = this._labelStyleReferences[this._currentState]
		} else {
			a = this._labelStyleReferences.disabled
		}
		if (a === undefined) {
			a = this._labelStyle
		}
		return a
	},
	updateLabel: function(b) {
		var a = this.getCurrentLabelStyle(),
			c;
		this.shouldUpdateLabel = false;
		if (b) {
			c = a.fontSize.replace("px", "");
			c = parseInt(c, 10);
			b = b.replace("px", "");
			b = parseInt(b, 10);
			if (c > b) {
				Sys.iterate(this._labelStyleReferences, function(d, e) {
					var f = parseInt(e.fontSize.replace("px", ""), 10);
					e.fontSize = Math.round(f * (b / c)) + "px"
				})
			}
		}
		if (this.labelText) {
			this.labelText.text = this._label;
			this.labelText.setLabelStyle(a)
		} else {
			if (this._label) {
				this.labelText = new Interface.utils.PIXILabel(this._label, a, this._labelMaxWidth, this.ID + ".label");
				this.addChild(this.labelText);
				this.shouldUpdateLabel = true
			}
		}
		this.shouldUpdateDimensions = true
	},
	getTexture: function(a) {
		var b = this._pooledGraphics[a];
		if (!b) {
			b = Game.PIXIFactory.createTexture(a);
			this._pooledGraphics[a] = b
		}
		return b
	},
	updateGraphics: function() {
		var a;
		if (this._enabled) {
			a = this._graphicReferences[this._currentState]
		} else {
			a = this._graphicReferences.disabled
		}
		if (this.graphics) {
			var b = this.getTexture(a);
			if (b !== undefined) {
				this.graphics.texture = b
			}
		} else {
			this.graphics = Game.PIXIFactory.createAndAddSprite(a, this)
		}
		this.shouldUpdateGraphics = false;
		this.shouldUpdateDimensions = true
	},
	updateDimensions: function() {
		this.updateLabelDimensions();
		this.updateHitArea();
		this.shouldUpdateDimensions = false
	},
	updateLabelDimensions: function() {
		if (this.labelText && this.labelText.text) {
			if (this._labelAnchor) {
				this.labelText.setAnchorPoint(this._labelAnchor)
			}
			if (this._labelPosition) {
				this.labelText.x = this._labelPosition.x;
				this.labelText.y = this._labelPosition.y
			} else {
				this.labelText.x = Math.floor((this.width - this.labelText.width) / 2);
				this.labelText.y = Math.floor((this.height - this.labelText.height) / 2)
			}
		}
	},
	updateHitArea: function() {
		if (this.hitArea) {
			if (this._customHitArea) {
				this.hitArea = this._customHitArea
			} else {
				this.hitArea.width = this.width;
				this.hitArea.height = this.height
			}
		} else {
			this.hitArea = new PIXI.Rectangle(0, 0, this.width, this.height)
		}
	},
	enable: function(a) {
		this.setEnabled(true)
	},
	disable: function(a) {
		this.setEnabled(false)
	},
	setEnabled: function(a) {
		if (this._enabled === a) {
			return
		}
		this._internalPressed = false;
		this._externalPressed = false;
		this._enabled = a;
		this.shouldUpdateGraphics = true;
		this.shouldUpdateLabel = true
	},
	setCurrentState: function(b) {
		if (this._currentState === b) {
			return
		}
		if (this.labelText) {
			this.labelText.setCurrentState(b);
			this.labelText.setLabelStyle(this.getCurrentLabelStyle())
		}
		var a = this._currentState;
		this._currentState = b;
		this.shouldUpdateGraphics = true;
		this.shouldUpdateLabel = true;
		if (this.soundEnabled && this._enabled) {
			this.playSoundByState(b, a)
		}
	},
	mouseup: function(a) {
		var b = this.checkInteractionTarget(a.data);
		if (this._enabled && this._internalPressed && b) {
			this.executeCallback("click", a);
			if (this.soundEnabled) {
				this.playClickSound()
			}
		}
		this.setStateFromEvent(this.UP, a)
	},
	tap: function(a) {
		var b = this.checkInteractionTarget(a.data);
		if (this._enabled && b) {
			this.executeCallback("click", a);
			if (this.soundEnabled) {
				this.playClickSound()
			}
		}
	},
	setCustomHitArea: function(a) {
		this._customHitArea = a
	},
	setLabel: function(a) {
		if (this._label === a) {
			return
		}
		this._label = a;
		this.shouldUpdateLabel = true
	},
	setLabelStyle: function(a) {
		if (this._labelStyle === a) {
			return
		}
		this._labelStyle = a;
		this.shouldUpdateLabel = true
	},
	setLabelUpStyle: function(a) {
		if (this._labelStyleReferences.up === a) {
			return
		}
		this._labelStyleReferences.up = a;
		this.shouldUpdateLabel = true
	},
	setLabelDownStyle: function(a) {
		if (this._labelStyleReferences.down === a) {
			return
		}
		this._labelStyleReferences.down = a;
		this.shouldUpdateLabel = true
	},
	setLabelOverStyle: function(a) {
		if (this._labelStyleReferences.over === a) {
			return
		}
		this._labelStyleReferences.over = a;
		this.shouldUpdateLabel = true
	},
	setLabelDisabledStyle: function(a) {
		if (this._labelStyleReferences.disabled === a) {
			return
		}
		this._labelStyleReferences.disabled = a;
		this.shouldUpdateLabel = true
	},
	setLabelPosition: function(a) {
		this._labelPosition = a;
		this.shouldUpdateDimensions = true
	},
	setLabelAnchorPoint: function(a) {
		this._labelAnchor = a;
		if (this.labelText) {
			this.labelText.setAnchorPoint(this._labelAnchor)
		}
		this.shouldUpdateDimensions = true
	},
	setLabelMaxWidth: function(a) {
		this._labelMaxWidth = a;
		if (this.labelText) {
			this.labelText.setLabelMaxWidth(a)
		}
	},
	redraw: function() {
		if (this.shouldUpdateLabel) {
			this.updateLabel()
		}
		if (this.shouldUpdateGraphics) {
			this.updateGraphics()
		}
		if (this.shouldUpdateDimensions) {
			this.updateDimensions()
		}
	},
	updateTransform: function() {
		if (this.redraw) {
			this.redraw()
		}
		Interface.utils.PIXIButton.superclass.updateTransform.apply(this, arguments)
	},
	registerTriggers: function() {
		var a = this.ID;
		Services.trigger.registerTrigger("notify:" + a + ".up", this, "When the button returns to the up state.");
		Services.trigger.registerTrigger("notify:" + a + ".hover", this, "When the button is hovered.");
		Services.trigger.registerTrigger("notify:" + a + ".over", this, "When the button hovered but wasn't the initial input target.");
		Services.trigger.registerTrigger("notify:" + a + ".down", this, "When the button is pressed down.");
		Services.trigger.registerTrigger("notify:" + a + ".click", this, "When the button is clicked.")
	},
	playClickSound: function() {
		var b = this.SOUND_CLICK;
		var a = "click";
		if (b) {
			this.fireEvent("request:audioPlayer.play", {
				name: b
			});
			this.fireEvent("notify:" + this.ID + "." + a)
		}
	},
	playSoundByState: function(c, a) {
		var d;
		var b;
		if (c === this.UP) {
			d = this.SOUND_UP;
			b = "up"
		} else {
			if (c === this.DOWN) {
				d = this.SOUND_DOWN;
				b = "down"
			} else {
				if (c === this.OVER && a !== this.DOWN) {
					d = this.SOUND_OVER;
					b = "hover"
				}
			}
		}
		if (d) {
			this.fireEvent("request:audioPlayer.play", {
				name: d
			});
			this.fireEvent("notify:" + this.ID + "." + b)
		}
	}
};
Interface.utils.PIXIButton = Sys.extend(Interface.utils.PIXIInteractive, Interface.utils.PIXIButton, "Interface.utils.PIXIButton");
Sys.ns("Interface.utils");
Interface.utils.PIXICheckBox = {
	DEFAULT_LABEL_GAP: 4,
	constructor: function(h, j, f, c, d, e, g, b, a) {
		Interface.utils.PIXICheckBox.superclass.constructor.apply(this, [h, j, f, c, a]);
		this._selectedGraphicReferences = {
			up: d,
			down: e,
			over: g,
			disabled: b
		};
		this.selected = false;
		this._labelGap = this.DEFAULT_LABEL_GAP;
		this._pooledGraphics = {}
	},
	getTexture: function(a) {
		var b = this._pooledGraphics[a];
		if (!b) {
			b = Game.PIXIFactory.createTexture(a);
			this._pooledGraphics[a] = b
		}
		return b
	},
	updateGraphics: function() {
		var b, a = this.selected ? this._selectedGraphicReferences : this._graphicReferences;
		if (this._enabled) {
			b = a[this._currentState]
		} else {
			b = a.disabled
		}
		if (this.graphics) {
			var c = this.getTexture(b);
			if (c !== undefined) {
				this.graphics.texture = c
			}
		} else {
			this.graphics = Game.PIXIFactory.createAndAddSprite(b, this)
		}
	},
	updateLabelDimensions: function() {
		if (this.labelText && this.labelText.text) {
			if (this._labelPosition) {
				this.labelText.x = this._labelPosition.x;
				this.labelText.y = this._labelPosition.y
			} else {
				this.labelText.x = this.graphics.width + this._labelGap;
				this.labelText.y = Math.floor((this.height - this.labelText.height) / 2)
			}
		}
	},
	setLabelGap: function(a) {
		if (this._labelGap !== a) {
			this._labelGap = a;
			this.shouldUpdateLabel = true
		}
	},
	toggleSelected: function() {
		this.selected = !this.selected
	},
	handleEvent: function(a, b) {
		var c = this.checkInteractionTarget(b.data);
		if (this._enabled && c) {
			if (a === this.DOWN) {
				this.setCurrentState(this.DOWN);
				this._internalPressed = true
			} else {
				if (a === this.UP) {
					if (this._internalOver && this._internalPressed) {
						this.toggleSelected()
					}
					if (this._internalOver) {
						this.setCurrentState(this.OVER)
					} else {
						this.setCurrentState(this.UP)
					}
					this._internalPressed = false
				} else {
					if (a === this.OVER) {
						this._internalOver = true;
						if (this._internalPressed) {
							this.setCurrentState(this.DOWN)
						} else {
							this.setCurrentState(this.OVER)
						}
					} else {
						if (this._internalOver) {
							this._internalOver = false
						}
						this.setCurrentState(this.UP)
					}
				}
			}
		}
	}
};
Interface.utils.PIXICheckBox = Sys.extend(Interface.utils.PIXIButton, Interface.utils.PIXICheckBox, "Interface.utils.PIXICheckBox");
Sys.ns("Interface.utils");
Interface.utils.PIXILabel = {
	DEFAULT_ID: "label",
	constructor: function(c, a, b, d) {
		Interface.utils.PIXILabel.superclass.constructor.apply(this, arguments);
		this.id = d || this.DEFAULT_ID;
		this.setLabel(c);
		this.setLabelStyle(a);
		this.setLabelMaxWidth(b);
		this.updateLabel()
	},
	updateLabel: function() {
		if (this.labelText) {
			this.labelText.text = this._label;
			this.labelText.style = this._labelStyle
		} else {
			this.labelText = new PIXI.Text(this._label, this._labelStyle);
			this.labelText.resolution = 2;
			this.addChild(this.labelText)
		}
		this.shouldUpdateLabel = false;
		if (this.labelText) {
			if (this._labelMaxWidth) {
				this.setLabelMaxWidth(this._labelMaxWidth)
			}
			this.checkLabelMaxWidthAndReduceFontSizeIfNecessary();
			if (this._anchorPoint) {
				this.labelText.anchor = this._anchorPoint
			}
		}
	},
	setAnchorPoint: function(a) {
		this._anchorPoint = a;
		this.updateLabel()
	},
	checkLabelMaxWidthAndReduceFontSizeIfNecessary: function() {
		if (this._labelMaxWidth) {
			var a = this.labelText.style;
			var c = this.getTextWidth(this._label, a);
			if (c > this._labelMaxWidth) {
				var d = this._labelMaxWidth / c;
				var b = a.fontSize.replace("px", "");
				b = parseInt(b, 10);
				b = Math.round(b * d) + "px";
				a.fontSize = b;
				this.fireEvent("notify:" + this.id + ".fontSizeReduced", b)
			}
		}
	},
	getTextWidth: function(b, a) {
		return Game.PIXIUtils.getTextWidth(b, a)
	},
	setLabelMaxWidth: function(a) {
		if (this._labelMaxWidth === a) {
			return
		}
		this._labelMaxWidth = a;
		this.shouldUpdateLabel = true
	},
	setLabel: function(a) {
		if (this._label === a) {
			return
		}
		this._label = a;
		this.shouldUpdateLabel = true
	},
	setLabelStyle: function(a) {
		if (this._labelStyle === a) {
			return
		}
		if (a.font) {
			Sys.applyProperties(a, Game.PIXIUtils.parseFont(a.font));
			delete a.font
		}
		this._labelStyle = a;
		this.style = a;
		this.shouldUpdateLabel = true
	},
	redraw: function() {
		this.alpha = this._enable ? 0.5 : 1;
		if (this.shouldUpdateLabel) {
			this.updateLabel()
		}
	},
	updateTransform: function() {
		if (this.redraw) {
			this.redraw()
		}
		Interface.utils.PIXILabel.superclass.updateTransform.apply(this, arguments)
	}
};
Interface.utils.PIXILabel = Sys.extend(Interface.utils.PIXIInteractive, Interface.utils.PIXILabel, "Interface.utils.PIXILabel");
Sys.ns("Interface.utils");
Interface.utils.PIXIStepSlider = {
	VALUE_CHANGED: "valueChanged",
	constructor: function(c, d, a, b) {
		Interface.utils.PIXIStepSlider.superclass.constructor.apply(this, arguments);
		this._graphicsReferences = {
			bar: c,
			barDisabled: d,
			background: a,
			backgroundDisabled: b
		};
		this._values = [0, 1, 2, 3, 4];
		this._index = 0;
		this._enabled = this._enabled !== false;
		this._pooledGraphics = {};
		this._allowMove = false;
		this.interactive = true;
		this.shouldUpdateDimensions = false;
		this.shouldUpdateGraphics = false;
		this.updateGraphics();
		this.updateDimensions();
		this.enableEventListeners(this._enabled)
	},
	getTexture: function(a) {
		var b = this._pooledGraphics[a];
		if (!b) {
			b = Game.PIXIFactory.createTexture(a);
			this._pooledGraphics[a] = b
		}
		return b
	},
	updateGraphics: function() {
		var a;
		if (this._background) {
			a = this._enabled ? this._graphicsReferences.background : this._graphicsReferences.backgroundDisabled;
			this._background.texture = this.getTexture(a)
		} else {
			this._background = Game.PIXIFactory.createAndAddSprite(this._graphicsReferences.background, this)
		}
		if (this._bar) {
			a = this._enabled ? this._graphicsReferences.bar : this._graphicsReferences.barDisabled;
			this._bar.texture = this.getTexture(a)
		} else {
			this._bar = Game.PIXIFactory.createAndAddSprite(this._graphicsReferences.bar, this)
		}
		this.shouldUpdateGraphics = false;
		this.shouldUpdateDimensions = true
	},
	updateDimensions: function() {
		this._bar.x = (this._background.width - this._bar.texture.width) / 2;
		this._bar.y = (this._background.height - this._bar.texture.height) / 2;
		var a = this._bar.texture.width / this._values.length;
		this._bar.width = Math.round(a * (this._index + 1));
		this.shouldUpdateDimensions = false
	},
	redraw: function() {
		if (this.shouldUpdateGraphics) {
			this.updateGraphics()
		}
		if (this.shouldUpdateDimensions) {
			this.updateDimensions()
		}
	},
	updateTransform: function() {
		if (this.redraw) {
			this.redraw()
		}
		Interface.utils.PIXIStepSlider.superclass.updateTransform.apply(this, arguments)
	},
	pixelToIndex: function(a) {
		var d = this._values.length - 1;
		var c = this._bar.texture.width / this._values.length;
		var e = a - this.worldTransform.tx - this._bar.x;
		var b = Math.floor(e / c);
		if (b < 0) {
			b = 0
		} else {
			if (b > d) {
				b = d
			}
		}
		return b
	},
	moveToPosition: function(a) {
		this.updateDimensions();
		Interface.utils.PIXIStepSlider.superclass.moveToPosition.apply(this, arguments)
	},
	updateIndexFromEventData: function(b) {
		var a = this.pixelToIndex(b.data.global.x);
		if (a > (this._values.length - 1)) {
			a = this._values.length - 1
		}
		if (a < 0) {
			a = 0
		}
		if (this._index === a) {
			return
		}
		this._index = a;
		this.shouldUpdateDimensions = true;
		this.emit(this.VALUE_CHANGED, {
			value: this.getValue(),
			index: this._index
		})
	},
	checkInteractionTarget: function(b) {
		if (Sys.isDefined(b.originalEvent) === false || b.originalEvent === null) {
			return false
		}
		var a = Sys.isDefined(b.originalEvent.target.id);
		return (a && b.originalEvent.target.id === "canvasAnimationManager")
	},
	onMouseDownHandler: function(a) {
		var b = this.checkInteractionTarget(a.data);
		if (b) {
			this._allowMove = true
		}
	},
	onMouseMoveHandler: function(a) {
		if (this._allowMove) {
			this.updateIndexFromEventData(a)
		}
	},
	onMouseUpHandler: function(a) {
		this._allowMove = false;
		this.updateIndexFromEventData(a)
	},
	enableEventListeners: function(a) {
		if (a) {
			this.clickCallback = this.onMouseUpHandler.bind(this);
			this.upCallback = this.onMouseUpHandler.bind(this);
			this.upOutsideCallback = this.onMouseUpHandler.bind(this);
			this.downCallback = this.onMouseDownHandler.bind(this);
			this.moveCallback = this.onMouseMoveHandler.bind(this)
		} else {
			this.clickCallback = undefined;
			this.upCallback = undefined;
			this.upOutsideCallback = undefined;
			this.downCallback = undefined;
			this.moveCallback = undefined
		}
	},
	setEnabled: function(a) {
		if (this._enabled === a) {
			return
		}
		this._enabled = a;
		this.enableEventListeners(this._enabled);
		this.shouldUpdateGraphics = true
	},
	setIndex: function(a) {
		if (a > (this._values.length - 1)) {
			a = this._values.length - 1
		}
		if (a < 0) {
			a = 0
		}
		if (this._index === a) {
			return
		}
		this._index = a;
		this.shouldUpdateDimensions = true
	},
	getIndex: function() {
		return this._index
	},
	setValues: function(a) {
		if (this._values === a) {
			return
		}
		this._values = a;
		this.shouldUpdateDimensions = true
	},
	getValue: function() {
		return this._values[this._index]
	}
};
Interface.utils.PIXIStepSlider = Sys.extend(Interface.utils.PIXIInteractive, Interface.utils.PIXIStepSlider, "Interface.utils.PIXIStepSlider");
Sys.ns("Interface.utils");
Interface.utils.PIXIValueStepper = {
	VALUE_CHANGED: "valueChanged",
	DEFAULT_GAP: 4,
	constructor: function(f, b, d, g, h, c, j, e, a) {
		Interface.utils.PIXIValueStepper.superclass.constructor.apply(this, arguments);
		this._enabled = this._enabled !== false;
		this.interactive = false;
		this._values = [0, 1, 2, 3, 4];
		this._index = 0;
		this._labelVerticalOffset = 0;
		this._gap = this.DEFAULT_GAP;
		this.shouldUpdateValueTextField = false;
		this.shouldUpdateDimensions = true;
		this._backgroundImageContainer = new PIXI.Container();
		this.addChild(this._backgroundImageContainer);
		this.createButtons(f, b, d, g, h, c, j, e, a);
		this.createValueText();
		this.valueTextMaxWidth = this.getValueTextMaxWidth(this._values)
	},
	createButtons: function(h, b, f, j, k, d, l, g, a) {
		var c = Sys.isDefined(a) ? a + "Increase" : undefined;
		var e = Sys.isDefined(a) ? a + "Decrease" : undefined;
		this.plusButton = new Interface.utils.PIXIButton(k, d, l, g, c);
		this.plusButton.clickCallback = this.plusClickHandler.bind(this);
		this.addChild(this.plusButton);
		this.minusButton = new Interface.utils.PIXIButton(h, b, f, j, e);
		this.minusButton.clickCallback = this.minusClickHandler.bind(this);
		this.addChild(this.minusButton)
	},
	createValueText: function() {
		this.valueTextField = Game.PIXIFactory.createAndAddText(this.getValue(), {}, this)
	},
	getValueTextMaxWidth: function(a) {
		var e = 0;
		for (var b = 0; b < a.length; b++) {
			var d = a[b];
			this.valueTextField.text = d;
			this.valueTextField.updateTransform();
			var c = this.valueTextField.width;
			if (c > e) {
				e = c
			}
		}
		return e
	},
	setValueTextMaxWidth: function(a) {
		this._maxWidthValues = a;
		this.valueTextMaxWidth = this.getValueTextMaxWidth(a)
	},
	increaseIndex: function() {
		var a = this.getIndex();
		this.setIndexWithValueChangedEvent(a + 1)
	},
	decreaseIndex: function() {
		var a = this.getIndex();
		this.setIndexWithValueChangedEvent(a - 1)
	},
	setIndexWithValueChangedEvent: function(a) {
		if (a > (this._values.length - 1)) {
			a = this._values.length - 1
		}
		if (a < 0) {
			a = 0
		}
		if (this._index === a) {
			return
		}
		this._index = a;
		this.shouldUpdateValueTextField = true;
		this.emit(this.VALUE_CHANGED, {
			value: this.getValue(),
			index: this._index
		})
	},
	moveToPosition: function(a) {
		this.updateDimensions();
		Interface.utils.PIXIValueStepper.superclass.moveToPosition.apply(this, arguments)
	},
	plusClickHandler: function() {
		this.increaseIndex()
	},
	minusClickHandler: function() {
		this.decreaseIndex()
	},
	updateButtonsEnableState: function() {
		if (this._index === 0) {
			this.minusButton.setEnabled(false)
		} else {
			if (this.minusButton.getEnabled() === false) {
				this.minusButton.setEnabled(true)
			}
		}
		if (this._index === this._values.length - 1) {
			this.plusButton.setEnabled(false)
		} else {
			if (this.plusButton.getEnabled() === false) {
				this.plusButton.setEnabled(true)
			}
		}
	},
	updateValueTextField: function() {
		if (this.valueTextField) {
			this.valueTextField.text = Sys.isDefined(this._fixedNumberOfDigits) ? Sys.utils.numberToFixedDigits(this.getValue(), this._fixedNumberOfDigits) : this.getValue();
			this.valueTextField.style = this._textStyle;
			if (this._enabled) {
				this.updateButtonsEnableState()
			}
		}
		this.shouldUpdateValueTextField = false;
		this.shouldUpdateDimensions = true
	},
	updateDimensions: function() {
		var c = (this._valueTextCustomWidth === undefined) ? this.valueTextMaxWidth : this._valueTextCustomWidth;
		var b = (c - this.valueTextField.width),
			f, e, d, a;
		this.valueTextField.x = this.minusButton.width + this._gap + (b / 2);
		this.valueTextField.y = (this.minusButton.height - this.valueTextField.height) / 2 + this._labelVerticalOffset;
		this.plusButton.x = this.minusButton.width + this._gap + c + this._gap;
		if (Sys.isDefined(this._backgroundColor)) {
			if (!this.background) {
				this.background = new PIXI.Graphics();
				this.addChildAt(this.background, 0)
			}
			f = this._paddingBackgroundX || this.minusButton.x + this.minusButton.width - 5;
			e = this._paddingBackgroundY || this.minusButton.y;
			d = this._paddingBackgroundWidth || this.plusButton.x - f + 5;
			a = this._paddingBackgroundHeight || this.minusButton.height;
			this.background.clear();
			this.background.beginFill(this._backgroundColor, this._backgroundOpacity);
			this.background.drawRect(f, this.minusButton.x, d, a);
			this.background.endFill()
		}
		if (Sys.isDefined(this._backgroundImage)) {
			f = this._paddingBackgroundX + 5 || this.minusButton.x + this.minusButton.width;
			e = this._paddingBackgroundY || this.minusButton.y;
			this._backgroundImage.position = new PIXI.Point(f, e)
		}
		this.shouldUpdateDimensions = false
	},
	redraw: function() {
		if (this.shouldUpdateValueTextField) {
			this.updateValueTextField()
		}
		if (this.shouldUpdateDimensions) {
			this.updateDimensions()
		}
	},
	updateTransform: function() {
		if (this.redraw) {
			this.redraw()
		}
		Interface.utils.PIXIValueStepper.superclass.updateTransform.apply(this, arguments)
	},
	setValueFieldStyle: function(a) {
		if (this._textStyle === a) {
			return
		}
		if (a.font) {
			Sys.applyProperties(a, Game.PIXIUtils.parseFont(a.font));
			delete a.font
		}
		this._textStyle = a;
		this.shouldUpdateValueTextField = true
	},
	setBackground: function(a, b) {
		if (this._backgroundColor === a && this._backgroundOpacity === b) {
			return
		}
		this._backgroundColor = a;
		this._backgroundOpacity = b || 1;
		this.shouldUpdateDimensions = true;
		this.redraw()
	},
	setBackgroundImage: function(a) {
		this._backgroundImage = Game.PIXIFactory.createAndAddSprite(a, this._backgroundImageContainer);
		this.shouldUpdateDimensions = true;
		this.redraw()
	},
	setEnabled: function(a) {
		if (this._enabled === a) {
			return
		}
		this._enabled = a;
		if (a) {
			this.updateButtonsEnableState()
		} else {
			this.plusButton.setEnabled(a);
			this.minusButton.setEnabled(a)
		}
	},
	setGap: function(a) {
		if (this._gap === a) {
			return
		}
		this._gap = a;
		this.shouldUpdateDimensions = true
	},
	setIndex: function(a) {
		if (a > (this._values.length - 1)) {
			a = this._values.length - 1
		}
		if (a < 0) {
			a = 0
		}
		if (this._index === a) {
			return
		}
		this._index = a;
		this.shouldUpdateValueTextField = true
	},
	getIndex: function() {
		return this._index
	},
	setValues: function(a) {
		if (this._values === a) {
			return
		}
		this._values = a;
		var b = this._maxWidthValues || this._values;
		this.valueTextMaxWidth = this.getValueTextMaxWidth(a);
		this.shouldUpdateValueTextField = true
	},
	setValueTextWidth: function(a) {
		if (this._valueTextCustomWidth === a) {
			return
		}
		this._valueTextCustomWidth = a;
		this.updateDimensions()
	},
	getValues: function() {
		return this._values
	},
	setValue: function(b) {
		var a = this._values.indexOf(b);
		if (a >= 0) {
			this.setIndex(a)
		}
	},
	getValue: function() {
		return this._values[this._index]
	},
	setButtonPadding: function(d, b, a, c) {
		this._paddingBackgroundHeight = this.minusButton.height - d - a;
		this._paddingBackgroundY = this.minusButton.y + d;
		this._paddingBackgroundWidth = this.plusButton.x - this.minusButton.x - this.minusButton.width + 10 + c + b;
		this._paddingBackgroundX = this.minusButton.x + this.minusButton.width - 5 - c;
		this.minusButton.setCustomHitArea(new PIXI.Rectangle(c, d, this.minusButton.width - c - b, this.minusButton.height - d - a));
		this.plusButton.setCustomHitArea(new PIXI.Rectangle(c, d, this.plusButton.width - c - b, this.plusButton.height - d - a));
		this.shouldUpdateDimensions = true;
		this.redraw()
	},
	useFixedNumberOfDigits: function(a) {
		this._fixedNumberOfDigits = a;
		this.shouldUpdateValueTextField = true
	}
};
Interface.utils.PIXIValueStepper = Sys.extend(Interface.utils.PIXIControl, Interface.utils.PIXIValueStepper, "Interface.utils.PIXIValueStepper");
Sys.ns("Interface.utils");
Interface.utils.PIXIValueStepperWithSlider = {
	DEFAULT_GAP: 4,
	constructor: function(h, c, f, j, l, e, n, g, k, d, a, m, b) {
		Interface.utils.PIXIValueStepperWithSlider.superclass.constructor.apply(this, [h, c, f, j, l, e, n, g, b]);
		this.createSlider(k, d, a, m)
	},
	createSlider: function(c, d, a, b) {
		this.slider = new Interface.utils.PIXIStepSlider(c, d, a, b);
		this.slider.setValues(this.getValues());
		this.slider.setIndex(this.getIndex());
		this.slider.on("valueChanged", this.sliderValueChangeHandler, this);
		this.addChild(this.slider)
	},
	setIndexWithValueChangedEvent: function(a) {
		Interface.utils.PIXIValueStepperWithSlider.superclass.setIndexWithValueChangedEvent.apply(this, arguments);
		this.slider.setIndex(a)
	},
	sliderValueChangeHandler: function(b) {
		var a = b.index;
		if (a > (this._values.length - 1)) {
			a = this._values.length - 1
		}
		if (a < 0) {
			a = 0
		}
		if (this._index === a) {
			return
		}
		this._index = a;
		this.shouldUpdateValueTextField = true;
		this.emit(this.VALUE_CHANGED, {
			value: this.getValue(),
			index: this._index
		})
	},
	updateGraphics: function() {
		Interface.utils.PIXIValueStepperWithSlider.superclass.updateGraphics.apply(this, arguments)
	},
	updateDimensions: function() {
		Interface.utils.PIXIValueStepperWithSlider.superclass.updateDimensions.apply(this, arguments);
		var b = this._sliderVerticalOffset || 0,
			d = this._sliderHorizontalOffset || 0,
			a = this.plusButton.x + this.plusButton.width,
			c = this._forcedSliderWidth || this.slider.width;
		this.slider.x = (a - c) / 2 + d;
		this.slider.y = this.minusButton.height + this._gap + b;
		this.shouldUpdateDimensions = false
	},
	setEnabled: function(a) {
		Interface.utils.PIXIValueStepperWithSlider.superclass.setEnabled.apply(this, arguments);
		this.slider.setEnabled(a)
	},
	setIndex: function(a) {
		Interface.utils.PIXIValueStepperWithSlider.superclass.setIndex.apply(this, arguments);
		this.slider.setIndex(a)
	},
	setValues: function(a) {
		Interface.utils.PIXIValueStepperWithSlider.superclass.setValues.apply(this, arguments);
		this.slider.setValues(a)
	},
	setSliderVerticalOffset: function(a) {
		this._sliderVerticalOffset = a
	},
	setSliderHorizontalOffset: function(a) {
		this._sliderHorizontalOffset = a
	},
	setLabelVerticalOffset: function(a) {
		this._labelVerticalOffset = a
	},
	forceSliderWidth: function(a) {
		this._forcedSliderWidth = a;
		this.shouldUpdateDimensions = true
	}
};
Interface.utils.PIXIValueStepperWithSlider = Sys.extend(Interface.utils.PIXIValueStepper, Interface.utils.PIXIValueStepperWithSlider, "Interface.utils.PIXIValueStepperWithSlider");
Sys.ns("Animation");
Animation.AddFilter = {
	constructor: function(a) {
		a.renderable = false;
		PIXI.Filter.call(this, null, "precision mediump float;varying vec2 vTextureCoord;uniform float delta;uniform sampler2D uSampler;uniform sampler2D fadeToTexture;void main(void){   vec4 color;   vec4 fromColor = texture2D(uSampler, vTextureCoord);   vec4 toColor = texture2D(fadeToTexture, vTextureCoord);   color.r = (toColor.r * delta) + (fromColor.r * (1.0 - delta));   color.b = (toColor.b * delta) + (fromColor.b * (1.0 - delta));   color.g = (toColor.g * delta) + (fromColor.g * (1.0 - delta));   color.a = (toColor.a * delta) + (fromColor.a * (1.0 - delta));   gl_FragColor = color;}", {
			fadeToTexture: {
				type: "sampler2D",
				value: a.texture
			},
			delta: {
				type: "1f",
				value: 0
			}
		})
	}
};
Animation.AddFilter = Sys.extend(Sys.Observable, Animation.AddFilter, "Animation.AddFilter");
Animation.AddFilter.prototype = Object.create(PIXI.Filter.prototype);
Object.defineProperties(Animation.AddFilter.prototype, {
	delta: {
		get: function() {
			return this.uniforms.delta.value
		},
		set: function(a) {
			this.uniforms.delta.value = a
		}
	}
});
Sys.ns("Animation");
Animation.DesaturationFilter = {
	constructor: function() {
		PIXI.Filter.call(this, null, "precision mediump float;varying vec2 vTextureCoord;uniform float delta;uniform float alpha;uniform sampler2D uSampler;void main(void){   vec4 color = texture2D(uSampler, vTextureCoord);   color.rgb = mix(color.rgb, vec3(0.2126*color.r + 0.7152*color.g + 0.0722*color.b), delta);   color.a = color.a * alpha;   gl_FragColor = color;}", {
			delta: {
				type: "1f",
				value: 1
			},
			alpha: {
				type: "1f",
				value: 1
			}
		})
	}
};
Animation.DesaturationFilter = Sys.extend(Sys.Observable, Animation.DesaturationFilter, "Animation.DesaturationFilter");
Animation.DesaturationFilter.prototype = Object.create(PIXI.Filter.prototype);
Object.defineProperties(Animation.DesaturationFilter.prototype, {
	delta: {
		get: function() {
			return this.uniforms.delta.value
		},
		set: function(a) {
			this.uniforms.delta.value = a
		}
	},
	alpha: {
		get: function() {
			return this.uniforms.alpha.value
		},
		set: function(a) {
			this.uniforms.alpha.value = a
		}
	}
});
Sys.ns("Language");
(function(b) {
	for (var a in b) {
		if (b.hasOwnProperty(a)) {
			Language.Keys[a] = b[a]
		}
	}
}({
	dontShowNextTime: "dontShowNextTime",
	continueButton: "OCTbutton_CONTINUE",
	startButton: "startFinn",
	totalWin: "OCTtotalWinWithColon",
	win: "OCTwin",
	freeSpinsLeftUC: "freeSpinsLeftUC",
	congratulations: "OCTcongratsLC",
	welcomeFreeSpinsWorld: "welcomeFreeSpinsWorld",
	coinsWon: "OCTcoinsWonColon",
	freeSpinsFinnCoinsGolden: "freeSpinsFinnCoinsGolden",
	freeSpinsFinnCoinsLava: "freeSpinsFinnCoinsLava",
	freeSpinsFinnCoinsLucky: "freeSpinsFinnCoinsLucky",
	freeSpinsFinnCoinsStar: "freeSpinsFinnCoinsStar",
	welcome: "welcomeFinn",
	openingSoon: "openingSoonFinn",
	freeSpinsFinn: "freeSpinsFinn",
	keysToUnlockFinn: "keysToUnlockFinn",
	keyToUnlockFinn: "keyToUnlockFinn",
	featureColonFinn: "featureColonFinn",
	numberOfFreeSpins: "numberOfFreeSpins",
	freeSpinsLeftColon: "FreeSpinsLeftColon",
	youNeedKeys: "youNeedKeys",
	freeSpinsLeft: "freeSpinsLeftNoCol",
	freeSpinLeft: "freeSpinLeftNoColon",
	lastFreeSpin: "lastFreeSpin",
	PaytableSymbols: "OCTsymbolPayout",
	PaytableWild: "wildSymUC",
	PaytableWildText0: "wildSubstituteExceptKey",
	PaytableWildText1: "wildSymbolsMobileFlagship",
	PaytableWildText2: "avalancheGeneration1",
	PaytableWildText3: "avalancheGeneration2",
	PaytableWildText4: "avalancheGeneration3",
	PaytableWildText5: "avalancheGeneration4",
	PaytableWildText6: "avalancheGeneration5",
	PaytableWildText7: "avalancheGeneration6",
	PaytableWildText8: "avalancheGeneration7",
	PaytableBonus: "bonusSymbolHeaderMobileFlagship",
	PaytableBonusText0: "bonusSymbol1",
	PaytableBonusText1: "bonusSymbol2",
	PaytableBonusText2: "bonusSymbol3",
	PaytableBonusText3: "bonusSymbol4",
	PaytableRandomFeatures: "randomFeaturesHeader",
	PaytableRandomFeaturesText0: "randomFeatures1",
	PaytableRandomFeaturesText1: "randomFeatures2",
	PaytableRandomFeaturesText2: "randomFeatures3",
	PaytableRandomFeaturesText3: "randomFeatures4Paytable",
	PaytableRF1: "starfallWildTitle",
	PaytableRF1Text0: "randomFeatures7",
	PaytableRF1Text1: "randomFeatures8",
	PaytableRF1Text2: "randomFeatures9",
	PaytableRF1Text3: "randomFeatures10",
	PaytableRF1Text4: "randomFeatures11",
	PaytableRF1Text5: "randomFeatures12",
	PaytableRF2: "dragonDestroyTitle",
	PaytableRF2Text0: "randomFeatures5",
	PaytableRF2Text1: "randomFeatures6",
	PaytableRF3: "drunkenLuckName",
	PaytableRF3Text0: "randomFeatures18",
	PaytableRF3Text1: "randomFeatures19",
	PaytableRF3Text2: "randomFeatures20",
	PaytableRF4: "magicTransformTitle",
	PaytableRF4Text0: "randomFeatures14",
	PaytableRF4Text1: "randomFeatures15",
	PaytableRF4Text2: "randomFeatures16",
	PaytableRF4Text3: "randomFeatures17",
	PaytableKeyCollecting: "titleKeyCollecting",
	PaytableKeyCollectingText0: "freeSpinsMobileFlagship6",
	PaytableKeyCollectingText1: "freeSpinsMobileFlagship7",
	PaytableKeyCollectingText2: "totalNumberKeys",
	PaytableBonusGame: "OCTfreeSpinsUC",
	PaytableBonusGameText0: "freeSpinsMobileFlagship1",
	PaytableBonusGameText1: "freeSpinsMobileFlagship2",
	PaytableBonusGameText2: "freeSpinsMobileFlagship3",
	PaytableFS1: "titleTheStarBar",
	PaytableFS1Text1: "starBarNumberFS",
	PaytableFS1Text2: "starBarKeyRequire",
	PaytableFS1Text0: "freeSpinsMobileFlagship8",
	PaytableFS2: "titleDragonsCave",
	PaytableFS2Text0: "freeSpinsMobileFlagship10",
	PaytableFS2Text1: "freeSpinsMobileFlagship11",
	PaytableFS2Text2: "freeSpinsMobileFlagship12",
	PaytableFS2Text3: "StickyWildFeatureUC",
	PaytableFS2Text4: "freeSpinsMobileFlagship9",
	PaytableFS2Text5: "finnStickyWild",
	PaytableFS2Text6: "lavaNumberFS",
	PaytableFS2Text7: "lavaLairKeyRequire",
	PaytableFS2Text8: "stickyWildLavaLairOnly",
	PaytableFS3: "luckyMugTitle",
	PaytableFS3Text0: "freeSpinsMobileFlagship13",
	PaytableFS3Text1: "freeSpinsMobileFlagship14",
	PaytableFS3Text2: "freeSpinsMobileFlagship15",
	PaytableFS3Text3: "freeSpinsMobileFlagship16",
	PaytableFS3Text4: "luckyMugNumberFS",
	PaytableFS3Text5: "luckyMugKeyRequire",
	PaytableFS4: "titleGoldenPot",
	PaytableFS4Text0: "freeSpinsMobileFlagship17",
	PaytableFS4Text1: "freeSpinsMobileFlagship18",
	PaytableFS4Text2: "freeSpinsMobileFlagship19",
	PaytableFS4Text3: "goldenPotNumberFS",
	PaytableFS4Text4: "goldenPotKeyRequire",
	PaytableWinSituations: "winMatchesHeader",
	PaytableWinSituationsText0: "winMatches1",
	PaytableWinSituationsText1: "winMatches2",
	PaytableWinSituationsText2: "winMatches3",
	PaytableWinSituationsText3: "winMatches4",
	Disclaimer0: "OCTpaytableHighestWinMatch",
	Disclaimer1: "3matchSymbols",
	Disclaimer2: "OCTvoidAllPays",
	Disclaimer3: "OCTextraInfo",
	Disclaimer4: "paytableInfoBetLevel1"
}));
Sys.override(Interface.SettingsWindowDesktopView, {
	showChild: function(a) {
		if (a === "paytable") {
			this.container.el.style.visibility = "hidden"
		} else {
			this.container.el.style.visibility = "visible"
		}
		this.setTitle(this.model.getChildConfig(a).title)
	}
});
Sys.ns("Finn");
Finn.BufferedSpinView = {
	constructor: function() {
		Finn.BufferedSpinView.superclass.constructor.apply(this, arguments)
	},
	setAnimationSpeed: function(d, b) {
		var c = this,
			a = c.currentReelGroup();
		a.setAnimationSpeed(d, b)
	},
	initAnimations: function() {
		var d = this,
			b = Resources.readData("config").reelGroups,
			e = d.model.readData("currentReelSet"),
			a, c = [],
			g = {},
			h = {},
			f = this.model.readData("spinType");
		Sys.iterate(b, function(k, j) {
			a = new Finn.ReelGroup(k, j, {
				reelStartCompleteCallback: d.onReelStartComplete.bind(d, k),
				reelStartedStoppingCallback: d.onReelStartedStopping.bind(d, k),
				reelBounceStartCallback: d.onReelStartedBouncing.bind(d, k),
				reelStoppedCallback: d.onReelStopped.bind(d, k),
				symbolBounceCallback: d.onSymbolBounceCallback.bind(d, k),
				fadeInStartedCallback: d.onFadeInStartedCallback.bind(d, k)
			}, d.isLowEndDevice());
			if (Sys.isDefined(f)) {
				a.setSpinType(f)
			}
			c.push(a);
			Sys.each(j.reelSets, function(l) {
				g[l] = a
			});
			h[k] = a
		});
		d.randomizer = new Finn.Randomizer();
		d.randomizer.initiate(["symbolBounce1", "symbolBounce2", "symbolBounce3", "symbolBounce4", "symbolBounce5"]);
		d.reelGroups = c;
		d.reelSetToGroupMapping = g;
		d.groupNameToGroupMapping = h;
		if (Sys.isDefined(e)) {
			d.activateReelSet(e, d.model.readData("startScene"))
		}
	},
	isLowEndDevice: function() {
		return false
	},
	replaceSymbols: function(c, b) {
		var a = this;
		a.currentReelGroup().replaceSymbols(c, b)
	},
	startFreeSpinTrigger: function() {
		var a = this;
		a.currentReelGroup().startFreeSpinTrigger()
	},
	stopBonusAttention: function() {
		var a = this;
		a.currentReelGroup().stopBonusAttention()
	},
	switchAmbienceAfterWinAnimation: function() {
		var a = this;
		a.currentReelGroup().switchAmbienceAfterWinAnimation()
	},
	onSymbolBounceCallback: function() {
		var a = this,
			b = a.randomizer.draw();
		a.fireEvent("view:playAudio", {
			name: b,
			id: b
		})
	},
	onFadeInStartedCallback: function() {
		var a = this;
		if (!a.spinSoundStarted) {
			if (a.model.readData("slowSpin")) {
				a.fireEvent("view:playAudio", {
					id: "slowReelSpin",
					name: "slowReelSpin"
				})
			} else {
				if (a.model.readData("spinType") === "quickSpin") {
					a.fireEvent("view:playAudio", {
						id: "quickReelSpin",
						name: "quickReelSpin"
					})
				} else {
					a.fireEvent("view:playAudio", a.getSoundConfig("reelSpin"))
				}
			}
			a.spinSoundStarted = true
		}
	},
	onReelStartComplete: function(a, c) {
		var b = this;
		b.fireEvent("view:startSpinComplete", c)
	},
	presentInitOutcome: function(b) {
		var a = this;
		Sys.each(a.reelGroups, function(c) {
			c.presentInitOutcome(b)
		})
	},
	resetSpinType: function() {
		var a = this;
		Sys.each(a.reelGroups, function(b) {
			b.resetSpinType()
		})
	}
};
Finn.BufferedSpinView = Sys.extend(Core.Slots.BufferedSpinView, Finn.BufferedSpinView, "Finn.BufferedSpinView");
Sys.ns("Finn");
Finn.BufferedSpinViewLow = {
	constructor: function() {
		Finn.BufferedSpinView.superclass.constructor.apply(this, arguments)
	},
	isLowEndDevice: function() {
		return true
	}
};
Finn.BufferedSpinViewLow = Sys.extend(Finn.BufferedSpinView, Finn.BufferedSpinViewLow, "Finn.BufferedSpinViewLow");
Sys.ns("Finn");
Finn.BufferedSpinController = {
	constructor: function() {
		Finn.BufferedSpinController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:responseParser.responseParsed": a.serverResponse,
			"notify:responseParser.bonusActionResponseParsed": a.serverResponse,
			"notify:stateHandler.enteringSpinningState": a.wantStartSpin,
			"notify:stateHandler.enteringStoppingState": a.wantStopSpin,
			"notify:stateHandler.enteringFreeSpinTriggerState": a.startFreeSpinTrigger,
			"notify:quickStopper.quickStop": a.quickStop,
			"notify:settingsManager.settingChanged": a.onSettingsChanged,
			"request:spin.stopBonusAttention": a.stopBonusAttention,
			"notify:spin.switchAmbience": a.switchAmbienceAfterWinAnimation,
			"request:spin.startNewRound": a.startNewRound,
			"request:spin.activateReelset": a.activateReelSet,
			"request:spin.activateInitReelset": a.activateReelSet,
			"request:spin.deactivateReelset": a.deactivateReelSet,
			"request:spin.presentInitOutcome": a.presentInitOutcome,
			"request:spin.startSpin": a.startSpin,
			"request:spin.stopSpin": a.stopSpin,
			"request:spin.cancelSpin": a.cancelSpin,
			"request:spin.activateDefaultOutcome": a.cancelSpin,
			"request:spin.setSymbols": a.setSymbols,
			"request:spin.pauseStopSequence": a.pauseStopSequence,
			"request:spin.resumeStopSequence": a.resumeStopSequence,
			"request:spin.updateInitReelInfo": a.setInitialOutcomeInfo,
			"request:spin.hideSymbols": a.hideSymbols,
			"request:spin.showSymbols": a.showSymbols,
			"request:spin.replaceSymbols": a.replaceSymbols,
			"request:spin.setTimeToMoveOneSlot": a.setTimeToMoveOneSlot,
			"view:startSpinComplete": a.onStartSpinComplete,
			"view:reelStoppedSpinning": a.announceReelStopped,
			"view:reelStopBouncingStarted": a.announceReelStopBouncingStarted,
			"view:allReelsStoppedSpinning": a.announceSpinComplete,
			"view:stopSequencePaused": a.announceSpinStopSequencePaused,
			"view:stopSequenceResumed": a.announceSpinStopSequenceResumed,
			"view:resumeStopSequence": a.resumeStopSequence,
			"view:reelStopStarted": a.announceStopSpinStarted,
			"view:fillerEvent": a.announceFillerEvent,
			"view:nearWinStarted": a.announceNearWinStarted,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop")
		})
	},
	setAnimationSpeed: function(c, a) {
		var b = this;
		b.view.setAnimationSpeed(c, a)
	},
	isPreRandomFeature: function(a) {
		return (a.clientaction === "spin" && a.rf && (a.rf.feature === "randomwilds" || a.rf.feature === "symboltransform"))
	},
	serverResponse: function(f) {
		var c = f.clientaction === "spin",
			b = f.rf && f.rf.feature === "randomwilds",
			e = f.rf && f.rf.feature === "symboltransform",
			a = c && (b || e),
			d;
		this.fireEvent("request:spin.child.storeServerResponse", f);
		this.model.storeData("initSpin", false);
		if (!f.clientaction.contains("init") && f.clientaction !== "endbonus" && f.clientaction !== "bonusaction") {
			this.model.storeData("isValidServerResponse", true);
			this.fireEvent("notify:spin:serverResponseReceived")
		} else {
			if (f.clientaction === "init") {
				this.model.storeData("initSpin", true)
			}
		}
		this.model.storeData("serverResponse", f);
		if (a) {
			this.setAnimationSpeed(850, true);
			this.fireEvent("request:quickStopper.disableForRandomFeature", d);
			this.fireEvent("request:character.randomFeatureStart." + f.rf.feature);
			this.model.storeData("slowSpin", true)
		} else {
			if (c || f.clientaction === "drop") {
				this.view.resetSpinType();
				this.model.storeData("slowSpin", false)
			}
		}
	},
	startSpin: function(b, d) {
		var c = this,
			e = c.model.readData("serverResponse"),
			a;
		if (e.gamestate.current === "basic" && !(Sys.isDefined(e.freespin) && e.nextaction === "spin") && c.model.readData("initSpin") && e.restore) {
			c.activateReelSet(b, d);
			c.restoreSpin(e)
		}
		if (c.model.readData("serverResponse").reelInfo) {
			a = c.getHeldReels()
		}
		c.aborted = false;
		c.dialogClosed = false;
		c.allReelsHaveStopped = false;
		c.model.storeData("isValidServerResponse", false);
		c.announceSpinStarted(b);
		if (c.model.readData("currentReelSet") !== b) {
			c.activateReelSet(b, d)
		}
		c.view.startSpin(a)
	},
	stopSpin: function(b, a, c) {
		Finn.BufferedSpinController.superclass.stopSpin.apply(this, arguments);
		this.fireEvent("request:keyHole.animate")
	},
	restoreSpin: function(c) {
		var b = this,
			a = Sys.isDefined(c.wins) ? c.wins.wintype : "smallWin";
		b.view.presentInitOutcome(c.reelInfo);
		b.fireEvent("request:winningSymbols.restoreWinningSymbols");
		b.fireEvent("request:winBanner.setWinType", a);
		b.fireEvent("request:winBanner.setCountUpDuration", 0);
		b.fireEvent("request:winBanner.animate");
		b.fireEvent("request:character.setProgressiveIdle");
		b.fireEvent("request:ambienceManager.ambienceEnableState", true)
	},
	replaceSymbols: function(a) {
		var c = this,
			b = a[0],
			d = a[1];
		c.view.replaceSymbols(b, d)
	},
	startFreeSpinTrigger: function() {
		var a = this;
		a.view.startFreeSpinTrigger()
	},
	stopBonusAttention: function() {
		var a = this;
		a.view.stopBonusAttention()
	},
	switchAmbienceAfterWinAnimation: function() {
		var a = this;
		a.view.switchAmbienceAfterWinAnimation()
	},
	setInitialOutcomeInfo: function(b, a) {
		this.model.setInitialOutcomeInfo(b, a)
	},
	presentInitOutcome: function(a) {
		this.view.presentInitOutcome(Resources.readData("config").reelSets[a].noWinOutcome)
	},
	announceSpinComplete: function() {
		var b = this,
			d = b.model.readData("serverResponse"),
			a = Services.settingsManager.getSetting("autoPlayNrSpins"),
			c = Sys.isDefined(a) && a > 0;
		if (b.aborted) {
			if (b.dialogClosed) {
				b.view.show()
			}
		}
		b.allReelsHaveStopped = true;
		if (d && ((c && d.gameover === true) || d.nextaction === "freespin")) {
			setTimeout(function() {
				b.fireEvent("notify:spin.spinAnimationComplete");
				b.fireEvent("notify:spin.AllIsStopped")
			}, 500)
		} else {
			this.fireEvent("notify:spin.spinAnimationComplete");
			this.fireEvent("notify:spin.AllIsStopped")
		}
	}
};
Finn.BufferedSpinController = Sys.extend(Core.Slots.BufferedSpinController, Finn.BufferedSpinController, "Finn.BufferedSpinController");
Sys.ns("Finn");
Finn.ReelGroup = function(e, a, c, d) {
	var b = this;
	b.spinType = "standard";
	b.spinTimes = a.spinTimes;
	b.reelHaveBeenCleared = Sys.utils.initArray(a.numberOfReels, false);
	b.createReelLists(e, a.numberOfReels, a.reelLayout, c, d)
};
Finn.ReelGroup.prototype = {
	createReelLists: function(k, b, g, h, d) {
		var j = this,
			f = 0,
			e, c, a;
		j.reelLists = [];
		j.reels = new PIXI.Container();
		j.reels.id = "reelsMainContainer";
		j.reels.visible = false;
		Game.stage.view.animationManager.getLayer("reel").addChild(j.reels);
		for (; f < b; f++) {
			e = Sys.applyProperties({}, g.standard);
			if (Sys.isDefined(g[f])) {
				Sys.applyProperties(e, g[f])
			}
			e.id = k + "_" + f;
			e.reelStopDelay = j.spinTimes[j.spinType].reelStopDelays[f];
			e.symbolInitialMoveX = g.symbolInitialMoveX[f];
			e.symbolInitialMoveY = g.symbolInitialMoveY[f];
			e.symbolPositions = g.symbolPositions;
			e.spiral = g.spiral;
			e.isLowEnd = d;
			Sys.applyProperties(e, j.getReelSpecificCallbacks(f, h));
			c = new Finn.BufferedReel(e);
			j.reelLists.push(c);
			j.reels.addChild(c.pixiContainer)
		}
		j.addReelMask(g.standard);
		j.presentInitOutcome(Resources.readData("config").reelSets.basic1.noWinOutcome)
	},
	createMeshAnimation: function() {
		var a = this;
		a.meshAnimation = Game.PIXIFactory.createAndAddSpineAnimation("spineTest5", a.reels);
		a.meshAnimation.fire = function(c, b) {
			a.meshAnimation.state.setAnimation(0, "bounce", true);
			a.meshAnimation.visible = true
		};
		a.meshAnimation.position.x = 100;
		a.meshAnimation.position.y = 350
	},
	startAnimate: function() {},
	addReelMask: function(a) {
		var b = new PIXI.Graphics();
		b.beginFill(16711680, 0.8);
		b.drawRect(0, a.top, 1280, a.visibleLength);
		b.endFill();
		this.reels.addChild(b);
		this.reels.mask = b
	},
	getReelSpecificCallbacks: function(d, c) {
		var b = this,
			a = {};
		a.reelStartCompleteCallback = function() {
			b.reelHaveBeenCleared[d] = true;
			b.tryToStartStopSequence(d);
			c.reelStartCompleteCallback(d)
		};
		a.reelStartedStoppingCallback = function() {
			c.reelStartedStoppingCallback(d)
		};
		a.reelBounceStartCallback = function() {
			c.reelBounceStartCallback(d)
		};
		a.reelStoppedCallback = function() {
			c.reelStoppedCallback(d)
		};
		a.symbolBounceCallback = function() {
			c.symbolBounceCallback(d)
		};
		a.symbolBounceCallback = function() {
			c.symbolBounceCallback(d)
		};
		a.fadeInStartedCallback = function() {
			c.fadeInStartedCallback(d)
		};
		return a
	},
	startSpin: function(b) {
		var c = this,
			a = c.reelLists;
		c.serverResponseRecieved = false;
		a.forEach(function(d) {
			d.activeReelSet = c.activeReelSet;
			d.startSpin()
		})
	},
	setSpinType: function(c) {
		var b = this,
			a = b.reelLists;
		b.spinType = c;
		a.forEach(function(d) {
			d.setSpinType(c)
		})
	},
	stopSpin: function(e, a, h) {
		var f = this,
			d = f.reelLists,
			g = [],
			b;
		for (var c = 0; c < e[0].symbols.length; c++) {
			if (c === 0) {
				b = {
					hold: false,
					symbols: [e[0].symbols[c]],
					lastSymbols: [e[0].lastSymbols[c]]
				};
				g.push(b)
			} else {
				g[0].symbols.push(e[0].symbols[c]);
				g[0].lastSymbols.push(e[0].lastSymbols[c])
			}
		}
		f.nearWinList = a;
		f.serverResponseRecieved = true;
		d.forEach(function(j, k) {
			j.setAllReelSymbols(g[k], h.clientaction, h.nextaction)
		});
		d.forEach(function(j, k) {
			f.tryToStartStopSequence(k)
		})
	},
	quickStop: function() {
		var b = this,
			a = b.reelLists;
		a.forEach(function(c) {
			c.tryQuickStop()
		})
	},
	cancelSpin: function() {
		var c = this,
			b = c.reelLists,
			a = Resources.readData("config").reelSets.basic1.noWinOutcome;
		c.serverResponseRecieved = true;
		b.forEach(function(d, e) {
			d.setAllReelSymbols(a[e]);
			c.tryToStartStopSequence(e)
		})
	},
	presentOutcome: function(c, d) {
		var b = this,
			a = b.reelLists;
		if (d.gameover && d.currentGameState === "freespin") {
			a.forEach(function(e, f) {
				e.presentOutcome(c[f].symbols)
			})
		}
	},
	presentInitOutcome: function(c) {
		var b = this,
			a = b.reelLists;
		a.forEach(function(d, e) {
			d.presentOutcome(c[e].symbols)
		})
	},
	stopNow: function() {
		var a = this;
		a.reelLists.forEach(function(b, c) {
			b.stopSpin();
			a.reelHaveBeenCleared[c] = false
		})
	},
	tryToStartStopSequence: function(b) {
		var a = this;
		if (a.canStop(b)) {
			a.stopNow(b)
		}
	},
	canStop: function() {
		return this.serverResponseRecieved && this.reelHaveBeenCleared.indexOf(false) === -1
	},
	getReelCount: function() {
		return this.reelLists.length
	},
	setSymbols: function(a) {
		var b = this;
		Sys.each(a, function(d, c) {
			b.reelLists[c].setSymbols(d)
		})
	},
	hide: function() {
		this.reelLists.forEach(function(a) {
			a.stop()
		})
	},
	hideSymbolsOnReel: function(c, b) {
		var a = this.reelLists[c];
		if (Sys.isDefined(a)) {
			a.hideSymbols(b)
		}
	},
	hideSymbols: function(a) {
		var b = this;
		Sys.iterate(a, function(d, c) {
			b.hideSymbolsOnReel(d, c)
		})
	},
	show: function() {
		this.reelLists.forEach(function(a) {
			a.show()
		})
	},
	showSymbolsOnReel: function(c, b) {
		var a = this.reelLists[c];
		if (Sys.isDefined(a)) {
			a.showSymbols(b)
		}
	},
	showSymbols: function(a) {
		var b = this;
		Sys.iterate(a, function(d, c) {
			b.showSymbolsOnReel(d, c)
		})
	},
	replaceSymbolsOnReel: function(e, b, d) {
		var c = this,
			a = c.reelLists[e];
		if (Sys.isDefined(a)) {
			a.replaceSymbols(b, d)
		}
	},
	replaceSymbols: function(c, b) {
		var a = this;
		Sys.iterate(c, function(e, d) {
			a.replaceSymbolsOnReel(e, d, b)
		})
	},
	startFreeSpinTrigger: function() {
		var b = this,
			a = b.reelLists;
		a.forEach(function(c) {
			c.startFreeSpinTrigger()
		})
	},
	stopBonusAttention: function() {
		var b = this,
			a = b.reelLists;
		a.forEach(function(c) {
			c.stopBonusAttention()
		})
	},
	switchAmbienceAfterWinAnimation: function() {
		var b = this,
			a = b.reelLists;
		a.forEach(function(c) {
			c.switchAmbienceAfterWinAnimation()
		})
	},
	activate: function(a, c) {
		var b = this;
		if (Sys.isDefined(b.activeReelSet)) {
			b.deactivate(b.activeReelSet)
		}
		b.reels.visible = true;
		b.activeReelSet = a
	},
	deactivate: function(a) {
		var b = this;
		if (a === b.activeReelSet) {
			b.reels.visible = false;
			b.activeReelSet = undefined
		}
	},
	resetSpinType: function() {
		var b = this,
			a = b.reelLists;
		a.forEach(function(c) {
			c.setSpinType(b.spinType || "standard")
		})
	},
	setAnimationSpeed: function(d, b) {
		var c = this,
			a = c.reelLists;
		a.forEach(function(e) {
			e.activeReelSet = c.activeReelSet;
			e.setAnimationSpeed(d, b)
		})
	}
};
Sys.ns("Finn");
Finn.BufferedReelModel = function(a) {
	var b = this;
	Sys.applyProperties(b, a);
	b.symbols = [];
	b.visibleSymbolsCount = a.numberOfOutcomeSymbols;
	b.gameState = "basic"
};
Finn.BufferedReelModel.prototype = {
	setInitialOutcome: function(c, e, a) {
		var d = this,
			b = false;
		d.clear();
		d.symbols = c.symbols;
		d.isRestoreState = c.restore;
		d.clientAction = e;
		d.nextAction = a;
		Sys.each(c.symbols, function(f) {
			if (f === "SYM2") {
				b = true
			}
		});
		d.gameState = b ? "basic" : "freespin"
	},
	getClientAction: function() {
		var a = this;
		return a.clientAction
	},
	getNextAction: function() {
		var a = this;
		return a.nextAction
	},
	getGameState: function() {
		var a = this;
		return a.gameState
	},
	clear: function() {
		this.symbols.length = 0
	},
	getSymbols: function() {
		return this.parseSymbols(this.symbols)
	},
	parseSymbols: function(b) {
		var a = [];
		if (!Sys.isDefined(b)) {
			return
		}
		b.forEach(function(c) {
			a.push({
				symbol: c
			})
		});
		return a
	},
	updateOutcome: function(a, b) {
		this.symbols[a] = b
	},
	isStopping: function() {
		return this.hasBeenToldToStop
	},
	setState: function(a) {
		this.state = a
	},
	getState: function() {
		return this.state
	}
};
Sys.ns("Finn");
Finn.BufferedReel = {
	BONUS_SYM: "SYM2",
	constructor: function(a) {
		var b = this;
		Finn.BufferedReel.superclass.constructor.call(b, {});
		b.pixiContainer = new PIXI.Container();
		b.pixiContainer.id = a.id;
		b.pixiContainer.position = new PIXI.Point(a.left + a.symbolWidths.standard / 2, a.top + a.symbolHeights.standard / 2);
		Game.stage.view.animationManager.addToAnimationLoop(b);
		b.symbolWidths = {
			standard: a.symbolWidths.standard
		};
		b.symbolHeights = {
			standard: a.symbolHeights.standard
		};
		b.model = b.createModel(a);
		b.bufferedReelSymbols = b.createBufferedReelSymbols(a);
		b.bufferedReelBonusSymbol = b.createBufferedReelBonusSymbol(a)
	},
	run: function(a) {},
	getSymbolLayout: function() {
		var b = this,
			a = [];
		Sys.each(b.bufferedReelSymbols, function(c) {
			a.push({
				left: c.pixiContainer.position.x,
				top: c.pixiContainer.position.y,
				width: b.symbolWidths,
				height: b.symbolHeights
			})
		});
		return a
	},
	createModel: function(a) {
		var b = this;
		b.symbolBounceCallback = a.symbolBounceCallback;
		return new Finn.BufferedReelModel({
			id: a.id,
			numberOfOutcomeSymbols: a.numberOfOutcomeSymbols,
			reelStartCompleteCallback: a.reelStartCompleteCallback,
			reelStartedStoppingCallback: a.reelStartedStoppingCallback,
			reelBounceStartCallback: a.reelBounceStartCallback,
			reelStoppedCallback: a.reelStoppedCallback,
			symbolCenterToCenter: a.symbolCenterToCenter,
			fadeInStartedCallback: a.fadeInStartedCallback
		})
	},
	createBufferedReelSymbols: function(c) {
		var e = this,
			b = [],
			a;
		for (var d = 0; d < c.numberOfOutcomeSymbols; d++) {
			a = new Finn.BufferedReelSymbol(c, d, {
				fadeInCallback: e.onFadeInCallback.bind(e),
				fadeOutCallback: e.onFadeOutCallback.bind(e),
				dropCallback: e.onDropCallback.bind(e),
				symbolBounceCallback: e.onSymbolBounceCallback.bind(e)
			});
			b.push(a);
			e.pixiContainer.addChild(a.pixiContainer)
		}
		return b
	},
	createBufferedReelBonusSymbol: function(a) {
		var b = this,
			c;
		c = new Finn.BufferedReelBonusSymbol(a, 0, {
			fadeInCallback: b.onFadeInCallback.bind(b),
			fadeOutCallback: b.onFadeOutCallback.bind(b),
			dropCallback: b.onDropCallback.bind(b)
		});
		b.pixiContainer.addChild(c.pixiContainer);
		return c
	},
	presentOutcome: function(a) {
		var b = this;
		b.newSyms = a;
		Sys.each(a, function(d, c) {
			b.bufferedReelSymbols[c].resetSymbol();
			b.bufferedReelSymbols[c].setSymbolTexture(d);
			if (d === b.BONUS_SYM) {
				b.bufferedReelBonusSymbol.setPosition(c)
			}
		});
		if (a.indexOf(b.BONUS_SYM) === -1) {
			b.bufferedReelBonusSymbol.deActivate()
		}
	},
	startSpin: function() {
		var a = this;
		a.model.setState("preSpinning");
		a.startPreSpin();
		a.model.reelStartCompleteCallback()
	},
	stopSpin: function() {
		var a = this,
			b = a.model.getClientAction();
		if (a.model.getState() === "preSpinning") {
			a.model.setState("spinning")
		}
		Sys.each(a.bufferedReelSymbols, function(c) {
			c.resetSymbol();
			c.stopPreSpin()
		});
		if (a.bufferedReelBonusSymbol.isActive()) {
			if (b === "spin") {
				a.bufferedReelBonusSymbol.resetSymbolPosition()
			}
			a.bufferedReelBonusSymbol.resetSymbolStyle();
			a.bufferedReelBonusSymbol.stopPreSpin()
		}
		if (b === "spin" || b === "freespin") {
			a.fadeOut()
		} else {
			if (b === "drop") {
				a.drop()
			}
		}
	},
	isStopping: function() {
		return this.model.isStopping()
	},
	getInitKeyFrames: function(a) {},
	setAllReelSymbols: function(c, e, a) {
		var d = this,
			b;
		d.newSyms = c.symbols || [];
		d.spawningIndexes = [];
		d.movingIndexes = [];
		if (e === "drop") {
			Sys.each(c.lastSymbols, function(g, f) {
				if (g === null) {
					d.spawningIndexes.push(f)
				} else {
					d.movingIndexes.push(f);
					if (g === d.BONUS_SYM) {
						b = f
					}
				}
			});
			d.setSpawningDropSymbols(c.symbols);
			d.setMovingDropSymbols(c.lastSymbols);
			if (Sys.isDefined(b)) {
				d.bufferedReelBonusSymbol.activate();
				d.setMovingDropBonusSymbol(b)
			} else {
				d.bufferedReelBonusSymbol.deActivate()
			}
		}
		Sys.each(d.bufferedReelSymbols, function(f) {
			f.setClientAction(e)
		});
		d.bufferedReelBonusSymbol.setClientAction(e);
		d.model.setInitialOutcome(c, e, a)
	},
	setSpawningDropSymbols: function(e) {
		var d = this,
			b = 0,
			c = d.spawningIndexes.length,
			a = d.movingIndexes.length;
		Sys.each(d.spawningIndexes, function(f) {
			d.bufferedReelSymbols[f].setSymbolTexture(e[b]);
			d.bufferedReelSymbols[f].setSpawningDrop(b, c, a);
			b++
		})
	},
	setMovingDropSymbols: function(e) {
		var d = this,
			c = d.movingIndexes.length,
			a, b;
		Sys.each(d.movingIndexes, function(g, f) {
			a = d.getNumberOfSteps(g);
			b = c - f;
			d.bufferedReelSymbols[g].setSymbolTexture(e[g]);
			d.bufferedReelSymbols[g].setMovingDrop(a, b)
		})
	},
	setMovingDropBonusSymbol: function(b) {
		var d = this,
			a = d.getNumberOfSteps(b),
			c = d.movingIndexes.length - d.movingIndexes.indexOf(b);
		d.bufferedReelBonusSymbol.setMovingDrop(a, c, b)
	},
	getNumberOfSteps: function(b) {
		var d = this,
			a = 0;
		for (var c = 0; c < d.spawningIndexes.length; c++) {
			if (d.spawningIndexes[c] > b) {
				a++
			}
		}
		return a
	},
	startPreSpin: function() {
		var a = this;
		Sys.each(a.bufferedReelSymbols, function(b) {
			b.startPreSpin()
		});
		if (a.bufferedReelBonusSymbol.isActive()) {
			a.bufferedReelBonusSymbol.startPreSpin()
		}
	},
	fadeOut: function() {
		var a = this;
		Sys.each(a.bufferedReelSymbols, function(b) {
			b.resetSymbol();
			b.startFadeOut()
		});
		if (a.bufferedReelBonusSymbol.isActive()) {
			a.bufferedReelBonusSymbol.startFadeOut()
		}
	},
	onFadeOutCallback: function(a) {
		var b = this;
		if (a === b.bufferedReelSymbols.length - 1) {
			b.fadeIn()
		}
	},
	fadeIn: function() {
		var c = this,
			b = c.model.getSymbols(),
			a;
		c.model.fadeInStartedCallback();
		Sys.each(c.bufferedReelSymbols, function(d, e) {
			d.resetSymbol();
			d.setSymbolTexture(b[e].symbol);
			if (b[e].symbol === c.BONUS_SYM) {
				a = e
			}
			if (c.model.getState() === "spinning") {
				d.startFadeIn()
			}
		});
		if (Sys.isDefined(a)) {
			c.bufferedReelBonusSymbol.activate();
			c.bufferedReelBonusSymbol.resetSymbolStyle();
			c.bufferedReelBonusSymbol.setPosition(a);
			if (c.model.getState() === "spinning") {
				c.bufferedReelBonusSymbol.startFadeIn(a)
			}
		} else {
			c.bufferedReelBonusSymbol.deActivate()
		}
		if (c.model.getState() === "stopped") {
			c.quickStop()
		}
	},
	onFadeInCallback: function(a) {
		var b = this;
		if (a === b.bufferedReelSymbols.length - 1) {
			b.model.setState("idle");
			b.model.reelStoppedCallback()
		}
	},
	drop: function() {
		var a = this;
		a.dropCounter = 0;
		if (a.model.getState() === "spinning") {
			Sys.each(a.movingIndexes, function(b) {
				a.bufferedReelSymbols[b].resetSymbolPosition();
				a.bufferedReelSymbols[b].startDrop()
			});
			Sys.each(a.spawningIndexes, function(b) {
				a.bufferedReelSymbols[b].moveToSpawnStart();
				a.bufferedReelSymbols[b].startDrop()
			});
			if (a.bufferedReelBonusSymbol.isActive()) {
				a.bufferedReelBonusSymbol.startDrop()
			}
		} else {
			if (a.model.getState() === "stopped") {
				a.quickStop()
			}
		}
	},
	onDropCallback: function() {
		var a = this;
		a.dropCounter++;
		if (a.dropCounter === 25) {
			a.resetAllSymbols();
			a.model.setState("idle");
			a.model.reelStoppedCallback()
		}
	},
	onSymbolBounceCallback: function() {
		var a = this;
		a.symbolBounceCallback()
	},
	setSymbols: function(a) {
		var b = this;
		Sys.each(a, function(d, c) {
			b.model.updateOutcome(c, d);
			b.bufferedReelSymbols[c].setSymbolTexture(d)
		})
	},
	resetAllSymbols: function() {
		var a = this;
		Sys.each(a.newSyms, function(c, b) {
			a.bufferedReelSymbols[b].resetSymbol();
			a.bufferedReelSymbols[b].setSymbolTexture(c)
		})
	},
	hideSymbols: function(a) {
		var b = this;
		if (Sys.isArray(a)) {
			Sys.each(a, function(c) {
				b.bufferedReelSymbols[c].hideSymbol()
			})
		} else {
			b.bufferedReelSymbols[a].hideSymbol()
		}
	},
	showSymbols: function(a) {
		var b = this;
		if (Sys.isArray(a)) {
			Sys.each(a, function(c) {
				b.bufferedReelSymbols[c].showSymbol()
			})
		} else {
			b.bufferedReelSymbols[a].showSymbol()
		}
	},
	replaceSymbols: function(a, c) {
		var b = this;
		if (Sys.isArray(a)) {
			Sys.each(a, function(d) {
				b.bufferedReelSymbols[d].setSymbolTexture(c);
				b.bufferedReelSymbols[d].showSymbol()
			})
		} else {
			b.bufferedReelSymbols[a].setSymbolTexture(c);
			b.bufferedReelSymbols[a].showSymbol()
		}
	},
	startFreeSpinTrigger: function() {
		var a = this;
		a.model.setState("idle");
		a.bufferedReelBonusSymbol.startFreeSpinTrigger()
	},
	stopBonusAttention: function() {
		var a = this;
		a.bufferedReelBonusSymbol.stopBonusAttention()
	},
	switchAmbienceAfterWinAnimation: function() {
		var a = this;
		a.bufferedReelBonusSymbol.switchAmbienceAfterWinAnimation()
	},
	tryQuickStop: function() {
		var a = this;
		if (a.model.getState() === "spinning") {
			a.quickStop()
		}
		a.model.setState("stopped")
	},
	quickStop: function() {
		var a = this,
			b = a.model.getState() === "stopped";
		a.dropCounter = 0;
		Sys.each(a.bufferedReelSymbols, function(c) {
			c.quickStop(b)
		});
		if (a.bufferedReelBonusSymbol.isActive() || a.model.getNextAction() === "bonusaction") {
			a.bufferedReelBonusSymbol.quickStop(b)
		}
	},
	setSpinType: function(b) {
		var a = this;
		Sys.each(a.bufferedReelSymbols, function(c) {
			c.setSpinType(b)
		});
		a.bufferedReelBonusSymbol.setSpinType(b)
	},
	correctMisalignedOutcomeOnDeviceRotate: function() {},
	setAnimationSpeed: function(c, a) {
		var b = this;
		Sys.each(b.bufferedReelSymbols, function(d) {
			d.setAnimationSpeed(c, a)
		});
		b.bufferedReelBonusSymbol.setAnimationSpeed(c, a)
	}
};
Finn.BufferedReel = Sys.extend(Sys.Observable, Finn.BufferedReel, "Finn.BufferedReel");
Sys.ns("Finn");
Finn.BufferedReelSymbol = {
	SPAWN_MODES: ["Fade", "Move"],
	WILD_SYMBOL: "SYM1",
	STICKY_WILD_SYMBOL: "SYM0",
	RUBY_SYMBOL: "SYM3",
	WILD_IDLE_OFFSET: {
		x: -100,
		y: -100
	},
	STICKY_WILD_IDLE_OFFSET: {
		x: -68,
		y: -69
	},
	RUBY_IDLE_OFFSET: {
		x: -150,
		y: -150
	},
	WILD_ANIMATION: {
		file: "wildSymbol",
		idleName: "wild_IDLE_EXPORT"
	},
	STICKY_WILD_ANIMATION: {
		file: "stickyWildSymbol",
		idleName: "animation"
	},
	RUBY_ANIMATION: {
		file: "rubySymbol",
		idleName: "animation"
	},
	constructor: function(a, b, d) {
		var c = this;
		Finn.BufferedReelSymbol.superclass.constructor.call(c, {});
		Sys.applyProperties(c, d);
		c.setSymbolConfig(a);
		c.isLowEnd = false;
		c.symbolId = b;
		c.symbolPosition = a.symbolPositions[b];
		c.activeWildIdle = false;
		c.pixiContainer = new PIXI.Container();
		c.pixiContainer.position = new PIXI.Point(0, 0);
		c.symbolContainer = new PIXI.Container();
		c.symbolContainer.position.x = c.symbolPosition.x * c.symbolWidths.standard;
		c.symbolContainer.position.y = c.symbolPosition.y * c.symbolHeights.standard;
		c.pixiContainer.addChild(c.symbolContainer);
		Game.stage.view.animationManager.addToAnimationLoop(c);
		c.spawnMode = c.SPAWN_MODES[1];
		c.initSymbolAnimations(c.symbolId, c.symbolPosition)
	},
	setSymbolConfig: function(a) {
		var b = this;
		b.symbolWidths = {
			standard: a.symbolWidths.standard
		};
		b.symbolHeights = {
			standard: a.symbolHeights.standard
		};
		b.orientation = a.orientation;
		b.symbolInitialMoveX = a.symbolInitialMoveX;
		b.symbolInitialMoveY = a.symbolInitialMoveY;
		b.symbolPositions = a.symbolPositions;
		b.spinType = "standard";
		b.standardSpinSpeed = a.spiral.speed;
		b.quickSpinSpeed = a.spiral.quickSpinSpeed;
		b.animationSpeed = a.spiral.speed;
		b.dropSpeedFactor = a.spiral.dropSpeedFactor;
		b.initialSpin = a.spiral.initial;
		b.bounceDirection = a.spiral.bounceDirection;
		b.bounceSpeedOut = a.spiral.bounceSpeedOut;
		b.bounceSpeedBack = a.spiral.bounceSpeedBack;
		b.bounceDistance = a.spiral.bounceDistance
	},
	initSymbolAnimations: function(b, a) {
		var c = this;
		c.initBasicAnimations(b, a);
		c.wildIdleAnimation = c.initSymbolSpineAnimations(c.WILD_ANIMATION.file, c.WILD_IDLE_OFFSET.x, c.WILD_IDLE_OFFSET.y, false);
		c.stickyWildIdleAnimation = c.initSymbolSpineAnimations(c.STICKY_WILD_ANIMATION.file, c.STICKY_WILD_IDLE_OFFSET.x, c.STICKY_WILD_IDLE_OFFSET.y, false);
		c.rubyIdleAnimation = c.initSymbolSpineAnimations(c.RUBY_ANIMATION.file, c.RUBY_IDLE_OFFSET.x, c.RUBY_IDLE_OFFSET.y, false)
	},
	initBasicAnimations: function(c, a) {
		var d = this,
			e = {
				x: 0,
				y: 0
			},
			f = {
				x: 0.5,
				y: 0.5
			},
			b = d.getInitialSpinDelay(c);
		d.symbolSprite = Game.PIXIFactory.createAndAddSprite("symbol", d.symbolContainer, e, f);
		d.symbolContainer.position.x = a.x * d.symbolWidths.standard;
		d.symbolContainer.position.y = a.y * d.symbolHeights.standard;
		d.preSpinAnimation = d.initPreSpinAnimation(d.symbolContainer);
		d.fadeOutAnimation = d.initFadeOutAnimation(d.symbolContainer, c);
		d.fadeInAnimation = d.initFadeInAnimation(d.symbolContainer, c, b);
		d.dropAnimation = d.initDropAnimation(d.symbolContainer, "position")
	},
	getInitialSpinDelay: function(b, d) {
		var f = this,
			a = f.animationSpeed * f.initialSpin.baseSpeedFactor * b;
		for (var c = 0; c <= b; c++) {
			if (Sys.isDefined(f.initialSpin.additionalDelaySteps[c])) {
				var e = d ? 1 : f.initialSpin.additionalDelaySteps[c];
				a += e * f.animationSpeed * f.initialSpin.baseSpeedFactor
			}
		}
		return a
	},
	initPreSpinAnimation: function(a) {
		var b = new Animation.Holder({
			id: "preSpin",
			prop: "scale",
			target: a,
			delay: 1000,
			loop: true,
			animate: {
				0: {
					x: 1,
					y: 1
				},
				500: {
					x: 1.2,
					y: 1.2
				},
				1000: {
					x: 1,
					y: 1
				}
			}
		});
		Game.stage.view.animationManager.addToAnimationLoop(b);
		return b
	},
	initFadeOutAnimation: function(d, b) {
		var c = this;
		var a = new Animation.Holder({
			id: "fadeOut",
			target: d,
			prop: "alpha",
			delay: 0,
			onStart: function() {
				this.target.alpha = 1
			},
			onEnd: function() {
				c.fadeOutCallback(b)
			},
			animate: {
				0: 1,
				200: 0
			}
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	initFadeInAnimation: function(g, e, c) {
		var f = this;
		var b = {
			prop: "alpha",
			animate: {
				0: 0,
				100: 1,
				200: 1
			}
		};
		var h = {
			prop: "scale",
			animate: {
				0: {
					x: 0.5,
					y: 0.5
				},
				100: {
					x: 1.4,
					y: 1.4
				},
				200: {
					x: 1,
					y: 1
				}
			}
		};
		var a = {
			prop: "position",
			animate: {
				0: {
					x: f.symbolPositions[e].x * f.symbolWidths.standard + f.symbolInitialMoveX[e],
					y: f.symbolPositions[e].y * f.symbolHeights.standard + f.symbolInitialMoveY[e]
				},
				100: {
					x: f.symbolPositions[e].x * f.symbolWidths.standard,
					y: f.symbolPositions[e].y * f.symbolHeights.standard
				},
				200: {
					x: f.symbolPositions[e].x * f.symbolWidths.standard,
					y: f.symbolPositions[e].y * f.symbolHeights.standard
				}
			}
		};
		var d = new Animation.Holder({
			id: "fadeIn",
			target: g,
			delay: c,
			children: [b, a, h],
			onStart: function() {
				this.target.alpha = 0
			},
			onEnd: f.onFadeInEnd.bind(f, e)
		});
		Game.stage.view.animationManager.addToAnimationLoop(d);
		return d
	},
	initDropAnimation: function(f, c) {
		var e = this;
		var a = {
			prop: c,
			animate: {
				0: {
					x: 0,
					y: 0
				},
				200: {
					x: 0,
					y: 0
				}
			}
		};
		var g = {
			prop: "scale",
			animate: {}
		};
		var b = {
			prop: "alpha",
			animate: {
				0: 1,
				200: 1
			}
		};
		var d = new Animation.Holder({
			id: "dropAnimation",
			target: f,
			delay: 0,
			onEnd: e.onDropEnd.bind(e),
			children: [a, g, b]
		});
		Game.stage.view.animationManager.addToAnimationLoop(d);
		return d
	},
	initSymbolSpineAnimations: function(c, b, a) {
		var d = this,
			e = Game.PIXIFactory.createAndAddSpineAnimation(c, d.symbolContainer);
		e.position = new PIXI.Point(b, a);
		e.fire = function(f) {
			Finn.AnimationUtils.initialize(e, f, true);
			e.visible = true;
			e.updateTransform()
		};
		e.visible = false;
		return e
	},
	setClientAction: function(b) {
		var a = this;
		a.clientAction = b
	},
	startPreSpin: function() {
		var a = this;
		a.preSpinAnimation.play()
	},
	stopPreSpin: function() {
		var a = this;
		a.preSpinAnimation.stop()
	},
	startFadeIn: function() {
		var a = this;
		a.fadeInAnimation.play()
	},
	onFadeInEnd: function(a) {
		var b = this;
		b.fadeInCallback(a)
	},
	startFadeOut: function() {
		var a = this;
		a.fadeOutAnimation.play()
	},
	startDrop: function() {
		var a = this;
		a.dropAnimation.play()
	},
	onDropEnd: function() {
		var a = this;
		a.ongoingDrop = false;
		a.dropCallback()
	},
	hideSymbol: function() {
		var a = this;
		a.pixiContainer.visible = false
	},
	showSymbol: function() {
		var a = this;
		a.pixiContainer.visible = true
	},
	setSymbolTexture: function(b) {
		var a = this;
		a.symbolSprite.texture = Resources.readData("animationImages")[b];
		if (b === a.WILD_SYMBOL && a.active !== "wild") {
			a.active = "wild";
			a.wildIdleAnimation.updateTransform();
			a.wildIdleAnimation.visible = true;
			a.wildIdleAnimation.fire(a.WILD_ANIMATION.idleName)
		} else {
			if (b === a.STICKY_WILD_SYMBOL && a.active !== "stickyWild") {
				a.active = "stickyWild";
				a.stickyWildIdleAnimation.updateTransform();
				a.stickyWildIdleAnimation.visible = true;
				a.stickyWildIdleAnimation.fire(a.STICKY_WILD_ANIMATION.idleName)
			} else {
				if (b === a.RUBY_SYMBOL && a.active !== "ruby") {
					a.active = "ruby";
					a.rubyIdleAnimation.updateTransform();
					a.rubyIdleAnimation.visible = true;
					a.rubyIdleAnimation.fire(a.RUBY_ANIMATION.idleName)
				}
			}
		}
		if (b !== a.WILD_SYMBOL) {
			Game.PIXIUtils.resetSpineAnimation(a.wildIdleAnimation);
			a.wildIdleAnimation.visible = false
		}
		if (b !== a.STICKY_WILD_SYMBOL) {
			Game.PIXIUtils.resetSpineAnimation(a.stickyWildIdleAnimation);
			a.stickyWildIdleAnimation.visible = false
		}
		if (b !== a.RUBY_SYMBOL) {
			Game.PIXIUtils.resetSpineAnimation(a.rubyIdleAnimation);
			a.rubyIdleAnimation.visible = false
		}
		if (b !== a.WILD_SYMBOL && b !== a.STICKY_WILD_SYMBOL && b !== a.RUBY_SYMBOL) {
			a.active = "none";
			a.symbolSprite.visible = true
		} else {
			a.symbolSprite.visible = false
		}
	},
	resetSymbol: function() {
		var a = this;
		a.resetSymbolPosition();
		a.resetSymbolStyle()
	},
	resetSymbolPosition: function() {
		var a = this;
		a.symbolContainer.position.x = a.symbolPosition.x * a.symbolWidths.standard;
		a.symbolContainer.position.y = a.symbolPosition.y * a.symbolHeights.standard;
		a.symbolContainer.pivot = new PIXI.Point(0.5, 0.5)
	},
	resetSymbolStyle: function() {
		var a = this;
		a.symbolContainer.rotation = 0;
		a.symbolContainer.alpha = 1;
		a.symbolContainer.scale = {
			x: 1,
			y: 1
		};
		a.symbolContainer.visible = true;
		a.pixiContainer.visible = true
	},
	setMovingDrop: function(a, c) {
		var e = this,
			b = c * e.animationSpeed * e.dropSpeedFactor,
			d = [];
		e.ongoingDrop = true;
		e.endPosition = e.symbolId + a;
		if (a === 0) {
			d.push(e.getSingleKeyFrame(e.symbolId, 0))
		} else {
			d = e.getMovingKeyFrames(e.symbolId, a, true)
		}
		e.dropAnimation.children[0].animation.keyFrames = d;
		e.dropAnimation.children[1].animation.keyFrames = [];
		e.dropAnimation.delay = b
	},
	bounceCallbackWrapper: function() {
		var a = this;
		a.symbolBounceCallback()
	},
	getMovingKeyFrames: function(b, h, c) {
		var g = this,
			e = [],
			f, a, j;
		for (var d = 0; d <= h; d++) {
			e.push(g.getSingleKeyFrame(b + d, d * g.animationSpeed));
			if (d === h && h > 0 && c) {
				Sys.applyProperties(e[e.length - 1], {
					callback: {
						func: g.bounceCallbackWrapper.bind(g),
						fireImmediately: true
					}
				});
				f = d * g.animationSpeed + g.animationSpeed * g.bounceSpeedOut;
				a = g.bounceDirection[b + d].x * g.bounceDistance * g.symbolWidths.standard;
				j = g.bounceDirection[b + d].y * g.bounceDistance * g.symbolHeights.standard;
				e.push(g.getSingleKeyFrame(b + d, f, a, j));
				f = d * g.animationSpeed + g.animationSpeed * (g.bounceSpeedOut + g.bounceSpeedBack);
				e.push(g.getSingleKeyFrame(b + d, f))
			}
		}
		return e
	},
	getSingleKeyFrame: function(e, c, a, j) {
		var g = this,
			b = g.symbolWidths.standard,
			h = g.symbolHeights.standard,
			d, f;
		if (e < 0) {
			d = g.symbolPositions[0].x * b;
			f = g.symbolPositions[0].y * h - h * e
		} else {
			d = g.symbolPositions[e].x * b + (a || 0);
			f = g.symbolPositions[e].y * h + (j || 0)
		}
		return {
			time: c,
			value: {
				x: d,
				y: f
			}
		}
	},
	setSpawningDrop: function(b, c, a) {
		var d = this;
		d.ongoingDrop = true;
		d.endPosition = b;
		if (d.spawnMode === d.SPAWN_MODES[0]) {
			d.setSpawningDrop1(b, c, a)
		} else {
			if (d.spawnMode === d.SPAWN_MODES[1]) {
				d.setSpawningDrop2(b, c, a)
			}
		}
	},
	setSpawningDrop1: function(d, e, a) {
		var f = this,
			b = (a * f.animationSpeed * f.dropSpeedFactor),
			c = b + f.getInitialSpinDelay(d) + (e * f.animationSpeed) + 500;
		f.dropAnimation.children[0].animation.keyFrames = f.getFadingPositionFrames(d);
		f.dropAnimation.children[1].animation.keyFrames = f.getFadingScalingFrames();
		f.dropAnimation.delay = c
	},
	setSpawningDrop2: function(c, d, a) {
		var e = this,
			b = (a + d - c) * e.animationSpeed * e.dropSpeedFactor;
		e.dropAnimation.children[0].animation.keyFrames = e.getMovingKeyFrames(c - d, d, true);
		e.dropAnimation.children[1].animation.keyFrames = [];
		e.dropAnimation.delay = b
	},
	getFadingPositionFrames: function(c) {
		var e = this,
			b = e.symbolPositions[c],
			d = e.symbolWidths.standard,
			a = e.symbolHeights.standard;
		return [{
			time: 0,
			value: {
				x: b.x * d + e.symbolInitialMoveX[c],
				y: b.y * a + e.symbolInitialMoveY[c]
			}
		}, {
			time: 100,
			value: {
				x: b.x * d,
				y: b.y * a
			}
		}, {
			time: 200,
			value: {
				x: b.x * d,
				y: b.y * a
			}
		}]
	},
	getFadingScalingFrames: function() {
		return [{
			time: 0,
			value: {
				x: 0.5,
				y: 0.5
			}
		}, {
			time: 100,
			value: {
				x: 1.3,
				y: 1.3
			}
		}, {
			time: 200,
			value: {
				x: 1,
				y: 1
			}
		}]
	},
	moveToSpawnStart: function() {
		var a = this;
		a.symbolContainer.position.x = 0;
		a.symbolContainer.position.y = 720
	},
	quickStop: function(b) {
		var a = this;
		a.fadeInAnimation.delay = 0;
		Sys.each(a.fadeInAnimation.children, function(c) {
			c.delay = 0
		});
		if (a.clientAction === "drop") {
			a.quickStopDropAnimations()
		} else {
			if (b) {
				a.fadeInAnimation.play()
			}
		}
	},
	quickStopDropAnimations: function() {
		var a = this;
		a.quickStopDropAnimation(a.dropAnimation)
	},
	quickStopDropAnimation: function(b) {
		var a = this,
			c = [];
		if (a.ongoingDrop) {
			c = a.getMovingKeyFrames(a.endPosition - 1, 1, true)
		} else {
			c.push(a.getSingleKeyFrame(a.endPosition, 0))
		}
		b.stop();
		b.restoreAnimation();
		b.children[0].animation.keyFrames = c;
		b.children[1].animation.keyFrames = [];
		b.delay = 0;
		b.play()
	},
	setSpinType: function(b) {
		var a = this;
		if (Sys.isDefined(a.spinType)) {
			a.animationSpeed = b === "quickSpin" ? a.quickSpinSpeed : a.standardSpinSpeed;
			a.fadeInAnimation.delay = a.getInitialSpinDelay(a.symbolId)
		}
		a.spinType = b
	},
	setAnimationSpeed: function(c, a) {
		var b = this;
		if (a) {
			b.spinType = "custom"
		}
		b.animationSpeed = c;
		b.fadeInAnimation.delay = b.getInitialSpinDelay(b.symbolId, a)
	}
};
Finn.BufferedReelSymbol = Sys.extend(Sys.Observable, Finn.BufferedReelSymbol, "Finn.BufferedReelSymbol");
Sys.ns("Finn");
Finn.BufferedReelBonusSymbol = {
	BONUS_SYM: "BONUS",
	SPINE_OFFSET: -160,
	PARTICLE_OFFSET: -64,
	ATTENTION_LEVELS: [0, 12, 18, 1, 24],
	initSymbolAnimations: function(b, a) {
		var c = this;
		c.activated = true;
		c.initBasicAnimations(b, a);
		c.initBonusSymbolAttentions();
		c.initBonusSymbolParticles();
		c.initTrench();
		c.attentionSound = true;
		c.attentionSound1 = false;
		c.attentionSound2 = false;
		c.stopAttentionSound = false;
		c.switchAmbience = false
	},
	initBonusSymbolAttentions: function() {
		var a = this;
		a.symbolSprite.texture = Resources.readData("animationImages")[a.BONUS_SYM];
		a.activeAttention1 = false;
		a.activeAttention2 = false;
		a.initAnimation = a.initSymbolSpineAnimations("bonusSym", a.SPINE_OFFSET, a.SPINE_OFFSET, false);
		a.attentionAnimation = a.initSymbolSpineAnimations("bonusSym", a.SPINE_OFFSET, a.SPINE_OFFSET, false);
		a.attentionAnimation2 = a.initSymbolSpineAnimations("bonusSym", a.SPINE_OFFSET, a.SPINE_OFFSET, false)
	},
	initSymbolSpineAnimations: function(d, c, a, b) {
		var e = this,
			f;
		f = Game.PIXIFactory.createAndAddSpineAnimation(d, e.symbolContainer);
		f.position = new PIXI.Point(c, a);
		f.fire = function(g, h) {
			var j = Finn.AnimationUtils.initialize(f, g, b);
			if (g === "init") {
				j.onAnimationEnd(e, e.onInitComplete)
			} else {
				if (g === "attention01" && e.activeAttention1) {
					j.onAnimationEnd(e, e.loopAttentionAnimation, f, g, 6667)
				} else {
					if (g === "attention02" && e.activeAttention2) {
						j.onAnimationEnd(e, e.loopAttentionAnimation, f, g, 3333)
					}
				}
			}
			Finn.AnimationUtils.setTime(f, h);
			f.updateTransform();
			f.visible = true
		};
		f.visible = false;
		return f
	},
	loopAttentionAnimation: function(c, a, d) {
		var b = this;
		if ((a === "attention01" && b.activeAttention1) || (a === "attention02" && b.activeAttention2)) {
			Game.PIXIUtils.resetSpineAnimation(c);
			c.fire(a, d)
		}
	},
	initBonusSymbolParticles: function() {
		var a = this;
		a.particleContainer = new PIXI.Container();
		a.particleContainer.position = new PIXI.Point(a.PARTICLE_OFFSET, a.PARTICLE_OFFSET);
		a.pixiContainer.addChild(a.particleContainer);
		a.emitter = new PIXI.particles.Emitter(a.particleContainer, [Resources.readData("animationImages").particles], Resources.readData("emitters").bonusSymbolEmitter1);
		a.emitter.emit = false;
		a.emitter.ownerPos.x = a.symbolPosition.x * a.symbolWidths.standard;
		a.emitter.ownerPos.y = a.symbolPosition.y * a.symbolHeights.standard;
		a.emitterHolder = new Animation.Holder({
			id: "emitterHolder1",
			target: a.emitter,
			loop: true,
			addToAnimationLoop: true,
			onUpdate: function(b) {
				a.emitter.update(b * 0.001)
			}
		});
		a.emitterHolder.play();
		a.emitterDropAnimation = a.initDropAnimation(a.emitter, "ownerPos");
		a.emitterDropAnimation.onStart = function() {};
		a.emitterDropAnimation.onEnd = a.onDropEnd.bind(a);
		a.emitter2 = new PIXI.particles.Emitter(a.particleContainer, [Resources.readData("animationImages").particles], Resources.readData("emitters").bonusSymbolEmitter2);
		a.emitter2.emit = false;
		a.emitter2.ownerPos.x = a.symbolPosition.x * a.symbolWidths.standard;
		a.emitter2.ownerPos.y = a.symbolPosition.y * a.symbolHeights.standard;
		a.emitterHolder2 = new Animation.Holder({
			id: "emitterHolder2",
			target: a.emitter2,
			loop: true,
			addToAnimationLoop: true,
			onUpdate: function(b) {
				a.emitter2.update(b * 0.001)
			}
		});
		a.emitterHolder2.play();
		a.emitterDropAnimation2 = a.initDropAnimation(a.emitter2, "ownerPos");
		a.emitterDropAnimation2.onStart = function() {};
		a.emitterDropAnimation2.onEnd = a.onDropEnd.bind(a);
		Game.stage.view.animationManager.addToAnimationLoop(a)
	},
	startFadeOut: function() {
		var a = this;
		a.emitter.emit = false;
		a.emitter2.emit = false;
		a.stopBonusSymbolAttentionAnimations();
		a.fadeOutAnimation.play()
	},
	startFadeIn: function(a) {
		var b = this;
		b.symbolSprite.visible = false;
		b.fadeInAnimation = b.initFadeInAnimation(b.symbolContainer, a, b.getInitialSpinDelay(a));
		b.fadeInAnimation.play();
		b.symbolContainer.alpha = 1;
		b.initAnimation.fire("init", 0)
	},
	onFadeInEnd: function() {
		var a = this;
		setTimeout(function() {
			a.setAttentionLevelGraphics(0)
		}, 500)
	},
	onInitComplete: function() {
		var a = this;
		a.initAnimation.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a.initAnimation)
	},
	startDrop: function() {
		var a = this;
		Finn.BufferedReelBonusSymbol.superclass.startDrop.apply(a);
		a.emitterDropAnimation.play();
		a.emitterDropAnimation2.play()
	},
	setAttentionLevelGraphics: function(a) {
		var b = this;
		if (a >= b.ATTENTION_LEVELS[2]) {
			if (!b.activeAttention2) {
				b.activeAttention2 = true;
				b.attentionAnimation2.visible = true;
				b.attentionAnimation2.fire("attention02", 0)
			}
			b.activeAttention1 = false;
			b.attentionAnimation.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b.attentionAnimation);
			b.symbolSprite.visible = false;
			b.emitter.emit = false;
			b.emitter2.emit = true
		} else {
			if (a >= b.ATTENTION_LEVELS[1]) {
				b.activeAttention2 = false;
				b.attentionAnimation2.visible = false;
				Game.PIXIUtils.resetSpineAnimation(b.attentionAnimation2);
				if (!b.activeAttention1) {
					b.activeAttention1 = true;
					b.attentionAnimation.visible = true;
					b.attentionAnimation.fire("attention01", 0)
				}
				b.symbolSprite.visible = false;
				b.emitter.emit = true
			} else {
				b.stopBonusSymbolAttentionAnimations();
				b.symbolSprite.visible = true
			}
		}
		b.setAttentionSound(a)
	},
	setAttentionSound: function(a) {
		var b = this;
		if (a >= b.ATTENTION_LEVELS[1] && !b.attentionSound2) {
			b.attentionSound2 = true;
			b.switchAmbience = false;
			if (b.attentionSound1) {
				b.fireEvent("notify:ambienceManager.startTransition", "ambienceGeneral2", "ambienceGeneral2", "ambienceGeneral1");
				b.attentionSound1 = false
			} else {
				b.fireEvent("notify:ambienceManager.startTransition", "ambienceGeneral2", "ambienceGeneral2", "ambienceGeneral");
				b.attentionSound = false
			}
		} else {
			if (!b.attentionSound1 && b.switchAmbience) {
				b.attentionSound1 = true;
				b.attentionSound = false;
				b.fireEvent("notify:ambienceManager.startTransition", "ambienceGeneral1", "ambienceGeneral1", "ambienceGeneral")
			} else {
				if ((a === b.ATTENTION_LEVELS[0] && !b.attentionSound && !b.switchAmbience) || b.stopAttentionSound) {
					b.attentionSound = true;
					b.stopAttentionSound = false;
					b.switchAmbience = false;
					if (b.attentionSound2) {
						b.fireEvent("notify:ambienceManager.startTransition", "ambienceGeneral", "ambienceGeneral", "ambienceGeneral2");
						b.attentionSound2 = false
					} else {
						b.fireEvent("notify:ambienceManager.startTransition", "ambienceGeneral", "ambienceGeneral", "ambienceGeneral1");
						b.attentionSound1 = false
					}
				}
			}
		}
	},
	onDropEnd: function() {
		var b = this,
			a = b.currentPosition + b.steps;
		b.dropAnimationCounter++;
		b.setAttentionLevelGraphics(a);
		if (b.dropAnimationCounter === 3) {
			if (b.ongoingDrop && b.endPosition > a) {
				b.setMovingDrop(b.endPosition - a, 0, a, true);
				b.startDrop()
			} else {
				b.ongoingDrop = false
			}
		}
	},
	resetSymbolPosition: function() {
		var a = this;
		if (!a.isLowEnd) {
			a.trench.clear()
		}
		a.currentPosition = 0;
		a.emitter.ownerPos.x = a.symbolPosition.x * a.symbolWidths.standard;
		a.emitter.ownerPos.y = a.symbolPosition.y * a.symbolHeights.standard
	},
	setPosition: function(a) {
		var b = this;
		b.currentPosition = a;
		b.symbolContainer.position.x = b.symbolPositions[a].x * b.symbolWidths.standard;
		b.symbolContainer.position.y = b.symbolPositions[a].y * b.symbolHeights.standard;
		b.emitter.ownerPos.x = b.symbolPositions[a].x * b.symbolWidths.standard;
		b.emitter.ownerPos.y = b.symbolPositions[a].y * b.symbolHeights.standard;
		b.emitter2.ownerPos.x = b.symbolPositions[a].x * b.symbolWidths.standard;
		b.emitter2.ownerPos.y = b.symbolPositions[a].y * b.symbolHeights.standard
	},
	setMovingDrop: function(k, b, a, j) {
		var h = this,
			d = b * h.animationSpeed * h.dropSpeedFactor,
			g = h.getAttentionLevel(a),
			l = h.getAttentionLevel(a + k),
			c, e = [],
			f;
		if (!j) {
			f = a < 24 ? a + 1 : a;
			if (!h.isLowEnd) {
				h.trench.start(f, k + a, d)
			}
		}
		h.setPosition(a);
		h.ongoingDrop = true;
		h.currentPosition = a;
		h.endPosition = a + k;
		h.dropAnimationCounter = 0;
		h.steps = (l > g) ? h.ATTENTION_LEVELS[g + 1] - a : k;
		if (h.steps === 0) {
			e.push(h.getSingleKeyFrame(h.symbolId, 0))
		} else {
			c = h.endPosition === h.currentPosition + h.steps;
			e = h.getMovingKeyFrames(a, h.steps, c)
		}
		h.dropAnimation.children[0].animation.keyFrames = e;
		h.dropAnimation.children[1].animation.keyFrames = [];
		h.dropAnimation.delay = d;
		h.emitterDropAnimation.children[0].animation.keyFrames = e;
		h.emitterDropAnimation.children[1].animation.keyFrames = [];
		h.emitterDropAnimation.delay = d;
		h.emitterDropAnimation2.children[0].animation.keyFrames = e;
		h.emitterDropAnimation2.children[1].animation.keyFrames = [];
		h.emitterDropAnimation2.delay = d
	},
	getAttentionLevel: function(a) {
		var b = this;
		if (a >= b.ATTENTION_LEVELS[2]) {
			return 2
		} else {
			if (a >= b.ATTENTION_LEVELS[1]) {
				return 1
			} else {
				return 0
			}
		}
	},
	quickStop: function(b) {
		var a = this;
		Finn.BufferedReelBonusSymbol.superclass.quickStop.apply(a, arguments);
		a.initAnimation.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a.initAnimation);
		a.setAttentionLevelGraphics(a.currentPosition)
	},
	quickStopDropAnimations: function() {
		var a = this;
		a.quickStopDropAnimation(a.dropAnimation);
		a.quickStopDropAnimation(a.emitterDropAnimation);
		a.quickStopDropAnimation(a.emitterDropAnimation2);
		if (!a.isLowEnd) {
			a.trench.quickDrawTrench()
		}
		a.ongoingDrop = false
	},
	startFreeSpinTrigger: function() {
		var a = this;
		a.stopBonusSymbolAttentionAnimations();
		a.symbolSprite.visible = false;
		a.deActivate();
		a.attentionSound = true;
		a.attentionSound1 = false;
		a.attentionSound2 = false
	},
	stopBonusSymbolAttentionAnimations: function() {
		var a = this;
		a.activeAttention1 = false;
		a.activeAttention2 = false;
		a.attentionAnimation.visible = false;
		a.attentionAnimation2.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a.attentionAnimation);
		Game.PIXIUtils.resetSpineAnimation(a.attentionAnimation2)
	},
	stopBonusAttention: function() {
		var a = this;
		a.symbolSprite.visible = true;
		if (a.attentionSound2 || a.attentionSound1) {
			a.stopAttentionSound = true;
			a.fireEvent("request:audioPlayer.play", {
				name: "returnToBase",
				id: "returnToBase",
				loop: false
			});
			a.setAttentionSound(a.currentPosition)
		}
		a.emitter.emit = false;
		a.emitter2.emit = false
	},
	switchAmbienceAfterWinAnimation: function() {
		var a = this;
		if (a.currentPosition === a.ATTENTION_LEVELS[0]) {
			a.switchAmbience = true;
			a.setAttentionSound(a.currentPosition)
		}
	},
	activate: function() {
		var a = this;
		a.showSymbol();
		a.activated = true
	},
	deActivate: function() {
		var a = this;
		if (!a.isLowEnd) {
			a.trench.clear()
		}
		a.hideSymbol();
		a.activated = false
	},
	isActive: function() {
		return this.activated
	},
	bounceCallbackWrapper: function() {},
	initTrench: function() {
		var a = this;
		if (!a.isLowEnd) {
			a.trench = new Finn.TrenchMasker(Game.stage.view.animationManager.getLayer("reelBackground"), "trench_Game");
			a.trench.setSpeed(a.animationSpeed)
		}
	},
	setSpinType: function(b) {
		var a = this;
		if (Sys.isDefined(a.spinType) && a.spinType !== b) {
			a.animationSpeed = b === "quickSpin" ? a.quickSpinSpeed : a.standardSpinSpeed;
			a.fadeInAnimation.delay = a.getInitialSpinDelay(a.symbolId)
		}
		a.spinType = b;
		if (!a.isLowEnd) {
			a.trench.setSpeed(a.animationSpeed)
		}
	}
};
Finn.BufferedReelBonusSymbol = Sys.extend(Finn.BufferedReelSymbol, Finn.BufferedReelBonusSymbol, "Finn.BufferedReelBonusSymbol");
Sys.ns("Finn");
Finn.SpinBaseController = {
	handleServerResponse: function(b) {
		var a = this;
		a.model.storeServerResponse(b);
		if (b.clientaction === "init") {
			a.model.initData();
			if (a.model.readData("active")) {
				a.fireEvent("request:spin.activateInitReelset", "basic1", a.model.readData("defaultScene"))
			}
		}
	}
};
Finn.SpinBaseController = Sys.extend(Core.Slots.SpinBaseController, Finn.SpinBaseController, "Finn.SpinBaseController");
Sys.ns("Finn");
Finn.SpinTypeBasic = {
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.SpinTypeBasicModel,
			controller: Finn.SpinBaseController
		}
	}
};
Finn.SpinTypeBasic = Sys.extend(Core.Slots.SpinTypeBasic, Finn.SpinTypeBasic, "Finn.SpinTypeBasic");
Sys.ns("Finn");
Finn.SpinTypeFreespin = {
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.SpinTypeFreespinModel,
			controller: Finn.SpinBaseController
		}
	}
};
Finn.SpinTypeFreespin = Sys.extend(Core.Slots.SpinTypeFreespin, Finn.SpinTypeFreespin, "Finn.SpinTypeFreespin");
Sys.ns("Finn");
Finn.WinningSymbols = {
	constructor: function() {
		Finn.WinningSymbols.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.WinningSymbolsModel,
			controller: Finn.WinningSymbolsController
		}
	}
};
Finn.WinningSymbols = Sys.extend(Core.Module, Finn.WinningSymbols, "Finn.WinningSymbols");
Sys.ns("Finn");
Finn.WinningSymbolsController = {
	STICKY_WILD_SYMBOL: "SYM0",
	WILD_SYMBOL: "SYM1",
	constructor: function() {
		Finn.WinningSymbolsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:winningSymbols.restoreWinningSymbols": a.restoreWinningSymbols,
			"notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
			"notify:winSituationsDisplay.showingAllWins": a.startWinAnimations,
			"notify:winningSymbolsAttention.winAttentionComplete": a.onWinAttentionComplete,
			"notify:winningSymbolsPresentation.winPresentationComplete": a.onWinPresentationComplete,
			"notify:winningSymbolsExplosion.winExplosionComplete": a.onWinExplosionComplete,
			"notify:winSituationsDisplay.abort": a.abort,
			"view:hideSymbol": a.hideSymbol,
			"view:showSymbol": a.showSymbol,
			"view:playSound": a.playSound,
			"view:stopSound": a.stopSound
		})
	},
	startWinAnimations: function() {
		var a = this;
		a.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
		a.showWinAttentions()
	},
	showWinAttentions: function() {
		var b = this,
			c = b.model.readData("wins"),
			a = b.model.readData("winType");
		if (b.model.getState() !== "stopped") {
			b.model.setState("attention");
			b.fireEvent("request:winningSymbolsAttention.startWinAttention", c, a)
		} else {
			b.onWinAttentionComplete()
		}
	},
	showWinPresentations: function() {
		var c = this,
			a = c.model.readData("winningSymbols"),
			d = c.model.readData("generatedWilds"),
			b = c.model.readData("explodingWilds");
		c.hideSymbolsOnReel(b);
		c.fireEvent("request:winBanner.animate");
		c.fireEvent("notify:winPresentation.showWinEffect", c.model.readData("winType"), c.model.readData("inMainGame"), c.model.getBetText(), c.model.getWinText(), c.model.readData("coinWin"));
		if (c.model.getState() === "attention") {
			c.model.setState("presentation");
			c.fireEvent("request:winningWildsExplosion.startWildsExplosion", b);
			c.fireEvent("request:winningSymbolsPresentation.startWinPresentation", a, d)
		} else {
			if (c.model.getState() === "stopped") {
				c.onWinPresentationComplete()
			}
		}
	},
	showWinExplosions: function() {
		var a = this,
			b = a.model.readData("explodingSymbols"),
			c = a.model.readData("generatedWilds");
		a.hideSymbolsOnReel(b);
		if (a.model.getState() === "presentation") {
			a.model.setState("explosion");
			a.fireEvent("request:winningSymbolsExplosion.startWinExplosion", b, c);
			a.addGeneratedWildsToReel()
		} else {
			if (a.model.getState() === "stopped") {
				a.onWinExplosionComplete()
			}
		}
	},
	hideSymbolsOnReel: function(b) {
		var c = this,
			a = {
				0: []
			};
		b.forEach(function(d) {
			if (d.symbol !== c.STICKY_WILD_SYMBOL) {
				a[0].push(d.index)
			}
		});
		if (a[0].length > 0) {
			c.fireEvent("request:spin.hideSymbols", a)
		}
	},
	onWinAttentionComplete: function() {
		var a = this;
		a.showWinPresentations()
	},
	onWinPresentationComplete: function() {
		var a = this;
		a.showWinExplosions()
	},
	onWinExplosionComplete: function() {
		var a = this;
		a.stopWinAnimations()
	},
	addGeneratedWildsToReel: function() {
		var b = this,
			c = b.model.readData("generatedWilds"),
			a = {
				0: []
			};
		if (c.length > 0) {
			c.forEach(function(d) {
				a[0].push(d.index)
			})
		}
		if (a[0].length > 0) {
			b.fireEvent("request:spin.replaceSymbols", [a, b.WILD_SYMBOL])
		}
	},
	stopWinAnimations: function() {
		var a = this;
		a.model.setState("idle");
		a.fireEvent("notify:winningSymbols.animationComplete")
	},
	abort: function() {
		var a = this;
		if (a.model.getState() === "attention" || a.model.getState() === "presentation" || a.model.getState() === "explosion") {
			a.model.setState("stopped");
			a.fireEvent("notify:winningSymbols.abort")
		}
	},
	restoreWinningSymbols: function() {
		var b = this,
			c = b.model.readData("explodingSymbols"),
			a = b.model.readData("explodingWilds");
		b.fireEvent("request:randomFeature.restore");
		b.hideSymbolsOnReel(c);
		b.hideSymbolsOnReel(a);
		b.addGeneratedWildsToReel()
	}
};
Finn.WinningSymbolsController = Sys.extend(Game.Slots.WinningSymbolsController, Finn.WinningSymbolsController, "Finn.WinningSymbolsController");
Sys.ns("Finn");
Finn.WinningSymbolsModel = {
	WILD_SYMBOL: "SYM1",
	constructor: function() {
		Finn.WinningSymbolsModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(k) {
		var l = this,
			f = k.reelInfo,
			c, n = [],
			e = [],
			a = [],
			m = [],
			g = [],
			j, h = 0,
			b, d = !Sys.isDefined(k.freespin);
		if (k.wins && Sys.isArray(k.wins.winSituations)) {
			h = k.wins.coins;
			b = k.wins.winType;
			l.storeData("winType", b);
			l.storeData("inMainGame", d);
			if (k.wins) {
				if (Sys.isDefined(k.wins.coins)) {
					l.storeData("win", k.wins.coins)
				} else {
					l.storeData("win", 0)
				}
			}
			Sys.each(k.wins.winSituations, function(o) {
				j = [];
				if (o.generatedWildPosition) {
					c = l.getSymbolConfig(o.generatedWildPosition, f, o.sym, o.wins.coins);
					a.push(c)
				}
				Sys.each(o.positions, function(p) {
					c = l.getSymbolConfig(p, f, o.sym, o.wins.coins);
					n.push(c);
					j.push(c);
					if (p.sym === l.WILD_SYMBOL) {
						m.push(c)
					} else {
						e.push(c)
					}
				});
				Sys.each(o.wildExplosions, function(p) {
					c = l.getSymbolConfig(p, f, o.sym, o.wins.coins);
					e.push(c)
				});
				g.push(j)
			})
		}
		l.storeData("coinWin", h);
		l.storeData("wins", g);
		l.storeData("winningSymbols", l.removeDuplicates(n));
		l.storeData("explodingSymbols", l.removeDuplicates(e));
		l.storeData("generatedWilds", l.removeDuplicates(a));
		l.storeData("explodingWilds", l.removeDuplicates(m))
	},
	removeDuplicates: function(c) {
		var b = this,
			a = [],
			d = {};
		Sys.each(c, function(e) {
			if (!d[e.index] || b.moreValuableWin(e.payoutSymbol, d[e.index].payoutSymbol)) {
				d[e.index] = e
			}
		});
		Sys.iterate(d, function(e, f) {
			a.push(f)
		});
		return a
	},
	moreValuableWin: function(c, a) {
		var d, b;
		d = parseInt(a.slice(-1), 10);
		b = parseInt(c.slice(-1), 10);
		return b < d
	},
	getSymbolConfig: function(c, e, h, b) {
		var d, g, a, f;
		d = c.symbolIndex;
		g = c.reelIndex;
		a = e[g].afterFeatureSymbols[d];
		f = {
			index: d,
			symbol: a,
			payoutSymbol: h,
			coins: b
		};
		return f
	},
	getBetText: function() {
		return Services.moneyManager.getBetCoins()
	},
	getWinText: function() {
		var a = this.readData("win");
		return a === 0 ? "" : a
	}
};
Finn.WinningSymbolsModel = Sys.extend(Game.Slots.WinningSymbolsModel, Finn.WinningSymbolsModel, "Finn.WinningSymbolsModel");
Sys.ns("Finn");
Finn.WinningSymbolsAttention = {
	constructor: function() {
		Finn.WinningSymbolsAttention.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.WinningSymbolsAttentionModel,
			view: Finn.WinningSymbolsAttentionView,
			controller: Finn.WinningSymbolsAttentionController
		}
	}
};
Finn.WinningSymbolsAttention = Sys.extend(Core.Module, Finn.WinningSymbolsAttention, "Finn.WinningSymbolsAttention");
Sys.ns("Finn");
Finn.WinningSymbolsAttentionController = {
	STICKY_WILD_SYMBOL: "SYM0",
	WILD_SYMBOL: "SYM1",
	constructor: function() {
		Finn.WinningSymbolsAttentionController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:winningSymbolsAttention.startWinAttention": a.startWinAttention,
			"notify:winningSymbols.abort": a.abortWinAttention,
			"view:allAttentionsComplete": a.onAllAttentionsComplete,
			"view:winAttentionComplete": a.onWinAttentionComplete,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
		})
	},
	startWinAttention: function(c, a) {
		var b = this;
		b.model.setState("animating");
		b.model.storeData("winType", a);
		b.winIndex = 0;
		b.wins = c;
		b.showNextWin()
	},
	onWinAttentionComplete: function() {
		var a = this;
		a.showSymbolsOnReel(a.wins[a.winIndex]);
		a.view.hideWinAnimations(a.wins[a.winIndex]);
		a.winIndex++;
		if (Sys.isDefined(a.wins[a.winIndex])) {
			a.showNextWin()
		} else {
			a.view.stop(false)
		}
	},
	showNextWin: function() {
		var a = this,
			b;
		a.hideSymbolsOnReel(a.wins[a.winIndex]);
		b = a.winIndex === (a.wins.length - 1);
		a.view.showWin(a.wins[a.winIndex], b)
	},
	onAllAttentionsComplete: function() {
		var a = this;
		a.model.setState("idle");
		a.fireEvent("notify:winningSymbolsAttention.winAttentionComplete")
	},
	getSymbolsOnReel: function(b) {
		var c = this,
			a = {
				0: []
			};
		b.forEach(function(d) {
			if (d.symbol !== c.STICKY_WILD_SYMBOL && d.symbol !== c.WILD_SYMBOL) {
				a[0].push(d.index)
			}
		});
		return a
	},
	hideSymbolsOnReel: function(b) {
		var c = this,
			a = c.getSymbolsOnReel(b);
		if (a[0].length > 0) {
			c.fireEvent("request:spin.hideSymbols", a)
		}
	},
	showSymbolsOnReel: function(b) {
		var c = this,
			a = c.getSymbolsOnReel(b);
		if (a[0].length > 0) {
			c.fireEvent("request:spin.showSymbols", a)
		}
	},
	abortWinAttention: function() {
		var a = this;
		if (a.model.getState() === "animating") {
			a.view.stop(true)
		}
	},
};
Finn.WinningSymbolsAttentionController = Sys.extend(Core.Controller, Finn.WinningSymbolsAttentionController, "Finn.WinningSymbolsAttentionController");
Sys.ns("Finn");
Finn.WinningSymbolsAttentionModel = {
	constructor: function() {
		Finn.WinningSymbolsAttentionModel.superclass.constructor.apply(this, arguments)
	}
};
Finn.WinningSymbolsAttentionModel = Sys.extend(Core.Model, Finn.WinningSymbolsAttentionModel, "Finn.WinningSymbolsAttentionModel");
Sys.ns("Finn");
Finn.WinningSymbolsAttentionView = {
	ATTENTION_INTERVAL: 600,
	COIN_TEXT_DELAY: 70,
	SOUND: [{
		name: "winAttention1",
		id: "winAttention1"
	}, {
		name: "winAttention2",
		id: "winAttention2"
	}, {
		name: "winAttention3",
		id: "winAttention3"
	}, {
		name: "winAttention4",
		id: "winAttention4"
	}],
	STICKY_WILD_SYMBOL: "SYM0",
	WILD_SYMBOL: "SYM1",
	WILD_OFFSET: {
		x: -40,
		y: -40
	},
	WIN_ATTENTION_CONFIG: {
		SYM0: {
			symAnimationName: "sym0_init_EXPORT",
			wildAnimationName: "wild_attention_purple_EXPORT",
			offset: {
				x: -90,
				y: -86.5
			},
			swooshName: "sym4"
		},
		SYM1: {
			symAnimationName: "sym3_init_EXPORT",
			wildAnimationName: "wild_attention_purple_EXPORT",
			offset: {
				x: -86.5,
				y: -86.5
			},
			swooshName: "sym4"
		},
		SYM3: {
			symAnimationName: "sym3_init_EXPORT",
			wildAnimationName: "wild_attention_purple_EXPORT",
			offset: {
				x: -86.5,
				y: -86.5
			},
			swooshName: "sym3"
		},
		SYM4: {
			symAnimationName: "sym4_init_EXPORT",
			wildAnimationName: "wild_attention_orange_EXPORT",
			offset: {
				x: -86.5,
				y: -86.5
			},
			swooshName: "sym4"
		},
		SYM5: {
			symAnimationName: "sym5_init_EXPORT",
			wildAnimationName: "wild_attention_green_EXPORT",
			offset: {
				x: -86.5,
				y: -86.5
			},
			swooshName: "sym5"
		},
		SYM6: {
			symAnimationName: "sym6_init_EXPORT",
			wildAnimationName: "wild_attention_green_EXPORT",
			offset: {
				x: -86.5,
				y: -86.5
			},
			swooshName: "sym6"
		},
		SYM7: {
			symAnimationName: "sym7_init_EXPORT",
			wildAnimationName: "wild_attention_pink_EXPORT",
			offset: {
				x: -32.5,
				y: -38.5
			},
			swooshName: "sym7"
		},
		SYM8: {
			symAnimationName: "sym8_init_EXPORT",
			wildAnimationName: "wild_attention_blue_EXPORT",
			offset: {
				x: -32,
				y: -35
			},
			swooshName: "sym8"
		}
	},
	LINE_OFFSET: {
		horizontal: {
			x: 0,
			y: 0
		},
		vertical: {
			x: 128,
			y: 0
		}
	},
	constructor: function() {
		Finn.WinningSymbolsAttentionView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var c = this,
			a = Game.stage.view.animationManager.getLayer("winSymbols"),
			b = Game.stage.view.animationManager.getLayer("winCoinNumbers");
		c.showNumbers = true;
		c.config = Resources.readData("config");
		c.reelLayout = c.config.reelGroups["default"].reelLayout;
		c.symbolWidths = c.reelLayout.standard.symbolWidths.standard;
		c.symbolHeights = c.reelLayout.standard.symbolHeights.standard;
		c.winSymbolContainer = new PIXI.Container();
		c.winSymbolContainer.position = new PIXI.Point(c.reelLayout[0].left, c.reelLayout.standard.top);
		a.addChild(c.winSymbolContainer);
		c.symbolAnimations = c.initSymbolAnimations(c.winSymbolContainer, "winAttention");
		c.wildAnimations = c.initSymbolAnimations(c.winSymbolContainer, "wildSymbol");
		c.lineAnimation = c.initAnimation(c.winSymbolContainer, "winAttentionLine");
		c.winCoinContainer = new PIXI.Container();
		c.winCoinContainer.position = new PIXI.Point(c.reelLayout[0].left, c.reelLayout.standard.top);
		b.addChild(c.winCoinContainer)
	},
	initSymbolAnimations: function(a, b) {
		var d = this,
			f = [],
			e, c;
		for (c = 0; c < d.reelLayout.symbolPositions.length; c++) {
			e = d.initAnimation(a, b);
			f.push(e)
		}
		return f
	},
	initAnimation: function(a, b) {
		var c = this,
			d;
		d = Game.PIXIFactory.createAndAddSpineAnimation(b, a);
		d.fire = function(e, h, g, f) {
			this.position.x = h.x + c.reelLayout.symbolPositions[g].x * c.symbolWidths;
			this.position.y = h.y + c.reelLayout.symbolPositions[f].y * c.symbolHeights;
			this.state.setAnimation(0, e, false);
			this.visible = true;
			this.updateTransform();
			c.timeOut = setTimeout(function() {
				c.animationComplete()
			}, c.ATTENTION_INTERVAL)
		};
		d.visible = false;
		return d
	},
	initCoinNumberText: function(c, e, d, b) {
		var a;
		a = Game.PIXIFactory.createAndAddText(e, d, c, b, new PIXI.Point(0.5, 0.5));
		a.alpha = 0;
		return a
	},
	initCoinNumberAnimation: function(o, c, b, d, g, a) {
		var k = this,
			j = c + (o.width / 2),
			f = d === "vertical" ? b + (o.height / 2) : b + (k.symbolHeights - (o.height / 2)),
			n = c + 0.5 * k.symbolWidths,
			l = b + 0.5 * k.symbolHeights;
		var m = {
			prop: "position",
			animate: [{
				time: 0,
				value: {
					x: j,
					y: f
				},
				ease: Animation.utils.powerTwoOut
			}, {
				time: 200,
				value: {
					x: n,
					y: l
				},
				ease: Animation.utils.powerTwoOut
			}, {
				time: 700,
				value: {
					x: n,
					y: l
				}
			}]
		};
		var h = {
			prop: "scale",
			animate: [{
				time: 0,
				value: {
					x: 0,
					y: 0
				},
				ease: Animation.utils.powerTwoIn
			}, {
				time: 50,
				value: {
					x: 1,
					y: 1
				}
			}, {
				time: 250,
				value: {
					x: 1,
					y: 1
				},
				ease: Animation.utils.powerTwoIn
			}, {
				time: 700,
				value: {
					x: 2,
					y: 2
				}
			}]
		};
		var p = {
			prop: "alpha",
			animate: [{
				time: 0,
				value: 0,
				ease: Animation.utils.powerTwoIn
			}, {
				time: 50,
				value: 1
			}, {
				time: 250,
				value: 1,
				ease: Animation.utils.powerTwoIn
			}, {
				time: 700,
				value: 0
			}]
		};
		var e = new Animation.Holder({
			id: "winNumber",
			target: o,
			delay: g,
			onEnd: function() {
				Game.stage.view.animationManager.removeFromAnimationLoop(e);
				k.winCoinContainer.removeChild(o);
				if (a && k.showNumbers) {
					k.winCoinContainer.visible = false
				}
			},
			children: [m, h, p]
		});
		Game.stage.view.animationManager.addToAnimationLoop(e);
		return e
	},
	showWin: function(f, a) {
		var h = this,
			g = h.reelLayout.symbolPositions,
			e, k, j, d, c, m, b;
		Sys.each(h.symbolAnimations, function(n) {
			n.visible = false;
			Game.PIXIUtils.resetSpineAnimation(n)
		});
		if (h.model.getState() === "animating") {
			h.completedAnimations = 0;
			h.numberOfAnimations = f.length + 1;
			h.lineAnimation.rotation = 0;
			Sys.each(f, function(n, o) {
				e = h.WIN_ATTENTION_CONFIG[n.symbol];
				if (n.symbol !== h.WILD_SYMBOL && n.symbol !== h.STICKY_WILD_SYMBOL) {
					h.symbolAnimations[n.index].fire(e.symAnimationName, e.offset, n.index, n.index)
				} else {
					if (n.symbol !== h.STICKY_WILD_SYMBOL) {
						h.animationComplete()
					} else {
						if (n.symbol === h.STICKY_WILD_SYMBOL) {
							h.symbolAnimations[n.index].fire(e.symAnimationName, e.offset, n.index, n.index)
						} else {
							h.completedAnimations++
						}
					}
				}
				k = (!Sys.isDefined(k) || g[n.index].x < g[k].x) ? n.index : k;
				j = (!Sys.isDefined(j) || g[n.index].y < g[j].y) ? n.index : j;
				d = (!Sys.isDefined(d) || g[n.index].x > g[f[d].index].x) ? o : d;
				c = (!Sys.isDefined(c) || g[n.index].y > g[f[c].index].y) ? o : c
			});
			b = g[f[0].index].x === g[f[1].index].x ? "vertical" : "horizontal";
			h.lineAnimation.rotation = b === "vertical" ? Math.PI / 2 : 0;
			h.lineAnimation.fire(f.length + "_" + e.swooshName, h.LINE_OFFSET[b], k, j);
			if (h.showNumbers) {
				m = b === "vertical" ? c : d;
				h.showCoinNumber(f, k, j, b, m, a)
			}
			var l = Math.floor((Math.random() * 4));
			h.fireEvent("view:playAudio", h.SOUND[l])
		}
	},
	showCoinNumber: function(l, n, m, d, o, a) {
		var j = this,
			f, e, c, b, h, g, k;
		j.winCoinContainer.visible = true;
		f = (j.reelLayout.symbolPositions[n].x) * j.symbolWidths;
		e = (j.reelLayout.symbolPositions[m].y) * j.symbolHeights;
		c = d === "vertical" ? f : f + (l.length - 1) * j.symbolWidths;
		b = d === "horizontal" ? e : e + (l.length - 1) * j.symbolHeights;
		h = Game.TextStyles.WIN_SITUATION_TEXT[l[o].symbol];
		h.fontSize = Game.TextStyles.WIN_SITUATION_TEXT[l[0].payoutSymbol].fontSize;
		g = l.length * j.COIN_TEXT_DELAY;
		k = j.initCoinNumberText(j.winCoinContainer, l[0].coins, h, new PIXI.Point(c, b));
		j.initCoinNumberAnimation(k, c, b, d, g, a).play()
	},
	animationComplete: function() {
		var a = this;
		a.completedAnimations++;
		if (a.completedAnimations === a.numberOfAnimations) {
			a.fireEvent("view:winAttentionComplete")
		}
	},
	hideWinAnimations: function(b) {
		var a = this;
		Sys.each(b, function(c) {
			a.symbolAnimations[c.index].visible = false;
			a.wildAnimations[c.index].visible = false
		})
	},
	stop: function(b) {
		var a = this;
		clearTimeout(a.timeOut);
		if (b) {
			a.winCoinContainer.removeChildren();
			a.winCoinContainer.visible = false
		}
		Sys.each(a.symbolAnimations, function(c) {
			c.visible = false;
			Game.PIXIUtils.resetSpineAnimation(c)
		});
		Sys.each(a.wildAnimations, function(c) {
			c.visible = false;
			Game.PIXIUtils.resetSpineAnimation(c)
		});
		Game.PIXIUtils.resetSpineAnimation(a.lineAnimation);
		a.lineAnimation.visible = false;
		a.lineAnimation.rotation = 0;
		a.fireEvent("view:allAttentionsComplete")
	},
};
Finn.WinningSymbolsAttentionView = Sys.extend(Core.View, Finn.WinningSymbolsAttentionView, "Finn.WinningSymbolsAttentionView");
Sys.ns("Finn");
Finn.WinningSymbolsExplosion = {
	constructor: function() {
		Finn.WinningSymbolsExplosion.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.WinningSymbolsExplosionModel,
			view: Finn.WinningSymbolsExplosionView,
			controller: Finn.WinningSymbolsExplosionController
		}
	}
};
Finn.WinningSymbolsExplosion = Sys.extend(Core.Module, Finn.WinningSymbolsExplosion, "Finn.WinningSymbolsExplosion");
Sys.ns("Finn");
Finn.WinningSymbolsExplosionController = {
	constructor: function() {
		Finn.WinningSymbolsExplosionController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:winningSymbolsExplosion.startWinExplosion": a.startWinExplosion,
			"notify:winningSymbols.abort": a.abortWinExplosion,
			"view:animationComplete": a.onAnimationComplete,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play")
		})
	},
	startWinExplosion: function(b, c) {
		var a = this;
		a.model.setState("animating");
		a.view.start(b, c)
	},
	onAnimationComplete: function() {
		var a = this;
		a.model.setState("idle");
		a.fireEvent("notify:winningSymbolsExplosion.winExplosionComplete")
	},
	abortWinExplosion: function() {
		var a = this;
		if (a.model.getState() === "animating") {
			a.view.stop()
		}
	}
};
Finn.WinningSymbolsExplosionController = Sys.extend(Core.Controller, Finn.WinningSymbolsExplosionController, "Finn.WinningSymbolsExplosionController");
Sys.ns("Finn");
Finn.WinningSymbolsExplosionModel = {
	constructor: function() {
		Finn.WinningSymbolsExplosionModel.superclass.constructor.apply(this, arguments)
	}
};
Finn.WinningSymbolsExplosionModel = Sys.extend(Core.Model, Finn.WinningSymbolsExplosionModel, "Finn.WinningSymbolsExplosionModel");
Sys.ns("Finn");
Finn.WinningSymbolsExplosionView = {
	SOUND_WILD_SPAWN: {
		name: "wildSpawn",
		id: "wildSpawn"
	},
	SOUND: [{
		name: "explosion1",
		id: "explosion1"
	}, {
		name: "explosion2",
		id: "explosion2"
	}, {
		name: "explosion3",
		id: "explosion3"
	}, {
		name: "explosion4",
		id: "explosion4"
	}],
	constructor: function() {
		Finn.WinningSymbolsExplosionView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this,
			a = Game.stage.view.animationManager.getLayer("winSymbols");
		b.config = Resources.readData("config");
		b.reelLayout = b.config.reelGroups["default"].reelLayout;
		b.symbolWidths = b.reelLayout.standard.symbolWidths.standard;
		b.symbolHeights = b.reelLayout.standard.symbolHeights.standard;
		b.winSymbolContainer = new PIXI.Container();
		b.winSymbolContainer.position = new PIXI.Point(b.reelLayout[0].left, b.reelLayout.standard.top);
		a.addChild(b.winSymbolContainer);
		b.symbolAnimations = b.initSymbolAnimations(b.winSymbolContainer, "winExplosion");
		b.wildAnimations = b.initSymbolAnimations(b.winSymbolContainer, "wildSymbol")
	},
	initSymbolAnimations: function(a, b) {
		var d = this,
			f = [],
			e, c;
		for (c = 0; c < d.reelLayout.symbolPositions.length; c++) {
			e = d.initAnimation(a, b, c);
			f.push(e)
		}
		return f
	},
	initAnimation: function(a, d, c) {
		var e = this,
			g, f = Platform.isDesktopDevice ? 1 : 0.75,
			b = (d === "wildSymbol") ? 2 : 1;
		g = Game.PIXIFactory.createAndAddSpineAnimation(d, a);
		g.fire = function(h, j) {
			Finn.AnimationUtils.initialize(g, h).onAnimationEnd(e, e.animationComplete);
			if (j) {
				this.rotation = Math.random() * 2 * Math.PI
			}
			this.visible = true;
			this.updateTransform()
		};
		g.position.x = -e.symbolWidths * 0.75 * b + (e.reelLayout.symbolPositions[c].x) * e.symbolWidths + (0.5 * g.width / f);
		g.position.y = -e.symbolHeights * 0.75 * b + (e.reelLayout.symbolPositions[c].y) * e.symbolHeights + (0.5 * g.height / f);
		g.pivot.x = (0.5 * g.width / f);
		g.pivot.y = (0.5 * g.height / f);
		g.visible = false;
		return g
	},
	animationComplete: function() {
		var a = this;
		a.completedAnimations++;
		if (a.completedAnimations === a.numberOfAnimations) {
			a.stop()
		}
	},
	start: function(b, c) {
		var a = this;
		a.completedAnimations = 0;
		a.numberOfAnimations = b.length + c.length;
		if (a.numberOfAnimations === 0) {
			a.fireEvent("view:animationComplete")
		}
		if (a.model.getState() === "animating") {
			a.startExplosion(b);
			a.generateWilds(c)
		}
	},
	startExplosion: function(c) {
		var b = this,
			a = 0;
		Sys.each(c, function(d) {
			b.symbolAnimations[d.index].fire("animation", true);
			a++
		});
		if (a > 11) {
			b.fireEvent("view:playAudio", b.SOUND[0])
		} else {
			if (a > 8) {
				b.fireEvent("view:playAudio", b.SOUND[1])
			} else {
				if (a > 5) {
					b.fireEvent("view:playAudio", b.SOUND[2])
				} else {
					b.fireEvent("view:playAudio", b.SOUND[3])
				}
			}
		}
	},
	generateWilds: function(c) {
		var b = this,
			a = false;
		Sys.each(c, function(d) {
			b.wildAnimations[d.index].fire("wild_INIT_EXPORT", false);
			a = true
		});
		if (a) {
			b.fireEvent("view:playAudio", b.SOUND_WILD_SPAWN)
		}
	},
	stop: function() {
		var a = this;
		Sys.each(a.symbolAnimations, function(b) {
			b.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b)
		});
		Sys.each(a.wildAnimations, function(b) {
			b.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b)
		});
		a.fireEvent("view:animationComplete")
	}
};
Finn.WinningSymbolsExplosionView = Sys.extend(Core.View, Finn.WinningSymbolsExplosionView, "Finn.WinningSymbolsExplosionView");
Sys.ns("Finn");
Finn.WinningSymbolsPresentation = {
	constructor: function() {
		Finn.WinningSymbolsPresentation.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.WinningSymbolsPresentationModel,
			view: Finn.WinningSymbolsPresentationView,
			controller: Finn.WinningSymbolsPresentationController
		}
	}
};
Finn.WinningSymbolsPresentation = Sys.extend(Core.Module, Finn.WinningSymbolsPresentation, "Finn.WinningSymbolsPresentation");
Sys.ns("Finn");
Finn.WinningSymbolsPresentationController = {
	constructor: function() {
		Finn.WinningSymbolsPresentationController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:winningSymbolsPresentation.startWinPresentation": a.startWinPresentation,
			"notify:winningSymbols.abort": a.abortWinPresentation,
			"view:animationComplete": a.onAnimationComplete,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play")
		})
	},
	startWinPresentation: function(a, c) {
		var b = this;
		b.model.setState("animating");
		b.view.start(a, c)
	},
	onAnimationComplete: function() {
		var a = this;
		a.model.setState("idle");
		a.fireEvent("notify:winningSymbolsPresentation.winPresentationComplete")
	},
	abortWinPresentation: function() {
		var a = this;
		if (a.model.getState() === "animating") {
			a.view.stop()
		}
	}
};
Finn.WinningSymbolsPresentationController = Sys.extend(Core.Controller, Finn.WinningSymbolsPresentationController, "Finn.WinningSymbolsPresentationController");
Sys.ns("Finn");
Finn.WinningSymbolsPresentationModel = {
	constructor: function() {
		Finn.WinningSymbolsPresentationModel.superclass.constructor.apply(this, arguments)
	}
};
Finn.WinningSymbolsPresentationModel = Sys.extend(Core.Model, Finn.WinningSymbolsPresentationModel, "Finn.WinningSymbolsPresentationModel");
Sys.ns("Finn");
Finn.WinningSymbolsPresentationView = {
	SOUND: [{
		name: "smallWin",
		id: "smallWin"
	}, {
		name: "mediumWin",
		id: "mediumWin"
	}, {
		name: "largeWin",
		id: "largeWin"
	}],
	SOUND_SPOILER: {
		name: "wildSpoiler",
		id: "wildSpoiler"
	},
	WILD_SYMBOL: "SYM1",
	LOW_WIN_SYMBOLS: ["SYM7", "SYM8"],
	MEDIUM_WIN_SYMBOLS: ["SYM4", "SYM5", "SYM6"],
	HIGH_WIN_SYMBOLS: ["SYM3"],
	WILD_WIN_SYMBOLS: ["SYM0", "SYM1"],
	SYMBOL_ANIMATIONS: {
		SYM0: "win_wild_EXPORT",
		SYM1: "win_wild_EXPORT",
		SYM3: "win_sym3_EXPORT",
		SYM4: "win_sym4_EXPORT",
		SYM5: "win_sym5_EXPORT",
		SYM6: "win_sym6_EXPORT",
		SYM7: "win_sym7_EXPORT",
		SYM8: "win_sym8_EXPORT"
	},
	WILD_SPOILER_ANIMATION: "wild_SPOILER_EXPORT",
	WILD_SPOILER_OFFSET: {
		x: 280,
		y: -50
	},
	LOW_WIN_OFFSET: {
		x: 255,
		y: -62
	},
	MEDIUM_WIN_OFFSET: {
		x: 232,
		y: -80
	},
	HIGH_WIN_OFFSET: {
		x: 190,
		y: -110
	},
	WILD_WIN_OFFSET: {
		x: 180,
		y: -130
	},
	constructor: function() {
		Finn.WinningSymbolsPresentationView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var c = this;
		c.config = Resources.readData("config");
		c.reelLayout = c.config.reelGroups["default"].reelLayout;
		c.symbolWidths = c.reelLayout.standard.symbolWidths.standard;
		c.symbolHeights = c.reelLayout.standard.symbolHeights.standard;
		c.rootContainerBelow = new PIXI.Container();
		c.winningSymbolsContainer = new PIXI.Container();
		c.rootContainerBelow.addChild(c.winningSymbolsContainer);
		var a = Game.stage.view.animationManager.getLayer("winPresentationBelowSymbols");
		a.addChild(c.rootContainerBelow);
		c.rootContainerAbove = new PIXI.Container();
		c.wildContainer = new PIXI.Container();
		c.rootContainerAbove.addChild(c.wildContainer);
		c.randomizer = [];
		c.randomizer.push(new Finn.Randomizer());
		c.randomizer.push(new Finn.Randomizer());
		c.randomizer.push(new Finn.Randomizer());
		c.randomizer[0].initiate(["smallWin", "smallWin1"]);
		c.randomizer[1].initiate(["mediumWin", "mediumWin1"]);
		c.randomizer[2].initiate(["largeWin", "largeWin1", "largeWin2"]);
		var b = Game.stage.view.animationManager.getLayer("winPresentationAboveSymbols");
		b.addChild(c.rootContainerAbove);
		c.symbolAnimations = c.initSymbolAnimations(c.winningSymbolsContainer, "winPresentation");
		c.wildAnimations = c.initSymbolAnimations(c.wildContainer, "wildSymbol")
	},
	initSymbolAnimations: function(a, d) {
		var f = this,
			h = [],
			g, e;
		var c = function(j, l, k) {
			this.position.x = l.x + f.reelLayout.symbolPositions[k].x * f.symbolWidths;
			this.position.y = l.y + f.reelLayout.symbolPositions[k].y * f.symbolHeights;
			Finn.AnimationUtils.initialize(this, j).onAnimationEnd(f, f.animationComplete);
			this.updateTransform()
		};
		for (e = 0; e < f.reelLayout.symbolPositions.length; e++) {
			g = Game.PIXIFactory.createAndAddSpineAnimation(d, a);
			g.fire = c.bind(g);
			g.visible = false;
			if (d === "winPresentation" && (Platform.isLowEndDevice || Platform.isIEBrowser || Platform.isEdgeBrowser)) {
				for (var b = 0; b < g.spineData.slots.length; b++) {
					g.spineData.slots[b].blendMode = 0
				}
			}
			h.push(g)
		}
		return h
	},
	animationComplete: function() {
		var a = this;
		a.completedAnimations++;
		if (a.completedAnimations === a.numberOfAnimations) {
			a.stop()
		}
	},
	start: function(a, c) {
		var b = this;
		b.completedAnimations = 0;
		b.numberOfAnimations = a.length + c.length;
		if (b.model.getState() === "animating") {
			b.showSymbolPresentation(a);
			b.showWildSpoilers(c)
		}
	},
	showSymbolPresentation: function(a) {
		var b = this,
			c = 0,
			d;
		Sys.each(a, function(e) {
			if (b.WILD_WIN_SYMBOLS.indexOf(e.symbol) >= 0) {
				b.symbolAnimations[e.index].fire(b.SYMBOL_ANIMATIONS[e.symbol], b.WILD_WIN_OFFSET, e.index);
				c = 2
			} else {
				if (b.HIGH_WIN_SYMBOLS.indexOf(e.symbol) >= 0) {
					b.symbolAnimations[e.index].fire(b.SYMBOL_ANIMATIONS[e.symbol], b.HIGH_WIN_OFFSET, e.index);
					c = 2
				} else {
					if (b.MEDIUM_WIN_SYMBOLS.indexOf(e.symbol) >= 0) {
						b.symbolAnimations[e.index].fire(b.SYMBOL_ANIMATIONS[e.symbol], b.MEDIUM_WIN_OFFSET, e.index);
						c = (c === 0) ? 1 : c
					} else {
						b.symbolAnimations[e.index].fire(b.SYMBOL_ANIMATIONS[e.symbol], b.LOW_WIN_OFFSET, e.index)
					}
				}
			}
		});
		d = b.randomizer[c].draw();
		b.fireEvent("view:playAudio", {
			name: d,
			id: d
		})
	},
	showWildSpoilers: function(c) {
		var b = this,
			a = false;
		Sys.each(c, function(d) {
			b.wildAnimations[d.index].fire(b.WILD_SPOILER_ANIMATION, b.WILD_SPOILER_OFFSET, d.index);
			a = true
		});
		if (a) {
			b.fireEvent("view:playAudio", b.SOUND_SPOILER)
		}
	},
	stop: function() {
		var a = this;
		Sys.each(a.symbolAnimations, function(b) {
			b.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b)
		});
		Sys.each(a.wildAnimations, function(b) {
			b.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b)
		});
		a.fireEvent("view:animationComplete")
	}
};
Finn.WinningSymbolsPresentationView = Sys.extend(Core.View, Finn.WinningSymbolsPresentationView, "Finn.WinningSymbolsPresentationView");
Sys.ns("Finn");
Finn.WinningWildsExplosion = {
	constructor: function() {
		Finn.WinningWildsExplosion.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.WinningWildsExplosionModel,
			view: Finn.WinningWildsExplosionView,
			controller: Finn.WinningWildsExplosionController
		}
	}
};
Finn.WinningWildsExplosion = Sys.extend(Core.Module, Finn.WinningWildsExplosion, "Finn.WinningWildsExplosion");
Sys.ns("Finn");
Finn.WinningWildsExplosionController = {
	constructor: function() {
		Finn.WinningWildsExplosionController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:winningWildsExplosion.startWildsExplosion": a.startWildExplosion,
			"notify:winningSymbols.abort": a.abortWildExplosion,
			"view:animationComplete": a.onAnimationComplete,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play")
		})
	},
	startWildExplosion: function(a) {
		var b = this;
		b.model.setState("animating");
		b.view.start(a)
	},
	onAnimationComplete: function() {
		var a = this;
		a.model.setState("idle");
		a.fireEvent("notify:winningWildsExplosion.wildExplosionComplete")
	},
	abortWildExplosion: function() {
		var a = this;
		if (a.model.getState() === "animating") {
			a.view.stop()
		}
	}
};
Finn.WinningWildsExplosionController = Sys.extend(Core.Controller, Finn.WinningWildsExplosionController, "Finn.WinningWildsExplosionController");
Sys.ns("Finn");
Finn.WinningWildsExplosionModel = {
	constructor: function() {
		Finn.WinningWildsExplosionModel.superclass.constructor.apply(this, arguments)
	}
};
Finn.WinningWildsExplosionModel = Sys.extend(Core.Model, Finn.WinningWildsExplosionModel, "Finn.WinningWildsExplosionModel");
Sys.ns("Finn");
Finn.WinningWildsExplosionView = {
	WILD_WIN_OFFSET: {
		x: 132,
		y: -196
	},
	SOUND_WILD_EXPLODE: {
		name: "wildExplode",
		id: "wildExplode"
	},
	constructor: function() {
		Finn.WinningWildsExplosionView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.config = Resources.readData("config");
		a.reelLayout = a.config.reelGroups["default"].reelLayout;
		a.symbolWidths = a.reelLayout.standard.symbolWidths.standard;
		a.symbolHeights = a.reelLayout.standard.symbolHeights.standard;
		a.rootContainer = new PIXI.Container();
		a.rootContainer.name = "Finn.WinningWildsExplosionView";
		a.winningWildsContainer = new PIXI.Container();
		a.rootContainer.addChild(a.winningWildsContainer);
		var b = Game.stage.view.animationManager.getLayer("wildExplosions");
		b.addChild(a.rootContainer);
		a.wildAnimations = a.initWinAnimation(a.winningWildsContainer, "wildSymbol", "wild_EXPL_EXPORT", a.WILD_WIN_OFFSET)
	},
	initWinAnimation: function(a, h, f, c) {
		var g = this,
			j = [],
			b, d;
		var e = function() {
			Finn.AnimationUtils.initialize(this, f).onAnimationEnd(g, g.animationComplete)
		};
		for (d = 0; d < g.reelLayout.symbolPositions.length; d++) {
			b = Game.PIXIFactory.createAndAddSpineAnimation(h, a);
			b.position.x = c.x + g.reelLayout.symbolPositions[d].x * g.symbolWidths;
			b.position.y = c.y + g.reelLayout.symbolPositions[d].y * g.symbolHeights;
			b.fire = e.bind(b);
			b.visible = false;
			j.push(b)
		}
		return j
	},
	animationComplete: function() {
		var a = this;
		a.completedAnimations++;
		if (a.completedAnimations === a.numberOfAnimations) {
			a.stop()
		}
	},
	start: function(c) {
		var b = this,
			a = false;
		b.completedAnimations = 0;
		b.numberOfAnimations = c.length;
		Sys.each(c, function(d) {
			if (b.model.getState() === "animating") {
				b.wildAnimations[d.index].fire(false);
				a = true
			}
		});
		if (a) {
			b.fireEvent("view:playAudio", b.SOUND_WILD_EXPLODE)
		}
	},
	stop: function() {
		var a = this;
		Sys.each(a.wildAnimations, function(b) {
			b.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b)
		});
		a.fireEvent("view:animationComplete")
	}
};
Finn.WinningWildsExplosionView = Sys.extend(Core.View, Finn.WinningWildsExplosionView, "Finn.WinningWildsExplosionView");
Sys.ns("Finn");
Finn.CashFieldModel = {
	constructor: function() {
		Finn.CashFieldModel.superclass.constructor.apply(this, arguments)
	},
	checkAndSetState: function(a) {
		var b = this;
		if (Sys.isDefined(a.freeRoundsLeft)) {
			if (!b.isState("freerounds")) {
				b.setState("freerounds")
			}
		} else {
			if ((a.nextaction === "freespin" && a.clientaction !== "init") || a.nextaction === "bonusaction" && a.clientaction !== "init") {
				if (!b.isState("freespin")) {
					b.setState("freespin")
				}
			} else {
				if (a.clientaction === "init" && Sys.isDefined(a.freespin)) {
					if (!b.isState("freespinRestore")) {
						b.setState("freespinRestore")
					}
				} else {
					if ((a.nextaction === "respin" || a.nextaction === "drop") && a.clientaction !== "init") {
						if (!b.isState("respin")) {
							b.setState("respin")
						}
					} else {
						if (a.clientaction === "respin" && a.nextaction === "spin") {
							if (!b.isState("respinLast")) {
								b.setState("respinLast")
							}
						} else {
							if (a.clientaction === "init" && (a.nextaction === "respin" || a.nextaction === "drop") && !Sys.isDefined(a.freespins)) {
								if (!b.isState("respinRestore")) {
									b.setState("respinRestore")
								}
							} else {
								if (a.clientaction === "freespin" || (a.clientaction === "freespin") && a.nextaction === "spin") {
									if (!b.isState("freespinLast")) {
										b.setState("freespinLast")
									}
								} else {
									if (!b.isState("basic")) {
										b.setState("basic")
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
Finn.CashFieldModel = Sys.extend(Interface.CashFieldModel, Finn.CashFieldModel, "Finn.CashFieldModel");
Sys.ns("Finn");
Finn.ServerManagerModel = {
	constructor: function() {
		Finn.ServerManagerModel.superclass.constructor.apply(this, arguments)
	},
	getActionParameters: function(a) {
		var b = this.getBaseParameters(a);
		b = b + this.getFreeroundsParameters();
		switch (a) {
			case "init":
				return b + this.getInitParameters();
			case "jmxinit":
				return b + this.getJMXInitParameters();
			case "paytable":
				return b + this.getPaytableParameters();
			case "drop":
			case "spin":
				return b + this.getSpinParameters();
			case "initfreespin":
				return b + this.getInitFreespinParameters();
			case "respin":
			case "freespin":
				return b + this.getFreespinParameters();
			case "bonusaction":
				return b + this.getPickFreespinParameters();
			default:
				return b
		}
	},
	getPickFreespinParameters: function() {
		var a = "&bonusid=" + this.readData("parameter:bonusId") + "&bonusactiontype=" + this.readData("parameter:bonusActionType") + "&freespin.selected=" + this.readData("parameter:selectedMode");
		return a
	}
};
Finn.ServerManagerModel = Sys.extend(Core.Slots.ServerManagerModel, Finn.ServerManagerModel, "Finn.ServerManagerModel");
Sys.ns("Finn");
Finn.ServerManagerController = {
	constructor: function() {
		Finn.ServerManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Finn.ServerManagerController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"notify:responseParser.bonusActionResponseParsed": a.storeNextAction
		})
	}
};
Finn.ServerManagerController = Sys.extend(Core.Slots.ServerManagerController, Finn.ServerManagerController, "Finn.ServerManagerController");
Sys.ns("Finn");
Finn.ResponseParserController = {
	constructor: function() {
		Finn.ResponseParserController.superclass.constructor.apply(this, arguments)
	},
	parseReelInfo: function(a) {
		var e, b = [],
			c, d;
		e = a.rs.i0.r;
		if (a.gamestate.current === "basic" && !(Sys.isDefined(a.freespin) && a.nextaction === "spin")) {
			e = this.getRestoredReelInfo(a)
		}
		for (c = 0; Sys.isDefined(e["i" + c]); c++) {
			d = {
				hold: e["i" + c].hold,
				symbols: e["i" + c].syms,
				lastSymbols: [],
				overlaySymbols: [],
				afterFeatureSymbols: e["i" + c].syms
			};
			if (e["i" + c].lastsyms) {
				d.lastSymbols = e["i" + c].lastsyms
			}
			if (e["i" + c].overlay) {
				d.overlaySymbols = this.getOverlaySymbols(e["i" + c].overlay)
			}
			if (Sys.isDefined(a.rf) && e["i" + c].beforefeaturesyms) {
				a.rf.targets = this.parseRandomFeatureTargets(a, e["i" + c].beforefeaturesyms);
				d.symbols = e["i" + c].beforefeaturesyms
			}
			b.push(d)
		}
		this.fireEvent("notify:responseParserController.parsingReelInfo", a);
		return b
	},
	getRestoredReelInfo: function(a) {
		var b;
		for (b = 0; Sys.isDefined(a.rs["i" + b]); b++) {
			if (Sys.isDefined(a.current) && a.current.rs.i0 === a.rs["i" + b].id) {
				return a.rs["i" + b].r
			}
		}
		return a.rs.i0.r
	},
	parseRandomFeatureTargets: function(e, c) {
		var b = 0,
			d, a = [];
		while (e.rf["i" + b]) {
			d = e.rf["i" + b];
			d.pos[0] = parseInt(d.pos[0].replace("(", ""), 10);
			d.pos[1] = parseInt(d.pos[1].replace(")", ""), 10);
			d.from = c[d.pos[1]];
			a.push(d);
			b++
		}
		return a
	},
	sortWinSituations: function(b, a) {
		return false
	},
	parseServerResponse: function(c) {
		var a = this,
			b = Finn.ResponseParserController.superclass.parseServerResponse.call(a, c);
		if (Sys.isDefined(b.ws) && Sys.isDefined(b.totalwin.coins) && b.totalwin.coins > 0) {
			b.wins.winType = a.setWinType(b.totalwin.coins, Services.moneyManager.getBetCoins())
		}
		return b
	},
	setWinType: function(e, a) {
		var b = Resources.readData("config"),
			d = b.winTypes,
			c = "";
		if (e > 0) {
			if ((e >= a * d.smallWin.from) && (e < a * d.smallWin.to)) {
				c = "smallWin"
			} else {
				if ((e >= a * d.mediumWin.from) && (e < a * d.mediumWin.to)) {
					c = "mediumWin"
				} else {
					if ((e >= a * d.largeWin.from) && (e < a * d.largeWin.to)) {
						c = "largeWin"
					} else {
						if ((e >= a * d.bigWin.from) && (e < a * d.bigWin.to)) {
							c = "bigWin"
						} else {
							if ((e >= a * d.megaWin.from) && (e < a * d.megaWin.to)) {
								c = "megaWin"
							} else {
								if (e >= a * d.superMegaWin.from) {
									c = "superMegaWin"
								}
							}
						}
					}
				}
			}
		}
		return c
	},
	parseWinSituations: function(b, c) {
		var d = 0,
			a = [],
			e;
		if (b.ws) {
			while (b.ws["i" + d]) {
				a.push(b.ws["i" + d]);
				d++
			}
		}
		e = this.parseWinLayouts(a, c);
		this.doGameSpecificWinSituationParsing(e, a, c);
		return e
	},
	doGameSpecificWinSituationParsing: function(e, a, b) {
		var c = this,
			d = b[0].afterFeatureSymbols;
		for (i = 0; i < a.length; i++) {
			if (a[i].generatedwildpos) {
				e.winSituations[i].generatedWildPosition = {
					reelIndex: a[i].generatedwildpos[0],
					symbolIndex: a[i].generatedwildpos[1]
				}
			}
			c.addSymbolToWinningPositions(e.winSituations[i].positions, d);
			e.winSituations[i].sym = a[i].sym;
			if (a[i].wildexplosionpos) {
				e.winSituations[i].wildExplosions = c.getExplosions(a[i].wildexplosionpos, d)
			}
		}
	},
	addSymbolToWinningPositions: function(a, b) {
		Sys.each(a, function(c) {
			c.sym = b[c.symbolIndex]
		})
	},
	getExplosions: function(c, b) {
		var a = [];
		Sys.iterate(c, function(d, e) {
			a.push({
				reelIndex: e[0],
				symbolIndex: e[1],
				sym: b[e[1]]
			})
		});
		return a
	}
};
Finn.ResponseParserController = Sys.extend(Core.Slots.ResponseParserController, Finn.ResponseParserController, "Finn.ResponseParserController");
Sys.ns("Finn");
Finn.Background = {
	constructor: function() {
		Finn.Background.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "trigger"]
	}
};
Finn.Background = Sys.extend(Game.Background, Finn.Background, "Finn.Background");
Sys.ns("Finn");
Finn.BackgroundView = {
	DEFAULT_BACKGROUND: "background",
	DEFAULT_FOREGROUND: "foreground",
	DEFAULT_FOREGROUND_TOP_LEFT: new PIXI.Point(500, 970),
	DEFAULT_REEL: "reelBG",
	DEFAULT_REEL_TOP_LEFT: new PIXI.Point(655, 360),
	GROUP_LAYER_POSITION: {
		DEFAULT: {
			x: 640,
			y: 360
		},
		LANDSCAPE: {
			x: 640,
			y: 360
		},
		PORTRAIT: {
			x: 360,
			y: 640
		}
	},
	POLLEN_POSITION: {
		DEFAULT: new PIXI.Point(0, 0),
		LANDSCAPE: new PIXI.Point(0, 0),
		PORTRAIT: new PIXI.Point(-100, 400)
	},
	ANIMATED_BG_POSITION: {
		DEFAULT: new PIXI.Point(640, 353),
		LANDSCAPE: new PIXI.Point(640, 353),
		PORTRAIT: new PIXI.Point(810, 885)
	},
	FREESPIN_STYLES: {
		randomwilds: {
			background: "freespinBackground1",
			foreground: "freespinForeground1",
			foregroundTopLeft: new PIXI.Point(500, 970),
			reel: "freespinReelBackground",
			reelTopLeft: new PIXI.Point(647, 320)
		},
		destroy: {
			background: "freespinBackground2",
			foreground: "freespinForeground2",
			foregroundTopLeft: new PIXI.Point(500, 1030),
			reel: "freespinReelBackground",
			reelTopLeft: new PIXI.Point(647, 320)
		},
		symboloverlay: {
			background: "freespinBackground3",
			foreground: "freespinForeground3",
			foregroundTopLeft: new PIXI.Point(500, 970),
			reel: "freespinReelBackground",
			reelTopLeft: new PIXI.Point(647, 320)
		},
		symboltransform: {
			background: "freespinBackground4",
			foreground: "freespinForeground4",
			foregroundTopLeft: new PIXI.Point(444, 972),
			reel: "freespinReelBackground",
			reelTopLeft: new PIXI.Point(647, 320)
		}
	},
	EFFECT_INTENSITY_SUBTLE: "subtle",
	EFFECT_INTENSITY_NORMAL: "normal",
	EFFECT_INTENSITY_INTENSE: "intense",
	constructor: function() {
		Finn.BackgroundView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var e = this,
			b = Environment.getStageResolution(),
			a = new PIXI.Point(b.width * 0.5, b.height * 0.5),
			g = new PIXI.Point(0, 0);
		e.shakeInProgress = 0;
		e.centeringGroupLayers();
		e.rootContainer = new PIXI.Container();
		e.backgroundContainer = new PIXI.Container();
		e.backgroundContainer.pivot = new PIXI.Point(a.x, a.y);
		e.backgroundContainer.position = new PIXI.Point(a.x, a.y);
		e.backgroundSprite = Game.PIXIFactory.createAndAddSprite(Game.stage.getOrientationSpecificImage(e.DEFAULT_BACKGROUND), e.backgroundContainer, g, g);
		e.skyContainer = new PIXI.Container();
		e.rootContainer.addChild(e.backgroundContainer);
		e.reelBackground = e.createAndAddLayer(e.DEFAULT_REEL, e.DEFAULT_REEL_TOP_LEFT);
		var d = Game.stage.view.animationManager.getLayer("reelBackground");
		d.addChildAt(e.reelBackground.container, 0);
		e.reelBackgroundAnimation = e.initReelBackgroundAnimation(Game.stage.view.animationManager.getGroupLayer(1));
		e.foregroundSprite = e.createAndAddLayer(Game.stage.getOrientationSpecificImage(e.DEFAULT_FOREGROUND), e.DEFAULT_FOREGROUND_TOP_LEFT);
		e.foregroundSprite.visible = false;
		var f = Game.stage.view.animationManager.getLayer("foreground");
		f.addChildAt(e.foregroundSprite.container, 0);
		e.createAndAddAnimationsAndImages();
		e.rootContainer.addChild(e.skyContainer);
		e.setMainGameBackground();
		var c = Game.stage.view.animationManager.getLayer("background");
		c.addChild(e.rootContainer);
		e.rootContainer.visible = true;
		e.createAndEnableAnimations();
		e.refresh()
	},
	centeringGroupLayers: function() {
		var a = this;
		Game.stage.view.animationManager.getGroupLayer(0).position = Environment.getOrientationSpecificConfig(a.GROUP_LAYER_POSITION, true);
		Game.stage.view.animationManager.getGroupLayer(0).pivot = Environment.getOrientationSpecificConfig(a.GROUP_LAYER_POSITION, true)
	},
	createAndAddAnimationsAndImages: function() {
		var c = this,
			f = new PIXI.Point(0, 0);
		c.cloudsBackground = Game.PIXIFactory.createAndAddSpineAnimation("movingCloud", c.skyContainer, new PIXI.Point(0, 0), new PIXI.Point(0.5, 0.5));
		c.skyContainer.addChild(c.cloudsBackground);
		c.tree = Game.PIXIFactory.createAndAddSprite("tree", c.skyContainer, new PIXI.Point(1140, 350), new PIXI.Point(0.5, 0.5));
		c.skyContainer.addChild(c.tree);
		c.tree.visible = false;
		c.animatedTree = Game.PIXIFactory.createAndAddSpineAnimation("animatedTree", c.skyContainer, Environment.getOrientationSpecificConfig(c.ANIMATED_BG_POSITION, true), f);
		c.skyContainer.addChild(c.animatedTree);
		c.foregroundContainer = new PIXI.Container();
		c.branchAndGrass = Game.PIXIFactory.createAndAddSprite("branchAndGrass", c.foregroundContainer);
		c.branchAndGrass.visible = false;
		c.animatedEnvironment = Game.PIXIFactory.createAndAddSpineAnimation("animatedEnvironment", c.foregroundContainer, Environment.getOrientationSpecificConfig(c.ANIMATED_BG_POSITION, true), f);
		var e = Game.stage.view.animationManager.getLayer("mainGameAnimation");
		e.addChild(c.animatedEnvironment);
		e.addChild(c.branchAndGrass);
		c.water = Game.PIXIFactory.createAndAddSpineAnimation("water", c.foregroundContainer, new PIXI.Point(493, 800), new PIXI.Point(0.5, 0.5));
		var b = Game.stage.view.animationManager.getLayer("foreground");
		b.addChild(c.water);
		c.water.pivot.x = 493;
		c.water.pivot.y = 800;
		c.pollen = Game.PIXIFactory.createAndAddSpineAnimation("pollen", c.foregroundContainer, Environment.getOrientationSpecificConfig(c.POLLEN_POSITION, true), new PIXI.Point(0.5, 0.5));
		e.addChild(c.pollen);
		c.logoContainer = new PIXI.Container();
		c.logoAnimation = Game.PIXIFactory.createAndAddSpineAnimation("logoAnimation", c.logoContainer, new PIXI.Point(16, 7), new PIXI.Point(0.5, 0.5));
		c.logoAnimation.fire = function() {
			c.logoAnimation.state.setAnimation(0, "animation", true);
			c.logoAnimation.visible = true
		};
		c.logoAnimation.alpha = 0;
		var a = Game.stage.view.animationManager.getLayer("logo");
		a.addChild(c.logoContainer);
		c.starbarFsAnimation = Game.PIXIFactory.createAndAddSpineAnimation("starbarFsAnimation", c.backgroundContainer, f, f);
		c.starbarFsAnimation.visible = false;
		c.rootContainer.addChild(c.starbarFsAnimation);
		c.lavaLairFsAnimation = Game.PIXIFactory.createAndAddSpineAnimation("lavaLairFsAnimation", c.backgroundContainer, f, f);
		c.lavaLairFsAnimation.visible = false;
		c.rootContainer.addChild(c.lavaLairFsAnimation);
		c.luckyMugFsAnimation = Game.PIXIFactory.createAndAddSpineAnimation("luckyMugFsAnimation", c.backgroundContainer, f, f);
		c.luckyMugFsAnimation.visible = false;
		c.rootContainer.addChild(c.luckyMugFsAnimation);
		c.goldenPotFsAnimation = Game.PIXIFactory.createAndAddSpineAnimation("goldenPotFsAnimation", c.backgroundContainer, f, f);
		c.goldenPotFsAnimation.visible = false;
		c.rootContainer.addChild(c.goldenPotFsAnimation);
		c.starbarFsAnimationPortraitForeground = Game.PIXIFactory.createAndAddSpineAnimation("starbarFsAnimation", c.foregroundSprite.container, f, f);
		c.starbarFsAnimationPortraitForeground.visible = false;
		var d = Game.stage.view.animationManager.getLayer("foreground");
		d.addChild(c.starbarFsAnimationPortraitForeground);
		c.luckyMugFsAnimationPortraitForeground = Game.PIXIFactory.createAndAddSpineAnimation("luckyMugFsAnimation", c.foregroundSprite.container, f, f);
		c.luckyMugFsAnimationPortraitForeground.visible = false;
		d.addChild(c.luckyMugFsAnimationPortraitForeground)
	},
	createAndEnableAnimations: function() {
		var a = this;
		if (a.model.readData(("inMainGame"))) {
			a.createMainGameBackgroundAnimations();
			a.startAnimatedEnvironment(true)
		} else {
			a.createFreeSpinsBackgroundAnimations();
			a.fireFreespinBackgroundAnimation();
			a.startAnimatedEnvironment(false)
		}
	},
	startAnimatedEnvironment: function(a) {
		var b = this;
		b.resetAnimation(b.cloudsBackground);
		b.resetAnimation(b.animatedEnvironment);
		b.resetAnimation(b.animatedTree);
		b.resetAnimation(b.pollen);
		b.resetAnimation(b.water);
		b.resetAnimation(b.logoAnimation);
		b.logoAnimation.fire();
		b.showLogoAnimation();
		if (a) {
			b.cloudsBackground.fire();
			b.animatedEnvironment.fire("idle", true);
			b.animatedTree.fire("idle", true);
			b.pollen.fire();
			b.water.fire();
			b.showWater();
			b.foregroundSprite.visible = false
		} else {
			b.tree.visible = false;
			b.branchAndGrass.visible = false;
			b.foregroundSprite.visible = true
		}
		b.showAsset = a
	},
	createMainGameBackgroundAnimations: function() {
		var a = this;
		a.cloudsBackground.fire = function() {
			a.cloudsBackground.state.setAnimation(0, "animation", true);
			a.cloudsBackground.visible = true
		};
		a.animatedTree.fire = function(c, b) {
			if (!(Platform.isIEBrowser || Platform.isEdgeBrowser)) {
				a.animatedTree.state.setAnimation(0, c, b);
				a.animatedTree.visible = true
			}
		};
		a.animatedEnvironment.fire = function(c, b) {
			if (Platform.isIEBrowser || Platform.isEdgeBrowser) {
				a.tree.visible = true;
				a.branchAndGrass.visible = true
			} else {
				a.animatedEnvironment.state.setAnimation(0, c, b);
				a.animatedEnvironment.visible = true;
				a.animatedEnvironment.state.addListener({
					complete: function() {
						a.animatedEnvironment.state.clearListeners();
						a.setBackgroundAnimation("idle", true)
					}
				});
				a.animatedEnvironment.updateTransform()
			}
		};
		a.water.fire = function() {
			a.water.state.setAnimation(0, "animation", true);
			a.water.visible = true
		};
		a.pollen.fire = function() {
			a.pollen.state.setAnimation(0, "animation", true);
			a.pollen.visible = true
		}
	},
	createFreeSpinsBackgroundAnimations: function() {
		var a = this;
		a.starbarFsAnimation.fire = function(b) {
			a.starbarFsAnimation.state.setAnimation(0, b, true);
			a.starbarFsAnimation.visible = true
		};
		a.lavaLairFsAnimation.fire = function(b) {
			a.lavaLairFsAnimation.state.setAnimation(0, b, true);
			a.lavaLairFsAnimation.visible = true
		};
		a.luckyMugFsAnimation.fire = function(b) {
			a.luckyMugFsAnimation.state.setAnimation(0, b, true);
			a.luckyMugFsAnimation.visible = true
		};
		a.goldenPotFsAnimation.fire = function(b) {
			a.goldenPotFsAnimation.state.setAnimation(0, b, true);
			a.goldenPotFsAnimation.visible = true
		};
		a.starbarFsAnimationPortraitForeground.fire = function() {
			a.starbarFsAnimationPortraitForeground.state.setAnimation(0, "StarbarFSAnimationForeground", true);
			a.starbarFsAnimationPortraitForeground.visible = true
		};
		a.luckyMugFsAnimationPortraitForeground.fire = function() {
			a.luckyMugFsAnimationPortraitForeground.state.setAnimation(0, "LuckyMugPortraitAnimationForeground", true);
			a.luckyMugFsAnimationPortraitForeground.visible = true
		}
	},
	showWater: function() {
		var a = this;
		if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
			a.water.visible = true
		} else {
			a.water.visible = false
		}
	},
	doShakingFor: function(d, h) {
		var b = Resources.readData("config").winTypes,
			c = (b.smallWin.to / 2),
			f = b.smallWin.to,
			e = b.mediumWin.to,
			g = (h ? this.doShakeOnAll : this.doShakeOnReels).bind(this),
			a;
		if (d >= e) {
			a = this.EFFECT_INTENSITY_INTENSE
		} else {
			if (d >= f) {
				a = this.EFFECT_INTENSITY_NORMAL
			} else {
				if (d >= c) {
					a = this.EFFECT_INTENSITY_SUBTLE
				}
			}
		}
		g(a)
	},
	doWinEffects: function(c, e, a, d) {
		var b = d / a;
		this.doShakingFor(b, e)
	},
	doShakeOnReels: function(b) {
		var c = this,
			a = Game.stage.view.animationManager.getGroupLayer(1),
			d;
		a.position = Environment.getOrientationSpecificConfig(c.GROUP_LAYER_POSITION, true);
		a.pivot = Environment.getOrientationSpecificConfig(c.GROUP_LAYER_POSITION, true);
		a.updateTransform();
		switch (b) {
			case this.EFFECT_INTENSITY_SUBTLE:
				d = this.getSubtleShakeAnimation(a, true);
				break;
			case this.EFFECT_INTENSITY_NORMAL:
				d = this.getNormalShakeAnimation(a, true);
				break;
			case this.EFFECT_INTENSITY_INTENSE:
				d = this.getIntenseShakeAnimation(a, true);
				break;
			default:
				d = {
					play: function() {}
				};
				break
		}
		d.play()
	},
	doShakeOnAll: function(a) {
		switch (a) {
			case this.EFFECT_INTENSITY_INTENSE:
				this.doIntenseShakeOnAll();
				break;
			case this.EFFECT_INTENSITY_NORMAL:
				this.doNormalShakeOnAll();
				break;
			case this.EFFECT_INTENSITY_SUBTLE:
				this.doShakeOnReels(this.EFFECT_INTENSITY_SUBTLE);
				break
		}
	},
	doNormalShakeOnAll: function() {
		if (!this.normalShakeAllAnimCache) {
			this.normalShakeAllAnimCache = [this.getNormalShakeAnimation(this.pollen), this.getNormalShakeAnimation(this.animatedEnvironment), this.getNormalShakeAnimation(this.animatedTree), this.getNormalShakeAnimation(this.water)]
		}
		this.delayAndTriggerBackgroundShakingAnimation();
		this.doShakeOnReels(this.EFFECT_INTENSITY_NORMAL);
		this.normalShakeAllAnimCache.forEach(function(a) {
			a.play()
		})
	},
	doIntenseShakeOnAll: function() {
		if (!this.intenseShakeAllAnimCache) {
			this.intenseShakeAllAnimCache = [this.getNormalShakingBackground(Game.stage.view.animationManager.getGroupLayer(0)), this.getIntenseShakeAnimation(this.skyContainer), this.getIntenseShakeAnimation(this.pollen), this.getIntenseShakeAnimation(this.foregroundContainer), this.getIntenseShakeAnimation(this.animatedTree)]
		}
		this.doShakeOnReels(this.EFFECT_INTENSITY_INTENSE);
		this.delayAndTriggerBackgroundShakingAnimation();
		this.intenseShakeAllAnimCache.forEach(function(a) {
			a.play()
		})
	},
	delayAndTriggerBackgroundShakingAnimation: function() {
		var a = this;
		a.animationTimeout = setTimeout(function() {
			a.setBackgroundAnimation("bigWin", false)
		}, 440)
	},
	setBackgroundAnimation: function(b, a) {
		var c = this;
		c.resetAnimation(c.animatedEnvironment);
		c.animatedEnvironment.fire(b, a);
		c.resetAnimation(c.animatedTree);
		c.animatedTree.fire(b, a);
		clearTimeout(c.animationTimeout)
	},
	getOnStartFunction: function(a) {
		var b = this;
		if (a) {
			return function() {
				b.shakeInProgress++;
				Game.stage.view.animationManager.getGroupLayer(1).position = Environment.getOrientationSpecificConfig(b.GROUP_LAYER_POSITION, true);
				Game.stage.view.animationManager.getGroupLayer(1).pivot = Environment.getOrientationSpecificConfig(b.GROUP_LAYER_POSITION, true);
				Game.stage.view.animationManager.getGroupLayer(1).updateTransform()
			}
		}
		return function() {}
	},
	setReelPivotTopLeft: function() {
		Game.stage.view.animationManager.getGroupLayer(1).position = new PIXI.Point(0, 0);
		Game.stage.view.animationManager.getGroupLayer(1).pivot = new PIXI.Point(0, 0);
		Game.stage.view.animationManager.getGroupLayer(1).updateTransform()
	},
	getOnEndFunction: function(a) {
		var b = this;
		if (a) {
			return function() {
				b.shakeInProgress--;
				if (b.shakeInProgress <= 0) {
					b.setReelPivotTopLeft()
				}
			}
		}
		return function() {}
	},
	getSubtleShakeAnimation: function(c, a) {
		var b = this,
			f;
		if (!c || !c._boundsID) {
			return
		}
		f = c._boundsID;
		if (!this.subtleShakeAnimations) {
			this.subtleShakeAnimations = {}
		}
		if (!this.subtleShakeAnimations[f]) {
			var d = {
				prop: "rotation",
				animate: {
					400: 0,
					440: 0.03,
					480: 0,
					520: 0.03,
					560: -0.07,
					600: 0.08,
					640: -0.03,
					680: 0.03,
					720: -0.01,
					760: 0
				}
			};
			var e = {
				prop: "scale",
				animate: [{
					time: 400,
					value: {
						x: 1,
						y: 1
					}
				}, {
					time: 440,
					value: {
						x: 1.003,
						y: 1.003
					}
				}, {
					time: 600,
					value: {
						x: 1.006,
						y: 1.006
					}
				}, {
					time: 700,
					value: {
						x: 1.009,
						y: 1.009
					}
				}, {
					time: 800,
					value: {
						x: 1,
						y: 1
					}
				}]
			};
			this.subtleShakeAnimations[f] = new Animation.Holder({
				id: "symbolsSmallShakingAnimation",
				delay: 0,
				onStart: b.getOnStartFunction(a),
				onEnd: b.getOnEndFunction(a),
				target: c,
				children: [d, e]
			});
			Game.stage.view.animationManager.addToAnimationLoop(this.subtleShakeAnimations[f])
		}
		return this.subtleShakeAnimations[f]
	},
	getNormalShakingBackground: function(a) {
		var d;
		if (!a || !a._boundsID) {
			return
		}
		d = a._boundsID;
		if (!this.shakingBackgroundAnims) {
			this.shakingBackgroundAnims = {}
		}
		if (!this.shakingBackgroundAnims[d]) {
			var b = {
				prop: "rotation",
				animate: {
					400: 0,
					440: 0.08,
					480: 0,
					520: 0.08,
					560: -0.16,
					600: 0.11,
					640: -0.08,
					680: 0.08,
					720: -0.03,
					760: 0
				}
			};
			var c = {
				prop: "scale",
				animate: [{
					time: 400,
					value: {
						x: 1,
						y: 1
					}
				}, {
					time: 440,
					value: {
						x: 1.1,
						y: 1.1
					}
				}, {
					time: 600,
					value: {
						x: 1.3,
						y: 1.3
					}
				}, {
					time: 700,
					value: {
						x: 1.2,
						y: 1.2
					}
				}, {
					time: 800,
					value: {
						x: 1,
						y: 1
					}
				}]
			};
			this.shakingBackgroundAnims[d] = new Animation.Holder({
				id: "backgroundShakingAnimation",
				delay: 0,
				target: a,
				children: [b, c]
			});
			Game.stage.view.animationManager.addToAnimationLoop(this.shakingBackgroundAnims[d])
		}
		return this.shakingBackgroundAnims[d]
	},
	getSubtleShakingBackground: function(a) {
		var d;
		if (!a || !a._boundsID) {
			return
		}
		d = a._boundsID;
		if (!this.subtleShakeBGAnimsCache) {
			this.subtleShakeBGAnimsCache = {}
		}
		if (!this.subtleShakeBGAnimsCache[d]) {
			var b = {
				prop: "rotation",
				animate: {
					400: 0,
					440: 0.06,
					480: 0,
					520: 0.06,
					560: -0.14,
					600: 0.1,
					640: -0.06,
					680: 0.06,
					720: -0.02,
					760: 0
				}
			};
			var c = {
				prop: "scale",
				animate: [{
					time: 400,
					value: {
						x: 1,
						y: 1
					}
				}, {
					time: 440,
					value: {
						x: 1.05,
						y: 1.05
					}
				}, {
					time: 600,
					value: {
						x: 1.2,
						y: 1.2
					}
				}, {
					time: 700,
					value: {
						x: 1.1,
						y: 1.1
					}
				}, {
					time: 800,
					value: {
						x: 1,
						y: 1
					}
				}]
			};
			this.subtleShakeBGAnimsCache[d] = new Animation.Holder({
				id: "backgroundSmallShakingAnimation",
				delay: 0,
				target: a,
				children: [b, c]
			});
			Game.stage.view.animationManager.addToAnimationLoop(this.subtleShakeBGAnimsCache[d])
		}
		return this.subtleShakeBGAnimsCache[d]
	},
	getNormalShakeAnimation: function(c, a) {
		var b = this,
			f;
		if (!c || !c._boundsID) {
			return
		}
		f = c._boundsID;
		if (!this.normalShakeAnimCache) {
			this.normalShakeAnimCache = {}
		}
		if (!this.normalShakeAnimCache[f]) {
			var d = {
				prop: "rotation",
				animate: {
					400: 0,
					440: 0.08,
					480: 0,
					520: 0.08,
					560: -0.16,
					600: 0.11,
					640: -0.08,
					680: 0.08,
					720: -0.03,
					760: 0
				}
			};
			var e = {
				prop: "scale",
				animate: [{
					time: 400,
					value: {
						x: 1,
						y: 1
					}
				}, {
					time: 440,
					value: {
						x: 1.01,
						y: 1.01
					}
				}, {
					time: 600,
					value: {
						x: 1.012,
						y: 1.012
					}
				}, {
					time: 700,
					value: {
						x: 1.02,
						y: 1.02
					}
				}, {
					time: 800,
					value: {
						x: 1,
						y: 1
					}
				}]
			};
			this.normalShakeAnimCache[f] = new Animation.Holder({
				id: "reelShakingAnimation",
				delay: 0,
				target: c,
				onStart: b.getOnStartFunction(a),
				onEnd: b.getOnEndFunction(a),
				children: [d, e]
			});
			Game.stage.view.animationManager.addToAnimationLoop(this.normalShakeAnimCache[f])
		}
		return this.normalShakeAnimCache[f]
	},
	getIntenseShakeAnimation: function(c, a) {
		var b = this,
			f;
		if (!c || !c._boundsID) {
			return
		}
		f = c._boundsID;
		if (!this.intenseShakeAnimsCache) {
			this.intenseShakeAnimsCache = {}
		}
		if (!this.intenseShakeAnimsCache[f]) {
			var d = {
				prop: "rotation",
				animate: {
					400: 0,
					440: 0.1,
					480: 0,
					520: 0.1,
					560: -0.18,
					600: 0.13,
					640: -0.1,
					680: 0.1,
					720: -0.05,
					760: 0
				}
			};
			var e = {
				prop: "scale",
				animate: [{
					time: 400,
					value: {
						x: 1,
						y: 1
					}
				}, {
					time: 440,
					value: {
						x: 1.02,
						y: 1.02
					}
				}, {
					time: 600,
					value: {
						x: 1.016,
						y: 1.016
					}
				}, {
					time: 700,
					value: {
						x: 1.03,
						y: 1.03
					}
				}, {
					time: 800,
					value: {
						x: 1,
						y: 1
					}
				}]
			};
			this.intenseShakeAnimsCache[f] = new Animation.Holder({
				id: "reelShakingAnimationMegaWin",
				delay: 0,
				target: c,
				onStart: b.getOnStartFunction(a),
				onEnd: b.getOnEndFunction(a),
				children: [d, e]
			});
			Game.stage.view.animationManager.addToAnimationLoop(this.intenseShakeAnimsCache[f])
		}
		return this.intenseShakeAnimsCache[f]
	},
	resetAnimation: function(a) {
		a.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a)
	},
	moveLogoAnimation: function(b, a, d) {
		var c = this;
		if (c.logoAnimation) {
			c.logoAnimation.position.x = b;
			c.logoAnimation.position.y = a;
			c.logoAnimation.scale.x = d;
			c.logoAnimation.scale.y = d
		}
	},
	showLogoAnimation: function() {
		var a = this;
		if (Services.orientation.isPortrait()) {
			a.logoAnimation.visible = false
		} else {
			a.logoAnimation.visible = true
		}
	},
	initReelBackgroundAnimation: function(c) {
		var b = this,
			a;
		a = new Animation.Holder({
			id: "reelBackgroundAnimation",
			target: c,
			prop: "position",
			delay: 0,
			onStart: function() {
				b.setReelPivotTopLeft()
			},
			onEnd: function() {
				b.fireEvent("view:freeSpinIntroduced")
			},
			animate: [{
				time: 0,
				value: {
					x: 0,
					y: -1000
				}
			}, {
				time: 500,
				value: {
					x: 0,
					y: -1000
				},
				ease: Animation.utils.powerTwoOut
			}, {
				time: 1500,
				value: {
					x: 0,
					y: 0
				}
			}, {
				time: 2000,
				value: {
					x: 0,
					y: 0
				}
			}]
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	createAndAddLayer: function(c, d) {
		var e = this,
			a = new PIXI.Container(),
			f = new PIXI.Point(-7, 210),
			b;
		b = Game.PIXIFactory.createAndAddSprite(c, a, f, new PIXI.Point(0.5, 0.8));
		a.position = d;
		return {
			container: a,
			sprite: b
		}
	},
	setMainGameBackground: function() {
		var a = this;
		a.createFreeSpinsBackgroundAnimations();
		a.refresh()
	},
	setFreespinBackground: function() {
		var a = this;
		a.reelBackgroundAnimation.play();
		a.createFreeSpinsBackgroundAnimations();
		a.refresh()
	},
	stopFsBackgroundAnimation: function() {
		var a = this;
		a.resetAnimation(a.starbarFsAnimation);
		a.resetAnimation(a.starbarFsAnimationPortraitForeground);
		a.resetAnimation(a.lavaLairFsAnimation);
		a.resetAnimation(a.luckyMugFsAnimation);
		a.resetAnimation(a.luckyMugFsAnimationPortraitForeground);
		a.resetAnimation(a.goldenPotFsAnimation)
	},
	freeSpinsBackgroundAnimation: function() {
		var c = this,
			a = c.model.readData("gameState"),
			b;
		if (a === "randomwilds") {
			if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
				b = "StarbarFSAnimationPortraitBackground"
			} else {
				b = "StarbarFSAnimation"
			}
		} else {
			if (a === "destroy") {
				if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
					b = "LavaLairBackgroundPortrait"
				} else {
					b = "LavaLairBackgroundDesktop"
				}
			} else {
				if (a === "symboloverlay") {
					if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
						b = "LuckyMugPortraitAnimationBackground"
					} else {
						b = "LuckyMugBacgkroundAnimation"
					}
				} else {
					if (a === "symboltransform") {
						if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
							b = "GoldenPotBackgroundAnimationPortrait"
						} else {
							b = "GoldenPotBackgroundAnimation"
						}
					}
				}
			}
		}
		return b
	},
	fireFreespinBackgroundAnimation: function() {
		var c = this,
			a = c.model.readData("gameState"),
			b = c.freeSpinsBackgroundAnimation();
		if (a === "randomwilds") {
			c.resetAnimation(c.starbarFsAnimation);
			c.starbarFsAnimation.fire(b);
			c.resetAnimation(c.starbarFsAnimationPortraitForeground);
			if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
				c.starbarFsAnimationPortraitForeground.fire()
			}
		} else {
			if (a === "destroy") {
				c.lavaLairFsAnimation.visible = false;
				Game.PIXIUtils.resetSpineAnimation(c.lavaLairFsAnimation);
				c.lavaLairFsAnimation.fire(b)
			} else {
				if (a === "symboloverlay") {
					c.luckyMugFsAnimation.visible = false;
					Game.PIXIUtils.resetSpineAnimation(c.luckyMugFsAnimation);
					c.luckyMugFsAnimation.fire(b);
					c.resetAnimation(c.luckyMugFsAnimationPortraitForeground);
					if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
						c.luckyMugFsAnimationPortraitForeground.fire()
					}
				} else {
					if (a === "symboltransform") {
						c.goldenPotFsAnimation.visible = false;
						Game.PIXIUtils.resetSpineAnimation(c.goldenPotFsAnimation);
						c.goldenPotFsAnimation.fire(b)
					}
				}
			}
		}
	},
	refresh: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.centeringGroupLayers();
		if (a === "randomwilds" || a === "destroy" || a === "symboloverlay" || a === "symboltransform") {
			b.backgroundSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FREESPIN_STYLES[a].background)];
			b.reelBackground.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FREESPIN_STYLES[a].reel)];
			b.reelBackground.container.position = b.FREESPIN_STYLES[a].reelTopLeft;
			b.foregroundSprite.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FREESPIN_STYLES[a].foreground)];
			b.foregroundSprite.container.position = b.FREESPIN_STYLES[a].foregroundTopLeft;
			b.fireFreespinBackgroundAnimation();
			b.startAnimatedEnvironment(false)
		} else {
			b.backgroundSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.DEFAULT_BACKGROUND)];
			b.reelBackground.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.DEFAULT_REEL)];
			b.reelBackground.container.position = b.DEFAULT_REEL_TOP_LEFT;
			b.foregroundSprite.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.DEFAULT_FOREGROUND)];
			b.foregroundSprite.container.position = b.DEFAULT_FOREGROUND_TOP_LEFT;
			b.pollen.position = Environment.getOrientationSpecificConfig(b.POLLEN_POSITION, true);
			b.animatedEnvironment.position = Environment.getOrientationSpecificConfig(b.ANIMATED_BG_POSITION, true);
			b.animatedTree.position = Environment.getOrientationSpecificConfig(b.ANIMATED_BG_POSITION, true);
			b.showWater();
			b.stopFsBackgroundAnimation()
		}
		b.showLogoAnimation()
	}
};
Finn.BackgroundView = Sys.extend(Game.BackgroundView, Finn.BackgroundView, "Finn.BackgroundView");
Sys.ns("Finn");
Finn.BackgroundViewLow = {
	STARBAR_MENU_POSITION: {
		DEFAULT: {
			x: 1068,
			y: 428
		},
		LANDSCAPE: {
			x: 1068,
			y: 428
		},
		PORTRAIT: {
			x: 628,
			y: 962
		}
	},
	STARBAR_STAR_POSITION: {
		DEFAULT: {
			x: 1080,
			y: 90
		},
		LANDSCAPE: {
			x: 1080,
			y: 90
		},
		PORTRAIT: {
			x: 750,
			y: 90
		}
	},
	LUCKYMUG_FLAME_POSITION: {
		DEFAULT: {
			x: 40,
			y: 340
		},
		LANDSCAPE: {
			x: 40,
			y: 340
		},
		PORTRAIT: {
			x: 190,
			y: 865
		}
	},
	LUCKYMUG_FOAM_POSITION: {
		DEFAULT: {
			x: 175,
			y: 235
		},
		LANDSCAPE: {
			x: 175,
			y: 235
		},
		PORTRAIT: {
			x: 735,
			y: 1060
		}
	},
	constructor: function() {
		Finn.BackgroundView.superclass.constructor.apply(this, arguments)
	},
	createAndAddAnimationsAndImages: function() {
		var a = this;
		a.shakeInProgress = 0;
		a.smallClouds = Game.PIXIFactory.createAndAddSprite("smallClouds", a.skyContainer, new PIXI.Point(555, 335), new PIXI.Point(0.5, 0.5));
		a.skyContainer.addChild(a.smallClouds);
		a.tree = Game.PIXIFactory.createAndAddSprite("tree", a.backgroundContainer, new PIXI.Point(1140, 350), new PIXI.Point(0.5, 0.5));
		a.backgroundContainer.addChild(a.tree);
		a.starbarMenu = Game.PIXIFactory.createAndAddSprite("starbarMenu", a.foregroundSprite.container, Environment.getOrientationSpecificConfig(a.STARBAR_MENU_POSITION, true), new PIXI.Point(0.5, 0.5));
		a.starbarMenu.visible = false;
		var b = Game.stage.view.animationManager.getLayer("foreground");
		b.addChild(a.starbarMenu);
		a.starbarStar = Game.PIXIFactory.createAndAddSprite("starbarStar", a.backgroundContainer, Environment.getOrientationSpecificConfig(a.STARBAR_STAR_POSITION, true), new PIXI.Point(0.5, 0.5));
		a.starbarStar.visible = false;
		a.rootContainer.addChild(a.starbarStar);
		a.luckymugFlame = Game.PIXIFactory.createAndAddSprite("luckymugFlame", a.foregroundSprite.container, Environment.getOrientationSpecificConfig(a.LUCKYMUG_FLAME_POSITION, true), new PIXI.Point(0.5, 0.5));
		a.luckymugFlame.visible = false;
		b.addChild(a.luckymugFlame);
		a.luckymugFoam = Game.PIXIFactory.createAndAddSprite("luckymugFoam", a.foregroundSprite.container, Environment.getOrientationSpecificConfig(a.LUCKYMUG_FOAM_POSITION, true), new PIXI.Point(0.5, 0.5));
		a.luckymugFoam.visible = false;
		b.addChild(a.luckymugFoam);
		a.branchContainer = new PIXI.Container();
		a.branchAndGrass = Game.PIXIFactory.createAndAddSprite("branchAndGrass", a.branchContainer);
		var c = Game.stage.view.animationManager.getLayer("mainGameAnimation");
		c.addChild(a.branchContainer)
	},
	createAndEnableAnimations: function() {
		var a = this;
		if (a.model.readData(("inMainGame"))) {
			a.startAnimatedEnvironment(true)
		} else {
			a.startAnimatedEnvironment(false)
		}
	},
	createMainGameBackgroundAnimations: function() {},
	createFreeSpinsBackgroundAnimations: function() {},
	startAnimatedEnvironment: function(a) {
		var b = this;
		if (a) {
			b.smallClouds.visible = true;
			b.tree.visible = true
		} else {
			b.smallClouds.visible = false;
			b.tree.visible = false;
			b.fireFreespinBackgroundAnimation()
		}
	},
	doIntenseShakeOnAll: function() {
		var a = this;
		a.getIntenseShakeAnimation(Game.stage.view.animationManager.getGroupLayer(0)).play();
		a.getIntenseShakeAnimation(Game.stage.view.animationManager.getGroupLayer(1)).play();
		a.getIntenseShakeAnimation(a.skyContainer).play();
		a.getIntenseShakeAnimation(a.foregroundSprite.container).play()
	},
	disablingImagesOnShakingAnimation: function() {
		var a = this;
		clearTimeout(a.animationTimeout);
		if (!(Services.orientation.isPortrait() && Platform.isMobileDevice)) {
			a.animationTimeout = setTimeout(function() {
				a.stopFsBackgroundAnimation()
			}, 440);
			a.animationTimeout = setTimeout(function() {
				a.fireFreespinBackgroundAnimation()
			}, 800)
		}
	},
	setMainGameBackground: function() {
		var b = this,
			a = b.model.readData("gameState");
		if (a === "randomwilds" || a === "destroy" || a === "symboloverlay" || a === "symboloverlay") {
			b.fireFreespinBackgroundAnimation()
		}
		b.refresh()
	},
	setBackgroundAnimation: function() {
		me.animatedEnvironment = null
	},
	setFreespinBackground: function() {
		var a = this;
		a.fireFreespinBackgroundAnimation();
		a.reelBackgroundAnimation.play();
		a.refresh()
	},
	stopFsBackgroundAnimation: function() {
		var a = this;
		a.starbarMenu.visible = false;
		a.starbarStar.visible = false;
		a.luckymugFlame.visible = false;
		a.luckymugFoam.visible = false
	},
	fireFreespinBackgroundAnimation: function() {
		var b = this,
			a = b.model.readData("gameState");
		if (a === "randomwilds") {
			b.starbarMenu.visible = true;
			b.starbarStar.visible = true;
			if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
				b.starbarMenu.scale.x = 1.32;
				b.starbarMenu.scale.y = 1.32
			} else {
				b.starbarMenu.scale.x = 1;
				b.starbarMenu.scale.y = 1
			}
		} else {
			if (a === "symboloverlay") {
				b.luckymugFlame.visible = true;
				b.luckymugFoam.visible = true;
				if (Services.orientation.isPortrait() && Platform.isMobileDevice) {
					b.luckymugFlame.scale.x = 1.33;
					b.luckymugFlame.scale.y = 1.33;
					b.luckymugFoam.scale.x = 1;
					b.luckymugFoam.scale.y = 1
				} else {
					b.luckymugFlame.scale.x = 1;
					b.luckymugFlame.scale.y = 1;
					b.luckymugFoam.scale.x = 0.5;
					b.luckymugFoam.scale.y = 0.5
				}
			}
		}
	},
	refresh: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.centeringGroupLayers();
		if (a === "randomwilds" || a === "destroy" || a === "symboloverlay" || a === "symboltransform") {
			b.branchContainer.visible = false;
			b.backgroundSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FREESPIN_STYLES[a].background)];
			b.reelBackground.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FREESPIN_STYLES[a].reel)];
			b.reelBackground.container.position = b.FREESPIN_STYLES[a].reelTopLeft;
			b.foregroundSprite.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FREESPIN_STYLES[a].foreground)];
			b.foregroundSprite.position = b.FREESPIN_STYLES[a].foregroundTopLeft;
			b.starbarMenu.position = Environment.getOrientationSpecificConfig(b.STARBAR_MENU_POSITION, true);
			b.starbarStar.position = Environment.getOrientationSpecificConfig(b.STARBAR_STAR_POSITION, true);
			b.luckymugFlame.position = Environment.getOrientationSpecificConfig(b.LUCKYMUG_FLAME_POSITION, true);
			b.luckymugFoam.position = Environment.getOrientationSpecificConfig(b.LUCKYMUG_FOAM_POSITION, true);
			b.fireFreespinBackgroundAnimation()
		} else {
			if (Services.orientation.isLandscape()) {
				b.branchContainer.visible = true
			} else {
				b.branchContainer.visible = false
			}
			b.backgroundSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.DEFAULT_BACKGROUND)];
			b.reelBackground.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.DEFAULT_REEL)];
			b.reelBackground.container.position = b.DEFAULT_REEL_TOP_LEFT;
			b.foregroundSprite.sprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.DEFAULT_FOREGROUND)];
			b.foregroundSprite.position = b.DEFAULT_FOREGROUND_TOP_LEFT;
			b.stopFsBackgroundAnimation()
		}
	},
	doShakeOnAll: function(a) {
		this.doShakeOnReels(a)
	}
};
Finn.BackgroundViewLow = Sys.extend(Finn.BackgroundView, Finn.BackgroundViewLow, "Finn.BackgroundViewLow");
Sys.ns("Finn");
Finn.BackgroundController = {
	constructor: function() {
		Finn.BackgroundController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:mainGameBackgroundAnimations.start": a.freespinEnd,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged,
			"request:background.introduceFS": a.introduceFS,
			"view:freeSpinIntroduced": a.freeSpinIntroduced,
			"view:triggerSound": a.onTriggerSound,
			"notify:stateHandler.enteringFreeSpinOutroState": a.stopFsBackgroundAnimation,
			"notify:stateHandler.enteringFreeSpinMapState": a.hideAnimatedEnvironment,
			"notify:winPresentation.showWinEffect": a.setShakingBackground,
			"request:logo.hide": a.moveLogoAnimationOnFeatureSplash,
			"request:logo.show": a.moveLogoAnimationOnMainGame,
			"notify:stateHandler.enteringFreeSpinTriggerState": a.freeSpinTriggerShake
		})
	},
	freeSpinTriggerShake: function() {
		var a = this;
		setTimeout(function() {
			a.view.doIntenseShakeOnAll()
		}, 300);
		setTimeout(function() {
			a.fireEvent("request:vibration.vibrate", [500, 100])
		}, 700)
	},
	onTriggerSound: function(b) {
		var a = this;
		a.fireEvent("notify:spin." + b)
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:spin.crosscakeEarthquake", this, "When the rumble occurs.");
		Services.trigger.registerTrigger("notify:spin.crosscakeEarthquakeEnd", this, "When the rumble ends.")
	},
	hideAnimatedEnvironment: function() {
		var a = this;
		a.view.startAnimatedEnvironment(false)
	},
	setShakingBackground: function(c, f, a, e, b) {
		var d = this;
		if (Sys.isDefined(c) && Sys.isDefined(f)) {
			d.view.doWinEffects(c, f, a, e, b)
		}
	},
	freespinEnd: function() {
		var a = this;
		a.model.storeData("gameState", "basic");
		a.view.setMainGameBackground();
		a.view.createMainGameBackgroundAnimations();
		a.view.startAnimatedEnvironment(true)
	},
	introduceFS: function(a) {
		this.model.storeData("gameState", a);
		this.view.setFreespinBackground()
	},
	freeSpinIntroduced: function() {
		this.fireEvent("notify:background.freeSpinIntroduced")
	},
	stopFsBackgroundAnimation: function() {
		this.view.stopFsBackgroundAnimation()
	},
	moveLogoAnimationOnFeatureSplash: function() {
		this.view.moveLogoAnimation(528, 13, 0.87)
	},
	moveLogoAnimationOnMainGame: function() {
		this.view.moveLogoAnimation(16, 7, 1)
	}
};
Finn.BackgroundController = Sys.extend(Game.BackgroundController, Finn.BackgroundController, "Finn.BackgroundController");
Sys.ns("Finn");
Finn.BackgroundModel = {
	constructor: function() {
		Finn.BackgroundModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.storeData("gameState", "basic")
	},
	processServerResponse: function(d) {
		var b = this,
			a = d.currentGameState,
			c = !Sys.isDefined(d.freespin);
		if (a === "freespin" && d.freespin) {
			b.storeData("gameState", d.freespin.selected)
		} else {
			b.storeData("gameState", "basic")
		}
		b.storeData("inMainGame", c)
	}
};
Finn.BackgroundModel = Sys.extend(Core.Model, Finn.BackgroundModel, "Finn.BackgroundModel");
Sys.ns("Finn");
Finn.LogoView = {
	LOGO_IMAGE: "logo",
	LOGO_POSITION: {
		DESKTOP: {
			x: 16,
			y: 5
		},
		LANDSCAPE: {
			x: 16,
			y: 5
		},
		PORTRAIT: {
			x: 335,
			y: 25
		}
	},
	constructor: function() {
		Game.LogoView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.name = "LogoView";
		b.logoSprite = Game.PIXIFactory.createAndAddSprite(Game.stage.getOrientationSpecificImage(b.LOGO_IMAGE), b.rootContainer, Environment.getOrientationSpecificConfig(b.LOGO_POSITION, true), new PIXI.Point(0, 0));
		var a = Game.stage.view.animationManager.getLayer("logo");
		a.addChild(b.rootContainer)
	},
	hide: function() {
		this.rootContainer.visible = false
	},
	show: function() {
		this.rootContainer.visible = true
	},
	resetLogoSize: function() {
		this.logoSprite.scale.x = 1;
		this.logoSprite.scale.y = 1
	},
	refresh: function() {
		var a = this;
		a.logoSprite.position = Environment.getOrientationSpecificConfig(a.LOGO_POSITION, true);
		a.logoSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(a.LOGO_IMAGE)]
	}
};
Finn.LogoView = Sys.extend(Game.LogoView, Finn.LogoView, "Finn.LogoView");
Sys.ns("Finn");
Finn.LogoController = {
	constructor: function() {
		Finn.LogoController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:logo.hide": a.hide,
			"request:logo.show": a.show,
			"notify:paytable.hidden": a.resetLogoSize,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	resetLogoSize: function() {
		this.view.resetLogoSize()
	},
	onGameSizeChanged: function() {
		var a = this;
		a.view.refresh()
	}
};
Finn.LogoController = Sys.extend(Game.LogoController, Finn.LogoController, "Finn.LogoController");
Sys.ns("Finn");
Finn.Logo = {
	constructor: function() {
		Finn.Logo.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "orientation"]
	},
	getDefaultMVCClasses: function() {
		return {
			view: Finn.LogoView,
			controller: Finn.LogoController
		}
	}
};
Finn.Logo = Sys.extend(Game.Logo, Finn.Logo, "Finn.Logo");
Sys.ns("Finn");
Finn.BackgroundOverlay = {
	constructor: function() {
		Finn.BackgroundOverlay.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation"]
	}
};
Finn.BackgroundOverlay = Sys.extend(Core.Module, Finn.BackgroundOverlay, "Finn.BackgroundOverlay");
Sys.ns("Finn");
Finn.BackgroundOverlayView = {
	FEATURE_BACKGROUND_OVERLAYS: {
		randomWilds: "featureBackgroundOverlay1",
		destroy: "featureBackgroundOverlay2",
		symbolOverlay: "featureBackgroundOverlay1",
		symbolTransform: "featureBackgroundOverlay1"
	},
	FEATURE_BACKGROUND_ANIMATIONS: {
		randomWilds: {
			animationName: "randomWilds",
			animationState: "animation"
		}
	},
	OVERLAY_ALPHA: {
		feature: 0.8,
		bigWin: 0.5
	},
	OVERLAY_DURATION: {
		feature: 2000,
		bigWin: 1000
	},
	ABOVE_REELS: {
		DEFAULT: true,
		LANDSCAPE: true,
		PORTRAIT: false
	},
	BIG_WIN_BACKGROUND_OVERLAY: {
		DEFAULT: {
			startX: 0,
			startY: (1280 / 2),
			endX: 1280,
			endY: (1280 / 2),
			colorStops: [{
				i: 0,
				color: "#001a33"
			}, {
				i: 0.2,
				color: "#003366"
			}, {
				i: 0.3,
				color: "transparent"
			}, {
				i: 0.7,
				color: "transparent"
			}, {
				i: 0.8,
				color: "#003366"
			}, {
				i: 1,
				color: "#001a33"
			}]
		},
		LANDSCAPE: {
			startX: 0,
			startY: (1280 / 2),
			endX: 1280,
			endY: (1280 / 2),
			colorStops: [{
				i: 0,
				color: "#001a33"
			}, {
				i: 0.2,
				color: "#003366"
			}, {
				i: 0.3,
				color: "transparent"
			}, {
				i: 0.7,
				color: "transparent"
			}, {
				i: 0.8,
				color: "#003366"
			}, {
				i: 1,
				color: "#001a33"
			}]
		},
		PORTRAIT: {
			startX: (1280 / 2),
			startY: 0,
			endX: (1280 / 2),
			endY: 1280,
			colorStops: [{
				i: 0,
				color: "#001a33"
			}, {
				i: 0.05,
				color: "#003366"
			}, {
				i: 0.15,
				color: "transparent"
			}, {
				i: 0.5,
				color: "transparent"
			}, {
				i: 0.7,
				color: "#003366"
			}, {
				i: 1,
				color: "#001a33"
			}]
		}
	},
	constructor: function() {
		Finn.BackgroundOverlayView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.ongoingFade = "none";
		a.rootContainer = new PIXI.Container();
		a.rootContainer.name = "BackgroundOverlayView";
		a.rootContainerContent = new PIXI.Container();
		a.rootContainerContent.name = "BackgroundOverlayViewContent";
		a.rootContainerPortrait = new PIXI.Container();
		a.rootContainerPortrait.name = "BackgroundOverlayViewPortrait";
		a.createFadeAnimations();
		a.backgroundContentAnimations = {};
		Sys.iterate(a.FEATURE_BACKGROUND_ANIMATIONS, function(b, c) {
			a.backgroundContentAnimations[b] = a.createBackgroundContentAnimation(c.animationName)
		});
		a.setBigWinLayers();
		Game.stage.view.animationManager.getLayer("backgroundOverlay").addChild(a.rootContainer);
		Game.stage.view.animationManager.getLayer("backgroundOverlayContent").addChild(a.rootContainerContent);
		Game.stage.view.animationManager.getLayer("backgroundOverlayPortrait").addChild(a.rootContainerPortrait)
	},
	createFadeAnimations: function() {
		var a = this;
		a.featureSprite = Game.PIXIFactory.createAndAddSprite("", a.rootContainer);
		a.featureSprite.visible = false;
		a.featureFadeInAnimation = a.createFadeInAnimation(a.featureSprite, a.OVERLAY_DURATION.feature, a.OVERLAY_ALPHA.feature, 0);
		a.featureFadeOutAnimation = a.createFadeOutAnimation(a.featureSprite, a.OVERLAY_DURATION.feature, a.OVERLAY_ALPHA.feature, 500);
		a.bigWinSprite = Game.PIXIFactory.createAndAddSprite("", a.rootContainer);
		a.bigWinSprite.visible = false;
		a.bigWinFadeInAnimation = a.createFadeInAnimation(a.bigWinSprite, a.OVERLAY_DURATION.bigWin, a.OVERLAY_ALPHA.bigWin, 0);
		a.bigWinFadeOutAnimation = a.createFadeOutAnimation(a.bigWinSprite, a.OVERLAY_DURATION.bigWin, a.OVERLAY_ALPHA.bigWin, 1000)
	},
	createFadeInAnimation: function(d, f, a, b) {
		var c = this,
			e;
		e = new Animation.Holder({
			id: "backgroundFadeIn",
			target: d,
			delay: b,
			prop: "alpha",
			animate: [{
				time: 0,
				value: 0
			}, {
				time: f,
				value: a
			}]
		});
		Game.stage.view.animationManager.addToAnimationLoop(e);
		return e
	},
	createFadeOutAnimation: function(d, f, b, a) {
		var c = this,
			e;
		e = new Animation.Holder({
			id: "backgroundFadeOut",
			target: d,
			delay: a,
			prop: "alpha",
			animate: [{
				time: 0,
				value: b
			}, {
				time: f,
				value: 0
			}]
		});
		Game.stage.view.animationManager.addToAnimationLoop(e);
		return e
	},
	createBackgroundContentAnimation: function(a) {
		var b = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(a, b.rootContainerContent);
		c.visible = false;
		c.fire = function(d) {
			Finn.AnimationUtils.initialize(c, d).onAnimationEnd(b, b.onBackgroundContentAnimationComplete)
		};
		return c
	},
	setBigWinLayers: function() {
		var b = this,
			a = Environment.getOrientationSpecificConfig(b.ABOVE_REELS, true);
		if (a) {
			b.rootContainer.removeChild(b.bigWinSprite);
			b.rootContainerPortrait.addChild(b.bigWinSprite)
		} else {
			b.rootContainerPortrait.removeChild(b.bigWinSprite);
			b.rootContainer.addChild(b.bigWinSprite)
		}
	},
	fadeInBackgroundOverlay: function(d) {
		var b = this,
			a = Environment.getOrientationSpecificConfig(b.BIG_WIN_BACKGROUND_OVERLAY, true),
			c = b.model.readData("inMainGame");
		b.hideBackgroundOverlays(d);
		b.show();
		if (d === "bigWin" && c) {
			b.setBigWinLayers();
			b.bigWinSprite.texture = b.getDynamicGradient(a);
			b.bigWinFadeInAnimation.play();
			b.ongoingFade = "bigWin"
		} else {
			if (d !== "none" && d !== "bigWin") {
				b.featureSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(b.FEATURE_BACKGROUND_OVERLAYS[d])];
				b.featureFadeInAnimation.play();
				b.ongoingFade = "feature"
			}
		}
	},
	getDynamicGradient: function(c) {
		var b = document.createElement("canvas"),
			a = b.getContext("2d"),
			d = a.createLinearGradient(c.startX, c.startY, c.endX, c.endY);
		b.width = 1280;
		b.height = 1280;
		Sys.each(c.colorStops, function(e) {
			d.addColorStop(e.i, e.color)
		});
		a.fillStyle = d;
		a.fillRect(0, 0, 1280, 1280);
		return PIXI.Texture.fromCanvas(b)
	},
	fadeOutBackgroundOverlay: function(c) {
		var a = this,
			b = a.model.readData("inMainGame");
		if (c === "bigWin" && b) {
			a.setBigWinLayers();
			a.bigWinFadeOutAnimation.play()
		} else {
			if (c !== "none" && c !== "bigWin") {
				a.featureFadeOutAnimation.play()
			}
		}
		a.ongoingFade = "none"
	},
	showBackgroundContentAnimation: function(b) {
		var a = this;
		a.backgroundContentAnimations[b].fire(a.FEATURE_BACKGROUND_ANIMATIONS[b].animationState)
	},
	onBackgroundContentAnimationComplete: function() {
		var a = this;
		a.hideBackgroundContentAnimations();
		a.resetBackgroundContentAnimations();
		a.fireEvent("view:backgroundContentAnimationComplete")
	},
	show: function() {
		var a = this;
		a.bigWinSprite.visible = true;
		a.featureSprite.visible = true
	},
	hide: function() {
		var a = this;
		a.hideBackgroundOverlays();
		a.hideBackgroundContentAnimations();
		a.resetBackgroundContentAnimations()
	},
	hideBackgroundOverlays: function() {
		var a = this;
		a.bigWinFadeInAnimation.stop();
		a.bigWinFadeOutAnimation.stop();
		a.bigWinSprite.alpha = 0;
		a.featureFadeInAnimation.stop();
		a.featureFadeOutAnimation.stop();
		a.featureSprite.alpha = 0;
		a.ongoingFade = "none"
	},
	hideBackgroundContentAnimations: function() {
		var a = this;
		Sys.iterate(a.backgroundContentAnimations, function(b, c) {
			c.visible = false
		})
	},
	resetBackgroundContentAnimations: function() {
		var a = this;
		Sys.iterate(a.backgroundContentAnimations, function(b, c) {
			Game.PIXIUtils.resetSpineAnimation(c)
		})
	},
	refresh: function() {
		var a = this,
			b = a.model.readData("mode");
		a.setBigWinLayers();
		if (b === "bigWin") {
			a.bigWinSprite.texture = a.getDynamicGradient(Environment.getOrientationSpecificConfig(a.BIG_WIN_BACKGROUND_OVERLAY, true))
		} else {
			if (b !== "none") {
				a.featureSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(a.FEATURE_BACKGROUND_OVERLAYS[a.model.readData("mode")])]
			}
		}
	}
};
Finn.BackgroundOverlayView = Sys.extend(Core.View, Finn.BackgroundOverlayView, "Finn.BackgroundOverlayView");
Sys.ns("Finn");
Finn.BackgroundOverlayController = {
	constructor: function() {
		Finn.BackgroundOverlayController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:backgroundOverlay.fadeIn": a.fadeIn,
			"request:backgroundOverlay.fadeOut": a.fadeOut,
			"request:backgroundOverlay.hideOverlay": a.hideOverlay,
			"request:backgroundOverlay.showBackgroundContentAnimation": a.showBackgroundContentAnimation,
			"view:backgroundContentAnimationComplete": a.backgroundContentAnimationComplete,
			"notify:winningSymbols.abort": a.hideOverlay,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	fadeIn: function(b) {
		var a = this;
		a.model.storeData("mode", b);
		a.view.fadeInBackgroundOverlay(b)
	},
	fadeOut: function() {
		var a = this,
			b = a.model.readData("mode");
		a.view.fadeOutBackgroundOverlay(b);
		a.model.storeData("mode", "none")
	},
	showBackgroundContentAnimation: function(a) {
		this.view.showBackgroundContentAnimation(a)
	},
	backgroundContentAnimationComplete: function() {
		this.fireEvent("notify:backgroundOverlay.backgroundContentAnimationComplete")
	},
	hideOverlay: function() {
		var a = this;
		a.view.hide();
		a.model.storeData("mode", "none")
	},
	onGameSizeChanged: function() {
		var a = this;
		a.view.refresh()
	}
};
Finn.BackgroundOverlayController = Sys.extend(Core.Controller, Finn.BackgroundOverlayController, "Finn.BackgroundOverlayController");
Sys.ns("Finn");
Finn.BackgroundOverlayModel = {
	constructor: function() {
		Finn.BackgroundOverlayModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.storeData("mode", "none")
	},
	processServerResponse: function(a) {
		this.storeData("inMainGame", !Sys.isDefined(a.freespin))
	}
};
Finn.BackgroundOverlayModel = Sys.extend(Core.Model, Finn.BackgroundOverlayModel, "Finn.BackgroundOverlayModel");
Sys.ns("Finn");
Finn.PIXIWinBanner = {
	constructor: function() {
		Finn.PIXIWinBanner.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.PIXIWinBannerModel,
			view: Finn.PIXIWinBannerView,
			controller: Finn.PIXIWinBannerController
		}
	}
};
Finn.PIXIWinBanner = Sys.extend(Core.CountUp, Finn.PIXIWinBanner, "Finn.PIXIWinBanner");
Sys.ns("Finn");
Finn.PIXIWinBannerController = {
	COUNT_UP_NAME: "winBanner",
	constructor: function() {
		Finn.PIXIWinBannerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Finn.PIXIWinBannerController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
			"notify:spin.spinAnimationStarted": a.hide,
			"request:winBanner.hideMgWinBanner": a.view.hideForNow.bind(a.view),
			"request:winBanner.showMgWinBanner": a.showForNow,
			"notify:settingsManager.settingChanged": a.settingChanged,
			"notify:stateHandler.enteringFreeSpinIntroState": a.hide,
			"request:winBanner.setWinType": a.setWinType,
			"request:winBanner.setCountUpDuration": a.setCountUpDuration,
			"request:winBanner.animate": a.start,
			"request:winBanner.endOfRound": a.endOfRound,
			"view:countUpComplete": a.onCountUpComplete,
			"view:playSound": a.playCountUpSound,
			"view:stopSound": a.stopCountUpSound
		})
	},
	setWinType: function(a) {
		this.model.storeData("winType", a)
	},
	setCountUpDuration: function(a) {
		this.model.storeData("countUpDuration", a)
	},
	settingChanged: function(a) {
		if (a === "betLevel" || a === "denomination") {
			this.hide()
		}
	},
	hide: function() {
		var a = this;
		if (a.model.readData("gameOver") || a.model.readData("enteringFreeSpin")) {
			a.view.hide();
			a.showAfterPaytableAndGameRules = false
		}
	},
	start: function(c) {
		var a = this,
			b = Sys.isDefined(c) ? c : a.model.readData("countUpDuration");
		if (a.model.readData("shouldAnimate")) {
			a.view.start(b);
			a.model.setState("countingUp")
		} else {
			a.view.resetScaling();
			a.view.hide();
			a.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
		}
		a.showAfterPaytableAndGameRules = true
	},
	showForNow: function() {
		var a = this;
		if (a.showAfterPaytableAndGameRules && a.model.readData("gameState") === "basic") {
			a.view.showForNow()
		}
	},
	playCountUpSound: function() {
		var a = this;
		a.fireEvent.bind(a, "request:audioPlayer.play", {
			name: "countUpLoop",
			loop: true,
			id: "winBannerCountUp"
		});
		a.fireEvent("notify:wincountup.wincountupStart")
	},
	stopCountUpSound: function() {
		var a = this;
		a.fireEvent.bind(a, "request:audioPlayer.stop", "winBannerCountUp");
		a.fireEvent("notify:wincountup.wincountupEnd")
	},
	onCountUpComplete: function() {
		var a = this;
		a.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
	},
	endOfRound: function() {
		this.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
	},
	registerTriggers: function() {
		Services.trigger.registerTrigger("notify:wincountup.wincountupStart", this, "count up start");
		Services.trigger.registerTrigger("notify:wincountup.wincountupEnd", this, "count up end");
		Services.trigger.registerTrigger("notify:soloMultiplier.outroBanner", this, "soloMultiplier");
		Services.trigger.registerTrigger("notify:soloMultiplier.outroWinAmountAttention", this, "soloMultiplier")
	}
};
Finn.PIXIWinBannerController = Sys.extend(Core.CountUpController, Finn.PIXIWinBannerController, "Finn.PIXIWinBannerController");
Sys.ns("Finn");
Finn.PIXIWinBannerModel = {
	THRESHOLD: {
		bigWin: 15,
		megaWin: 30,
		superMegaWin: 60
	},
	constructor: function() {
		Finn.PIXIWinBannerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		Finn.PIXIWinBannerModel.superclass.setupData.apply(this, arguments);
		this.storeData("coinWin", 0);
		this.storeData("countUpDuration", 0)
	},
	processServerResponse: function(g) {
		var d = this,
			b = 0,
			f = 0,
			e = (!Sys.isDefined(g.freespin)),
			a = g.nextaction === "bonusaction",
			c = g.currentGameState;
		d.storeData("lastWinType", d.readData("winType") || "none");
		d.storeData("enteringFreeSpin", a);
		if (g.clientaction === "spin") {
			d.storeData("lastWinType", "none")
		}
		if (Sys.isDefined(g.wins) && Sys.isDefined(g.wins.coins)) {
			b = g.wins.coins
		}
		if (Sys.isDefined(g.wins) && Sys.isDefined(g.wins.coinsTotal)) {
			b = g.wins.coinsTotal;
			f = g.wins.coinsTotal
		}
		d.storeData("shouldAnimate", (b > 0 && e));
		d.storeData("gameOver", g.gameover);
		d.storeData("coinWin", b);
		d.storeData("totalCoinWin", f);
		d.multiplier = g.multiplier;
		if (c === "freespin" && g.freespin) {
			d.storeData("gameState", g.freespin.selected)
		} else {
			d.storeData("gameState", "basic")
		}
	}
};
Finn.PIXIWinBannerModel = Sys.extend(Core.CountUpModel, Finn.PIXIWinBannerModel, "Finn.PIXIWinBannerModel");
Sys.ns("Finn");
Finn.PIXIWinBannerView = {
	BACKGROUND_ANIMATION_POSITION: {
		x: 0,
		y: 162
	},
	BACKGROUND_IDLE_ANIMATION: {
		animation: "win_loop"
	},
	BACKGROUND_COUNTUP_ANIMATIONS: {
		win: {
			animation: "win_small",
			scale: 0.85
		},
		smallWin: {
			animation: "win_small",
			scale: 0.85
		},
		mediumWin: {
			animation: "win_medium",
			scale: 0.85
		},
		largeWin: {
			animation: "win_large",
			scale: 0.85
		},
		bigWin: {
			animation: "win_big",
			scale: 1.4
		},
		megaWin: {
			animation: "win_mega",
			scale: 1.6
		},
		superMegaWin: {
			animation: "win_superMega",
			scale: 1.8
		}
	},
	TEXT_CONTAINER_POSITION: {
		x: 640,
		y: 502
	},
	DEFAULT_FONT_SCALE: 0.7,
	WIN_TEXT: {
		key: Language.Keys.win,
		rightMargin: 5
	},
	constructor: function() {
		Finn.PIXIWinBannerView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.currentCoinCount = 0;
		b.coinWin = 0;
		b.totalCoinWin = 0;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.position = new PIXI.Point(0, 0);
		b.backgroundIdleAnimation = b.initBackgroundAnimation(b.rootContainer, "winBanner", true);
		b.backgroundIdleAnimation.position.y = b.BACKGROUND_ANIMATION_POSITION.y;
		b.backgroundIdleAnimation.state.timeScale = 0.6;
		b.backgroundCountUpAnimation = b.initBackgroundAnimation(b.rootContainer, "winBanner", false);
		b.textContainer = new PIXI.Container();
		b.textContainer.scale = new PIXI.Point(1, 1);
		b.textContainer.position = b.TEXT_CONTAINER_POSITION;
		b.rootContainer.addChild(b.textContainer);
		b.winText = {};
		b.winText.win = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(b.WIN_TEXT.key).toUpperCase() + "", Game.TextStyles.WIN_BANNER_WIN_TEXT, b.textContainer, new PIXI.Point(0, 0), new PIXI.Point(0.5, 0.5));
		b.winText.win.alpha = 1;
		b.winText.bigWin = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.bigWin).toUpperCase() + "", Game.TextStyles.WIN_BANNER_WIN_TEXT, b.textContainer, new PIXI.Point(0, 0), new PIXI.Point(0.5, 0.5));
		b.winText.bigWin.alpha = 0;
		b.winText.megaWin = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.megaWin).toUpperCase() + "", Game.TextStyles.WIN_BANNER_WIN_TEXT, b.textContainer, new PIXI.Point(0, 0), new PIXI.Point(0.5, 0.5));
		b.winText.megaWin.alpha = 0;
		b.winText.superMegaWin = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.superMegaWin).toUpperCase() + "", Game.TextStyles.WIN_BANNER_WIN_TEXT, b.textContainer, new PIXI.Point(0, 0), new PIXI.Point(0.5, 0.5));
		b.winText.superMegaWin.alpha = 0;
		b.countUpText = Game.PIXIFactory.createAndAddText("", Game.TextStyles.WIN_BANNER_COUNT_UP_TEXT, b.textContainer, new PIXI.Point(0, b.winText.win.height * 1.08 * b.DEFAULT_FONT_SCALE), new PIXI.Point(0.5, 0.5));
		b.countUp = b.createCountUpAnimation();
		b.scale = b.createEffectAnimation(b.textContainer);
		b.animations = new Animation.Holder({
			id: "winBannerCountUpAnimations",
			children: [b.countUp, b.scale]
		});
		Game.stage.view.animationManager.addToAnimationLoop(b.animations);
		var a = Game.stage.view.animationManager.getLayer("countUp");
		a.addChild(b.rootContainer);
		b.stop();
		b.resetScaling()
	},
	resetScaling: function() {
		var a = this;
		a.winText.win.scale = new PIXI.Point(a.DEFAULT_FONT_SCALE, a.DEFAULT_FONT_SCALE);
		a.winText.bigWin.scale = new PIXI.Point(a.DEFAULT_FONT_SCALE, a.DEFAULT_FONT_SCALE);
		a.winText.megaWin.scale = new PIXI.Point(a.DEFAULT_FONT_SCALE, a.DEFAULT_FONT_SCALE);
		a.winText.superMegaWin.scale = new PIXI.Point(a.DEFAULT_FONT_SCALE, a.DEFAULT_FONT_SCALE);
		a.countUpText.scale = new PIXI.Point(a.DEFAULT_FONT_SCALE, a.DEFAULT_FONT_SCALE)
	},
	initBackgroundAnimation: function(a, b, c) {
		var d = this,
			e;
		e = Game.PIXIFactory.createAndAddSpineAnimation(b, a);
		e.fire = function(f) {
			var g = Finn.AnimationUtils.initialize(e, f, c);
			e.visible = true;
			e.updateTransform();
			if (!c) {
				g.onAnimationEnd(d, d.animationComplete, e)
			}
		};
		e.visible = false;
		return e
	},
	animationComplete: function(a) {
		a.visible = false
	},
	createEffectAnimation: function(a) {
		return new Animation.Holder({
			id: "effect",
			target: a,
			prop: "scale"
		})
	},
	createCountUpAnimation: function() {
		var a = this;
		return new Animation.Holder({
			id: "countUpText",
			target: this,
			prop: "currentCoinCount",
			onUpdate: a.setCountUpText.bind(a),
			onEnd: function() {
				a.fireEvent("view:countUpComplete");
				a.fireEvent("view:stopSound");
				a.countUpDone = true
			}
		})
	},
	setCountUpText: function() {
		var c = this,
			b = c.model.readData("winType") || "win",
			a = b === "smallWin" || b === "mediumWin" || b === "largeWin" ? "win" : b;
		if (c.currentCoinCount <= 0) {
			c.countUpText.alpha = 0
		} else {
			c.countUpText.alpha = 1
		}
		c.countUpText.text = Math.floor(c.currentCoinCount).toString();
		c.countUpText.updateTransform();
		Sys.iterate(c.winText, function(d, e) {
			e.alpha = 0
		});
		c.winText[a].alpha = 1
	},
	start: function(g) {
		var d = this,
			b = d.model.readData("coinWin"),
			c = d.model.readData("winType") || "smallWin",
			a = d.BACKGROUND_COUNTUP_ANIMATIONS[c],
			f = g || 0,
			e, h;
		Game.PIXIUtils.resetSpineAnimation(d.backgroundCountUpAnimation);
		d.animations.stop();
		d.coinWin = b;
		d.totalCoinWin = d.model.readData("totalCoinWin");
		d.rootContainer.visible = true;
		d.countUpDone = false;
		this.fireEvent("view:playSound");
		e = [{
			time: 0,
			value: d.currentCoinCount
		}, {
			time: f,
			value: d.coinWin
		}];
		d.countUp.animate(e);
		d.countUp.play();
		h = [{
			time: 0,
			value: {
				x: d.DEFAULT_FONT_SCALE,
				y: d.DEFAULT_FONT_SCALE
			}
		}, {
			time: f / 2,
			value: {
				x: a.scale,
				y: a.scale
			}
		}, {
			time: f,
			value: {
				x: d.DEFAULT_FONT_SCALE,
				y: d.DEFAULT_FONT_SCALE
			}
		}];
		d.scale.animate(h);
		d.scale.play();
		d.backgroundCountUpAnimation.position.y = d.BACKGROUND_ANIMATION_POSITION.y;
		d.backgroundCountUpAnimation.fire(a.animation);
		d.backgroundIdleAnimation.fire(d.BACKGROUND_IDLE_ANIMATION.animation)
	},
	stop: function() {
		var a = this;
		if (a.animations.running) {
			if (!a.countUpDone) {
				a.showTotal()
			}
		} else {
			a.rootContainer.visible = false;
			Game.PIXIUtils.resetSpineAnimation(a.backgroundIdleAnimation)
		}
	},
	hide: function() {
		var a = this;
		a.rootContainer.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a.backgroundIdleAnimation);
		a.currentCoinCount = 0
	},
	hideForNow: function() {
		var a = this;
		a.rootContainer.visible = false
	},
	showForNow: function() {
		var a = this;
		a.rootContainer.visible = true
	},
	pause: function() {
		var a = this;
		a.fireEvent("view:stopSound");
		a.countUp.pause()
	},
	resume: function() {
		var a = this;
		if (a.model.isState("countingUp")) {
			a.fireEvent("view:playSound")
		}
		a.countUp.play()
	}
};
Finn.PIXIWinBannerView = Sys.extend(Core.CountUpView, Finn.PIXIWinBannerView, "Finn.PIXIWinBannerView");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.OrientationManager = {
	constructor: function() {
		pixiGenericSlot.OrientationManager.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation", "animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Model,
			view: Core.View,
			controller: pixiGenericSlot.OrientationManagerController
		}
	}
};
pixiGenericSlot.OrientationManager = Sys.extend(Core.Module, pixiGenericSlot.OrientationManager, "pixiGenericSlot.OrientationManager");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.OrientationManagerController = {
	constructor: function() {
		pixiGenericSlot.OrientationManagerController.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		var b = Game.stage.view.animationManager;
		a.landscapeLayers = [];
		a.portraitLayers = [];
		a.reelLayers = [b.layers.backgroundOverlayContent, b.layers.reelBackground, b.layers.winPresentationBelowSymbols, b.layers.reel, b.layers.winSymbols, b.layers.winPresentationAboveSymbols, b.layers.wildExplosions, b.layers.randomFeaturePresentations, b.layers.countUp, b.layers.winCoinNumbers, b.layers.freeSpinCountDown, b.layers.freespinIntro];
		a.splashScreensLayers = [b.layers.splashScreensContent, b.layers.splashScreensContentOverlay, b.layers.splashScreensDialog];
		a.userInterfaceLayers = [b.layers.userInterface];
		a.backgroundLayers = [b.layers.background];
		a.logoLayers = [b.layers.logo];
		a.leftSideLayers = [b.layers.character];
		a.rightSideLayers = [];
		a.allButBackgroundLayers = [b.layers.backgroundOverlayContent, b.layers.reelBackground, b.layers.winPresentationBelowSymbols, b.layers.reel, b.layers.winSymbols, b.layers.winPresentationAboveSymbols, b.layers.wildExplosions, b.layers.randomFeaturePresentations, b.layers.countUp, b.layers.winCoinNumbers, b.layers.freeSpinCountDown, b.layers.userInterface, b.layers.character, b.layers.freespinIntro]
	},
	onPortrait: function() {
		var a = this;
		a.specialScaling(a.reelLayers);
		a.scaleRightLayers(a.rightSideLayers);
		a.scaleLeftLayers(a.leftSideLayers);
		Sys.each(a.splashScreensLayers, function(b) {
			b.position = new PIXI.Point(-280 + 100 / 0.75, 120)
		});
		a.hideLayers(a.landscapeLayers);
		a.showLayers(a.portraitLayers);
		a.letterBoxFix(a.allButBackgroundLayers)
	},
	letterBoxFix: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].position.x += 100 / 0.75
		}
	},
	onLandscape: function() {
		var a = this;
		a.specialReverseScaling(a.reelLayers);
		a.revertRightLayers(a.rightSideLayers);
		a.revertLeftLayers(a.leftSideLayers);
		Sys.each(a.splashScreensLayers, function(b) {
			b.position = new PIXI.Point(0, 0)
		});
		a.showLayers(a.logoLayers);
		a.hideLayers(a.portraitLayers);
		a.showLayers(a.landscapeLayers)
	},
	scaleRightLayers: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].scale = new PIXI.Point(1.125, 1.125);
			b[a].position = new PIXI.Point(-505, 230)
		}
	},
	scaleLeftLayers: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].scale = new PIXI.Point(1.5, 1.5);
			b[a].position = new PIXI.Point(-80, 275)
		}
	},
	revertRightLayers: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].position = new PIXI.Point(0, 0);
			b[a].scale = new PIXI.Point(1, 1)
		}
	},
	revertLeftLayers: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].scale = new PIXI.Point(1, 1);
			b[a].position = new PIXI.Point(0, 0)
		}
	},
	specialScaling: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].scale = new PIXI.Point(1.125, 1.125);
			b[a].position = new PIXI.Point(-360, 120)
		}
	},
	specialReverseScaling: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].position = new PIXI.Point(0, 0);
			b[a].scale = new PIXI.Point(1, 1)
		}
	},
	scaleLayers: function(e, g, b, f) {
		var a = new PIXI.Point(1280 * b.x, 720 * b.y);
		var d = new PIXI.Point(f.x * g.x, f.y * g.y);
		for (var c = 0; c < e.length; c++) {
			e[c].scale = g;
			e[c].pivot = a;
			e[c].position = new PIXI.Point(a.x + d.x, a.y + d.y)
		}
	},
	justScaleLayers: function(b, c) {
		for (var a = 0; a < b.length; a++) {
			b[a].scale = c
		}
	},
	showLayers: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].visible = true
		}
	},
	hideLayers: function(b) {
		for (var a = 0; a < b.length; a++) {
			b[a].visible = false
		}
	}
};
pixiGenericSlot.OrientationManagerController = Sys.extend(Core.Controller, pixiGenericSlot.OrientationManagerController, "pixiGenericSlot.OrientationManagerController");
Sys.ns("Finn");
Finn.QuickStopper = {
	constructor: function() {
		Game.Slots.QuickStopper.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "userInput", "animation", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.QuickStopperModel,
			view: Finn.QuickStopperView,
			controller: Finn.QuickStopperController
		}
	}
};
Finn.QuickStopper = Sys.extend(Game.Slots.QuickStopper, Finn.QuickStopper, "Finn.QuickStopper");
Sys.ns("Finn");
Finn.QuickStopperView = {
	constructor: function() {
		Game.Slots.QuickStopperView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.quickStopperGraphics = new PIXI.Graphics();
		b.quickStopperGraphics.beginFill(16777215, 1);
		b.quickStopperGraphics.drawRect(0, 0, 1280, 720);
		b.quickStopperGraphics.endFill();
		b.rootContainer.addChild(b.quickStopperGraphics);
		b.quickStopAnim = new Animation.Holder({
			id: "QuickStopperView - fadeAnim",
			target: b.rootContainer,
			onEnd: b.onAnimComplete.bind(b),
			animate: {
				0: {
					alpha: 0
				},
				100: {
					alpha: 0.2
				},
				200: {
					alpha: 0
				}
			}
		});
		Game.stage.view.animationManager.addToAnimationLoop(b.quickStopAnim);
		var a = Game.stage.view.animationManager.getLayer("quickStopper");
		a.addChild(b.rootContainer);
		b.rootContainer.visible = false
	},
	onAnimComplete: function() {
		this.rootContainer.visible = false
	},
	setupEvents: function() {
		var a = this;
		a.on({})
	},
	quickStop: function() {
		this.rootContainer.visible = true;
		this.quickStopAnim.restore();
		this.quickStopAnim.play()
	}
};
Finn.QuickStopperView = Sys.extend(Core.View, Finn.QuickStopperView, "Finn.QuickStopperView");
Sys.ns("Finn");
Finn.QuickStopperController = {
	QUICKSTOP_TIMER: 2000,
	constructor: function() {
		Game.Slots.QuickStopperController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:quickStopper.disableInMode": a.disableInMode,
			"request:quickStopper.enableInMode": a.enableInMode,
			"request:quickStopper.quickStop": a.performQuickStop,
			"notify:spin.spinAnimationStarted": a.spinStarted,
			"notify:spin.spinAnimationComplete": a.spinStopped,
			"request:quickStopper.disableForRandomFeature": a.disableForRandomFeature,
			"request:quickStopper.enableForRandomFeature": a.enableForRandomFeature,
			"notify:spinButton.clickedWhileHidden": a.performQuickStop,
			"notify:freeSpinCountDown:animationComplete": a.freeSpinCounterEnded
		})
	},
	spinStopped: function() {
		var a = this;
		if (a.model.readData("disabledForRandomFeature")) {
			return
		}
		a.stopListeningToUserInput();
		a.model.setState("stopped");
		a.fireEvent("request:spinButton.enable", a.MODULE_NAME)
	},
	disableForRandomFeature: function() {
		var a = this;
		a.model.storeData("disabledForRandomFeature", true);
		a.stopListeningToUserInput();
		a.fireEvent("request:spinButton.disable", a.MODULE_NAME)
	},
	enableForRandomFeature: function() {
		var a = this;
		a.model.storeData("disabledForRandomFeature", false);
		a.startListeningToUserInput();
		a.fireEvent("request:spinButton.enable", a.MODULE_NAME)
	},
	enableQuickstopWithDelay: function() {
		var a = this;
		if (a.model.readData("gameState") === "basic" || a.model.readData("nextAction") === "bonusaction") {
			setTimeout(function() {
				a.fireEvent("request:spinButton.enable", a.MODULE_NAME);
				a.startListeningToUserInput()
			}, a.QUICKSTOP_TIMER)
		} else {
			a.fireEvent("request:spinButton.enable", a.MODULE_NAME);
			a.startListeningToUserInput()
		}
	},
	disableQuickStop: function() {
		var a = this;
		a.stopListeningToUserInput();
		a.model.setState("stopped");
		a.fireEvent("request:spinButton.enable", a.MODULE_NAME)
	},
	spinStarted: function() {
		var b = this,
			a = b.model.readData("nextAction");
		if (a !== "bonusaction" && a !== "freespin") {
			b.startListeningToUserInput();
			b.model.setState("spinning")
		} else {
			b.model.setState("counter")
		}
	},
	freeSpinCounterEnded: function() {
		var a = this;
		a.startListeningToUserInput();
		a.model.setState("randomFeature")
	}
};
Finn.QuickStopperController = Sys.extend(Game.Slots.QuickStopperController, Finn.QuickStopperController, "Finn.QuickStopperController");
Sys.ns("Finn");
Finn.QuickStopperModel = {
	constructor: function() {
		Game.Slots.QuickStopperModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(d) {
		var c = this,
			b = d.gamestate.current,
			a = d.nextaction;
		c.storeData("nextAction", a);
		c.storeData("gameState", b)
	},
	canQuickStop: function() {
		return (this.isState("spinning") || this.isState("randomFeature")) && !this.isInDisabledMode()
	}
};
Finn.QuickStopperModel = Sys.extend(Game.Slots.QuickStopperModel, Finn.QuickStopperModel, "Finn.QuickStopperModel");
Sys.ns("Finn");
Finn.WinSituationsDisplayController = {
	constructor: function() {
		Finn.WinSituationsDisplayController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringSpinningState": a.abort,
			"request:winSituationsDisplay.abort": a.abort,
			"request:abortPresentation": a.abort,
			"request:winSituationsDisplay.showAllWins": a.showAllWins,
			"notify:settingsManager.settingChanged": a.processSettingsChanges,
			"request:winSituationsDisplay.waitFor": a.handleWaitRequest
		})
	}
};
Finn.WinSituationsDisplayController = Sys.extend(Game.Slots.WinSituationsDisplayController, Finn.WinSituationsDisplayController, "WinSituationsDisplayController");
Sys.ns("Finn");
Finn.AmbienceManager = {
	constructor: function() {
		Finn.AmbienceManager.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.AmbienceManagerModel,
			controller: Finn.AmbienceManagerController
		}
	},
	getMixinDependencies: function() {
		return ["serverResponse"]
	}
};
Finn.AmbienceManager = Sys.extend(Game.AmbienceManager, Finn.AmbienceManager, "Finn.AmbienceManager");
Sys.ns("Finn");
Finn.AmbienceManagerModel = {
	constructor: function() {
		Finn.AmbienceManagerModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = this;
		a.storeData("isGameStateBasic", (b.gamestate.current === "basic"))
	},
	setupData: function() {
		var a = this;
		a.storeData("activeAmbience", [{
			name: "ambienceGeneral",
			id: "ambienceGeneral",
			loop: true,
			fadeIn: {
				from: 0.01,
				to: 0.5,
				time: 1
			},
			fadeOut: {
				from: 0.5,
				to: 0.01,
				time: 5
			}
		}]);
		Services.storage.storeData("AmbienceManager.playing", false)
	}
};
Finn.AmbienceManagerModel = Sys.extend(Game.AmbienceManagerModel, Finn.AmbienceManagerModel, "Finn.AmbienceManagerModel");
Sys.ns("Finn");
Finn.AmbienceManagerController = {
	MAIN_MUSIC_OVERLAY_VOLUME: 0.5,
	MAIN_MUSIC_OVERLAY_FADE_IN_TIME: 1,
	MAIN_MUSIC_OVERLAY_FADE_OUT_TIME: 5,
	FIRST_ATTENTION_MUSIC_OVERLAY_VOLUME: 0.5,
	FIRST_ATTENTION_MUSIC_OVERLAY_FADE_IN_TIME: 1,
	FIRST_ATTENTION_MUSIC_OVERLAY_FADE_OUT_TIME: 5,
	SECOND_ATTENTION_MUSIC_OVERLAY_VOLUME: 0.4,
	SECOND_ATTENTION_MUSIC_OVERLAY_FADE_IN_TIME: 1,
	SECOND_ATTENTION_MUSIC_OVERLAY_FADE_OUT_TIME: 5,
	FADE_OUT_DELAY_TIME: 1000,
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:audioPlayer.soundLoaded": a.onSoundLoaded,
			"request:ambienceManager.ambienceEnableState": a.changeAmbienceEnableState,
			"request:ambienceManager.ambienceChangeActive": a.setActiveAmbience,
			"request:ambienceManager.ambiencePauseSwitch": a.changePauseSwitch,
			"request:ambienceManager.ambienceStopActive": a.stopAmbience,
			"notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
			"notify:stateHandler.leavingShowingIntroMovieState": a.changeAmbienceEnableState.bind(a, true),
			"notify:ambienceManager.startTransition": a.onBonusSymbolAttentionSound
		})
	},
	onSoundLoaded: function() {
		this.model.storeData("isSoundsLoaded", true);
		var a = Services.settingsManager.getSetting("showIntroMovie");
		if (a === false || Platform.isMobileDevice || Platform.isTabletDevice) {
			this.changeAmbienceEnableState(true)
		}
	},
	changeAmbienceEnableState: function(a) {
		var b = this.model.readData("isSoundsLoaded");
		if (b) {
			Finn.AmbienceManagerController.superclass.changeAmbienceEnableState.apply(this, arguments)
		}
	},
	onBonusSymbolAttentionSound: function(a, b, d) {
		var c = this,
			e, g, f = 0;
		if (!c.model.readData("isGameStateBasic")) {
			return
		}
		if (a === "ambienceGeneral") {
			e = c.MAIN_MUSIC_OVERLAY_VOLUME;
			g = c.MAIN_MUSIC_OVERLAY_FADE_IN_TIME;
			f = c.MAIN_MUSIC_OVERLAY_FADE_OUT_TIME
		} else {
			if (a === "ambienceGeneral1") {
				e = c.FIRST_ATTENTION_MUSIC_OVERLAY_VOLUME;
				g = c.FIRST_ATTENTION_MUSIC_OVERLAY_FADE_IN_TIME;
				f = c.FIRST_ATTENTION_MUSIC_OVERLAY_FADE_OUT_TIME
			} else {
				if (a === "ambienceGeneral2") {
					e = c.SECOND_ATTENTION_MUSIC_OVERLAY_VOLUME;
					g = c.SECOND_ATTENTION_MUSIC_OVERLAY_FADE_IN_TIME;
					f = c.SECOND_ATTENTION_MUSIC_OVERLAY_FADE_OUT_TIME
				}
			}
		}
		c.setActiveAmbience({
			name: a,
			id: b,
			volume: e,
			fadeIn: {
				from: 0.01,
				to: e,
				time: g
			},
			fadeOut: {
				from: e,
				to: 0.01,
				time: f
			},
			loop: true,
			syncWithId: d
		})
	}
};
Finn.AmbienceManagerController = Sys.extend(Game.AmbienceManagerController, Finn.AmbienceManagerController, "Finn.AmbienceManagerController");
Sys.ns("Game");
Game.TextStyles = {
	PORTRAIT_LOGO: {
		fontFamily: "riffic-bold",
		fontSize: "24px",
		align: "left",
		letterSpacing: 1.2,
		fill: "#FFFFFF"
	},
	SKIP_INTRO_STYLE: {
		fontFamily: "NetentStandardUI",
		fontSize: "20px",
		align: "center",
		fill: "#FFFFFF"
	},
	ACTIVE_TEXT_STYLE: {
		fontFamily: "riffic-bold",
		fontSize: "30px",
		fill: "#fff100",
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#0f0155",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	INACTIVE_TEXT_STYLE: {
		fontFamily: "riffic-bold",
		fontSize: "30px",
		fill: "#FFFFFF",
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#0f0155",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	CONTINUE_BUTTON: {
		fontFamily: "riffic-bold",
		fontSize: "18px",
		align: "center",
		fill: "#feff84",
		letterSpacing: 2,
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 2,
		dropShadowBlur: 0
	},
	CONTINUE_BUTTON_DISABLED: {
		fontFamily: "riffic-bold",
		fontSize: "18px",
		align: "center",
		fill: "#afbeb2",
		letterSpacing: 2,
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 2,
		dropShadowBlur: 0
	},
	SKIP_CHECK_BOX: {
		fontFamily: "OpenSans-Regular",
		fontWeight: "bold",
		fontSize: "16px",
		align: "left",
		fill: "#0f0155"
	},
	MAX_BET_BUTTON_UP: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#feff84",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	MAX_BET_BUTTON_OVER: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#feff84",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	MAX_BET_BUTTON_DOWN: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#abac54",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	MAX_BET_BUTTON_DISABLED: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#8D8D73",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	AUTOPLAY_BUTTON_UP: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#feff84",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	AUTOPLAY_BUTTON_OVER: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#feff84",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	AUTOPLAY_BUTTON_DOWN: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#abac54",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	AUTOPLAY_BUTTON_DISABLED: {
		fontFamily: "riffic-bold",
		fontSize: "21px",
		align: "center",
		fill: "#8D8D73",
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	TOTAL_WIN_LABEL: {
		fontFamily: "FuturaCom-ExtraBoldCond",
		fontSize: "24px",
		align: "center",
		fill: "#ffffff"
	},
	FREESPINS_LEFT_LABEL: {
		fontFamily: "FuturaCom-ExtraBoldCond",
		fontSize: "24px",
		align: "center",
		fill: "#ffffff"
	},
	GENERIC_LABEL_STYLE: {
		fontFamily: "FuturaCom-ExtraBoldCond",
		fontSize: "14px",
		align: "center",
		fill: "#ffffff"
	},
	GENERIC_VALUE_STYLE: {
		fontFamily: "FuturaCom-ExtraBoldCond",
		fontSize: "24px",
		align: "center",
		fill: "#ffffff"
	},
	WIN_SITUATION_TEXT: {
		SYM0: {
			fontFamily: "riffic-bold",
			fontSize: "46px",
			align: "center",
			fill: "#e6b800",
			letterSpacing: 2,
			padding: 5,
			stroke: "#ffffff",
			strokeThickness: 8
		},
		SYM1: {
			fontFamily: "riffic-bold",
			fontSize: "46px",
			align: "center",
			fill: "#e6b800",
			letterSpacing: 2,
			padding: 5,
			stroke: "#ffffff",
			strokeThickness: 8
		},
		SYM3: {
			fontFamily: "FuturaCom-ExtraBoldCond",
			fontSize: "46px",
			align: "center",
			fill: "#c60735",
			letterSpacing: 2,
			padding: 5,
			stroke: "#ffb3c9",
			strokeThickness: 8
		},
		SYM4: {
			fontFamily: "FuturaCom-ExtraBoldCond",
			fontSize: "40px",
			align: "center",
			fill: "#d45f11",
			letterSpacing: 2,
			padding: 5,
			stroke: "#f6ec87",
			strokeThickness: 6
		},
		SYM5: {
			fontFamily: "FuturaCom-ExtraBoldCond",
			fontSize: "40px",
			align: "center",
			fill: "#847728",
			letterSpacing: 2,
			padding: 5,
			stroke: "#e6dd9c",
			strokeThickness: 6
		},
		SYM6: {
			fontFamily: "FuturaCom-ExtraBoldCond",
			fontSize: "40px",
			align: "center",
			fill: "#64902b",
			letterSpacing: 2,
			padding: 5,
			stroke: "#bee79b",
			strokeThickness: 6
		},
		SYM7: {
			fontFamily: "FuturaCom-ExtraBoldCond",
			fontSize: "36px",
			align: "center",
			fill: "#85584c",
			letterSpacing: 2,
			padding: 5,
			stroke: "#e1a69b",
			strokeThickness: 4
		},
		SYM8: {
			fontFamily: "FuturaCom-ExtraBoldCond",
			fontSize: "36px",
			align: "center",
			fill: "#6B6E82",
			letterSpacing: 2,
			padding: 5,
			stroke: "#CACCD6",
			strokeThickness: 4
		}
	},
	WIN_BANNER_WIN_TEXT: {
		fontFamily: "riffic-bold",
		fontSize: "54px",
		align: "center",
		fill: "#ffffff",
		letterSpacing: 4,
		padding: 10,
		stroke: "#000000",
		strokeThickness: 4,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 8,
		dropShadowBlur: 0
	},
	WIN_BANNER_COUNT_UP_TEXT: {
		fontFamily: "riffic-bold",
		fontSize: "86px",
		align: "center",
		fill: "#ffe017",
		letterSpacing: 4,
		padding: 10,
		stroke: "#000000",
		strokeThickness: 5,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 10,
		dropShadowBlur: 0
	},
	BETLINE_BUTTON_LABEL: {
		fontFamily: "FuturaCom-ExtraBoldCond",
		fontSize: "20px",
		align: "center",
		fill: "#FFFFFF"
	},
	PROGRESSION_TEXT: {
		fontFamily: "riffic-bold",
		letterSpacing: 4,
		padding: 10,
		fontSize: "32px",
		align: "center",
		fill: "#FCFE84",
		dropShadow: true,
		dropShadowColor: "#1b1849",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 1
	},
	PROGRESSION_TEXT_FS: {
		fontFamily: "riffic-bold",
		letterSpacing: 4,
		padding: 10,
		fontSize: "32px",
		align: "center",
		fill: "#EDDECF",
		dropShadow: true,
		dropShadowColor: "#1b1849",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 1
	},
	LABELS_TEXT_FREESPINMAP: {
		fontFamily: "riffic-bold",
		letterSpacing: 2,
		padding: 10,
		fontSize: "20px",
		align: "center",
		fill: "#f4ea87",
		dropShadow: true,
		dropShadowColor: "#1b1849",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 1
	},
	KEYS_NEEDED_FOR_CASINOS_TEXT: {
		fontFamily: "riffic-bold",
		letterSpacing: 4,
		padding: 10,
		fontSize: "20px",
		fill: "#ffd700"
	},
	BIG_WIN_TEXT: {
		fontFamily: "BodoniPosterCompressed-Bold_DB",
		fontSize: "170px",
		align: "center",
		fill: "#fdcd00",
		padding: 10,
		dropShadow: true,
		dropShadowColor: "#306368",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 5
	},
	MEGA_WIN_TEXT: {
		fontFamily: "BodoniPosterCompressed-Bold_DB",
		fontSize: "170px",
		align: "center",
		fill: "#fdcd00",
		padding: 10,
		dropShadow: true,
		dropShadowColor: "#306368",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 5
	},
	SUPER_MEGA_WIN_TEXT: {
		fontFamily: "BodoniPosterCompressed-Bold_DB",
		fontSize: "170px",
		align: "center",
		fill: "#fdcd00",
		padding: 10,
		dropShadow: true,
		dropShadowColor: "#306368",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 5
	},
	PAYTABLE_LABEL: {
		fontFamily: "riffic-bold",
		fontSize: "30px",
		align: "center",
		fill: "#96e1f6",
		letterSpacing: 2,
		padding: 14,
		dropShadow: true,
		dropShadowColor: "#0f0155",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	PAYTABLE_PAYOUT_LABEL: {
		fontFamily: "riffic-bold",
		fontSize: "30px",
		align: "center",
		fill: "#96e1f6"
	},
	PAYTABLE_PAYOUT_VALUE: {
		fontFamily: "riffic-bold",
		fontSize: "30px",
		align: "center",
		fill: "#f1ee64",
		letterSpacing: 2
	},
	PAYTABLE_TEXT: {
		fontFamily: "NetentStandardUI",
		fontSize: "38px",
		align: "left",
		fill: "#ffffff",
		lineHeight: 46
	},
	PAYTABLE_VOID_PAYS_FIRST: {
		fontFamily: "FuturaCom-MediumCondensed",
		fontSize: "13px",
		textAlign: "center",
		fill: "#ffffff"
	},
	PAYTABLE_VOID_PAYS: {
		fontFamily: "FuturaCom-MediumCondensed",
		fontSize: "14px",
		textAlign: "center",
		fill: "#ffffff"
	},
	PAYTABLE_TEXT_MOBILE: {
		fontFamily: "FuturaCom-MediumCondensed",
		fontSize: "26px",
		align: "left",
		fill: "#ffffff",
		lineHeight: 32
	},
	PAYTABLE_RANDOMD_FEATURES_STARFALL_LABEL: {
		fontFamily: "riffic-bold",
		fontSize: "25px",
		align: "center",
		fill: "#D770F1",
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	PAYTABLE_RANDOMD_FEATURES_DRAGON_LABEL: {
		fontFamily: "riffic-bold",
		fontSize: "25px",
		align: "center",
		fill: "#F4691F",
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	PAYTABLE_RANDOMD_FEATURES_DRUNKEN_LUCK_LABEL: {
		fontFamily: "riffic-bold",
		fontSize: "25px",
		align: "center",
		fill: "#87FE3E",
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	PAYTABLE_RANDOMD_FEATURES_MAGIC_TRANSFORM_LABEL: {
		fontFamily: "riffic-bold",
		fontSize: "25px",
		align: "center",
		fill: "#EAE40F",
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	MAP_INFO_HEADING: {
		fontFamily: "NetentStandardUI",
		fontSize: "32px",
		align: "center",
		fill: "#ffffff"
	},
	MAP_PREVIEW_HEADING: {
		fontFamily: "riffic-bold",
		fontSize: "36px",
		align: "center",
		fill: "#feff84",
		letterSpacing: 2,
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	MAP_PREVIEW_TEXT: {
		fontFamily: "riffic-bold",
		fontSize: "20px",
		align: "center",
		fill: "#ffffff",
		letterSpacing: 2,
		padding: 15,
		wordWrap: true,
		wordWrapWidth: 180
	},
	MAP_PREVIEW_FEATURE: {
		fontFamily: "riffic-bold",
		fontSize: "28px",
		align: "center",
		fill: "#feff84",
		letterSpacing: 1,
		padding: 15,
		stroke: "#ffffff",
		strokeThickness: 4
	},
	MAP_PREVIEW_FREESPINS_LEFT: {
		fontFamily: "riffic-bold",
		fontSize: "18px",
		align: "center",
		fill: "#feff84",
		letterSpacing: 2,
		padding: 15,
		dropShadow: true,
		dropShadowColor: "#08124c",
		dropShadowAngle: 1.5,
		dropShadowDistance: 3,
		dropShadowBlur: 0
	},
	INTRO_CONGRATULATIONS: {
		fontFamily: "riffic-bold",
		fontSize: "58px",
		align: "center",
		fill: "#717cb2",
		stroke: "#ffffff",
		strokeThickness: 6,
		letterSpacing: 5,
		padding: 10,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	INTRO_WELCOME: {
		fontFamily: "riffic-bold",
		fontSize: "44px",
		align: "center",
		fill: "#717cb2",
		stroke: "#ffffff",
		strokeThickness: 5,
		letterSpacing: 5,
		padding: 10,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0,
		wordWrap: true,
		wordWrapWidth: 540
	},
	OUTRO_CONGRATULATIONS: {
		fontFamily: "riffic-bold",
		fontSize: "53px",
		align: "center",
		fill: "#f7decc",
		letterSpacing: 2,
		padding: 10,
		textShadow: "2px 2px 4px #1b1c49",
		dropShadow: true,
		dropShadowColor: "#1b1c49",
		stroke: "#1b1c49",
		strokeThickness: 8,
		dropShadowDistance: 6,
		dropShadowBlur: 0
	},
	OUTRO_YOU_WON: {
		fontFamily: "riffic-bold",
		fontSize: "51px",
		align: "center",
		fill: "#f7decc",
		letterSpacing: 2,
		padding: 5,
		textShadow: "2px 2px 4px #1b1c49",
		dropShadow: true,
		dropShadowColor: "#1b1c49",
		stroke: "#1b1c49",
		strokeThickness: 8,
		dropShadowDistance: 6,
		dropShadowBlur: 0
	},
	OUTRO_COINS: {
		fontFamily: "riffic-bold",
		fontSize: "108px",
		align: "center",
		fill: "#fedc19",
		stroke: "#000000",
		strokeThickness: 8,
		letterSpacing: 5,
		padding: 10,
		textShadow: "2px 2px 4px #1b1c49",
		dropShadow: true,
		dropShadowColor: "#1b1849",
		dropShadowDistance: 5,
		dropShadowBlur: 0
	},
	OUTRO_CASINO: {
		fontFamily: "riffic-bold",
		fontSize: "32px",
		align: "center",
		fill: "#f9f18a",
		letterSpacing: 2,
		padding: 5,
		dropShadow: true,
		dropShadowColor: "#1b1849",
		dropShadowAngle: 1.4,
		dropShadowDistance: 5,
		dropShadowBlur: 0
	},
	FREESPIN_COUNTER_TEXT: {
		fontFamily: "riffic-bold",
		fontSize: "60px",
		align: "center",
		fill: "#ffffff",
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	FREESPIN_COUNTER_NUMBER_FS1: {
		fontFamily: "riffic-bold",
		fontSize: "172px",
		align: "center",
		fill: "#e677ed",
		stroke: "#ffffff",
		strokeThickness: 10,
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	FREESPIN_COUNTER_NUMBER_FS2: {
		fontFamily: "riffic-bold",
		fontSize: "172px",
		align: "center",
		fill: "#FF6600",
		stroke: "#ffffff",
		strokeThickness: 10,
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	FREESPIN_COUNTER_NUMBER_FS3: {
		fontFamily: "riffic-bold",
		fontSize: "172px",
		align: "center",
		fill: "#54EF43",
		stroke: "#ffffff",
		strokeThickness: 10,
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	FREESPIN_COUNTER_NUMBER_FS4: {
		fontFamily: "riffic-semibold",
		fontSize: "172px",
		align: "center",
		fill: "#C7AE60",
		stroke: "#ffffff",
		strokeThickness: 10,
		letterSpacing: 2,
		padding: 8,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowAngle: 0.7,
		dropShadowDistance: 4,
		dropShadowBlur: 0
	},
	TICKER_TAPE_TEXT: {
		fontFamily: "NetentStandardUI",
		fontSize: "20px",
		align: "center",
		fill: "#FFFFFF",
		dropShadow: true,
		dropShadowColor: "#004959",
		dropShadowAngle: 0.785398,
		dropShadowDistance: 3,
		padding: 10,
		miterLimit: 5
	},
	MAP_INFO_TEXT: {
		fontFamily: "NetentStandardUI",
		fontSize: "30px",
		align: "center",
		fill: "#ffffff"
	}
};
Sys.ns("pixiGenericSlot");
pixiGenericSlot.Positions = {
	CONTINUE_BUTTON: {
		position: new PIXI.Point(640, 630),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	SPIN_BUTTON: {
		position: new PIXI.Point(640, 700),
		anchorPoint: new PIXI.Point(0.5, 1)
	},
	PAYTABLE_BUTTON: {
		position: new PIXI.Point(75, 667),
		anchorPoint: new PIXI.Point(0, 0.5)
	},
	PAYTABLE_CLOSE_BUTTON: {
		position: new PIXI.Point(1240, 33),
		anchorPoint: new PIXI.Point(0, 0.5)
	},
	MAX_BET_BUTTON: {
		position: new PIXI.Point(635, 695),
		anchorPoint: new PIXI.Point(0, 1)
	},
	AUTOPLAY_BUTTON: {
		position: new PIXI.Point(645, 695),
		anchorPoint: new PIXI.Point(1, 1)
	},
	MAX_BET_BUTTON_LABEL: {
		position: new PIXI.Point(113, 36),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	AUTOPLAY_BUTTON_LABEL: {
		position: new PIXI.Point(75, 36),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	BET_LEVEL_LABEL: {
		position: new PIXI.Point(330, 641),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	BET_LEVEL_SELECTOR: {
		position: new PIXI.Point(296, 674),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	COIN_VALUE_LABEL: {
		position: new PIXI.Point(960, 641),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	COIN_VALUE_SELECTOR: {
		position: new PIXI.Point(926, 674),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	FS_KEYPAD_TOTAL_WIN: {
		position: new PIXI.Point(640, 660),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	FREESPINS_LEFT_LABEL: {
		position: new PIXI.Point(640, 635),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	FREESPIN_BETLEVEL_LABEL: {
		position: new PIXI.Point(330, 641),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	FREESPIN_BETLEVEL_VALUE: {
		position: new PIXI.Point(330, 674),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	FREESPIN_COINVALUE_LABEL: {
		position: new PIXI.Point(960, 641),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	FREESPIN_COINVALUE_VALUE: {
		position: new PIXI.Point(960, 674),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	BASIC_BET_LABEL: {
		position: new PIXI.Point(207, 641),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	BASIC_BET_VALUE: {
		position: new PIXI.Point(205, 674),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	BASIC_BALANCE_LABEL: {
		position: new PIXI.Point(1140, 641),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	BASIC_BALANCE_VALUE: {
		position: new PIXI.Point(1140, 674),
		anchorPoint: new PIXI.Point(0.5, 0.5)
	},
	BIG_WIN_TEXT: {
		position: new PIXI.Point(640, -70),
		anchorPoint: new PIXI.Point(0.5, 0)
	},
	createCurrentCanvasRectangle: function() {
		var c = Environment.getStageResolution().width,
			b = Environment.getStageResolution().height,
			a = c < b;
		if (a) {
			c = 980
		}
		return new PIXI.Rectangle(0, 0, c, b)
	}
};
Sys.ns("Finn");
(function() {
	Finn.particles = new Sys.Observable();

	function b(u, w, v) {
		Object.defineProperty(v, u, {
			value: w,
			writeable: false,
			enumerable: true,
			configurable: false
		})
	}
	var a = new PIXI.ticker.Ticker(),
		p = pixiGenericSlot.Positions.createCurrentCanvasRectangle();
	particleArray = [];
	b("NO_TINT_COLOUR", 16777215, Finn.particles);
	b("MAXIMUM_PARTICLES_EVER_ALLOWED", 100000, Finn.particles);
	b("DEFAULT_PARTICLE_COUNT", 100, Finn.particles);
	b("DEFAULT_MIN_DELAY", 0, Finn.particles);
	b("DEFAULT_MAX_DELAY", 4000, Finn.particles);
	b("DEFAULT_MIN_HEIGHT_SCALE", 1, Finn.particles);
	b("DEFAULT_MAX_HEIGHT_SCALE", 1, Finn.particles);
	b("DEFAULT_MIN_WIDTH_SCALE", 1, Finn.particles);
	b("DEFAULT_MAX_WIDTH_SCALE", 1, Finn.particles);
	b("DEFAULT_OVERALL_MAX_SCALE", 1, Finn.particles);
	b("DEFAULT_OVERALL_MIN_SCALE", 1, Finn.particles);
	b("DEFAULT_MIN_OPACITY", 1, Finn.particles);
	b("DEFAULT_MAX_OPACITY", 1, Finn.particles);
	b("DEFAULT_MIN_MOVE_SPEED", 2, Finn.particles);
	b("DEFAULT_MAX_MOVE_SPEED", 5, Finn.particles);
	b("DEFAULT_MIN_ROTATING_SPEED", 1, Finn.particles);
	b("DEFAULT_MAX_ROTATING_SPEED", 10, Finn.particles);
	b("DEFAULT_MIN_UPDATE_SPEED", 0, Finn.particles);
	b("DEFAULT_MAX_UPDATE_SPEED", 0.5, Finn.particles);
	b("DEFAULT_POSSIBLE_COLOURS", [16711680, 65280, 255], Finn.particles);
	b("DEFAULT_IMAGE_URL", "confetto", Finn.particles);
	b("DEFAULT_FRAME_COUNT", 1, Finn.particles);
	b("DEFAULT_BOUNDS_RECTANGLE", new PIXI.Rectangle(0, 0, 1280, 720), Finn.particles);
	Finn.particles.createIn = function(u, w) {
		var y = t();
		addParticle = function() {
			var A = l(w, ++z),
				B = particleArray.length === 0;
			particleArray.push(A);
			u.addChild(A);
			if (B) {
				a.start()
			}
		};
		w = g(w);
		for (var x = 1; x <= w.particleCount; x++) {
			var v = s(w.minDelayBeforeStart, w.maxDelayBeforeStart),
				z = 0;
			window.setTimeout(addParticle, v)
		}
		u.addChild(y)
	};
	Finn.particles.getNewParticlePrototype = function() {
		return new d()
	};

	function l(x, u) {
		var y = x.uncolouredTexture,
			A = x.Particle,
			D = x.combinedAndColouredTexture,
			B = s(0, x.coloursArray.length - 1),
			E = B * y.frame.width,
			F = n(y.frame.x + E, y.frame.y, y.frame.width, y.frame.height),
			w = n(F.x, F.y, F.width, F.height),
			G = n(F.x, F.y, F.width, F.height),
			v = new PIXI.Texture(D, w, F, G),
			C = new A(v);
		e.call(C, x);
		C.anchor.x = 0.5 + B;
		C.anchor.y = (1 / C.frameCount) - (1 / C.frameCount / 2);
		C.particleNumber = u;
		var z = C.texture.height / C.frameCount;
		C.texture.trim = new PIXI.Rectangle(F.x, F.y, F.width, z);
		C.init();
		return C
	}

	function d(u) {
		this.constructor(u)
	}
	d.prototype = new PIXI.Sprite();
	d.prototype.alpha = 1;
	d.prototype.frameCount = 1;
	d.prototype.frameProgress = 1;
	d.prototype.rotation = 0;
	d.prototype.rotatingSpeed = 0;
	d.prototype.rotatingDirection = 1;
	d.prototype.movingSpeed = 0;
	d.prototype.updateSpeed = 0;
	d.prototype.boundsRectangle = new PIXI.Rectangle(0, 0, 800, 600);
	d.prototype.anchor.x = 0.5;
	d.prototype.anchor.y = 0.5;
	d.prototype.particleNumber = 0;
	d.prototype.toggles = [];
	d.prototype.tickParticle = function() {};
	d.prototype.init = function() {};
	d.prototype.onGameSizeChanged = function(E, u) {
		var D = u.width / E.width,
			z = u.height / E.height,
			C = this.boundsRectangle.x * D,
			B = this.boundsRectangle.y * z,
			F = this.boundsRectangle.width * D,
			y = this.boundsRectangle.height * z,
			x = this.spawnRectangle.x * D,
			w = this.spawnRectangle.y * z,
			A = this.spawnRectangle.width * D,
			v = this.spawnRectangle.height * z;
		this.boundsRectangle = new PIXI.Rectangle(C, B, F, y);
		this.spawnRectangle = new PIXI.Rectangle(x, w, A, v);
		this.x = this.x * D;
		this.y = this.y * z
	};
	d.prototype.addPropertyToggle = function(v, y, w, x) {
		var u = {};
		u.propertyName = v;
		u.min = y > w ? w : y;
		u.max = y > w ? y : w;
		u.speed = x;
		u.isMovingUp = Math.random() > 0.5;
		u.currentValue = u.isMovingUp ? u.min : u.max;
		this.toggles.push(u);
		if (!this[v]) {
			throw "Attempted to set a toggle effect on non-existent property '" + v + "'. Please ensure that your particle has this property set. (probably set it in particle.init function)."
		}
	};

	function m(v) {
		var u = function(w) {
			d.call(this, w)
		};
		u.prototype = v;
		return u
	}

	function e(u) {
		var v = s(u.minOverallScale * 100, u.maxOverallScale * 100) / 100;
		this.frameCount = u.frameCount;
		this.height = v * this.height * (s(u.minHeightScale * 100, u.maxHeightScale * 100) / 100);
		this.width = v * this.width * (s(u.minWidthScale * 100, u.maxWidthScale * 100) / 100);
		this.minOpacity = u.minOpacity;
		this.maxOpacity = u.maxOpacity;
		this.alpha = s(u.minOpacity * 100, u.maxOpacity * 100) / 100;
		this.x = s(u.spawnRectangle.x, u.spawnRectangle.x + u.spawnRectangle.width);
		this.y = s(u.spawnRectangle.y, u.spawnRectangle.y + u.spawnRectangle.height);
		this.frameProgress = s(0, u.frameCount - 1);
		this.rotation = 0;
		this.rotatingSpeed = s(u.minRotatingSpeed, u.maxRotatingSpeed);
		this.rotatingDirection = s(0, 1) === 0 ? 1 : -1;
		this.movingSpeed = s(u.minMoveSpeed, u.maxMoveSpeed);
		this.updateSpeed = s(u.minUpdateSpeed * 1000, u.maxUpdateSpeed * 1000) / 1000;
		this.boundsRectangle = u.boundsRectangle;
		this.spawnRectangle = u.spawnRectangle;
		this.isAlive = true;
		this.toggles = []
	}

	function s(v, u) {
		if (u < v) {
			throw "Invalid min/max arguments supplied to getRandomIntegerBetween function! (" + v + "/" + u + ")"
		}
		return Math.round((Math.random() * (u - v)) + v)
	}

	function g(u) {
		var v = u || {};
		v.particleCount = f(v.particleCount) ? v.particleCount : Finn.particles.DEFAULT_PARTICLE_COUNT;
		v.minDelayBeforeStart = f(v.minDelayBeforeStart) ? v.minDelayBeforeStart : Finn.particles.DEFAULT_MIN_DELAY;
		v.maxDelayBeforeStart = f(v.maxDelayBeforeStart) ? v.maxDelayBeforeStart : Finn.particles.DEFAULT_MAX_DELAY;
		v.minWidthScale = f(v.minWidthScale) ? v.minWidthScale : Finn.particles.DEFAULT_MIN_WIDTH_SCALE;
		v.maxWidthScale = f(v.maxWidthScale) ? v.maxWidthScale : Finn.particles.DEFAULT_MAX_WIDTH_SCALE;
		v.minHeightScale = f(v.minHeightScale) ? v.minHeightScale : Finn.particles.DEFAULT_MIN_HEIGHT_SCALE;
		v.maxHeightScale = f(v.maxHeightScale) ? v.maxHeightScale : Finn.particles.DEFAULT_MAX_HEIGHT_SCALE;
		v.minOpacity = f(v.minOpacity) ? v.minOpacity : Finn.particles.DEFAULT_MIN_OPACITY;
		v.maxOpacity = f(v.maxOpacity) ? v.maxOpacity : Finn.particles.DEFAULT_MAX_OPACITY;
		v.minMoveSpeed = f(v.minMoveSpeed) ? v.minMoveSpeed : Finn.particles.DEFAULT_MIN_MOVE_SPEED;
		v.maxMoveSpeed = f(v.maxMoveSpeed) ? v.maxMoveSpeed : Finn.particles.DEFAULT_MAX_MOVE_SPEED;
		v.minRotatingSpeed = f(v.minRotatingSpeed) ? v.minRotatingSpeed : Finn.particles.DEFAULT_MIN_ROTATING_SPEED;
		v.maxRotatingSpeed = f(v.maxRotatingSpeed) ? v.maxRotatingSpeed : Finn.particles.DEFAULT_MAX_ROTATING_SPEED;
		v.minUpdateSpeed = f(v.minUpdateSpeed) ? v.minUpdateSpeed : Finn.particles.DEFAULT_MIN_UPDATE_SPEED;
		v.maxUpdateSpeed = f(v.maxUpdateSpeed) ? v.maxUpdateSpeed : Finn.particles.DEFAULT_MAX_UPDATE_SPEED;
		v.maxOverallScale = f(v.maxOverallScale) ? v.maxOverallScale : Finn.particles.DEFAULT_OVERALL_MAX_SCALE;
		v.minOverallScale = f(v.minOverallScale) ? v.minOverallScale : Finn.particles.DEFAULT_OVERALL_MIN_SCALE;
		v.frameCount = f(v.frameCount) ? v.frameCount : Finn.particles.DEFAULT_FRAME_COUNT;
		v.spawnRectangle = v.spawnRectangle || Finn.particles.DEFAULT_BOUNDS_RECTANGLE;
		v.boundsRectangle = v.boundsRectangle || Finn.particles.DEFAULT_BOUNDS_RECTANGLE;
		v.coloursArray = v.coloursArray || Finn.particles.DEFAULT_POSSIBLE_COLOURS;
		v.imageURL = v.imageURL || Finn.particles.DEFAULT_IMAGE_URL;
		v.movingSpeed = s(v.minMoveSpeed, v.maxMoveSpeed);
		v.uncolouredTexture = PIXI.Texture.fromImage(v.imageURL);
		v.combinedAndColouredTexture = o(v.uncolouredTexture, v.coloursArray);
		v.ParticlePrototype = v.ParticlePrototype || d.prototype;
		v.Particle = m(v.ParticlePrototype);
		return v
	}

	function f(u) {
		return !(u === null || u === undefined)
	}

	function r() {
		var u = c.call(this, this.boundsRectangle),
			v = c.call(this, this.spawnRectangle);
		if (u && v) {
			this.isAlive = false
		} else {
			this.frameProgress = this.frameProgress + this.updateSpeed >= this.frameCount ? 0 : this.frameProgress + this.updateSpeed;
			j.call(this)
		}
	}

	function k() {
		var u = [];
		particleArray.forEach(function(v) {
			if (v.isAlive) {
				v.tickParticle();
				q.call(v);
				u.push(v)
			} else {
				v.destroy()
			}
		});
		particleArray = u;
		if (particleArray.length === 0) {
			a.stop()
		}
	}

	function j() {
		this.toggles.forEach(function(u) {
			if (u.isMovingUp) {
				u.currentValue += u.speed;
				u.isMovingUp = u.currentValue > u.max ? false : true
			} else {
				u.currentValue -= u.speed;
				u.isMovingUp = u.currentValue < u.min ? true : false
			}
			this[u.propertyName] = u.currentValue
		}.bind(this))
	}

	function c(w) {
		var x = w.y + w.height,
			y = w.x + w.width,
			u = w.x,
			z = w.y,
			v = this.y + (this.height * this.anchor.y);
		return (this.x > y || this.x < u || this.y > x || v < z)
	}

	function h() {
		var u = pixiGenericSlot.Positions.createCurrentCanvasRectangle();
		particleArray.forEach(function(v) {
			v.onGameSizeChanged(p, u)
		});
		p = u
	}

	function q() {
		var w = Math.floor(this.frameProgress),
			v = this.texture.height / this.frameCount,
			u = this.texture.orig,
			x = u.y + (v * w);
		this.texture.frame = new PIXI.Rectangle(u.x, x, u.width, v);
		r.call(this)
	}

	function o(v, w) {
		var B = new PIXI.Container(),
			u = 0;
		for (var C = 0; C < w.length; C++) {
			var A = w[C],
				z = new PIXI.Sprite(v);
			B.addChild(z);
			z.tint = A;
			z.x = u;
			z.y = 0;
			u += z.width
		}
		var y = Game.stage.view.animationManager.renderer.generateTexture(B);
		return y
	}

	function n(v, z, w, u) {
		return new PIXI.Rectangle(Math.floor(v), Math.floor(z), Math.floor(w), Math.floor(u))
	}

	function t() {
		var u = {
			scale: true,
			position: true,
			rotation: true,
			uvs: true,
			alpha: true
		};
		return new PIXI.particles.ParticleContainer(Finn.particles.MAXIMUM_PARTICLES_EVER_ALLOWED, u)
	}
	a.add(k);
	Finn.particles.addListener("notify:scaling.gameSizeChanged", h)
}());
Sys.ns("Finn");
Finn.IntroMovie = {
	constructor: function() {
		Finn.IntroMovie.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model;
		return {
			showingIntroMovie: {
				state: {
					name: "ShowingIntroMovie",
					execute: function() {},
					waitEvents: {
						"notify:introMovie.closed": false
					}
				}
			},
			beforeLoaderClose: {
				queue: [function(b) {
					if (a.shouldShowIntroMovie()) {
						b.stateHandler.pushState(b.states.showingIntroMovie)
					}
				}]
			},
			setupGame: {
				waitEvents: ["notify:introMovie.buffered"]
			}
		}
	},
	getMixinDependencies: function() {
		return ["animation"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.IntroMovieModel,
			controller: Finn.IntroMovieController,
			view: Finn.IntroMovieView
		}
	}
};
Finn.IntroMovie = Sys.extend(Core.Module, Finn.IntroMovie, "Finn.IntroMovie");
Sys.ns("Finn");
Finn.IntroMovieController = {
	constructor: function() {
		Finn.IntroMovieController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Finn.IntroMovieController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"notify:stateHandler.enteringShowingIntroMovieState": a.show,
			"view:animationComplete": a.close,
			"view:introMovieBuffered": a.onIntroMovieBuffered,
			"notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
			"notify:stateHandler.enteringFeatureSplashState": a.enteringFeatureSplashStateHandler,
			"request:introMovie.close": a.close.bind(a),
			canplaythrough: a.view.onCanPlayThroughHack.bind(a.view),
			ended: a.view.onVideoEnded.bind(a.view)
		})
	},
	onIntroMovieBuffered: function() {
		var a = this;
		a.fireEvent("notify:introMovie.buffered")
	},
	close: function() {
		var a = this;
		a.fireEvent("request:ambienceManager.ambiencePauseSwitch", false);
		a.fireEvent("request:stage.lower");
		a.fireEvent("notify:introMovie.closed");
		Services.storage.storeData("IntroMovie.showing", false);
		a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
		a.fireEvent("request:enableBasicGamePanel", a.MODULE_NAME);
		a.view.stop();
		if (a.model.readData("showFeatureSplash") === false) {
			a.view.hide()
		}
	},
	show: function() {
		var a = this;
		if (a.model.shouldShowIntroMovie()) {
			a.fireEvent("request:ambienceManager.ambiencePauseSwitch", true);
			a.fireEvent("request:stage.elevate");
			Services.storage.storeData("IntroMovie.showing", true);
			a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
			a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
			a.view.play()
		}
	},
	enteringFeatureSplashStateHandler: function() {
		var a = this;
		if (a.model.readData("showFeatureSplash")) {
			a.view.hide()
		}
	},
	onModulesFinishedLoading: function() {
		var a = this;
		Services.storage.storeData("shouldShowIntroMovie", a.model.shouldShowIntroMovie())
	}
};
Finn.IntroMovieController = Sys.extend(Core.Controller, Finn.IntroMovieController, "Finn.IntroMovieController");
Sys.ns("Finn");
Finn.IntroMovieModel = {
	constructor: function() {
		Finn.IntroMovieModel.superclass.constructor.apply(this, arguments)
	},
	shouldShowIntroMovie: function() {
		return this.readData("initNotRestore") && Services.settingsManager.getSetting("showIntroMovie") && this.readData("shouldShowIntroMovie")
	},
	setupData: function() {
		var c = Resources.readData("gameServerInitResponse"),
			b = Environment.platform === "desktop",
			a = (Services.localStorageManager.hasData("showFeatureSplash") && Services.localStorageManager.readData("showFeatureSplash") === "true");
		this.storeData("initNotRestore", c.clientaction === "init" && c.restore !== true);
		Services.storage.storeData("IntroMovie.showing", false);
		this.storeData("showFeatureSplash", a);
		this.storeData("shouldShowIntroMovie", b)
	}
};
Finn.IntroMovieModel = Sys.extend(Core.Model, Finn.IntroMovieModel, "Finn.IntroMovieModel");
Sys.ns("Finn");
Finn.IntroMovieView = {
	SRC: "introMovie",
	constructor: function() {
		Finn.IntroMovieView.superclass.constructor.apply(this, arguments)
	},
	callbackMouseClick: function(c, a) {
		var b = this;
		b.close()
	},
	initAnimations: function() {
		var d = this,
			b = Environment.getStageResolution();
		d.rootContainer = new PIXI.Container();
		d.rootContainer.interactive = true;
		d.introMovieElement = Game.PIXIFactory.createVideoElement(d.SRC, false, false);
		d.introMovieSprite = Game.PIXIFactory.createAndAddVideo(d.introMovieElement, d.rootContainer, new PIXI.Point(0, 0), new PIXI.Point(0, 0));
		d.introMovieElement.addEventListener("canplaythrough", d.onCanPlayThrough.bind(d));
		d.introMovieElement.addEventListener("ended", d.onVideoEnded.bind(d));
		var a = Services.languageManager.getText(Language.Keys.skipIntro);
		d.skipButton = new Interface.utils.PIXILabel(a, Game.TextStyles.SKIP_INTRO_STYLE);
		d.skipButton.id = "FeatureSplashContinue";
		d.skipButton.clickCallback = d.callbackMouseClick.bind(d);
		d.skipButton.x = (b.width - d.skipButton.width) / 2;
		d.skipButton.y = b.height - d.skipButton.height - 20;
		d.rootContainer.addChild(d.skipButton);
		var c = Game.stage.view.animationManager.getLayer("introMovie");
		c.addChild(d.rootContainer);
		d.rootContainer.visible = false
	},
	onVideoEnded: function() {
		this.close()
	},
	close: function() {
		this.fireEvent("view:animationComplete")
	},
	onCanPlayThroughHack: function() {
		if (!Platform.isIEBrowser) {
			this.onCanPlayThrough()
		}
	},
	onCanPlayThrough: function() {
		this.fireEvent("view:introMovieBuffered")
	},
	stop: function() {
		var a = this;
		a.introMovieElement.pause();
		if (Platform.isEdgeBrowser) {
			Game.PIXIFactory.resetMSEdgeVideo("introMovie")
		}
		a.skipButton.visible = false;
		a.introMovieElement = undefined
	},
	hide: function() {
		var a = this;
		a.rootContainer.removeChild(a.introMovieSprite);
		a.introMovieSprite = undefined;
		a.rootContainer.visible = false
	},
	play: function() {
		var c = this;
		c.rootContainer.visible = true;
		c.introMovieElement.currentTime = 0;
		var b = c.introMovieElement.play();

		function d() {}

		function a() {
			c.close()
		}
		if (Platform.isEdgeBrowser) {
			Game.PIXIFactory.playMSEdgeVideo("introMovie")
		} else {
			if (b !== undefined) {
				b.then(d, a)
			}
		}
	}
};
Finn.IntroMovieView = Sys.extend(Core.View, Finn.IntroMovieView, "Finn.IntroMovieView");
Sys.ns("Finn");
Finn.FeatureSplash = {
	constructor: function() {
		Finn.FeatureSplash.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput"]
	},
	getStateChanges: function() {
		var b = this,
			a = b.model;
		return {
			featureSplash: {
				state: {
					name: "FeatureSplash",
					execute: function() {},
					waitEvents: {
						"notify:featureSplash.closed": false
					}
				}
			},
			beforeLoaderClose: {
				queue: [function(c) {
					if (a.readData("animationRequested")) {
						c.stateHandler.pushState(c.states.featureSplash)
					}
				}]
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.FeatureSplashModel,
			controller: Finn.FeatureSplashController,
			view: Finn.FeatureSplashView
		}
	}
};
Finn.FeatureSplash = Sys.extend(Core.Module, Finn.FeatureSplash, "Finn.FeatureSplash");
Sys.ns("Finn");
Finn.FeatureSplashController = {
	AUTO_CLOSE_DURATION: 30000,
	constructor: function() {
		Finn.FeatureSplashController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringFeatureSplashState": a.start,
			"request:featureSplash.close": a.close,
			"notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
			"view:closed": a.onClosed,
			"view:checkboxClicked": a.onCheckboxClicked,
			"notify:scaling.gameSizeChanged": this.view.onGameSizeChanged.bind(this.view)
		})
	},
	start: function() {
		var a = this;
		this.autoCloseTimeOut = setTimeout(a.close.bind(a), a.AUTO_CLOSE_DURATION);
		a.fireEvent("request:logo.hide");
		if (a.model.readData("animationRequested") && a.model.getShowNextTime() === true) {
			a.show()
		} else {
			a.onClosed()
		}
	},
	show: function() {
		var a = this;
		a.fireEvent("request:character.hide");
		a.fireEvent("request:keyCounter.hide");
		a.fireEvent("request:keyCounter.hideMgKeyCounter");
		a.view.show();
		a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
		a.fireEvent("notify:featureSplash.showing")
	},
	close: function() {
		var a = this;
		a.view.close();
		a.clearTimeouts();
		a.off();
		a.removeListener("notify:scaling.gameSizeChanged")
	},
	clearTimeouts: function() {
		var a = this;
		if (Sys.isDefined(a.autoCloseTimeOut)) {
			clearTimeout(a.autoCloseTimeOut)
		}
	},
	onClosed: function() {
		var a = this;
		a.stopListeningToUserInput();
		a.fireEvent("request:enableBasicGamePanel", a.MODULE_NAME);
		a.fireEvent("request:spinButton.show", a.MODULE_NAME);
		a.fireEvent("request:logo.show");
		a.fireEvent("notify:featureSplash.closed");
		a.fireEvent("request:keyCounter.show");
		a.fireEvent("request:character.show");
		clearTimeout(a.autoCloseTimeOut)
	},
	onCheckboxClicked: function() {
		var a = this,
			b = a.model.getShowNextTime();
		a.model.setShowNextTime(!b);
		a.view.updateCheckBox();
		a.fireEvent("request:settingsManager.storeData", "showFeatureSplash", !b, true)
	},
	onLeavingIdleState: function() {
		var a = this;
		a.close()
	}
};
Finn.FeatureSplashController = Sys.extend(Core.Controller, Finn.FeatureSplashController, "Finn.FeatureSplashController");
Sys.ns("Finn");
Finn.FeatureSplashModel = {
	constructor: function() {
		Finn.FeatureSplashModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = this;
		if (b.gamestate.current === "basic" && b.clientaction === "init" && b.restore === false) {
			a.storeData("animationRequested", true)
		} else {
			a.storeData("animationRequested", false)
		}
	},
	setupData: function() {
		var a = this,
			b = (Services.localStorageManager.hasData("showFeatureSplash") && Services.localStorageManager.readData("showFeatureSplash") === "true");
		a.setShowNextTime(b)
	},
	setShowNextTime: function(a) {
		this.storeData("showNextTime", a)
	},
	getShowNextTime: function() {
		var a = this;
		return a.readData("showNextTime")
	}
};
Finn.FeatureSplashModel = Sys.extend(Core.Model, Finn.FeatureSplashModel, "Finn.FeatureSplashModel");
Sys.ns("Finn");
Finn.FeatureSplashView = {
	BACKGROUND: {
		LANDSCAPE: {
			image: "featureSplashBackground",
			x: 0,
			y: 0
		},
		PORTRAIT: {
			image: "featureSplashBackgroundPortrait",
			x: 147,
			y: -117
		}
	},
	NETENT_PRODUCTION: {
		image: "netentProduction",
		x: 1120,
		y: 16
	},
	CONTINUE_BOX: {
		LANDSCAPE: {
			x: 540,
			y: 585
		},
		PORTRAIT: {
			x: 530,
			y: 940
		},
		button: {
			x: 0,
			y: 0,
			textKey: Language.Keys.continueButton,
			images: {
				idle: "continueButtonIdle",
				click: "continueButtonClick",
				hover: "continueButtonHover",
				disabled: "continueButtonDisabled"
			}
		},
		CHECKBOX: {
			LANDSCAPE: {
				x: 20,
				y: 64,
				labelPosition: Environment.platform !== "desktop" ? new PIXI.Point(37, 8) : new PIXI.Point(33, 5)
			},
			PORTRAIT: {
				x: 20,
				y: 85,
				labelPosition: new PIXI.Point(37, 10)
			},
			textKey: Language.Keys.dontShowNextTime,
			IMAGES: {
				checkIdle: "checkBoxUnchecked",
				checkClick: "checkBoxUnchecked",
				checkHover: "checkBoxUnchecked",
				checkDisabled: "checkBoxUnchecked",
				unCheckIdle: "checkBoxChecked",
				unCheckClick: "checkBoxChecked",
				unCheckHover: "checkBoxChecked",
				unCheckDisabled: "checkBoxChecked"
			}
		}
	},
	constructor: function() {
		Finn.FeatureSplashView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var c = this,
			b = new PIXI.Point(0, 0);
		c.rootContainer = new PIXI.Container();
		c.rootContainer.name = "FeatureSplash";
		c.backgroundContainer = new PIXI.Container();
		c.rootContainer.addChild(c.backgroundContainer);
		c.landscapeBackground = Game.PIXIFactory.createSpriteWithTexture(c.BACKGROUND.LANDSCAPE.image, new PIXI.Point(c.BACKGROUND.LANDSCAPE.x, c.BACKGROUND.LANDSCAPE.y), b);
		c.portraitBackground = Game.PIXIFactory.createSpriteWithTexture(c.BACKGROUND.PORTRAIT.image, new PIXI.Point(c.BACKGROUND.PORTRAIT.x, c.BACKGROUND.PORTRAIT.y), b);
		c.netentProduction = Game.PIXIFactory.createAndAddSprite(c.NETENT_PRODUCTION.image, c.rootContainer, new PIXI.Point(c.NETENT_PRODUCTION.x, c.NETENT_PRODUCTION.y), b);
		c.continueButton = new Interface.utils.PIXIButton(c.CONTINUE_BOX.button.images.idle, c.CONTINUE_BOX.button.images.click, c.CONTINUE_BOX.button.images.hover, c.CONTINUE_BOX.button.images.disabled);
		c.continueButton.id = "featureSplashView.ContinueButton";
		c.continueButton.setLabel(Services.languageManager.getText(c.CONTINUE_BOX.button.textKey));
		c.continueButton.setLabelStyle(Game.TextStyles.CONTINUE_BUTTON);
		c.continueButton.setLabelPosition(new PIXI.Point((c.continueButton.width / 2), (c.continueButton.height / 2)));
		c.continueButton.setLabelAnchorPoint(new PIXI.Point(0.5, 0.5));
		c.continueButton.redraw();
		c.continueButton.clickCallback = c.callbackContinueClick.bind(c);
		c.continueButton.x = c.CONTINUE_BOX.button.x;
		c.continueButton.y = c.CONTINUE_BOX.button.y;
		c.showAgainCheckbox = new Interface.utils.PIXICheckBox(c.CONTINUE_BOX.CHECKBOX.IMAGES.checkIdle, c.CONTINUE_BOX.CHECKBOX.IMAGES.checkClick, c.CONTINUE_BOX.CHECKBOX.IMAGES.checkHover, c.CONTINUE_BOX.CHECKBOX.IMAGES.checkDisabled, c.CONTINUE_BOX.CHECKBOX.IMAGES.unCheckIdle, c.CONTINUE_BOX.CHECKBOX.IMAGES.unCheckClick, c.CONTINUE_BOX.CHECKBOX.IMAGES.unCheckHover, c.CONTINUE_BOX.CHECKBOX.IMAGES.unCheckDisabled);
		c.showAgainCheckbox.check = Game.PIXIFactory.createAndAddSprite("featureCheckboxCheck", c.showAgainCheckbox, b, b);
		c.showAgainCheckbox.id = "featureSplashView.Checkbox";
		c.showAgainCheckbox.setLabel(Services.languageManager.getText(c.CONTINUE_BOX.CHECKBOX.textKey));
		c.showAgainCheckbox.setLabelStyle(Game.TextStyles.SKIP_CHECK_BOX);
		c.showAgainCheckbox.clickCallback = c.callbackCheckboxClick.bind(c);
		c.continueBox = new Interface.utils.PIXIVBox();
		c.continueButton.id = "continueBox";
		c.continueBox.setHorizontalAlign("left");
		c.continueBox.setVerticalAlign("top");
		c.continueBox.addChild(c.continueButton);
		c.continueBox.addChild(c.showAgainCheckbox);
		c.rootContainer.addChild(c.continueBox);
		var a = Game.stage.view.animationManager.getLayer("splashScreensContent");
		a.addChild(c.rootContainer);
		c.rootContainer.visible = false;
		this.onGameSizeChanged()
	},
	onGameSizeChanged: function() {
		var b = Environment.viewportOrientation === "PORTRAIT",
			a = b ? "PORTRAIT" : "LANDSCAPE";
		this.backgroundContainer.removeChildren();
		this.backgroundContainer.addChild(b ? this.portraitBackground : this.landscapeBackground);
		this.continueBox.y = this.CONTINUE_BOX[a].y;
		this.continueBox.x = this.CONTINUE_BOX[a].x;
		this.showAgainCheckbox.x = this.CONTINUE_BOX.CHECKBOX[a].x;
		this.showAgainCheckbox.y = this.CONTINUE_BOX.CHECKBOX[a].y;
		this.showAgainCheckbox.setLabelPosition(this.CONTINUE_BOX.CHECKBOX[a].labelPosition)
	},
	callbackCheckboxClick: function(c, a) {
		var b = this;
		b.fireEvent("view:checkboxClicked")
	},
	showHTMLGameFooter: function(b) {
		var d = [document.getElementById("homeButton"), document.getElementById("soundOnOffButton"), document.getElementById("spinButton"), document.getElementById("coinsField"), document.getElementById("coinsField_betAndBalance_balanceDisplay"), document.getElementsByClassName("interface-settingsButton_baseButton")[0]];
		d.forEach(function(g) {
			if (g) {
				var f = g.getAttribute("class"),
					h = b && f ? f.replace("hidden", "") : f + " hidden";
				g.setAttribute("class", h)
			}
		});
		var c = document.getElementById("gameFooter"),
			a = c.getAttribute("class"),
			e = b ? a.replace("splash", "") : a + " splash";
		c.setAttribute("class", e)
	},
	updateCheckBox: function() {
		var a = this;
		a.showAgainCheckbox.selected = !a.model.getShowNextTime()
	},
	callbackContinueClick: function(c, a) {
		var b = this;
		b.close()
	},
	show: function() {
		var a = this;
		a.updateCheckBox();
		if (!Platform.isDesktopDevice) {
			a.showHTMLGameFooter(false)
		}
		a.rootContainer.visible = true
	},
	close: function() {
		var a = this;
		a.rootContainer.visible = false;
		if (!Platform.isDesktopDevice) {
			a.showHTMLGameFooter(true)
		}
		a.fireEvent("view:closed")
	}
};
Finn.FeatureSplashView = Sys.extend(Core.View, Finn.FeatureSplashView, "Finn.FeatureSplashView");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.SpinButtonDesktopView = {
	constructor: function() {
		pixiGenericSlot.SpinButtonDesktopView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var c = this,
			b = Game.stage.view.animationManager.getLayer("userInterface");
		c.spinButton = new Interface.utils.PIXIButton("spinButtonIdle", "spinButtonDown", "spinButtonOver", "spinButtonDisabled");
		c.spinButton.id = c.MODULE_NAME + ".spinButton";
		c.spinButton.moveToPosition(pixiGenericSlot.Positions.SPIN_BUTTON);
		c.spinButton.clickCallback = c.callbackMouseClick.bind(c);
		var a = c.spinButton.width / 2;
		c.spinButton.setCustomHitArea(new PIXI.Circle(a, c.spinButton.height / 2, a));
		b.addChild(c.spinButton)
	},
	callbackMouseClick: function() {
		var a = this;
		a.fireEvent("view:clicked")
	},
	press: function() {
		var a = this;
		a.fireEvent("view:playSound", a.SOUND_DOWN);
		a.fireEvent("view:notify", "notify:spinButton.down");
		if (a.buttonItem) {
			a.buttonItem.prop.image = a.IMAGE_DOWN
		}
	},
	release: function() {
		if (this.buttonItem) {
			this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
		}
	},
	hide: function() {
		var a = this;
		if (a.model.hasProperty("hidden") || !a.model.hasProperty("visibleDuringRound")) {
			a.spinButton.visible = false;
			a.fireEvent("view:hidden")
		}
	},
	hidden: function() {
		return this.spinButton.visible
	},
	show: function() {
		var a = this;
		a.spinButton.visible = true;
		this.fireEvent("view:shown")
	},
	enable: function() {
		this.spinButton.setEnabled(true)
	},
	disable: function() {
		var a = this;
		a.spinButton.setEnabled(false)
	},
	enableSpinningAnimations: function() {},
	disableSpinningAnimations: function() {},
	userInputStart: function() {},
	userInputMove: function() {},
	userInputHover: function() {},
	userInputEnd: function() {}
};
pixiGenericSlot.SpinButtonDesktopView = Sys.extend(Interface.Slots.SpinButtonDesktopView, pixiGenericSlot.SpinButtonDesktopView, "pixiGenericSlot.SpinButtonDesktopView");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.MaxBetButtonDesktopView = {
	constructor: function() {
		pixiGenericSlot.MaxBetButtonDesktopView.superclass.constructor.apply(this, arguments)
	},
	setUpKeypadButton: function() {
		var b = this,
			a = Game.stage.view.animationManager.getLayer("userInterface");
		b.keypadButton = new Interface.utils.PIXIButton("maxBetButtonUp", "maxBetButtonDown", "maxBetButtonOver", "maxBetButtonDisabled");
		b.keypadButton.id = "maxBetButton";
		b.keypadButton.setLabel(Services.languageManager.getText(Language.Keys.btn_maxbet));
		b.keypadButton.setLabelUpStyle(Game.TextStyles.MAX_BET_BUTTON_UP);
		b.keypadButton.setLabelDownStyle(Game.TextStyles.MAX_BET_BUTTON_DOWN);
		b.keypadButton.setLabelOverStyle(Game.TextStyles.MAX_BET_BUTTON_OVER);
		b.keypadButton.setLabelDisabledStyle(Game.TextStyles.MAX_BET_BUTTON_DISABLED);
		b.keypadButton.setLabelPosition(pixiGenericSlot.Positions.MAX_BET_BUTTON_LABEL.position);
		b.keypadButton.setLabelAnchorPoint(pixiGenericSlot.Positions.MAX_BET_BUTTON_LABEL.anchorPoint);
		b.keypadButton.moveToPosition(pixiGenericSlot.Positions.MAX_BET_BUTTON);
		b.keypadButton.clickCallback = b.onButtonClick.bind(b);
		b.keypadButton.setLabelMaxWidth(115);
		a.addChild(b.keypadButton);
		var c = [new PIXI.Point(31, 0), new PIXI.Point(163, 0), new PIXI.Point(167, 2), new PIXI.Point(176, 11), new PIXI.Point(182, 25), new PIXI.Point(181, 46), new PIXI.Point(175, 57), new PIXI.Point(166, 65), new PIXI.Point(0, 65), new PIXI.Point(2, 61), new PIXI.Point(11, 59), new PIXI.Point(20, 54), new PIXI.Point(28, 46), new PIXI.Point(34, 35), new PIXI.Point(36, 28), new PIXI.Point(36, 12)];
		b.keypadButton.setCustomHitArea(new PIXI.Polygon(c))
	},
	updateKeypadButtonEnabledState: function() {
		var a = this.model.hasProperty("keypadButtonDisabled") === false;
		this.keypadButton.setEnabled(a)
	},
	updateKeypadButtonVisibility: function() {
		var a = this.model.hasProperty("keypadButtonHidden") === false;
		this.keypadButton.visible = a
	},
	enable: function(a) {
		this.model.removeProperty("keypadButtonDisabled", a);
		this.updateKeypadButtonEnabledState()
	},
	disable: function(a) {
		this.model.addProperty("keypadButtonDisabled", a);
		this.updateKeypadButtonEnabledState()
	},
	show: function(b) {
		var a = this;
		a.model.removeProperty("keypadButtonHidden", b);
		a.updateKeypadButtonVisibility()
	},
	hide: function(b) {
		var a = this;
		a.model.addProperty("keypadButtonHidden", b);
		a.updateKeypadButtonVisibility()
	}
};
pixiGenericSlot.MaxBetButtonDesktopView = Sys.extend(Interface.Slots.MaxBetButtonBaseView, pixiGenericSlot.MaxBetButtonDesktopView, "pixiGenericSlot.MaxBetButtonDesktopView");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.MaxBetButton = {
	constructor: function() {
		pixiGenericSlot.MaxBetButton.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "trigger", "properties"]
	}
};
pixiGenericSlot.MaxBetButton = Sys.extend(Interface.Slots.MaxBetButton, pixiGenericSlot.MaxBetButton, "pixiGenericSlot.MaxBetButton");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.MaxBetButtonController = {
	constructor: function() {
		pixiGenericSlot.MaxBetButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		pixiGenericSlot.MaxBetButtonController.superclass.setupEvents.apply(this, arguments);
		var a = this;
		a.on({
			"request:maxBetButton.hide": a.view.hide.bind(a.view),
			"request:maxBetButton.show": a.view.show.bind(a.view)
		})
	}
};
pixiGenericSlot.MaxBetButtonController = Sys.extend(Interface.Slots.MaxBetButtonController, pixiGenericSlot.MaxBetButtonController, "pixiGenericSlot.MaxBetButtonController");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.AutoplaySettings = {
	constructor: function() {
		pixiGenericSlot.AutoplaySettings.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["userInput", "animation", "properties"]
	}
};
pixiGenericSlot.AutoplaySettings = Sys.extend(Interface.AutoplaySettings, pixiGenericSlot.AutoplaySettings, "pixiGenericSlot.AutoplaySettings");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.AutoplaySettingsController = {
	constructor: function() {
		pixiGenericSlot.AutoplaySettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		pixiGenericSlot.AutoplaySettingsController.superclass.setupEvents.apply(this, arguments);
		var a = this;
		a.on({
			"request:autoplayButton.hide": a.view.hideKeypadButton.bind(a.view),
			"request:autoplayButton.show": a.view.showKeypadButton.bind(a.view)
		})
	}
};
pixiGenericSlot.AutoplaySettingsController = Sys.extend(Interface.AutoplaySettingsController, pixiGenericSlot.AutoplaySettingsController, "pixiGenericSlot.AutoplaySettingsController");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.AutoplaySettingsView = {
	ADVANCED_CONFIG_CONTROLS: [{
		id: "stopAutoplayOnAnyWin",
		label: Language.Keys.autoplay_setting_onAnyWin,
		type: "checkbox"
	}, {
		id: "stopAutoplayIfFreeSpinWon",
		label: Language.Keys.autoplay_setting_ifFreeSpinsIsStarted,
		type: "checkbox"
	}, {
		id: "stopAutoplayIfAutoplayingBonusGameWon",
		label: Language.Keys.autoplay_setting_ifFBonusIsStarted,
		type: "checkbox",
		disabled: true
	}, {
		id: "stopAutoplayIfWinExceeds",
		label: Language.Keys.autoplay_setting_ifWinExeeds,
		type: "checkbox",
		withInput: {
			label: undefined
		}
	}, {
		id: "stopAutoplayIfBalanceIncreasedBy",
		label: Language.Keys.autoplay_setting_ifCashIncreasesBy,
		type: "checkbox",
		withInput: {
			label: undefined
		}
	}, {
		id: "stopAutoplayIfBalanceDecreasedBy",
		label: Language.Keys.autoplay_setting_ifCashDecreasesBy,
		type: "checkbox",
		withInput: {
			label: undefined
		}
	}],
	constructor: function() {
		pixiGenericSlot.AutoplaySettingsView.superclass.constructor.apply(this, arguments)
	},
	setUpKeypadButton: function() {
		var b = this,
			a = Game.stage.view.animationManager.getLayer("userInterface");
		b.fireEvent("request:quickStopper.enableInMode", "autoPlay");
		b.keypadButton = new Interface.utils.PIXIButton("autoPlayButtonUp", "autoPlayButtonDown", "autoPlayButtonOver", "autoPlayButtonDisabled");
		b.keypadButton.id = "autoPlayButton";
		b.keypadButton.setLabel(Services.languageManager.getText(Language.Keys.btn_autoplay));
		b.keypadButton.setLabelUpStyle(Game.TextStyles.AUTOPLAY_BUTTON_UP);
		b.keypadButton.setLabelDownStyle(Game.TextStyles.AUTOPLAY_BUTTON_DOWN);
		b.keypadButton.setLabelOverStyle(Game.TextStyles.AUTOPLAY_BUTTON_OVER);
		b.keypadButton.setLabelDisabledStyle(Game.TextStyles.AUTOPLAY_BUTTON_DISABLED);
		b.keypadButton.setLabelPosition(pixiGenericSlot.Positions.AUTOPLAY_BUTTON_LABEL.position);
		b.keypadButton.setLabelAnchorPoint(pixiGenericSlot.Positions.AUTOPLAY_BUTTON_LABEL.anchorPoint);
		b.keypadButton.moveToPosition(pixiGenericSlot.Positions.AUTOPLAY_BUTTON);
		b.keypadButton.clickCallback = b.onButtonClick.bind(b);
		b.keypadButton.setLabelMaxWidth(115);
		a.addChild(b.keypadButton);
		var c = [new PIXI.Point(19, 0), new PIXI.Point(151, 0), new PIXI.Point(146, 12), new PIXI.Point(146, 28), new PIXI.Point(148, 35), new PIXI.Point(154, 46), new PIXI.Point(162, 54), new PIXI.Point(171, 59), new PIXI.Point(180, 61), new PIXI.Point(182, 65), new PIXI.Point(16, 65), new PIXI.Point(7, 57), new PIXI.Point(1, 46), new PIXI.Point(0, 25), new PIXI.Point(6, 11), new PIXI.Point(15, 2)];
		b.keypadButton.setCustomHitArea(new PIXI.Polygon(c))
	},
	updateKeypadButtonEnabledState: function() {
		var a = this.model.hasProperty("keypadButtonDisabled") === false;
		this.keypadButton.setEnabled(a)
	},
	updateKeypadButtonVisibility: function() {
		var a = this.model.hasProperty("keypadButtonHidden") === false;
		this.keypadButton.visible = a
	},
	showKeypadButton: function(b) {
		var a = this;
		a.model.removeProperty("keypadButtonHidden", b);
		a.updateKeypadButtonVisibility()
	},
	hideKeypadButton: function(b) {
		var a = this;
		a.model.addProperty("keypadButtonHidden", b);
		a.updateKeypadButtonVisibility()
	},
	enableKeypadButton: function(c) {
		var b = this,
			a;
		if (Sys.isDefined(b.keypadButton)) {
			b.enable(c)
		} else {
			a = b.keypadPendingDisable.indexOf(c);
			if (a >= 0) {
				b.keypadPendingDisable.splice(a, 1)
			}
		}
	},
	disableKeypadButton: function(b) {
		var a = this;
		if (Sys.isDefined(a.keypadButton)) {
			a.disable(b)
		} else {
			if (!a.keypadPendingDisable.contains(b)) {
				a.keypadPendingDisable.push(b)
			}
		}
	},
	enable: function(a) {
		this.model.removeProperty("keypadButtonDisabled", a);
		this.updateKeypadButtonEnabledState()
	},
	disable: function(a) {
		this.model.addProperty("keypadButtonDisabled", a);
		this.updateKeypadButtonEnabledState()
	}
};
pixiGenericSlot.AutoplaySettingsView = Sys.extend(Interface.AutoplaySettingsView, pixiGenericSlot.AutoplaySettingsView, "pixiGenericSlot.AutoplaySettingsView");
Sys.ns("Finn");
Finn.CoinsFieldMobileView = {
	constructor: function() {
		Finn.CoinsFieldMobileView.superclass.constructor.apply(this, arguments)
	},
	showWin: function() {}
};
Finn.CoinsFieldMobileView = Sys.extend(Interface.Slots.CoinsFieldMobileView, Finn.CoinsFieldMobileView, "Finn.CoinsFieldMobileView");
Sys.ns("Finn");
Finn.CoinsFieldDesktopView = {
	FREESPINS_LEFT_LANGUAGE_KEY: "freeSpinsLeftUC",
	FS_TEXT_MAX_WIDTH: 500,
	BACKGROUND_ALPHA: 0.8,
	BACKGROUND_COLOR: 0,
	constructor: function() {
		Finn.CoinsFieldDesktopView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var d = this,
			c = Game.stage.view.animationManager.getLayer("userInterface"),
			f = new PIXI.Container(),
			b, e, a;
		f.position.x = 0;
		f.position.y = 0;
		f.id = d.MODULE_NAME + ".rootContainer";
		d.createKeypadBackground();
		b = new PIXI.Container();
		b.x = 0;
		b.y = 0;
		b.visible = true;
		f.addChild(b);
		e = new PIXI.Container();
		e.x = 0;
		e.y = 0;
		e.visible = false;
		f.addChild(e);
		a = new PIXI.Container();
		a.x = 0;
		a.y = 0;
		a.visible = false;
		f.addChild(a);
		d.basicStateContainer = b;
		d.freeSpinsStateContainer = e;
		d.totalWinFieldContainer = a;
		d.rootContainer = f;
		d.setupTextFields();
		c.addChild(f);
		d.onGameModeChanged("BASIC")
	},
	createKeypadBackground: function() {
		var b = this;
		var a = Game.stage.view.animationManager.getLayer("keypadBackground");
		b.keypadBackgroundContainer = new PIXI.Container();
		b.keypadBackgroundImage = Game.PIXIFactory.createAndAddSprite("keypadBackground", b.keypadBackgroundContainer, new PIXI.Point(0, 631));
		b.keypadBackgroundContainer.addChild(b.keypadBackgroundImage);
		a.addChild(b.keypadBackgroundContainer)
	},
	setupTextFields: function() {
		var c = this;
		c.betLableTextFieldBasic = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.machinetext_bet), Game.TextStyles.GENERIC_LABEL_STYLE, c.basicStateContainer, pixiGenericSlot.Positions.BASIC_BET_LABEL.position, pixiGenericSlot.Positions.BASIC_BET_LABEL.anchorPoint);
		c.betValueTextFieldBasic = Game.PIXIFactory.createAndAddText(c.model.getBetText(), Game.TextStyles.GENERIC_VALUE_STYLE, c.basicStateContainer, pixiGenericSlot.Positions.BASIC_BET_VALUE.position, pixiGenericSlot.Positions.BASIC_BET_VALUE.anchorPoint);
		c.balanceLableTextFieldBasic = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.machinetext_coins), Game.TextStyles.GENERIC_LABEL_STYLE, c.basicStateContainer, pixiGenericSlot.Positions.BASIC_BALANCE_LABEL.position, pixiGenericSlot.Positions.BASIC_BALANCE_LABEL.anchorPoint);
		c.coinsValueTextFieldBasic = Game.PIXIFactory.createAndAddText(c.model.getBalanceText(), Game.TextStyles.GENERIC_VALUE_STYLE, c.basicStateContainer, pixiGenericSlot.Positions.BASIC_BALANCE_VALUE.position, pixiGenericSlot.Positions.BASIC_BALANCE_VALUE.anchorPoint);
		var a = Services.languageManager.getText(c.FREESPINS_LEFT_LANGUAGE_KEY, [0]);
		c.freeSpinsLeftLabelTextFieldFreeSpins = Game.PIXIFactory.createAndAddText(a, Game.TextStyles.FREESPINS_LEFT_LABEL, c.freeSpinsStateContainer, pixiGenericSlot.Positions.FREESPINS_LEFT_LABEL.position, pixiGenericSlot.Positions.FREESPINS_LEFT_LABEL.anchorPoint);
		var b = Services.languageManager.getText(Language.Keys.totalWinColonVar_uc, [0]);
		c.totalWinLabelTextField = Game.PIXIFactory.createAndAddText(b, Game.TextStyles.TOTAL_WIN_LABEL, c.totalWinFieldContainer, pixiGenericSlot.Positions.FS_KEYPAD_TOTAL_WIN.position, pixiGenericSlot.Positions.FS_KEYPAD_TOTAL_WIN.anchorPoint)
	},
	updateBetValueField: function() {
		if (this.betValueTextFieldBasic) {
			var a = this.model.getBetText();
			this.betValueTextFieldBasic.text = a
		}
	},
	updateCoinsValueField: function() {
		if (this.coinsValueTextFieldBasic) {
			var a = this.model.getBalanceText();
			this.coinsValueTextFieldBasic.text = a
		}
	},
	updateTotalWinValueField: function() {
		if (this.totalWinLabelTextField) {
			var a = Services.languageManager.getText(Language.Keys.totalWinColonVar_uc, [this.model.getTotalWinText()]);
			this.totalWinLabelTextField.text = a
		}
	},
	updateFreespinsLeftField: function() {
		if (this.freeSpinsLeftLabelTextFieldFreeSpins) {
			var b = this.model.getFreeSpinsLeftText();
			var a = Services.languageManager.getText(this.FREESPINS_LEFT_LANGUAGE_KEY);
			this.freeSpinsLeftLabelTextFieldFreeSpins.text = a + " " + b
		}
	},
	showBalanceAndBet: function() {
		this.updateBetValueField();
		this.updateCoinsValueField();
		this.updateTotalWinValueField()
	},
	showWin: function() {},
	showProgressiveWin: function() {
		this.updateTotalWinValueField()
	},
	countUpProgressiveWin: function() {
		this.updateTotalWinValueField();
		this.fireEvent("view:countUpComplete")
	},
	showFreeSpinsLeft: function() {
		this.updateFreespinsLeftField()
	},
	showAdditionalFreeSpinsWon: function() {},
	showWinUpTo: function() {},
	show: function() {},
	setupView: function() {},
	hideCoinsField: function() {
		this.basicStateContainer.visible = false
	},
	showCoinsField: function() {
		this.basicStateContainer.visible = true
	},
	onGameModeChanged: function(c) {
		var b = this,
			a = (c !== "BASIC");
		b.freeSpinsStateContainer.visible = a;
		b.totalWinFieldContainer.visible = a;
		b.basicStateContainer.alpha = 1
	}
};
Finn.CoinsFieldDesktopView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Finn.CoinsFieldDesktopView, "Finn.CoinsFieldDesktopView");
Sys.ns("Finn");
Finn.CoinsField = {
	constructor: function() {
		Finn.CoinsField.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["serverResponse", "orientation", "userInput"],
			desktop: ["serverResponse", "animation", "userInput"]
		}
	}
};
Finn.CoinsField = Sys.extend(Interface.Slots.CoinsField, Finn.CoinsField, "Finn.CoinsField");
Sys.ns("Finn");
Finn.CoinsFieldController = {
	TOGGLE_SEQUENCE: [{
		action: "showBalanceAndBet",
		displayDuration: 3000
	}],
	constructor: function() {
		Finn.CoinsFieldController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		Finn.CoinsFieldController.superclass.setupEvents.apply(this, arguments);
		var a = this;
		a.on({
			"notify:responseParser.bonusActionResponseParsed": a.onBonusActionResponseParsed,
			"request:coinsField.showWin": a.onShowWinRequest,
			"request:coinsField.showFreeSpinsLeft": a.showFreeSpinsLeft,
			"request:coinsField.hide": a.view.hideCoinsField,
			"request:coinsField.show": a.view.showCoinsField
		})
	},
	onBonusActionResponseParsed: function(b) {
		var a = this;
		a.model.processServerResponse(b);
		a.showFreeSpinsLeft()
	},
	onShowWinRequest: function() {
		this.showBalanceAndBet();
		Finn.CoinsFieldController.superclass.onShowWinRequest.apply(this, arguments)
	}
};
Finn.CoinsFieldController = Sys.extend(Interface.Slots.CoinsFieldController, Finn.CoinsFieldController, "Finn.CoinsFieldController");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.BetSettingsDesktopView = {
	constructor: function() {
		pixiGenericSlot.BetSettingsDesktopView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this,
			a = Game.stage.view.animationManager.getLayer("userInterface"),
			c = new PIXI.Container();
		b.rootContainer = c;
		b.betLevelLabelText = Services.languageManager.getText(Language.Keys.level);
		b.coinValueLabelText = Services.languageManager.getText(Language.Keys.machinetext_coinvalue);
		a.addChild(c);
		b.initSelectors();
		b.initFreespinItems();
		b.update()
	},
	initSelectors: function() {
		var h = this,
			g, e = h.model.readData("updatableBetLevels"),
			d = h.model.readData("updatableCoinValues"),
			f = h.model.readData("coinValues"),
			c = h.model.readData("betLevels");
		h.selectorContainer = new PIXI.Container();
		h.rootContainer.addChild(h.selectorContainer);
		g = f.map(function(n) {
			return Sys.utils.numberToFixedDigits(n, 3)
		});
		var k = new Interface.utils.PIXIValueStepper("selectorMinusUp", "selectorMinusDown", "selectorMinusOver", "selectorMinusDisabled", "selectorPlusUp", "selectorPlusDown", "selectorPlusOver", "selectorPlusDisabled");
		k.id = "betLevelSelector";
		k.setValues(h.model.readData("betLevels"));
		k.on("valueChanged", this.betLevelChangeHandler, this);
		k.setEnabled(e);
		k.setValueFieldStyle(Game.TextStyles.GENERIC_VALUE_STYLE);
		k.moveToPosition(pixiGenericSlot.Positions.BET_LEVEL_SELECTOR);
		var a = k.plusButton.width / 2;
		k.plusButton.setCustomHitArea(new PIXI.Circle(a, k.plusButton.height / 2, a));
		var m = k.minusButton.width / 2;
		k.minusButton.setCustomHitArea(new PIXI.Circle(m, k.minusButton.height / 2, m));
		h.betLevelLabel = Game.PIXIFactory.createAndAddText(h.betLevelLabelText, Game.TextStyles.GENERIC_LABEL_STYLE, h.selectorContainer, pixiGenericSlot.Positions.BET_LEVEL_LABEL.position, pixiGenericSlot.Positions.BET_LEVEL_LABEL.anchorPoint);
		var l = new Interface.utils.PIXIValueStepper("selectorMinusUp", "selectorMinusDown", "selectorMinusOver", "selectorMinusDisabled", "selectorPlusUp", "selectorPlusDown", "selectorPlusOver", "selectorPlusDisabled");
		l.id = "coinValueSelector";
		l.setValues(g);
		l.on("valueChanged", this.coinValueChangeHandler, this);
		l.setEnabled(d);
		l.setValueFieldStyle(Game.TextStyles.GENERIC_VALUE_STYLE);
		l.moveToPosition(pixiGenericSlot.Positions.COIN_VALUE_SELECTOR);
		var j = l.plusButton.width / 2;
		l.plusButton.setCustomHitArea(new PIXI.Circle(j, l.plusButton.height / 2, j));
		var b = l.minusButton.width / 2;
		l.minusButton.setCustomHitArea(new PIXI.Circle(b, l.minusButton.height / 2, b));
		h.coinValueLabel = Game.PIXIFactory.createAndAddText(h.coinValueLabelText, Game.TextStyles.GENERIC_LABEL_STYLE, h.selectorContainer, pixiGenericSlot.Positions.COIN_VALUE_LABEL.position, pixiGenericSlot.Positions.COIN_VALUE_LABEL.anchorPoint);
		k.setValue(h.model.readData("betLevel"));
		l.setValue(h.model.readData("coinValue"));
		h.selectorContainer.addChild(k);
		h.selectorContainer.addChild(l);
		h.betLevelSelector = k;
		h.coinValueSelector = l
	},
	initFreespinItems: function() {
		var c = this,
			d = pixiGenericSlot.Positions.createCurrentCanvasRectangle(),
			a = new PIXI.Point(d.width / 2, d.height - 58),
			b = new PIXI.Point(0.5, 0.5);
		c.freespinsContainer = new PIXI.Container();
		c.freespinsContainer.alpha = 1;
		c.rootContainer.addChild(c.freespinsContainer);
		Game.PIXIFactory.createAndAddSprite("freeSpinBackground", c.freespinsContainer, a, b);
		c.betLevelLabelItem = Game.PIXIFactory.createAndAddText(c.betLevelLabelText, Game.TextStyles.GENERIC_LABEL_STYLE, c.freespinsContainer, pixiGenericSlot.Positions.FREESPIN_BETLEVEL_LABEL.position, pixiGenericSlot.Positions.FREESPIN_BETLEVEL_LABEL.anchorPoint);
		c.betLevelValueItem = Game.PIXIFactory.createAndAddText(c.model.readData("betLevel"), Game.TextStyles.GENERIC_VALUE_STYLE, c.freespinsContainer, pixiGenericSlot.Positions.FREESPIN_BETLEVEL_VALUE.position, pixiGenericSlot.Positions.FREESPIN_BETLEVEL_VALUE.anchorPoint);
		c.coinValueLabelItem = Game.PIXIFactory.createAndAddText(c.coinValueLabelText, Game.TextStyles.GENERIC_LABEL_STYLE, c.freespinsContainer, pixiGenericSlot.Positions.FREESPIN_COINVALUE_LABEL.position, pixiGenericSlot.Positions.FREESPIN_COINVALUE_LABEL.anchorPoint);
		c.coinValueValueItem = Game.PIXIFactory.createAndAddText(c.model.readData("coinValue"), Game.TextStyles.GENERIC_VALUE_STYLE, c.freespinsContainer, pixiGenericSlot.Positions.FREESPIN_COINVALUE_VALUE.position, pixiGenericSlot.Positions.FREESPIN_COINVALUE_VALUE.anchorPoint);
		c.hideFreespinLabels()
	},
	betLevelChangeHandler: function(a) {
		this.onValueChange("betLevelChanged", a.value)
	},
	coinValueChangeHandler: function(a) {
		this.onValueChange("coinValueChanged", a.value)
	},
	updateValueItem: function(a, b) {
		a.text = Sys.utils.numberToFixedDigits(b, 3)
	},
	isBetSettingsEnabled: function() {
		return this.model.hasProperty("betSettingsDisabled") === false
	},
	enable: function(d) {
		var c = this,
			b = c.model.readData("updatableBetLevels"),
			a = c.model.readData("updatableCoinValues");
		c.enabled = true;
		c.model.removeProperty("betSettingsDisabled", d);
		if (b) {
			c.betLevelSelector.setEnabled(c.isBetSettingsEnabled())
		}
		if (a) {
			c.coinValueSelector.setEnabled(c.isBetSettingsEnabled())
		}
		c.update()
	},
	disable: function(b) {
		var a = this;
		a.enabled = false;
		a.model.addProperty("betSettingsDisabled", b);
		a.betLevelSelector.setEnabled(a.isBetSettingsEnabled());
		a.coinValueSelector.setEnabled(a.isBetSettingsEnabled())
	},
	hideSelectors: function() {
		this.disable("BetSettings");
		this.selectorContainer.visible = false
	},
	showSelectors: function() {
		this.enable("BetSettings");
		this.selectorContainer.visible = true
	},
	update: function() {
		var e = this,
			b = e.model,
			d = b.readData("updatableBetLevels"),
			a = b.readData("updatableCoinValues"),
			c = Sys.utils.numberToFixedDigits(e.model.readData("coinValue"), 3);
		if (this.enabled) {
			if (d) {
				var f = e.model.readData("betLevel");
				e.betLevelSelector.setValue(f)
			}
			if (a) {
				e.coinValueSelector.setValue(c.toString())
			}
		}
		if (Sys.isDefined(e.coinValueValueItem && e.betLevelValueItem)) {
			if (b.readData("updatableBetLevels")) {
				e.betLevelValueItem.text = e.model.readData("betLevel")
			}
			if (b.readData("updatableCoinValues")) {
				e.coinValueSelector.setValue(c.toString());
				e.coinValueValueItem.text = c.toString()
			}
			e.fireEvent("view:updateBetAndCoinsValue")
		}
	},
	showFreespinLabels: function() {
		this.freespinsContainer.visible = true
	},
	hideFreespinLabels: function() {
		this.freespinsContainer.visible = false
	}
};
pixiGenericSlot.BetSettingsDesktopView = Sys.extend(Interface.BetSettingsDesktopView, pixiGenericSlot.BetSettingsDesktopView, "pixiGenericSlot.BetSettingsDesktopView");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.BetSettings = {
	constructor: function() {
		pixiGenericSlot.BetSettings.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["userInput"],
			desktop: ["userInput", "animation", "properties"]
		}
	}
};
pixiGenericSlot.BetSettings = Sys.extend(Interface.BetSettings, pixiGenericSlot.BetSettings, "pixiGenericSlot.BetSettings");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.BetSettingsController = {
	constructor: function() {
		pixiGenericSlot.BetSettingsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		pixiGenericSlot.BetSettingsController.superclass.setupEvents.apply(this, arguments);
		var a = this;
		a.on({
			"request:betSelectors.hide": a.view.hideSelectors.bind(a.view),
			"request:betSelectors.show": a.view.showSelectors.bind(a.view)
		})
	},
	onSettingChanged: function(b, c) {
		if (b === "betLevel" || b === "denomination") {
			var a = this.model.readData(b);
			this.model.storeData(b, c);
			if (a !== c) {
				this.view.update()
			}
		}
	}
};
pixiGenericSlot.BetSettingsController = Sys.extend(Interface.BetSettingsController, pixiGenericSlot.BetSettingsController, "pixiGenericSlot.BetSettingsController");
Sys.ns("Finn");
Finn.SpinSettingsView = {
	constructor: function() {
		Finn.SpinSettingsView.superclass.constructor.apply(this, arguments)
	},
	ADVANCED_AUTOPLAY_SETTINGS: {
		stopAutoplayTitle: {
			labelOCTKey: Language.Keys.autoplay_setting_stopAutoPlay,
			type: "settingGroupTitle"
		},
		stopAutoplayIfBalanceDecreasedBy: {
			labelOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesBy,
			buttonTextOCTKey: Language.Keys.btn_addValue,
			infoOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesByInfoTouch,
			type: "interactiveContainer",
			defaultValue: 0
		},
		stopAutoplayIfWinExceeds: {
			labelOCTKey: Language.Keys.autoplay_setting_ifWinExeeds,
			buttonTextOCTKey: Language.Keys.btn_addValue,
			type: "interactiveContainer",
			defaultValue: 0
		},
		stopAutoplayIfBalanceIncreasedBy: {
			labelOCTKey: Language.Keys.autoplay_setting_ifCashIncreasesBy,
			buttonTextOCTKey: Language.Keys.btn_addValue,
			type: "interactiveContainer",
			defaultValue: 0
		},
		stopAutoplayOnAnyWin: {
			type: "ToggleSwitch",
			titleOCTKey: Language.Keys.autoplay_setting_onAnyWin,
			defaultValue: false
		},
		stopAutoplayIfFreeSpinWon: {
			type: "ToggleSwitch",
			titleOCTKey: Language.Keys.stopIfFreeSpins,
			defaultValue: false
		}
	}
};
Finn.SpinSettingsView = Sys.extend(Interface.SpinSettingsView, Finn.SpinSettingsView, "Finn.SpinSettingsView");
Sys.ns("Finn");
Finn.QuickSettingsMenuFullscreenCanvasView = {
	PORTRAIT_POSITION: {
		BOTTOM: 0.116,
		MIN_BOTTOM: 100,
		LEFT: 0.3997
	}
};
Finn.QuickSettingsMenuFullscreenCanvasView = Sys.extend(Interface.QuickSettingsMenuFullscreenCanvasView, Finn.QuickSettingsMenuFullscreenCanvasView, "Finn.QuickSettingsMenuFullscreenCanvasView");
Sys.ns("Finn");
Finn.SpinButtonMobileFullscreenCanvasView = {
	BUTTON_POSITION: {
		PORTRAIT: {
			LEFT: {
				BOTTOM: 0.17,
				LEFT: 0.5,
				MIN_BOTTOM: 100
			},
			RIGHT: {
				BOTTOM: 0.17,
				LEFT: 0.5,
				MIN_BOTTOM: 100
			}
		},
		LANDSCAPE: {
			LEFT: {
				TOP: 0.5,
				RIGHT: 0.82
			},
			RIGHT: {
				TOP: 0.5,
				LEFT: 0.9
			}
		}
	},
	LANDSCAPE_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		HEIGHT: 0.296,
		AUTO_PLAY_HEIGHT: 0.15,
		ORIGINAL_HEIGHT: 0.296
	},
	PORTRAIT_SIZE: {
		VERTICAL_OFFSET: "center",
		HORIZONTAL_OFFSET: "center",
		ASPECT_RATIO: 1,
		WIDTH: 0.296,
		AUTO_PLAY_WIDTH: 0.15,
		ORIGINAL_WIDTH: 0.296
	},
	setAppearance: function(a) {
		var b = this;
		Finn.SpinButtonMobileFullscreenCanvasView.superclass.setAppearance.apply(b, arguments);
		b.currentType = a;
		b.setSize(b.currentOrientation)
	},
	setSize: function(a) {
		var b = this;
		if (b.currentType === "autoPlayStop") {
			b.LANDSCAPE_SIZE.HEIGHT = b.LANDSCAPE_SIZE.AUTO_PLAY_HEIGHT;
			b.PORTRAIT_SIZE.WIDTH = b.PORTRAIT_SIZE.AUTO_PLAY_WIDTH
		}
		Mixins.orientation.view.methods.setSize.apply(b, arguments);
		b.LANDSCAPE_SIZE.HEIGHT = b.LANDSCAPE_SIZE.ORIGINAL_HEIGHT;
		b.PORTRAIT_SIZE.WIDTH = b.PORTRAIT_SIZE.ORIGINAL_WIDTH
	}
};
Finn.SpinButtonMobileFullscreenCanvasView = Sys.extend(Interface.Slots.SpinButtonMobileFullscreenCanvasView, Finn.SpinButtonMobileFullscreenCanvasView, "Finn.SpinButtonMobileFullscreenCanvasView");
Sys.ns("Finn");
Finn.SpinButtonController = {
	constructor: function() {
		Finn.SpinButtonController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		Finn.SpinButtonController.superclass.setupEvents.apply(this, arguments)
	}
};
Finn.SpinButtonController = Sys.extend(Interface.Slots.SpinButtonController, Finn.SpinButtonController, "Finn.SpinButtonController");
Sys.ns("Finn");
Finn.NetEntLogoFullscreenCanvasView = {
	PORTRAIT_POSITION: {
		BOTTOM: 0,
		LEFT: 0.9
	},
	constructor: function() {
		Interface.NetEntLogoFullscreenCanvasView.superclass.constructor.apply(this, arguments)
	}
};
Finn.NetEntLogoFullscreenCanvasView = Sys.extend(Interface.NetEntLogoBaseView, Finn.NetEntLogoFullscreenCanvasView, "Finn.NetEntLogoFullscreenCanvasView");
Sys.ns("Finn");
Finn.StateTransitionManager = {
	constructor: function() {
		Finn.StateTransitionManager.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				randomWilds: {
					state: {
						name: "RandomWilds",
						execute: function() {},
						waitEvents: {
							"notify:randomWilds.presentationFinished": false
						}
					}
				},
				symbolTransform: {
					state: {
						name: "SymbolTransform",
						execute: function() {},
						waitEvents: {
							"notify:symbolTransform.presentationFinished": false
						}
					}
				},
				symbolOverlay: {
					state: {
						name: "SymbolOverlay",
						execute: function() {},
						waitEvents: {
							"notify:symbolOverlay.presentationFinished": false
						}
					}
				},
				destroy: {
					state: {
						name: "Destroy",
						execute: function() {},
						waitEvents: {
							"notify:destroy.presentationFinished": false
						}
					}
				},
				freeSpinTrigger: {
					state: {
						name: "FreeSpinTrigger",
						execute: function() {},
						waitEvents: {
							"notify:freeSpinTrigger.presentationFinished": false
						}
					}
				},
				freeSpinMap: {
					state: {
						name: "FreeSpinMap",
						execute: function() {},
						waitEvents: {
							"notify:freeSpinMap.selected": false
						}
					}
				},
				freeSpinCountDown: {
					state: {
						name: "FreeSpinCountDown",
						execute: function() {},
						waitEvents: {
							"notify:freeSpinCountDown:end": false
						}
					}
				},
				freeSpinIntro: {
					queue: [function(c) {
						c.stateHandler.pushState(c.states.stopped);
						c.stateHandler.pushState(c.states.stopping);
						c.stateHandler.pushState(c.states.beforeStopping);
						c.stateHandler.pushState(c.states.spinning);
						c.stateHandler.pushState(c.states.freeSpinMap)
					}]
				},
				beforeStopping: {
					queue: [function(c) {
						if (a.readData("countDownRequested")) {
							c.stateHandler.pushState(c.states.freeSpinCountDown)
						}
					}]
				},
				stopped: {
					queue: [function(c) {
						if (a.readData("bonusActionWon")) {
							c.stateHandler.pushState(c.states.freeSpinTrigger)
						} else {
							if (a.readData("randomFeatureWon")) {
								if (a.readData("feature") === "randomwilds") {
									c.stateHandler.pushState(c.states.randomWilds)
								} else {
									if (a.readData("feature") === "symboltransform") {
										c.stateHandler.pushState(c.states.symbolTransform)
									} else {
										if (a.readData("feature") === "symboloverlay") {
											c.stateHandler.pushState(c.states.symbolOverlay);
											c.stateHandler.pushState(c.states.pauseForEffect)
										} else {
											if (a.readData("feature") === "destroy") {
												c.stateHandler.pushState(c.states.destroy);
												c.stateHandler.pushState(c.states.pauseForEffect)
											}
										}
									}
								}
							}
						}
					}]
				},
				pauseForEffect: {
					state: {
						name: "PauseForEffect",
						execute: function(c) {},
						waitEvents: {
							"notify:stateTransitionManagerController.hasPausedForEffect": false
						}
					}
				},
				beforeLoaderClose: {
					queue: [function(c) {
						if (a.readData("isRestoreState")) {
							if (a.readData("bonusActionWon")) {
								c.stateHandler.pushState(c.states.stopped);
								c.stateHandler.pushState(c.states.stopping);
								c.stateHandler.pushState(c.states.beforeStopping);
								c.stateHandler.pushState(c.states.spinning);
								c.stateHandler.pushState(c.states.freeSpinMap)
							} else {
								if (a.readData("freeSpinsWon")) {
									c.stateHandler.pushState(c.states.freeSpinCountDown);
									c.stateHandler.pushState(c.states.freeSpinMap)
								}
							}
						}
						if (a.hasFreeRounds()) {
							c.stateHandler.pushState(c.states.freeRoundsDialog)
						}
					}]
				}
			};
		return b
	},
	getMixinDependencies: function() {
		return ["serverResponse", "userInput"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.StateTransitionManagerModel,
			controller: Finn.StateTransitionManagerController
		}
	}
};
Finn.StateTransitionManager = Sys.extend(Core.Module, Finn.StateTransitionManager, "Finn.StateTransitionManager");
Sys.ns("Finn");
Finn.StateTransitionManagerModel = {
	constructor: function() {
		Finn.StateTransitionManagerModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var b = this,
			a = Resources.readData("gameServerInitResponseObject");
		b.handleFreeRounds(a)
	},
	hasFreeRounds: function() {
		var a = this.readData("freeRoundsLeft");
		return Sys.isDefined(a) && a > 0
	},
	handleFreeRounds: function(a) {
		if (Sys.isDefined(a.freeRoundsLeft)) {
			this.storeData("freeRoundsLeft", a.freeRoundsLeft)
		}
	},
	processServerResponse: function(g) {
		var c = this,
			a = Sys.isDefined(g.rf) && Sys.isDefined(g.rf.feature),
			f = (g.nextaction === "bonusaction"),
			b = Sys.isDefined(g.freespins) && g.clientAction !== "bonusaction",
			e = (g.restore === true) && Sys.isDefined(g.freespin),
			d = g.clientaction === "freespin";
		if (a) {
			c.storeData("feature", g.rf.feature)
		}
		c.storeData("countDownRequested", d);
		c.storeData("randomFeatureWon", a);
		c.storeData("bonusActionWon", f);
		c.storeData("freeSpinsWon", b);
		c.storeData("isRestoreState", e)
	}
};
Finn.StateTransitionManagerModel = Sys.extend(Core.Model, Finn.StateTransitionManagerModel, "Finn.StateTransitionManagerModel");
Sys.ns("Finn");
Finn.StateTransitionManagerController = {
	constructor: function() {
		Finn.StateTransitionManagerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:responseParser.bonusActionResponseParsed": a.onBonusActionResponseParsed,
			"notify:stateHandler.enteringPauseForEffectState": a.enteringPauseForEffect,
			"notify:stateHandler.leavingPauseForEffectState": a.leavingPauseForEffect
		})
	},
	onUserInputStart: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			clearTimeout(a.pauseTimeout);
			a.fireEvent("notify:stateTransitionManagerController.hasPausedForEffect")
		}
	},
	enteringPauseForEffect: function() {
		var a = this;
		clearTimeout(a.pauseTimeout);
		a.pauseTimeout = setTimeout(function() {
			a.fireEvent("notify:stateTransitionManagerController.hasPausedForEffect")
		}, 1500);
		a.startListeningToUserInput()
	},
	leavingPauseForEffect: function() {
		var a = this;
		a.stopListeningToUserInput()
	},
	onBonusActionResponseParsed: function(a) {
		this.model.processServerResponse(a)
	}
};
Finn.StateTransitionManagerController = Sys.extend(Core.Controller, Finn.StateTransitionManagerController, "Finn.StateTransitionManagerController");
Sys.ns("Finn");
Finn.AutoPlayerController = {
	constructor: function() {
		Finn.AutoPlayerController.superclass.constructor.apply(this, arguments)
	},
	play: function() {
		var a = this;
		if (!a.model.isState("PLAYING") && a.model.readData("nrRounds") > 0) {
			a.model.setState("PLAYING");
			a.fireEvent("request:spinButton.removeDisplayType", "autoPlay");
			a.fireEvent("request:spinButton.addDisplayType", "autoPlayStop");
			a.fireEvent("request:spinButton.disable", a.MODULE_NAME);
			a.fireEvent("request:betSettings.disable", a.MODULE_NAME);
			a.fireEvent("request:maxBetButton.disable", a.MODULE_NAME);
			a.fireEvent("notify:autoPlayer.starting");
			a.fireEvent("request:playModeManager.addMode", "autoplay");
			a.reduceNumberOfRounds()
		}
	}
};
Finn.AutoPlayerController = Sys.extend(Core.AutoPlayerController, Finn.AutoPlayerController, "Finn.AutoPlayerController");
Sys.ns("Finn");
Finn.KeyHole = {
	getDefaultMVCClasses: function() {
		return {
			model: Finn.KeyHoleModel,
			controller: Finn.KeyHoleController,
			view: Finn.KeyHoleView
		}
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation"]
	}
};
Finn.KeyHole = Sys.extend(Core.Module, Finn.KeyHole, "Finn.KeyHole");
Sys.ns("Finn");
Finn.KeyHoleModel = {
	constructor: function() {
		Finn.KeyHoleModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.shouldAnimate = false;
		a.storeData("shouldAnimate", a.shouldAnimate)
	},
	processServerResponse: function(e) {
		var a = this,
			c = e.clientaction,
			b = (!Sys.isDefined(e.freespin)),
			d = false;
		if (Sys.isDefined(e.reelInfo) && Sys.isDefined(e.reelInfo[0].lastSymbols)) {
			d = e.reelInfo[0].lastSymbols[24] === null
		}
		a.shouldAnimate = b && (c === "spin" || d);
		a.storeData("shouldAnimate", a.shouldAnimate)
	}
};
Finn.KeyHoleModel = Sys.extend(Core.Model, Finn.KeyHoleModel, "Finn.KeyHoleModel");
Sys.ns("Finn");
Finn.KeyHoleController = {
	constructor: function() {
		Finn.KeyHoleController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:keyHole.animate": a.animate,
			"notify:quickStopper.quickStop": a.resetAnimation
		})
	},
	animate: function() {
		var b = this,
			a = b.model.readData("shouldAnimate");
		if (a) {
			b.view.animate()
		}
	},
	resetAnimation: function() {
		this.view.resetAnimation()
	}
};
Finn.KeyHoleController = Sys.extend(Core.Controller, Finn.KeyHoleController, "Finn.KeyHoleController");
Sys.ns("Finn");
Finn.KeyHoleView = {
	KEY_HOLE_POSITION: {
		x: 0,
		y: 0
	},
	constructor: function() {
		Finn.KeyHoleView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.position = new PIXI.Point(0, 0);
		b.keyHoleAnimation = b.initAnimation();
		var a = Game.stage.view.animationManager.getLayer("winPresentationBelowSymbols");
		a.addChild(b.rootContainer)
	},
	initAnimation: function() {
		var a = this,
			b;
		b = Game.PIXIFactory.createAndAddSpineAnimation("keyHole", a.rootContainer);
		b.fire = function() {
			Finn.AnimationUtils.initialize(b, "keyhole_spinGlow").onAnimationEnd(a, a.resetAnimation, a.MODULE_NAME)
		};
		b.position = a.KEY_HOLE_POSITION;
		b.visible = false;
		return b
	},
	animate: function() {
		var a = this;
		a.keyHoleAnimation.fire()
	},
	resetAnimation: function() {
		var a = this;
		a.keyHoleAnimation.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a.keyHoleAnimation)
	}
};
Finn.KeyHoleView = Sys.extend(Core.View, Finn.KeyHoleView, "Finn.KeyHoleView");
Sys.ns("Finn");
Finn.KeyCounter = {
	getDefaultMVCClasses: function() {
		return {
			model: Finn.KeyCounterModel,
			controller: Finn.KeyCounterController,
			view: Finn.KeyCounterView
		}
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "orientation"]
	}
};
Finn.KeyCounter = Sys.extend(Core.Module, Finn.KeyCounter, "Finn.KeyCounter");
Sys.ns("Finn");
Finn.KeyCounterModel = {
	constructor: function() {
		Finn.KeyCounterModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.storeData("keys", 0);
		a.storeData("gameState", "basic")
	},
	processServerResponse: function(c) {
		var b = this,
			a = c.gamestate.current;
		b.storeData("keys", c.totalkeys || 0);
		if (a === "freespin" && c.freespin) {
			b.storeData("gameState", c.freespin.selected)
		} else {
			b.storeData("gameState", "basic")
		}
	}
};
Finn.KeyCounterModel = Sys.extend(Core.Model, Finn.KeyCounterModel, "Finn.KeyCounterModel");
Sys.ns("Finn");
Finn.KeyCounterController = {
	constructor: function() {
		Finn.KeyCounterController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:keyCounter.show": a.showMgKeyCounter,
			"request:keyCounter.hide": a.hide,
			"notify:keyCounter.showGlowingKey": a.view.showGlowingKey.bind(a.view),
			"notify:keyCounter.hideGlowingKey": a.view.hideGlowingKey.bind(a.view),
			"request:keyCounter.hideMgKeyCounter": a.view.hideMgKeyCounter.bind(a.view),
			"request:keyCounter.showMgKeyCounter": a.showMgKeyCounter,
			"notify:spinButton.clicked": a.view.showMgKeyCounter.bind(a.view),
			"notify:stateHandler.enteringFreeSpinMapState": a.showFreeSpinMapContent,
			"notify:stateHandler.enteringIdleState": a.updateKeys,
			"notify:stateHandler.enteringStoppedState": a.updateKeys,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged,
			"notify:stateHandler.enteringFreeSpinIntroState": a.hide,
			"notify:keyCounter.show": a.view.showMgKeyCounter.bind(a.view)
		})
	},
	showFreeSpinMapContent: function() {
		var a = this;
		a.view.showFreeSpinMapContent()
	},
	show: function() {
		var a = this;
		a.view.show()
	},
	hide: function() {
		var a = this;
		a.view.hide()
	},
	updateKeys: function() {
		var a = this;
		a.view.updateKeys()
	},
	onGameSizeChanged: function() {
		var a = this;
		a.view.refresh()
	},
	showMgKeyCounter: function() {
		var a = this;
		if (a.model.readData("gameState") === "basic") {
			a.view.showMgKeyCounter()
		}
	}
};
Finn.KeyCounterController = Sys.extend(Core.Controller, Finn.KeyCounterController, "Finn.KeyCounterController");
Sys.ns("Finn");
Finn.KeyCounterView = {
	KEY_COUNTER_LABEL: {
		DEFAULT: {
			x: 1006,
			y: 533
		},
		LANDSCAPE: {
			x: 1006,
			y: 533
		},
		PORTRAIT: {
			x: 898,
			y: 754
		}
	},
	KEY_CONFIG: {
		DEFAULT: {
			x: 1024,
			y: 525
		},
		LANDSCAPE: {
			x: 1024,
			y: 525
		},
		PORTRAIT: {
			x: 859,
			y: 760
		}
	},
	KEY_NUMBER: {
		DEFAULT: {
			x: 1050,
			y: 580
		},
		LANDSCAPE: {
			x: 1050,
			y: 580
		},
		PORTRAIT: {
			x: 942,
			y: 800
		}
	},
	KEY_COUNTER_LABEL_FS: {
		DEFAULT: {
			x: 1006,
			y: 533
		},
		LANDSCAPE: {
			x: 1006,
			y: 533
		},
		PORTRAIT: {
			x: 840,
			y: 770
		}
	},
	KEY_NUMBER_FS: {
		DEFAULT: {
			x: 1050,
			y: 580
		},
		LANDSCAPE: {
			x: 1050,
			y: 580
		},
		PORTRAIT: {
			x: 883,
			y: 818
		}
	},
	constructor: function() {
		Finn.KeyCounterView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.keyCounterMgContainer = new PIXI.Container();
		b.freeSpinContainer = new PIXI.Container();
		b.freeSpinContainer.visible = false;
		b.glowingKeyContainer = new PIXI.Container();
		b.glowingKeyContainer.visible = false;
		b.rootContainer.addChild(b.freeSpinContainer);
		b.rootContainer.addChild(b.glowingKeyContainer);
		b.keyCounterMg = Game.PIXIFactory.createAndAddSprite("keyCountMg", b.keyCounterMgContainer, Environment.getOrientationSpecificConfig(b.KEY_COUNTER_LABEL, true), new PIXI.Point(0, 0));
		b.keyCounterMgContainer.visible = true;
		b.keys = b.keyCounterText(Game.TextStyles.PROGRESSION_TEXT, b.KEY_NUMBER, b.keyCounterMgContainer);
		var c = Game.stage.view.animationManager.getLayer("splashScreensContent");
		c.addChild(b.keyCounterMgContainer);
		b.rootContainer.visible = true;
		b.keyCounterFs = Game.PIXIFactory.createAndAddSprite("keyCountFs", b.freeSpinContainer, Environment.getOrientationSpecificConfig(b.KEY_COUNTER_LABEL_FS, true), new PIXI.Point(0, 0));
		b.key = Game.PIXIFactory.createAndAddSprite("key", b.glowingKeyContainer, Environment.getOrientationSpecificConfig(b.KEY_CONFIG, true), new PIXI.Point(0, 0));
		b.keysFs = b.keyCounterText(Game.TextStyles.PROGRESSION_TEXT_FS, b.KEY_NUMBER_FS, b.freeSpinContainer);
		var a = Game.stage.view.animationManager.getLayer("splashScreensDialog");
		a.addChild(b.rootContainer)
	},
	hide: function() {
		var a = this;
		a.freeSpinContainer.visible = false;
		a.rootContainer.visible = false;
		a.glowingKeyContainer.visible = false
	},
	hideMgKeyCounter: function() {
		var a = this;
		a.keyCounterMgContainer.visible = false
	},
	showMgKeyCounter: function() {
		var a = this;
		a.keyCounterMgContainer.visible = true
	},
	showGlowingKey: function() {
		var a = this;
		a.glowingKeyContainer.visible = true
	},
	hideGlowingKey: function() {
		var a = this;
		a.glowingKeyContainer.visible = false
	},
	showFreeSpinMapContent: function() {
		var a = this;
		a.freeSpinContainer.visible = true;
		a.keyCounterMgContainer.visible = false;
		a.rootContainer.visible = true
	},
	updateKeys: function() {
		var a = this;
		a.keys.setLabel(a.model.readData("keys").toString());
		a.keys.updateLabel();
		a.keysFs.setLabel(a.model.readData("keys").toString());
		a.keysFs.updateLabel()
	},
	keyCounterText: function(e, a, c) {
		var d = this,
			b;
		b = new Interface.utils.PIXILabel("0", e);
		b.position = Environment.getOrientationSpecificConfig(a, true);
		b.setAnchorPoint(new PIXI.Point(0.5, 0.5));
		b.setLabelMaxWidth(53);
		b.setLabel(d.model.readData("keys").toString());
		b.updateLabel();
		c.addChild(b);
		return b
	},
	refresh: function() {
		var a = this;
		a.keyCounterFs.position = Environment.getOrientationSpecificConfig(a.KEY_COUNTER_LABEL_FS, true);
		a.keyCounterMg.position = Environment.getOrientationSpecificConfig(a.KEY_COUNTER_LABEL, true);
		a.key.position = Environment.getOrientationSpecificConfig(a.KEY_CONFIG, true);
		a.keys.position = Environment.getOrientationSpecificConfig(a.KEY_NUMBER, true);
		a.keysFs.position = Environment.getOrientationSpecificConfig(a.KEY_NUMBER_FS, true)
	}
};
Finn.KeyCounterView = Sys.extend(Core.View, Finn.KeyCounterView, "Finn.KeyCounterView");
Sys.ns("Finn");
Finn.FreeSpinTrigger = {
	getDefaultMVCClasses: function() {
		return {
			controller: Finn.FreeSpinTriggerController,
			view: Finn.FreeSpinTriggerView
		}
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput"]
	}
};
Finn.FreeSpinTrigger = Sys.extend(Core.Module, Finn.FreeSpinTrigger, "Finn.FreeSpinTrigger");
Sys.ns("Finn");
Finn.FreeSpinTriggerController = {
	ABORT_TIMER: 1000,
	constructor: function() {
		Finn.FreeSpinTriggerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringFreeSpinTriggerState": a.startFreeSpinTrigger,
			"view:freespinTriggerFinished": a.freeSpinTriggerFinished,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop"),
			"view:character.hide": a.fireEvent.bind(a, "request:character.hide")
		})
	},
	setupData: function() {
		this.model.setState("idle")
	},
	startFreeSpinTrigger: function() {
		var a = this;
		a.model.setState("animating");
		a.view.startFreeSpinTrigger();
		a.fireEvent("request:ambienceManager.ambiencePauseSwitch", true);
		setTimeout(function() {
			a.fireEvent("request:spinButton.enable", a.MODULE_NAME);
			a.startListeningToUserInput()
		}, a.ABORT_TIMER)
	},
	freeSpinTriggerFinished: function() {
		var a = this;
		a.model.setState("idle");
		a.stopListeningToUserInput();
		a.fireEvent("notify:freeSpinTrigger.presentationFinished");
		a.fireEvent("notify:freeSpinTrigger.bonusWinFinished")
	},
	onUserInputEnd: function() {
		var a = this;
		if (a.model.getState() === "animating") {
			a.view.freeSpinTriggerFinished();
			a.model.setState("stopped")
		}
	},
	onGameSizeChanged: function() {
		var a = this;
		a.view.refresh()
	}
};
Finn.FreeSpinTriggerController = Sys.extend(Core.Controller, Finn.FreeSpinTriggerController, "Finn.FreeSpinTriggerController");
Sys.ns("Finn");
Finn.FreeSpinTriggerView = {
	BONUS_SYM_POS: {
		x: 0,
		y: 7
	},
	SOUND_LOCKUP: {
		name: "freespinLockUp",
		id: "freespinLockUp"
	},
	ZOOM_CONFIG: {
		DEFAULT: {
			x: -320,
			y: -180
		},
		LANDSCAPE: {
			x: -320,
			y: -180
		},
		PORTRAIT: {
			x: -240,
			y: -185
		}
	},
	ZOOM_TIMING: {
		START: 5000,
		END: 8000
	},
	constructor: function() {
		Finn.FreeSpinTriggerView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.position = new PIXI.Point(0, 0);
		b.trenchContainer = new PIXI.Container();
		b.trenchContainer.position = new PIXI.Point(0, 0);
		b.trenchFillAnimation = b.addTrenchFillAnimation();
		b.bonusSymAnimation = b.initBonusSymAnimation();
		var a = Game.stage.view.animationManager.getLayer("freespinIntro");
		a.addChild(b.rootContainer);
		var c = Game.stage.view.animationManager.getLayer("reelBackground");
		c.addChild(b.trenchContainer);
		b.zoomAnimation = b.initZoomAnimation(Game.stage.view.animationManager.getRootLayer());
		b.refresh()
	},
	initBonusSymAnimation: function() {
		var c = this,
			b;
		b = Game.PIXIFactory.createAndAddSpineAnimation("bonusWin", c.rootContainer);
		b.fire = function() {
			Finn.AnimationUtils.initialize(b, "animation").onAnimationEnd(c, c.freeSpinTriggerFinished, c.MODULE_NAME)
		};
		if (Platform.isLowEndDevice || Platform.isIEBrowser || Platform.isEdgeBrowser) {
			for (var a = 0; a < b.spineData.slots.length; a++) {
				b.spineData.slots[a].blendMode = 0
			}
		}
		b.position = c.BONUS_SYM_POS;
		b.visible = false;
		return b
	},
	addTrenchFillAnimation: function() {
		var b = this,
			a;
		a = Game.PIXIFactory.createAndAddSpineAnimation("trenchFill", b.trenchContainer);
		a.position = new PIXI.Point(0, 0);
		a.fire = function() {
			a.state.setAnimation(0, "trench_GameAttention", true);
			a.visible = true;
			a.updateTransform()
		};
		a.visible = false;
		return a
	},
	startFreeSpinTrigger: function() {
		var a = this;
		a.fireEvent("view:playAudio", a.SOUND_LOCKUP);
		a.bonusSymAnimation.fire();
		a.zoomAnimation.play();
		if (!Platform.isLowEndDevice && !Platform.isIEBrowser && !Platform.isEdgeBrowser) {
			a.trenchFillAnimation.fire()
		}
	},
	freeSpinTriggerFinished: function() {
		var b = this,
			a = Platform.isDesktopDevice ? 1 : 0.75;
		b.fireEvent("view:stopAudio", b.SOUND_LOCKUP.name);
		b.fireEvent("view:character.hide");
		b.zoomAnimation.stop();
		b.trenchFillAnimation.visible = false;
		Game.PIXIUtils.resetSpineAnimation(b.trenchFillAnimation);
		Game.stage.view.animationManager.getRootLayer().position = {
			x: 0,
			y: 0
		};
		Game.stage.view.animationManager.getRootLayer().scale = {
			x: a,
			y: a
		};
		setTimeout(function() {
			b.bonusSymAnimation.visible = false;
			Game.PIXIUtils.resetSpineAnimation(b.bonusSymAnimation)
		}, 250);
		b.fireEvent("view:freespinTriggerFinished")
	},
	initZoomAnimation: function(e, c) {
		var d = this;
		var a = {
			prop: "position",
			animate: [{
				time: 0,
				value: {
					x: 0,
					y: 0
				}
			}, {
				time: d.ZOOM_TIMING.START,
				value: {
					x: 0,
					y: 0
				},
				ease: Animation.utils.powerTwoIn
			}, {
				time: d.ZOOM_TIMING.END,
				value: {
					x: d.ZOOM_CONFIG.DEFAULT.x,
					y: d.ZOOM_CONFIG.DEFAULT.y
				},
				ease: Animation.utils.powerTwoOut
			}]
		};
		var f = {
			prop: "scale",
			animate: [{
				time: 0,
				value: {
					x: 1,
					y: 1
				}
			}, {
				time: d.ZOOM_TIMING.START,
				value: {
					x: 1,
					y: 1
				},
				ease: Animation.utils.powerTwoIn
			}, {
				time: d.ZOOM_TIMING.END,
				value: {
					x: 1.5,
					y: 1.5
				},
				ease: Animation.utils.powerTwoOut
			}]
		};
		var b = new Animation.Holder({
			id: "zoomAnimation",
			target: e,
			delay: 0,
			onEnd: function() {
				d.fireEvent("view:zoomCompleted")
			},
			children: [a, f]
		});
		Game.stage.view.animationManager.addToAnimationLoop(b);
		return b
	},
	refresh: function() {
		var d = this,
			b = Platform.isDesktopDevice ? 1.5 : 1.125,
			c = Platform.isDesktopDevice ? 1 : 0.75,
			a = Environment.getOrientationSpecificConfig(d.ZOOM_CONFIG, true);
		d.zoomAnimation.children[1].animation.keyFrames[0].value = {
			x: c,
			y: c
		};
		d.zoomAnimation.children[1].animation.keyFrames[1].value = {
			x: c,
			y: c
		};
		d.zoomAnimation.children[1].animation.keyFrames[2].value = {
			x: b,
			y: b
		};
		d.zoomAnimation.children[0].animation.keyFrames[2].value = {
			x: a.x * c,
			y: a.y * c
		}
	}
};
Finn.FreeSpinTriggerView = Sys.extend(Core.View, Finn.FreeSpinTriggerView, "Finn.FreeSpinTriggerView");
Sys.ns("Finn");
Finn.FreeSpinIntro = {
	constructor: function() {
		Finn.FreeSpinIntro.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model,
			b = {
				freeSpinIntro: {
					state: {
						name: "FreeSpinIntro",
						execute: function() {},
						waitEvents: {
							"notify:freeSpinIntro.closed": false
						}
					}
				},
				stopped: {
					queue: [function(c) {
						if (a.readData("showFreeSpinIntro")) {
							c.stateHandler.pushState(c.states.freeSpinIntro)
						}
					}]
				}
			};
		return b
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.FreeSpinIntroModel,
			controller: Finn.FreeSpinIntroController,
			view: Finn.FreeSpinIntroView
		}
	}
};
Finn.FreeSpinIntro = Sys.extend(Game.Slots.FreeSpinIntro, Finn.FreeSpinIntro, "Finn.FreeSpinIntro");
Sys.ns("Finn");
Finn.FreeSpinIntroModel = {
	constructor: function() {
		Finn.FreeSpinIntroModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(e) {
		var b = this,
			d = (e.restore === true) && e.nextaction === "freespin",
			c = e.nextaction === "bonusaction",
			a = Sys.isDefined(e.freespins) ? e.freespins.left : 0;
		b.storeData("freeSpinsWon", a);
		b.storeData("showFreeSpinIntro", d || c);
		b.storeData("isRestoreState", d)
	}
};
Finn.FreeSpinIntroModel = Sys.extend(Game.Slots.FreeSpinIntroModel, Finn.FreeSpinIntroModel, "Finn.FreeSpinIntroModel");
Sys.ns("Finn");
Finn.FreeSpinIntroController = {
	constructor: function() {
		Finn.FreeSpinIntroController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:closed": a.onClosed,
			"view:splashClosed": a.onSplashClosed,
			"view:introAnimationFinished": a.onIntroAnimationFinished,
			"notify:stateHandler.enteringFreeSpinIntroState": a.start
		})
	},
	start: function() {
		var a = this;
		a.show();
		a.startListeningToUserInput();
		a.fireEvent("request:closeOpenWindows");
		a.fireEvent("request:disableBasicGamePanel", "freespinSplash");
		if (!Platform.isDesktopDevice) {
			a.fireEvent("request:spinButton.hide")
		}
		a.fireEvent("request:keyCounter.hideMgKeyCounter")
	},
	show: function() {
		var a = this;
		a.model.storeData("isShowing", true);
		a.stopAutoplay();
		a.view.show();
		a.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: "freeSpinMapIntro",
			id: "freeSpinMapIntro",
			loop: false
		});
		a.fireEvent("request:ambienceManager.ambiencePauseSwitch", false);
		a.fireEvent("request:coinsField.showWin");
		a.fireEvent("request:coinsField.showProgressiveWin", true);
		Services.storage.storeData("freeSpins.canStart", true)
	},
	onSplashClosed: function() {
		var a = this;
		if (Sys.isDefined(a.autoCloseTimeOut)) {
			clearTimeout(a.autoCloseTimeOut)
		}
		a.fireEvent("request:spin.activateInitReelset", "freespin1", "base");
		a.fireEvent("request:coinsField.showWin");
		a.fireEvent("request:coinsField.showProgressiveWin", true);
		a.fireEvent("notify:freeSpinIntro.splashClosed")
	},
	onIntroAnimationFinished: function() {
		var a = this;
		a.view.close();
		a.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: "freeSpinMap",
			id: "freeSpinMap",
			loop: true
		})
	},
	onClosed: function() {
		var a = this;
		a.model.storeData("isShowing", false);
		clearTimeout(a.autoCloseTimeOut);
		a.stopListeningToUserInput();
		a.fireEvent("notify:freeSpinIntro.closed", a.model.readData("freeSpinsWon"))
	},
	onUserInputEnd: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			a.view.abortPresentation()
		}
	}
};
Finn.FreeSpinIntroController = Sys.extend(Game.Slots.FreeSpinIntroController, Finn.FreeSpinIntroController, "Finn.FreeSpinIntroController");
Sys.ns("Finn");
Finn.FreeSpinIntroView = {
	SPLASH_CONGRATULATIONS: {
		key: Language.Keys.congratulations,
		x: 640,
		y: 250
	},
	SPLASH_WELCOME: {
		key: Language.Keys.welcomeFreeSpinsWorld,
		x: 640,
		y: 380
	},
	SPLASH_BUTTON_CONTINUE: {
		key: Language.Keys.continue_uc,
		loadingKey: Language.Keys.loadingDots,
		restoreKey: Language.Keys.continue_uc,
		x: 640,
		y: 640
	},
	MOVIE_BUTTON_CONTINUE: {
		key: Language.Keys.skipIntro,
		x: 640,
		y: 640
	},
	constructor: function() {
		var a = this;
		Finn.FreeSpinIntroView.superclass.constructor.apply(a, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.name = "FreeSpinIntroView";
		b.splashScreenContainer = b.createSplashContent();
		b.splashScreenContainer.pivot = new PIXI.Point(640, 360);
		b.splashScreenContainer.position = new PIXI.Point(640, 360);
		b.splashScreenContainer.visible = false;
		b.textAnimation = b.initTextAnimation(b.splashScreenContainer);
		b.introAnimationClouds = b.createCloudAnimation("freeSpinIntroClouds", "animation");
		b.introAnimationClouds.visible = false;
		var c = Game.stage.view.animationManager.getLayer("splashScreensContentOverlay");
		c.addChild(b.splashScreenContainer);
		var a = Game.stage.view.animationManager.getLayer("cutScene");
		a.addChild(b.rootContainer)
	},
	createSplashContent: function() {
		var e = this,
			c = new PIXI.Container(),
			b = {},
			d = new PIXI.Point(0.5, 0.5);
		b.congratulations = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(e.SPLASH_CONGRATULATIONS.key).toUpperCase(), Game.TextStyles.INTRO_CONGRATULATIONS, c, new PIXI.Point(e.SPLASH_CONGRATULATIONS.x, e.SPLASH_CONGRATULATIONS.y), d);
		var a = Services.languageManager.getText(e.SPLASH_WELCOME.key, [0]);
		b.welcome = Game.PIXIFactory.createAndAddText(a, Game.TextStyles.INTRO_WELCOME, c, new PIXI.Point(e.SPLASH_WELCOME.x, e.SPLASH_WELCOME.y), d);
		return c
	},
	initTextAnimation: function(d) {
		var c = this;
		var a = {
			prop: "alpha",
			animate: [{
				time: 0,
				value: 0,
				ease: Animation.utils.powerOneIn
			}, {
				time: 500,
				value: 1
			}, {
				time: 3000,
				value: 1,
				ease: Animation.utils.powerOneIn
			}, {
				time: 3500,
				value: 0
			}]
		};
		var e = {
			prop: "scale",
			animate: [{
				time: 0,
				value: {
					x: 0.6,
					y: 0.6
				},
				ease: Animation.utils.powerOneIn
			}, {
				time: 1500,
				value: {
					x: 1,
					y: 1
				}
			}, {
				time: 3500,
				value: {
					x: 1,
					y: 1
				}
			}]
		};
		var b = new Animation.Holder({
			id: "textAnimation",
			target: d,
			delay: 0,
			onEnd: c.hideSplash.bind(c),
			children: [a, e]
		});
		Game.stage.view.animationManager.addToAnimationLoop(b);
		return b
	},
	createCloudAnimation: function(d, a) {
		var b = this,
			c = Game.PIXIFactory.createAndAddSpineAnimation(d, b.rootContainer);
		c.fire = function() {
			Finn.AnimationUtils.initialize(c, a).onAnimationEnd(b, b.introAnimationComplete)
		};
		return c
	},
	introAnimationComplete: function() {
		var a = this;
		Game.PIXIUtils.resetSpineAnimation(a.introAnimationClouds);
		a.introAnimationClouds.visible = false;
		a.fireEvent("view:introAnimationFinished")
	},
	show: function() {
		var a = this;
		a.rootContainer.visible = true;
		a.showSplash();
		a.introAnimationClouds.fire();
		a.textAnimation.play()
	},
	close: function() {
		this.rootContainer.visible = false;
		this.fireEvent("view:closed")
	},
	showSplash: function() {
		var a = this;
		a.splashScreenContainer.visible = true
	},
	hideSplash: function() {
		var a = this;
		a.textAnimation.restore();
		a.splashScreenContainer.visible = false;
		a.fireEvent("view:splashClosed")
	},
	abortPresentation: function() {
		var a = this;
		a.introAnimationComplete();
		a.hideSplash();
		a.close()
	}
};
Finn.FreeSpinIntroView = Sys.extend(Game.Slots.FreeSpinIntroView, Finn.FreeSpinIntroView, "Finn.FreeSpinIntroView");
Sys.ns("Finn");
Finn.FreeSpinMap = {
	constructor: function() {
		Finn.FreeSpinMap.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["orientation", "serverResponse", "animation", "userInput", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.FreeSpinMapModel,
			controller: Finn.FreeSpinMapController,
			view: Finn.FreeSpinMapView
		}
	}
};
Finn.FreeSpinMap = Sys.extend(Core.Module, Finn.FreeSpinMap, "Finn.FreeSpinMap");
Sys.ns("Finn");
Finn.FreeSpinMapController = {
	FS_AMBIENCE: {
		randomwilds: "starAmbience",
		destroy: "dragonAmbience",
		symboloverlay: "luckyAmbience",
		symboltransform: "goldenAmbience"
	},
	constructor: function() {
		Finn.FreeSpinMapController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:showPreview": a.showPreview,
			"view:showGlowingKey": a.showGlowingKey,
			"view:hideGlowingKey": a.hideGlowingKey,
			"view:unlockAnimationsComplete": a.unlockAnimationsComplete,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"request:freeSpinMap.showBlurryDialogueBackground": a.showBlurryDialogueBackground,
			"request:freeSpinMap.hideBlurredMap": a.hideBlurredMap,
			"notify:stateHandler.enteringFreeSpinIntroState": a.zoomTransition,
			"notify:stateHandler.enteringFreeSpinMapState": a.setMapMode,
			"notify:freeSpinMapPreview:previewClosed": a.previewClosed,
			"notify:freeSpinMapPreview:modeSelected": a.modeSelected,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged,
			"notify:responseParser.bonusActionResponseParsed": a.introduceFS,
			"notify:background.freeSpinIntroduced": a.startFS,
			"notify:stateHandler.enteringIdleState": a.view.updateKeys.bind(a.view),
			"notify:stateHandler.enteringStoppedState": a.view.updateKeys.bind(a.view)
		})
	},
	zoomTransition: function() {
		var b = this,
			a = b.model.readData("totalKeys");
		b.model.setState("zooming");
		b.startListeningToUserInput();
		if (a > 1) {
			b.view.displayProgression(false);
			b.view.playUnlockedCasinosAnimations(true)
		} else {
			b.view.hideAllLocks()
		}
		b.view.zoomMap();
		b.view.showMap()
	},
	showBlurryDialogueBackground: function() {
		var a = this;
		a.view.fadeInMap();
		a.view.hideMap()
	},
	hideBlurredMap: function() {
		var a = this;
		a.view.fadeOutMap()
	},
	showPreview: function(c, a, b) {
		var d = this;
		d.fireEvent("request:freeSpinMapPreview:showPreview", c, a, b)
	},
	previewClosed: function() {
		var a = this;
		a.view.previewClosed()
	},
	setMapMode: function() {
		var b = this,
			c = b.model.readData("freeSpinRestore"),
			a = b.model.readData("totalKeys");
		b.startListeningToUserInput();
		if (c) {
			b.restoreMap()
		} else {
			if (a === 1) {
				b.model.setState("unlockingAnimation");
				b.view.startFirstFreespinAnimation()
			} else {
				if (a === 4 || a === 9 || a === 16) {
					b.model.setState("unlockingAnimation");
					b.showGlowingKey();
					b.view.unlockCasino()
				} else {
					b.model.setState("idle");
					b.view.removeLockedPadlocks();
					b.view.enableSelection()
				}
			}
		}
	},
	unlockAnimationsComplete: function() {
		var a = this;
		a.model.setState("idle")
	},
	restoreMap: function() {
		var a = this;
		a.fireEvent("request:disableBasicGamePanel", "freespinSplash");
		a.fireEvent("request:coinsField.showProgressiveWin", true);
		a.fireEvent("request:coinsField.showWin");
		a.fireEvent("request:cashField.showWin");
		a.fireEvent("request:ambienceManager.ambienceEnableState", true);
		a.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: "freeSpinMap",
			id: "freeSpinMap",
			loop: true
		});
		a.view.restoreMap()
	},
	modeSelected: function(c) {
		var b = this,
			a = b.model.readData("shouldSelectCasino");
		b.model.storeData("selectedMode", c);
		b.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: b.FS_AMBIENCE[c],
			id: b.FS_AMBIENCE[c],
			loop: true
		});
		if (a) {
			b.fireEvent("request:serverManager.storeParameter", "bonusId", "pickfeature");
			b.fireEvent("request:serverManager.storeParameter", "bonusActionType", "pickbonus");
			b.fireEvent("request:serverManager.storeParameter", "selectedMode", c);
			b.fireEvent("request:serverManager.sendAction", "bonusaction", "notify:responseParser.bonusActionResponseParsed")
		} else {
			b.restoreFS()
		}
	},
	introduceFS: function() {
		var a = this,
			c = a.model.readData("selectedMode"),
			b = c === "destroy" ? "destroy1" : "freespin1";
		a.setFreeSpinGameMode();
		a.fireEvent("request:spin.activateInitReelset", b, "base");
		a.fireEvent("request:spin.presentInitOutcome", b);
		a.fireEvent("request:keyCounter.hide", c);
		a.fireEvent("request:background.introduceFS", c);
		a.fireEvent("request:coinsField.showFreeSpinsLeft");
		a.view.hideMap()
	},
	setFreeSpinGameMode: function() {
		var a = this;
		a.fireEvent("request:playModeManager.removeMode", "basic");
		a.fireEvent("request:playModeManager.addMode", "freespin");
		a.fireEvent("notify:gameModeChanged", "FREESPIN")
	},
	startFS: function() {
		var a = this,
			c = a.model.readData("selectedMode"),
			b = a.model.readData("nexRS");
		a.fireEvent("request:spin.activateReelset", b, "base");
		a.fireEvent("notify:freeSpinMap.selected", c)
	},
	restoreFS: function() {
		var a = this,
			c = a.model.readData("selectedMode"),
			b = a.model.readData("nextRS");
		a.fireEvent("request:keyCounter.hide", c);
		a.fireEvent("request:spin.presentInitOutcome", b);
		a.setFreeSpinGameMode();
		a.view.hideMap();
		a.startFS()
	},
	onUserInputEnd: function() {
		var a = this;
		if (a.model.getState() === "zooming") {
			a.view.abortZoom()
		}
		a.stopListeningToUserInput();
		a.model.setState("idle")
	},
	onGameSizeChanged: function() {
		var a = this;
		a.view.refresh()
	},
	showGlowingKey: function() {
		var a = this;
		a.fireEvent("notify:keyCounter.showGlowingKey")
	},
	hideGlowingKey: function() {
		var a = this;
		a.fireEvent("notify:keyCounter.hideGlowingKey")
	}
};
Finn.FreeSpinMapController = Sys.extend(Core.Controller, Finn.FreeSpinMapController, "Finn.FreeSpinMapController");
Sys.ns("Finn");
Finn.FreeSpinMapModel = {
	DEFAULT_REELSET: "freespin",
	KEY_LEVELS: [{
		id: "randomwilds",
		min: 1,
		max: 1
	}, {
		id: "destroy",
		min: 1,
		max: 4
	}, {
		id: "symboloverlay",
		min: 4,
		max: 9
	}, {
		id: "symboltransform",
		min: 9,
		max: 16
	}],
	constructor: function() {
		Finn.FreeSpinMapModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(h) {
		var c = this,
			a = (h.nextaction === "bonusaction"),
			f = (h.restore === true) && Sys.isDefined(h.freespin),
			d = Sys.isDefined(h.next) ? h.next.rs : "freespin1",
			e = {},
			g, b;
		if (a) {
			e = c.getAvailableFreeSpins(h.freespin.mode)
		} else {
			if (f) {
				b = Sys.isDefined(h.freespins.left) ? h.freespins.left : h.freespins.initial;
				g = h.freespin.selected;
				e[g] = b
			}
		}
		c.storeData("totalKeys", h.totalkeys);
		c.storeData("shouldSelectCasino", a);
		c.storeData("freeSpinRestore", f);
		c.storeData("availableFreeSpins", e);
		c.storeData("selectedMode", g);
		c.storeData("nextRS", d)
	},
	getAvailableFreeSpins: function(b) {
		var a = this,
			c = {};
		Sys.iterate(b, function(e, d) {
			c[d.id] = d.freespins
		});
		return c
	},
	getFreespinReelInfo: function(a) {
		return Sys.utils.parseReelInfo(a, this.DEFAULT_REELSET)
	},
	getCasinosWithLabels: function() {
		var c = this,
			b = c.readData("totalKeys"),
			a = [];
		Sys.each(c.KEY_LEVELS, function(d) {
			if (b >= d.min && b <= d.max) {
				a.push(d.id)
			}
		});
		return a
	},
	getNumberOfCasinos: function() {
		return this.KEY_LEVELS.length
	},
	getCasinoFromIndex: function(a) {
		return this.KEY_LEVELS[a].id
	},
	getListOfCasinos: function() {
		var a = this,
			b = [];
		Sys.each(a.KEY_LEVELS, function(c) {
			b.push(c.id)
		});
		return b
	}
};
Finn.FreeSpinMapModel = Sys.extend(Core.Model, Finn.FreeSpinMapModel, "Finn.FreeSpinMapModel");
Sys.ns("Finn");
Finn.FreeSpinMapView = {
	CONFIG: {
		DEFAULT: {
			x: -1280 / 4,
			y: -720 / 4
		},
		LANDSCAPE: {
			x: -1280 / 4,
			y: -720 / 4
		},
		PORTRAIT: {
			x: -720 / 4,
			y: -1280 / 4
		}
	},
	PULSE_INTERVAL: 5000,
	MAP_BACKGROUND_BLUR: 6,
	ARROW_POS: {
		DESKTOP: {
			x: 166,
			y: 549
		},
		MOBILE: {
			x: 224,
			y: 542
		}
	},
	MAP_BACKGROUND_IMAGE: "freespinMapBackground",
	MAP_ISLANDS: [{
		image: "freespinIsland2",
		position: {
			x: 972,
			y: 644
		}
	}, {
		image: "freespinIsland1",
		position: {
			x: 654,
			y: 691
		}
	}, {
		image: "freespinIsland4",
		position: {
			x: 1007,
			y: 315
		}
	}, {
		image: "freespinIsland3",
		position: {
			x: 738,
			y: 407
		}
	}, {
		image: "freespinIsland6",
		position: {
			x: 306,
			y: 755
		}
	}, {
		image: "freespinIsland5",
		position: {
			x: -170,
			y: 600
		}
	}],
	ZOOM_CONFIG: {
		BACKGROUND: {
			DEFAULT: {
				startScale: 0.76,
				startPosition: {
					x: 323,
					y: -2.5
				}
			},
			LANDSCAPE: {
				startScale: 0.76,
				startPosition: {
					x: 323,
					y: -2.5
				}
			},
			PORTRAIT: {
				startScale: 0.76,
				startPosition: {
					x: 255.5,
					y: 60
				}
			}
		},
		CONTENT: {
			startScale: 0.36,
			startPosition: {
				x: 838,
				y: 92
			}
		}
	},
	MAP_CASINO_OFFSET: 32,
	MAP_CASINOS_VERTICAL_PORTRAIT_OFFSET: {
		DEFAULT: 0,
		LANDSCAPE: 0,
		PORTRAIT: 0
	},
	MAP_CASINOS: {
		randomwilds: {
			unlocked: "freespinMapCasino1Unlocked",
			hover: "freespinMapCasino1Hover",
			pulse: "freespinMapCasino1Pulse",
			click: "freespinMapCasino1Click",
			locked: "freespinMapCasino1Locked",
			disabled: "freespinMapCasino1Disabled",
			overlay: "starbarIdleAnimation",
			glow: "freespinMapCasino1Hover",
			position: {
				x: 285,
				y: 285
			},
			overlayposition: {
				x: -30,
				y: -13
			}
		},
		destroy: {
			unlocked: "freespinMapCasino2Unlocked",
			hover: "freespinMapCasino2Hover",
			pulse: "freespinMapCasino2Pulse",
			click: "freespinMapCasino2Click",
			locked: "freespinMapCasino2Locked",
			disabled: "freespinMapCasino2Disabled",
			overlay: "destroyIdleAnimation",
			glow: "freespinMapCasino2Hover",
			position: {
				x: 655,
				y: 285
			},
			overlayposition: {
				x: -131,
				y: -106
			}
		},
		symboloverlay: {
			unlocked: "freespinMapCasino3Unlocked",
			hover: "freespinMapCasino3Hover",
			pulse: "freespinMapCasino3Pulse",
			click: "freespinMapCasino3Click",
			locked: "freespinMapCasino3Locked",
			disabled: "freespinMapCasino3Disabled",
			overlay: "symbolOverlayIdleAnimation",
			glow: "freespinMapCasino3Hover",
			position: {
				x: 402,
				y: 63
			},
			overlayposition: {
				x: -20,
				y: -79
			}
		},
		symboltransform: {
			unlocked: "freespinMapCasino4Unlocked",
			hover: "freespinMapCasino4Hover",
			pulse: "freespinMapCasino4Pulse",
			click: "freespinMapCasino4Click",
			locked: "freespinMapCasino4Locked",
			disabled: "freespinMapCasino4Disabled",
			overlay: "symbolTransformIdleAnimation",
			glow: "freespinMapCasino4Hover",
			position: {
				x: 708,
				y: -7
			},
			overlayposition: {
				x: -73,
				y: -18
			}
		}
	},
	PADLOCK_LOCKED_IMAGE: "padlockLocked",
	PADLOCK_UNLOCKED_IMAGE: "padlockUnlocked",
	KEYCOUNT_LABEL: "labelforkeycount",
	PADLOCK_LOCKED_ANIMATION: "freeSpinMaPadlock",
	PADLOCK_LOCKED_ANIMATION_OFFSET_POSITION: 60,
	PADLOCK_LOCKED_UNLOCKED_ANIMATION_OFFSET_POSITION: 26,
	MAP_PADLOCKS: {
		randomwilds: {
			padlock_locked_position: {
				x: 425,
				y: 440
			},
			padlock_unlocked_position: {
				x: 385,
				y: 426
			}
		},
		destroy: {
			padlock_locked_position: {
				x: 739,
				y: 410
			},
			padlock_unlocked_position: {
				x: 699,
				y: 396
			}
		},
		symboloverlay: {
			padlock_locked_position: {
				x: 503,
				y: 189
			},
			padlock_unlocked_position: {
				x: 463,
				y: 173
			}
		},
		symboltransform: {
			padlock_locked_position: {
				x: 775,
				y: 108
			},
			padlock_unlocked_position: {
				x: 735,
				y: 94
			}
		}
	},
	MAP_KEYS: {
		destroy: {
			key_position: {
				x: 724,
				y: 500
			},
			needed_keys: 4
		},
		symboloverlay: {
			key_position: {
				x: 488,
				y: 279
			},
			needed_keys: 9
		},
		symboltransform: {
			key_position: {
				x: 760,
				y: 198
			},
			needed_keys: 16
		}
	},
	PADLOCK_ANIMATION_OFFSET_X: 56.5,
	PADLOCK_ANIMATION_OFFSET_Y: 47.5,
	KEY_COUNTER_TEXT_OFFSET_X: 64,
	KEY_COUNTER_TEXT_OFFSET_Y: 17,
	KEYS_NEEDED_OFFSET: 12,
	constructor: function() {
		Finn.FreeSpinMapView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainerBackground = new PIXI.Container();
		b.backgroundContainer = new PIXI.Container();
		b.backgroundSprite = Game.PIXIFactory.createAndAddSprite(Game.stage.getOrientationSpecificImage(b.MAP_BACKGROUND_IMAGE), b.backgroundContainer);
		b.backgroundContainer.position.x = -1280 / 4;
		b.backgroundContainer.position.y = -720 / 4;
		b.backgroundContainer.visible = false;
		b.rootContainerBackground.addChild(b.backgroundContainer);
		var a = Game.stage.view.animationManager.getLayer("splashScreensBackground");
		a.addChild(b.rootContainerBackground);
		b.rootContainerContent = new PIXI.Container();
		b.rootContainerContent.position.x = -1280 / 4;
		b.rootContainerContent.position.y = -720 / 4;
		b.mapIslandContainer = b.createIslands();
		b.mapIslandContainer.visible = false;
		b.mapContentContainer = b.createMap();
		b.mapContentContainer.position.x = 1280 / 4;
		b.mapContentContainer.position.y = 720 / 4;
		b.mapContentContainer.visible = false;
		b.createCasinoPadlocks();
		b.createAndTriggerArrowAnimation();
		b.rootContainerContent.addChild(b.mapIslandContainer);
		b.rootContainerContent.addChild(b.mapContentContainer);
		a = Game.stage.view.animationManager.getLayer("splashScreensContent");
		a.addChild(b.rootContainerContent);
		b.zoomBackgroundAnimation = b.initZoomAnimation(Game.stage.view.animationManager.getGroupLayer(3), Environment.getOrientationSpecificConfig(b.ZOOM_CONFIG.BACKGROUND, true));
		b.zoomContentAnimation = b.initZoomAnimation(Game.stage.view.animationManager.getGroupLayer(4), b.ZOOM_CONFIG.CONTENT);
		b.fadeInBackgroundAnimation = b.initFadeInAnimation(Game.stage.view.animationManager.getGroupLayer(3));
		b.fadeInContentAnimation = b.initFadeInAnimation(Game.stage.view.animationManager.getGroupLayer(4));
		b.fadeOutBackgroundAnimation = b.initFadeOutAnimation(Game.stage.view.animationManager.getGroupLayer(3));
		b.fadeOutContentAnimation = b.initFadeOutAnimation(Game.stage.view.animationManager.getGroupLayer(4))
	},
	createIslands: function() {
		var b = this,
			a = new PIXI.Container(),
			c;
		Sys.each(b.MAP_ISLANDS, function(d) {
			c = Game.PIXIFactory.createAndAddSprite(d.image, a);
			c.position = new PIXI.Point(d.position.x, d.position.y)
		});
		return a
	},
	createMap: function() {
		var d = this,
			b = new PIXI.Container(),
			a = {
				casinos: {}
			},
			e, c;
		d.initialHeight = {};
		Sys.iterate(d.MAP_CASINOS, function(f, g) {
			e = g.position.x + d.MAP_CASINO_OFFSET;
			c = g.position.y + d.MAP_CASINO_OFFSET + Environment.getOrientationSpecificConfig(d.MAP_CASINOS_VERTICAL_PORTRAIT_OFFSET, true);
			a.casinos[f] = new Finn.CasinoButton(g.locked, g.click, g.hover, g.pulse, g.unlocked, g.disabled, g.overlay, g.overlayposition, f);
			a.casinos[f].moveTo(new PIXI.Point(e, c + a.casinos[f].height), new PIXI.Point(0, 0));
			a.casinos[f].setEnabled(false);
			a.casinos[f].clickCallback = d.showPreview.bind(d, f, false);
			a.casinos[f].transform.pivot.y = a.casinos[f].height;
			d.initialHeight[f] = a.casinos[f].height;
			b.addChild(a.casinos[f])
		});
		d.mapItems = a;
		return b
	},
	createAndTriggerArrowAnimation: function() {
		var a = this;
		a.arrow = Game.PIXIFactory.createAndAddSpineAnimation("arrowAnimationFSmap", a.mapContentContainer, new PIXI.Point(a.ARROW_POS.DESKTOP.x, a.ARROW_POS.DESKTOP.y), new PIXI.Point(0, 0));
		a.mapContentContainer.addChild(a.arrow);
		a.arrow.visible = false;
		a.arrow.fire = function() {
			a.arrow.state.setAnimation(0, "animation", true);
			a.arrow.visible = true
		};
		Game.PIXIUtils.resetSpineAnimation(a.arrow);
		a.arrow.fire()
	},
	showArrowAnimation: function() {
		var a = this;
		if (!Platform.isDesktopDevice) {
			a.arrow.position.x = a.ARROW_POS.MOBILE.x;
			a.arrow.position.y = a.ARROW_POS.MOBILE.y;
			a.arrow.scale.x = 1.33;
			a.arrow.scale.y = 1.33
		} else {
			a.arrow.position.x = a.ARROW_POS.DESKTOP.x;
			a.arrow.position.y = a.ARROW_POS.DESKTOP.y;
			a.arrow.scale.x = 1;
			a.arrow.scale.y = 1
		}
	},
	createCasinoPadlocks: function() {
		var b = this,
			a = {
				casinos: {},
				padlocks: {},
				padlocksanimation: {},
				padlocksUnlockedanimation: {},
				padlockkeys: {},
				padlockkeycounter: {}
			};
		Sys.iterate(b.MAP_CASINOS, function(c, f) {
			var e = f.position.x + b.MAP_CASINO_OFFSET;
			var d = f.position.y + b.MAP_CASINO_OFFSET + Environment.getOrientationSpecificConfig(b.MAP_CASINOS_VERTICAL_PORTRAIT_OFFSET, true);
			a.casinos[c] = b.createPadlockSprite(f.unlocked, e, d)
		});
		Sys.iterate(b.MAP_PADLOCKS, function(e, f) {
			a.padlocks[e] = b.createPadlockSprite(b.PADLOCK_LOCKED_IMAGE, f.padlock_locked_position.x, f.padlock_locked_position.y);
			var d = f.padlock_locked_position.x - b.PADLOCK_ANIMATION_OFFSET_X;
			var c = f.padlock_locked_position.y - b.PADLOCK_ANIMATION_OFFSET_Y;
			a.padlocksanimation[e] = b.createAnimation(b.PADLOCK_LOCKED_ANIMATION, d, c);
			a.padlocksanimation[e].fire = function(g) {
				b.fireEvent("view:playAudio", {
					id: "lockCasino",
					name: "lockCasino"
				});
				a.padlocksanimation[e].visible = true;
				a.padlocksanimation[e].state.setAnimation(0, "padlock_locked", false);
				a.padlocksanimation[e].state.addListener({
					complete: function() {
						a.padlocksanimation[e].state.clearListeners();
						b.playNextLockingAnimation(g)
					}
				});
				a.padlocksanimation[e].updateTransform()
			};
			a.padlocksUnlockedanimation[e] = b.createAnimation(b.PADLOCK_LOCKED_ANIMATION, d, c);
			a.padlocksUnlockedanimation[e].fire = function(g, j) {
				b.fireEvent("view:playAudio", {
					id: "unlockCasino",
					name: "unlockCasino"
				});
				a.padlocksUnlockedanimation[e].visible = true;
				a.padlocksUnlockedanimation[e].state.setAnimation(0, "padlock_unlocked", false);
				var h = a.padlocksUnlockedanimation[e].state;
				h.addListener({
					complete: function() {
						h.clearListeners();
						b.removeUnlockedAnimation(g, j)
					}
				});
				a.padlocksUnlockedanimation[e].updateTransform()
			}
		});
		Sys.iterate(b.MAP_KEYS, function(e, g) {
			var f = b.model.readData("totalKeys").toString() + "/" + g.needed_keys.toString();
			a.padlockkeys[e] = b.createPadlockSprite(b.KEYCOUNT_LABEL, g.key_position.x, g.key_position.y);
			var d = g.key_position.x + b.KEY_COUNTER_TEXT_OFFSET_X;
			var c = g.key_position.y + b.KEY_COUNTER_TEXT_OFFSET_Y;
			a.padlockkeycounter[e] = b.createPadlockText(" ", Game.TextStyles.LABELS_TEXT_FREESPINMAP, d, c, 44);
			a.padlockkeycounter[e].setLabel(f);
			a.padlockkeycounter[e].updateLabel()
		});
		b.mapItemsProgression = a
	},
	createPadlockSprite: function(d, a, e) {
		var c = this,
			b;
		b = Game.PIXIFactory.createAndAddSprite(d, c.mapContentContainer, new PIXI.Point(a, e), new PIXI.Point(0, 0));
		c.mapContentContainer.addChild(b);
		b.visible = false;
		return b
	},
	createAnimation: function(d, a, e) {
		var c = this,
			b;
		b = Game.PIXIFactory.createAndAddSpineAnimation(d, c.mapContentContainer, new PIXI.Point(a, e), new PIXI.Point(0, 0));
		c.mapContentContainer.addChild(b);
		b.visible = false;
		return b
	},
	playNextLockingAnimation: function(a) {
		var b = this;
		if (a > 0) {
			b.lockingCasino(a - 1)
		} else {
			b.showGlowingKey()
		}
	},
	removeUnlockedAnimation: function(a, c) {
		var b = this;
		b.removeUnlockedPadlock(a, c)
	},
	createPadlockText: function(f, c, a, g, e) {
		var d = this,
			b;
		b = new Interface.utils.PIXILabel(f, c);
		b.id = "KeyCounterLabel";
		b.x = a;
		b.y = g;
		b.setAnchorPoint(new PIXI.Point(0.5, 0.5));
		b.setLabelMaxWidth(e);
		d.mapContentContainer.addChild(b);
		b.visible = false;
		return b
	},
	initZoomAnimation: function(d, c) {
		var a = {
			prop: "position",
			animate: [{
				time: 0,
				value: c.startPosition,
				ease: Animation.utils.powerOneOut
			}, {
				time: 7000,
				value: {
					x: 0,
					y: 0
				}
			}]
		};
		var e = {
			prop: "scale",
			animate: [{
				time: 0,
				value: {
					x: c.startScale,
					y: c.startScale
				},
				ease: Animation.utils.powerOneOut
			}, {
				time: 7000,
				value: {
					x: 1,
					y: 1
				}
			}]
		};
		var b = new Animation.Holder({
			id: "zoomAnimation",
			target: d,
			delay: 0,
			children: [a, e]
		});
		Game.stage.view.animationManager.addToAnimationLoop(b);
		return b
	},
	initFadeInAnimation: function(c) {
		var b = this;
		var a = new Animation.Holder({
			id: "fadeInAnimation",
			target: c,
			delay: 0,
			prop: "alpha",
			onStart: function() {
				b.showMap()
			},
			animate: [{
				time: 0,
				value: 0
			}, {
				time: 1000,
				value: 1
			}]
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	initFadeOutAnimation: function(c) {
		var b = this;
		var a = new Animation.Holder({
			id: "fadeInAnimation",
			target: c,
			delay: 0,
			prop: "alpha",
			onEnd: b.fadeOutComplete.bind(b),
			animate: [{
				time: 0,
				value: 1
			}, {
				time: 1000,
				value: 0
			}]
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	fadeOutComplete: function() {
		var a = this;
		a.hideMap();
		Game.stage.view.animationManager.getGroupLayer(3).alpha = 1;
		Game.stage.view.animationManager.getGroupLayer(4).alpha = 1
	},
	fadeInMap: function() {
		var a = this;
		a.fadeInBackgroundAnimation.play();
		a.fadeInContentAnimation.play()
	},
	fadeOutMap: function() {
		var a = this;
		a.fadeOutBackgroundAnimation.play();
		a.fadeOutContentAnimation.play()
	},
	showMap: function() {
		var a = this;
		a.backgroundContainer.visible = true;
		a.mapIslandContainer.visible = true;
		a.mapContentContainer.visible = true;
		a.refresh()
	},
	hideMap: function() {
		var a = this;
		a.backgroundContainer.visible = false;
		a.mapIslandContainer.visible = false;
		a.mapContentContainer.visible = false
	},
	zoomMap: function() {
		var b = this,
			c = Environment.getOrientationSpecificConfig(b.ZOOM_CONFIG.BACKGROUND, true),
			a = b.ZOOM_CONFIG.CONTENT;
		b.zoomBackgroundAnimation.children[0].animation.keyFrames[0].value = c.startPosition;
		b.zoomContentAnimation.children[0].animation.keyFrames[0].value = a.startPosition;
		b.zoomBackgroundAnimation.play();
		b.zoomContentAnimation.play()
	},
	showPreview: function(c, b) {
		var d = this,
			e = d.model.readData("availableFreeSpins"),
			a = (d.model.getState() !== "unlockingAnimation" && d.model.getState() !== "zooming");
		if (a) {
			d.fireEvent("view:showPreview", c, e[c], b);
			d.disableAllModes()
		}
	},
	previewClosed: function() {
		var a = this;
		a.enableSelection()
	},
	enableSelection: function() {
		var a = this,
			b = a.model.readData("availableFreeSpins");
		Sys.iterate(b, function(c) {
			a.mapItems.casinos[c].setUnLocked(true)
		});
		a.enableAllModes();
		a.pulseInIdle()
	},
	playUnlockedCasinosAnimations: function(f) {
		var e = this,
			b = e.model.getCasinosWithLabels(),
			a = b[0];
		for (var d in this.mapItems.casinos) {
			if (d !== a) {
				var c = this.mapItems.casinos[d];
				c.setUnLocked(f);
				c.updateGraphics();
				c.isDoingPadlockAnimation = true;
				e.enableAllModes()
			} else {
				break
			}
		}
	},
	displayProgression: function(d) {
		var c = this,
			b = c.model.readData("totalKeys"),
			a = c.model.getCasinosWithLabels(),
			e;
		if (d && a.length >= 2) {
			e = a[1]
		} else {
			if (!d || b < 16) {
				e = a[0]
			}
		}
		Sys.iterate(c.MAP_KEYS, function(g, f) {
			if ((d && b === f.needed_keys) || b > f.needed_keys) {
				c.mapItemsProgression.padlocks[g].visible = false
			} else {
				c.mapItemsProgression.padlocks[g].visible = true
			}
		});
		c.showNextCasinoKeyLabel(e)
	},
	showNextCasinoKeyLabel: function(a) {
		var c = this,
			b;
		Sys.iterate(c.MAP_KEYS, function(d) {
			b = d === a;
			c.setKeyLabelVisibility(d, b)
		})
	},
	setKeyLabelVisibility: function(a, c) {
		var b = this;
		if (Sys.isDefined(b.MAP_KEYS[a])) {
			b.mapItemsProgression.padlockkeys[a].visible = c;
			b.mapItemsProgression.padlockkeycounter[a].visible = c
		}
	},
	lockingAndUnlockingCasinos: function(a, c) {
		var b = this;
		b.mapItems.casinos[a].setUnLocked(c);
		b.mapItems.casinos[a].updateGraphics()
	},
	updateKeys: function() {
		var a = this;
		Sys.iterate(a.MAP_KEYS, function(b, c) {
			a.mapItemsProgression.padlockkeycounter[b].setLabel(a.model.readData("totalKeys").toString() + "/" + c.needed_keys.toString());
			a.mapItemsProgression.padlockkeycounter[b].updateLabel()
		})
	},
	startFirstFreespinAnimation: function() {
		var a = this;
		a.highlightCasino(0)
	},
	highlightCasino: function(b) {
		var c = this,
			a = c.model.getCasinoFromIndex(b);
		c.fireEvent("view:playAudio", {
			id: "highlightCasino",
			name: "highlightCasino"
		});
		c.mapItemsProgression.casinos[a].visible = true;
		c.animationTimeout = setTimeout(function() {
			if (b < c.model.getNumberOfCasinos() - 1) {
				c.highlightCasino(b + 1)
			} else {
				c.lockingCasino(c.model.getNumberOfCasinos() - 1)
			}
		}, 700)
	},
	lockingCasino: function(b) {
		var c = this,
			a = c.model.getCasinoFromIndex(b);
		c.mapItemsProgression.casinos[a].visible = false;
		c.lockingAndUnlockingCasinos(a, false);
		c.mapItemsProgression.padlocksanimation[a].visible = true;
		Game.PIXIUtils.resetSpineAnimation(c.mapItemsProgression.padlocksanimation[a]);
		c.mapItemsProgression.padlocksanimation[a].fire(b)
	},
	showGlowingKey: function() {
		var a = this;
		a.fireEvent("view:showGlowingKey");
		a.animationTimeout = setTimeout(function() {
			a.unlockCasino()
		}, 700)
	},
	unlockCasino: function() {
		var c = this,
			b = c.model.getCasinosWithLabels(),
			a = b[0],
			d = b[1];
		c.mapItemsProgression.padlocks[a].visible = false;
		c.mapItemsProgression.padlocksanimation[a].visible = false;
		c.mapItemsProgression.padlocksUnlockedanimation[a].visible = true;
		Game.PIXIUtils.resetSpineAnimation(c.mapItemsProgression.padlocksUnlockedanimation[a]);
		c.mapItemsProgression.padlocksUnlockedanimation[a].fire(a, d);
		c.animationTimeout = setTimeout(function() {
			c.fireEvent("view:hideGlowingKey")
		}, 700)
	},
	removeLockedPadlocks: function() {
		var e = this,
			c = e.model.getCasinosWithLabels(),
			b = c[0],
			a = e.model.getListOfCasinos();
		for (var d = 0; d < a.length; d++) {
			if (a[d] === b) {
				break
			}
			e.mapItemsProgression.padlocks[a[d]].visible = false
		}
	},
	removeUnlockedPadlock: function(a, c) {
		var b = this;
		b.mapItemsProgression.padlocksUnlockedanimation[a].visible = false;
		b.lockingAndUnlockingCasinos(a, true);
		b.setKeyLabelVisibility(a, false);
		b.mapItems.casinos[a].highlight();
		b.enableSelection();
		b.animationTimeout = setTimeout(function() {
			b.showNextCasinoKeyLabel(c, true);
			b.fireEvent("view:unlockAnimationsComplete")
		}, 700)
	},
	pulseInIdle: function() {
		var a = this,
			b = a.model.readData("availableFreeSpins");
		a.pulseInterval = setInterval(function() {
			Sys.iterate(b, function(c) {
				a.mapItems.casinos[c].highlight()
			})
		}, a.PULSE_INTERVAL)
	},
	enableAllModes: function() {
		var a = this;
		Sys.iterate(a.mapItems.casinos, function(b, c) {
			c.setEnabled(true);
			c.redraw()
		})
	},
	disableAllModes: function() {
		var a = this;
		clearInterval(a.pulseInterval);
		Sys.iterate(a.mapItems.casinos, function(b, c) {
			c.setEnabled(false);
			c.redraw()
		})
	},
	restoreMap: function() {
		var b = this,
			a = b.model.readData("shouldSelectCasino"),
			c = b.model.readData("selectedMode");
		b.showMap();
		if (a) {
			b.enableSelection();
			b.displayProgression(true)
		} else {
			b.showPreview(c, true);
			b.disableAllModes()
		}
	},
	abortZoom: function() {
		var a = this;
		a.zoomBackgroundAnimation.stop();
		a.zoomContentAnimation.stop();
		Game.stage.view.animationManager.getGroupLayer(3).position = {
			x: 0,
			y: 0
		};
		Game.stage.view.animationManager.getGroupLayer(4).position = {
			x: 0,
			y: 0
		};
		Game.stage.view.animationManager.getGroupLayer(3).scale = {
			x: 1,
			y: 1
		};
		Game.stage.view.animationManager.getGroupLayer(4).scale = {
			x: 1,
			y: 1
		}
	},
	refreshZoom: function() {
		var b = this,
			c = Environment.getOrientationSpecificConfig(b.ZOOM_CONFIG.BACKGROUND, true),
			a = b.ZOOM_CONFIG.CONTENT;
		b.zoomBackgroundAnimation.children[0].animation.keyFrames[0].value = c.startPosition;
		b.zoomContentAnimation.children[0].animation.keyFrames[0].value = a.startPosition
	},
	abortUnlockingCasinosAnimation: function() {
		var a = this;
		clearTimeout(a.animationTimeout);
		a.hideAllLocks();
		a.displayProgression(true);
		a.enableSelection();
		a.fireEvent("view:hideGlowingKey")
	},
	hideAllLocks: function() {
		var a = this;
		Sys.iterate(a.MAP_PADLOCKS, function(b) {
			a.mapItemsProgression.padlocks[b].visible = false;
			a.mapItemsProgression.padlocksanimation[b].visible = false;
			a.mapItemsProgression.padlocksUnlockedanimation[b].visible = false;
			a.mapItemsProgression.casinos[b].visible = false
		});
		Sys.iterate(a.MAP_KEYS, function(b) {
			a.setKeyLabelVisibility(b, false)
		})
	},
	refresh: function() {
		var a = this;
		a.refreshZoom();
		a.backgroundSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(a.MAP_BACKGROUND_IMAGE)];
		a.backgroundContainer.position = Environment.getOrientationSpecificConfig(a.CONFIG, true);
		a.showArrowAnimation();
		Sys.iterate(a.MAP_CASINOS, function(b, c) {
			a.mapItems.casinos[b].position.y = a.initialHeight[b] + c.position.y + a.MAP_CASINO_OFFSET + Environment.getOrientationSpecificConfig(a.MAP_CASINOS_VERTICAL_PORTRAIT_OFFSET, true)
		})
	}
};
Finn.FreeSpinMapView = Sys.extend(Core.View, Finn.FreeSpinMapView, "Finn.FreeSpinMapView");
Sys.ns("Finn");
Finn.FreeSpinMapViewLow = {
	constructor: function() {
		Finn.FreeSpinMapViewLow.superclass.constructor.apply(this, arguments)
	},
	blurBackground: function() {},
	unBlurBackground: function() {}
};
Finn.FreeSpinMapViewLow = Sys.extend(Finn.FreeSpinMapView, Finn.FreeSpinMapViewLow, "Finn.FreeSpinMapViewLow");
Sys.ns("Finn");
Finn.CasinoButton = {
	constructor: function(j, k, f, b, g, c, d, e, a) {
		Interface.utils.PIXIButton.superclass.constructor.apply(this, arguments);
		var h = this;
		this.ID = Sys.isDefined(a) ? a : this.DEFAULT_ID;
		this._graphicReferences = {
			up: j,
			down: k,
			over: f,
			disabled: c,
			unLocked: g,
			pulse: b
		};
		this._labelStyleReferences = {
			up: undefined,
			down: undefined,
			over: undefined,
			disabled: undefined,
			unLocked: undefined,
			pulse: undefined
		};
		this._pooledGraphics = {};
		this.shouldUpdateDimensions = false;
		this.shouldUpdateLabel = false;
		this.shouldUpdateGraphics = false;
		this.backgroundGraphics = Game.PIXIFactory.createAndAddSprite(b, this);
		this.pulseAnimation = this.initPulseAnimation(this.backgroundGraphics);
		this.updateGraphics();
		this.updateHitArea();
		if (Sys.isDefined(Services.trigger)) {
			this.registerTriggers()
		}
		h.overlayGraphics = Game.PIXIFactory.createAndAddSpineAnimation(d, this);
		if (d === "destroyIdleAnimation") {
			h.overlayGraphics.state.timeScale = 0.7
		}
		h.overlayGraphics.fire = function() {
			h.overlayGraphics.state.setAnimation(0, "animation", true);
			h.overlayGraphics.visible = true
		};
		h.overlayGraphics.visible = false;
		h.overlayGraphics.position.x = e.x;
		h.overlayGraphics.position.y = e.y;
		this.soundEnabled = true;
		this.unLocked = false
	},
	updateGraphics: function() {
		var c = this;
		var a;
		if (this._enabled) {
			if (this._currentState === this.UP && this.unLocked) {
				a = this._graphicReferences.unLocked
			} else {
				a = this._graphicReferences[this._currentState]
			}
		} else {
			a = this._graphicReferences.disabled
		}
		if (c._enabled && c.unLocked && !c.overlayGraphics.visible) {
			Game.PIXIUtils.resetSpineAnimation(c.overlayGraphics);
			c.overlayGraphics.fire();
			c.overlayGraphics.visible = true
		} else {
			if (c.overlayGraphics && !c.overlayGraphics.visible) {
				Game.PIXIUtils.resetSpineAnimation(c.overlayGraphics);
				c.overlayGraphics.visible = false
			}
		}
		if (this.graphics) {
			var b = this.getTexture(a);
			if (b !== undefined) {
				this.setTexture(b)
			}
		} else {
			this.graphics = Game.PIXIFactory.createAndAddSprite(a, this)
		}
		this.shouldUpdateGraphics = false;
		this.shouldUpdateDimensions = true
	},
	setTexture: function(a) {
		var b = this._currentState;
		if (this._currentState === this.UP || !this._enabled) {
			this.backgroundGraphics.alpha = 0;
			this.graphics.texture = a
		} else {
			this.pulseAnimation.stop();
			this.backgroundGraphics.alpha = 1;
			this.backgroundGraphics.texture = a;
			if (this.unLocked) {
				this.graphics.texture = this.getTexture(this._graphicReferences.unLocked)
			} else {
				this.graphics.texture = this.getTexture(this._graphicReferences.up)
			}
		}
	},
	highlight: function() {
		if (this._currentState === this.UP) {
			this.backgroundGraphics.alpha = 0;
			this.pulseAnimation.play()
		} else {
			if (this._enabled) {
				this.backgroundGraphics.alpha = 1;
				this.pulseAnimation.stop()
			} else {
				this.backgroundGraphics.alpha = 0;
				this.pulseAnimation.stop()
			}
		}
	},
	setUnLocked: function(a) {
		this.unLocked = a
	},
	initPulseAnimation: function(b) {
		var a = new Animation.Holder({
			id: "pulseAnimation",
			target: b,
			loop: false,
			prop: "alpha",
			animate: {
				0: 0,
				500: 1,
				1000: 0
			}
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	}
};
Finn.CasinoButton = Sys.extend(Interface.utils.PIXIButton, Finn.CasinoButton, "Finn.CasinoButton");
Sys.ns("Finn");
Finn.FreeSpinMapPreview = {
	constructor: function() {
		Finn.FreeSpinMapPreview.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			controller: Finn.FreeSpinMapPreviewController,
			view: Finn.FreeSpinMapPreviewView
		}
	}
};
Finn.FreeSpinMapPreview = Sys.extend(Core.Module, Finn.FreeSpinMapPreview, "Finn.FreeSpinMapPreview");
Sys.ns("Finn");
Finn.FreeSpinMapPreviewController = {
	constructor: function() {
		Finn.FreeSpinMapPreviewController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:modeSelected": a.modeSelected,
			"view:previewClosed": a.previewClosed,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"request:freeSpinMapPreview:showPreview": a.showPreview,
			"notify:scaling.gameSizeChanged": a.onGameSizeChanged
		})
	},
	showPreview: function(b, d, a) {
		var c = this;
		c.view.showPreview(b, d, a)
	},
	previewClosed: function() {
		var a = this;
		a.fireEvent("notify:freeSpinMapPreview:previewClosed")
	},
	modeSelected: function(b) {
		var a = this;
		a.fireEvent("notify:freeSpinMapPreview:modeSelected", b)
	},
	onGameSizeChanged: function() {
		var a = this;
		a.view.refresh()
	}
};
Finn.FreeSpinMapPreviewController = Sys.extend(Core.Controller, Finn.FreeSpinMapPreviewController, "Finn.FreeSpinMapPreviewController");
Sys.ns("Finn");
Finn.FreeSpinMapPreviewView = {
	IMAGE_SUFFIX: "Portrait",
	MAP_BACKGROUND_IMAGE: "freespinMapBackground",
	MAP_BACKGROUND_BLURRED_IMAGE: "freespinmapBlurredImage",
	MAP_BACKGROUND_BLURRED_IMAGE_POSITION: {
		DESKTOP: {
			x: 640,
			y: 360
		},
		LANDSCAPE: {
			x: 640,
			y: 360
		},
		PORTRAIT: {
			x: 640,
			y: 522
		}
	},
	MAP_CASINO_PREVIEWS: {
		randomwilds: {
			previewBackground: "freeespinPreview1",
			headingKey: Language.Keys.PaytableFS1,
			featureKey: Language.Keys.PaytableRF1,
			color: "#e677ed",
			numberOfKeys: 1,
			numberOfFreeSpins: 7
		},
		destroy: {
			previewBackground: "freeespinPreview2",
			headingKey: Language.Keys.PaytableFS2,
			featureKey: Language.Keys.PaytableRF2,
			color: "#ff5c11",
			numberOfKeys: 4,
			numberOfFreeSpins: 3
		},
		symboloverlay: {
			previewBackground: "freeespinPreview3",
			headingKey: Language.Keys.PaytableFS3,
			featureKey: Language.Keys.PaytableRF3,
			color: "#009933",
			numberOfKeys: 9,
			numberOfFreeSpins: 4
		},
		symboltransform: {
			previewBackground: "freeespinPreview4",
			headingKey: Language.Keys.PaytableFS4,
			featureKey: Language.Keys.PaytableRF4,
			color: "#ffa500",
			numberOfKeys: 16,
			numberOfFreeSpins: 2
		}
	},
	MAP_PREVIEW_POSITIONS: {
		background: {
			x: 335,
			y: 50
		},
		heading: {
			x: 640,
			y: 120
		},
		casinoInformation: {
			x: 420,
			y: 190,
			width: 180
		},
		bottomText: {
			x: 640,
			y: 495
		},
		cancelButton: {
			x: 875,
			y: 40
		},
		startButton: {
			x: 640,
			y: 522
		}
	},
	MAP_PREVIEW_TEXT_STRINGS: {
		welcome: Language.Keys.welcome,
		openingSoon: Language.Keys.openingSoon,
		freeSpins: Language.Keys.freeSpinsFinn,
		keysToUnlock: Language.Keys.keysToUnlockFinn,
		keyToUnlock: Language.Keys.keyToUnlockFinn,
		feature: Language.Keys.featureColonFinn,
		youNeedKeys: Language.Keys.youNeedKeys,
		freeSpinsLeft: Language.Keys.freeSpinsLeftColon
	},
	MAP_PREVIEW_BUTTON_START: {
		key: Language.Keys.startButton,
		x: 640,
		y: 640
	},
	MAP_PREVIEW_BUTTON_CONTINUE: {
		key: Language.Keys.continueButton,
		x: 640,
		y: 640
	},
	constructor: function() {
		Finn.FreeSpinMapPreviewView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this,
			a;
		b.previews = {};
		b.rootContainer = new PIXI.Container();
		b.backgroundBlurredImage = Game.PIXIFactory.createAndAddSprite(Game.stage.getOrientationSpecificImage(b.MAP_BACKGROUND_BLURRED_IMAGE), b.rootContainer, Environment.getOrientationSpecificConfig(b.MAP_BACKGROUND_BLURRED_IMAGE_POSITION, true), new PIXI.Point(0.5, 0.5));
		b.backgroundBlurredImage.visible = false;
		b.previewContainer = b.createPreviews();
		b.rootContainer.addChild(b.previewContainer);
		a = Game.stage.view.animationManager.getLayer("splashScreensDialog");
		a.addChild(b.rootContainer)
	},
	createPreviews: function() {
		var b = this,
			a = new PIXI.Container(),
			c, d;
		Sys.iterate(b.MAP_CASINO_PREVIEWS, function(e, f) {
			c = b.createPreviewBox(e, f);
			b.previews[e] = c;
			d = b.createPreviewCasinoInformation(e, f);
			c.container.addChild(d.container);
			c.container.visible = false;
			a.addChild(c.container)
		});
		return a
	},
	createPreviewBox: function(d, c) {
		var f = this,
			a = new PIXI.Container(),
			b = {},
			e = new PIXI.Point(0, 0),
			g = new PIXI.Point(0.5, 0);
		b.background = Game.PIXIFactory.createAndAddSprite(c.previewBackground, a, new PIXI.Point(f.MAP_PREVIEW_POSITIONS.background.x, f.MAP_PREVIEW_POSITIONS.background.y), e);
		b.heading = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(f.MAP_PREVIEW_TEXT_STRINGS.openingSoon), Game.TextStyles.MAP_PREVIEW_HEADING, a, new PIXI.Point(f.MAP_PREVIEW_POSITIONS.heading.x, f.MAP_PREVIEW_POSITIONS.heading.y), g);
		b.bottomText = Game.PIXIFactory.createAndAddText("", Game.TextStyles.MAP_PREVIEW_FREESPINS_LEFT, a, new PIXI.Point(f.MAP_PREVIEW_POSITIONS.bottomText.x, f.MAP_PREVIEW_POSITIONS.bottomText.y), g);
		b.bottomText.visible = false;
		b.cancelButton = f.createCancelButton(d);
		a.addChild(b.cancelButton);
		b.startButton = f.createContinueButton(d, f.MAP_PREVIEW_BUTTON_START.key, f.MAP_PREVIEW_POSITIONS.startButton);
		a.addChild(b.startButton);
		b.continueButton = f.createContinueButton(d, f.MAP_PREVIEW_BUTTON_CONTINUE.key, f.MAP_PREVIEW_POSITIONS.startButton);
		a.addChild(b.continueButton);
		return {
			container: a,
			items: b
		}
	},
	createPreviewCasinoInformation: function(k, f) {
		var h = this,
			g = {},
			b = new PIXI.Container(),
			j = h.MAP_PREVIEW_POSITIONS.casinoInformation.width,
			m = new PIXI.Point(0.5, 0),
			l = 10,
			e = 1,
			d = 0,
			a, c;
		b.position = new PIXI.Point(h.MAP_PREVIEW_POSITIONS.casinoInformation.x, h.MAP_PREVIEW_POSITIONS.casinoInformation.y);
		b.width = j;
		g.freeSpinsNumber = Game.PIXIFactory.createAndAddText(f.numberOfFreeSpins, Game.TextStyles.MAP_PREVIEW_HEADING, b, new PIXI.Point(j / 2, e * d), m);
		d += g.freeSpinsNumber.height;
		g.freeSpinsText = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(h.MAP_PREVIEW_TEXT_STRINGS.freeSpins), Game.TextStyles.MAP_PREVIEW_TEXT, b, new PIXI.Point(j / 2, e * d), m);
		d += g.freeSpinsText.height;
		d += l;
		g.keysToUnlockNumber = Game.PIXIFactory.createAndAddText(f.numberOfKeys, Game.TextStyles.MAP_PREVIEW_HEADING, b, new PIXI.Point(j / 2, e * d), m);
		d += g.keysToUnlockNumber.height;
		c = f.numberOfKeys > 1 ? h.MAP_PREVIEW_TEXT_STRINGS.keysToUnlock : h.MAP_PREVIEW_TEXT_STRINGS.keyToUnlock;
		g.keysToUnlockText = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(c), Game.TextStyles.MAP_PREVIEW_TEXT, b, new PIXI.Point(j / 2, e * d), m);
		d += 40;
		d += 2 * l;
		g.featureHeading = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(h.MAP_PREVIEW_TEXT_STRINGS.feature), Game.TextStyles.MAP_PREVIEW_TEXT, b, new PIXI.Point(j / 2, e * d), m);
		d += g.featureHeading.height;
		a = Game.TextStyles.MAP_PREVIEW_FEATURE;
		a.fill = f.color;
		a.wordWrap = true;
		a.wordWrapWidth = h.MAP_PREVIEW_POSITIONS.casinoInformation.width;
		g.featureText = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(f.featureKey).split(" ").join("\n"), a, b, new PIXI.Point(j / 2, e * d), m);
		return {
			container: b,
			items: g
		}
	},
	createContinueButton: function(e, b, a) {
		var f = this,
			d = new PIXI.Point(a.x, a.y),
			g = new PIXI.Point(0.5, 0),
			c;
		c = new Interface.utils.PIXIButton("continueButtonIdle", "continueButtonClick", "continueButtonHover", "continueButtonDisabled");
		c.setLabel(Services.languageManager.getText(b).toUpperCase());
		c.setLabelStyle(Game.TextStyles.CONTINUE_BUTTON);
		c.setLabelDisabledStyle(Game.TextStyles.CONTINUE_BUTTON_DISABLED);
		c.setLabelPosition(new PIXI.Point((c.width / 2), (c.height / 2)));
		c.setLabelAnchorPoint(new PIXI.Point(0.5, 0.5));
		c.moveTo(d, g);
		c.clickCallback = f.modeSelected.bind(f, e);
		c.visible = false;
		f.backgroundBlurredImage.visible = false;
		return c
	},
	createCancelButton: function(b) {
		var d = this,
			a, c = new PIXI.Point(0, 0);
		d.backgroundBlurredImage.visible = false;
		a = new Interface.utils.PIXIButton("closeButtonIdle", "closeButtonClick", "closeButtonHover", "closeButtonDisabled");
		a.clickCallback = d.previewClosed.bind(d, b);
		a.moveTo(new PIXI.Point(d.MAP_PREVIEW_POSITIONS.cancelButton.x, d.MAP_PREVIEW_POSITIONS.cancelButton.y), c);
		a.setCustomHitArea(new PIXI.Circle(a.width / 2, a.height / 2, a.width / 2));
		return a
	},
	showPreview: function(b, d, a) {
		var c = this;
		c.backgroundBlurredImage.visible = true;
		if (a) {
			c.setPreviewRestoreInformation(b, d)
		} else {
			c.setPreviewStartInformation(b, d)
		}
		c.previews[b].container.visible = true
	},
	previewClosed: function(a) {
		var b = this;
		b.backgroundBlurredImage.visible = false;
		b.previews[a].container.visible = false;
		b.fireEvent("view:previewClosed")
	},
	setPreviewStartInformation: function(c, e) {
		var d = this,
			b = d.previews[c].items,
			a = Services.languageManager.getText(d.MAP_PREVIEW_TEXT_STRINGS.youNeedKeys);
		if (Sys.isDefined(e)) {
			b.heading.text = Services.languageManager.getText(d.MAP_PREVIEW_TEXT_STRINGS.welcome);
			b.bottomText.visible = false
		} else {
			b.heading.text = Services.languageManager.getText(d.MAP_PREVIEW_TEXT_STRINGS.openingSoon);
			b.bottomText.visible = true;
			b.bottomText.text = a.replace("{0}", d.MAP_CASINO_PREVIEWS[c].numberOfKeys)
		}
		b.bottomText.updateTransform();
		b.cancelButton.setEnabled(true);
		b.startButton.visible = true;
		b.continueButton.visible = false;
		b.startButton.setEnabled(Sys.isDefined(e))
	},
	setPreviewRestoreInformation: function(b, e) {
		var c = this,
			a = c.previews[b].items,
			d = Services.languageManager.getText(c.MAP_PREVIEW_TEXT_STRINGS.freeSpinsLeft);
		a.heading.text = Services.languageManager.getText(c.MAP_PREVIEW_TEXT_STRINGS.welcome);
		a.bottomText.visible = true;
		a.bottomText.text = d + " " + e;
		a.bottomText.updateTransform();
		a.cancelButton.setEnabled(false);
		a.startButton.visible = false;
		a.continueButton.visible = true
	},
	modeSelected: function(a) {
		var b = this;
		b.fireEvent("view:playAudio", {
			id: "startFreespin",
			name: "startFreespin"
		});
		b.backgroundBlurredImage.visible = false;
		b.previews[a].container.visible = false;
		b.fireEvent("view:modeSelected", a)
	},
	refresh: function() {
		var a = this;
		a.backgroundBlurredImage.position = Environment.getOrientationSpecificConfig(a.MAP_BACKGROUND_BLURRED_IMAGE_POSITION, true);
		a.backgroundBlurredImage.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(a.MAP_BACKGROUND_BLURRED_IMAGE)]
	}
};
Finn.FreeSpinMapPreviewView = Sys.extend(Core.View, Finn.FreeSpinMapPreviewView, "Finn.FreeSpinMapPreviewView");
Sys.ns("Finn");
(function() {
	Finn.particles.rainConfettiIn = function(a) {
		var j = Finn.particles.getNewParticlePrototype(),
			h = Platform.PlatformManager.getDevicePerformance(),
			e, c, b, f;
		switch (h) {
			case Platform.PlatformManager.LOW_END_DEVICE:
				e = 0;
				break;
			case Platform.PlatformManager.MEDIUM_DEVICE:
				e = Platform.isAndroidMajorVersion < 6 ? 0 : 350;
				c = 2;
				b = "confettoLow";
				f = [16711680, 15400704, 15400704];
				break;
			case Platform.PlatformManager.HIGH_END_DEVICE:
				e = 2000;
				c = 5;
				b = "confetto";
				f = [16515327, 16711680, 15400704, 65508, 2608896];
				break;
			default:
				e = 0;
				break
		}
		if (!e) {
			return
		}

		function g() {
			var k = pixiGenericSlot.Positions.createCurrentCanvasRectangle();
			k.y = -k.height;
			return k
		}
		var d = {
			particleCount: e,
			minDelayBeforeStart: 500,
			maxDelayBeforeStart: 5000,
			minWidthScale: 0.7,
			maxWidthScale: 1,
			minHeightScale: 0.8,
			maxHeightScale: 1,
			minOverallScale: 1,
			maxOverallScale: 1,
			minOpacity: 1,
			maxOpacity: 1,
			minMoveSpeed: 3,
			maxMoveSpeed: 6,
			minRotatingSpeed: 1,
			maxRotatingSpeed: 10,
			coloursArray: f,
			minUpdateSpeed: 0,
			maxUpdateSpeed: 0.5,
			frameCount: c,
			boundsRectangle: pixiGenericSlot.Positions.createCurrentCanvasRectangle(),
			spawnRectangle: g(),
			ParticlePrototype: j,
			imageURL: b
		};
		j.tickParticle = function() {
			var k = Math.random() * 1000;
			if (k < 5) {
				this.rotatingDirection = -this.rotatingDirection
			}
			this.y += this.movingSpeed;
			this.rotation += (this.rotatingSpeed / 100) * this.rotatingDirection
		};
		Finn.particles.createIn(a, d)
	}
}());
Sys.ns("Finn");
(function() {
	Finn.particles.createBalloonsIn = function(a) {
		var c = Finn.particles.getNewParticlePrototype(),
			f = Platform.PlatformManager.getDevicePerformance(),
			e;
		switch (f) {
			case Platform.PlatformManager.LOW_END_DEVICE:
				e = Platform.isAndroidMajorVersion < 6 ? 0 : 2;
				break;
			case Platform.PlatformManager.MEDIUM_DEVICE:
				e = Platform.isAndroidMajorVersion < 6 ? 0 : 3;
				break;
			case Platform.PlatformManager.HIGH_END_DEVICE:
				e = 5;
				break;
			default:
				e = 0;
				break
		}

		function b() {
			var g = pixiGenericSlot.Positions.createCurrentCanvasRectangle();
			g.y = g.height;
			g.height = 1;
			return g
		}
		var d = {
			particleCount: e,
			minDelayBeforeStart: 0,
			maxDelayBeforeStart: 1500,
			minWidthScale: 0.9,
			maxWidthScale: 1.1,
			minHeightScale: 1,
			maxHeightScale: 1,
			minOverallScale: 0.7,
			maxOverallScale: 0.9,
			minOpacity: 0.9,
			maxOpacity: 1,
			minMoveSpeed: 1,
			maxMoveSpeed: 1,
			minRotatingSpeed: 1,
			maxRotatingSpeed: 1,
			coloursArray: [Finn.particles.NO_TINT_COLOUR],
			minUpdateSpeed: 0,
			maxUpdateSpeed: 0.5,
			frameCount: 1,
			boundsRectangle: pixiGenericSlot.Positions.createCurrentCanvasRectangle(),
			spawnRectangle: b(),
			ParticlePrototype: c,
			imageURL: "balloon"
		};
		c.DECELERATION_FACTOR = 20;
		c.init = function() {
			var g = (this.boundsRectangle.width / e);
			this.x = (g * this.particleNumber) - g / 2;
			this.deceleratingSpeed = this.movingSpeed * this.DECELERATION_FACTOR
		};
		c.tickParticle = function() {
			this.deceleratingSpeed = Math.round(this.deceleratingSpeed) === Math.round(this.movingSpeed) ? this.movingSpeed : this.deceleratingSpeed - (this.deceleratingSpeed / 25);
			this.y -= this.deceleratingSpeed
		};
		Finn.particles.createIn(a, d)
	}
}());
Sys.ns("Finn");
Finn.FreeSpinOutro = {
	getDefaultMVCClasses: function() {
		return {
			model: Finn.FreeSpinOutroModel,
			controller: Finn.FreeSpinOutroController,
			view: Finn.FreeSpinOutroView
		}
	}
};
Finn.FreeSpinOutro = Sys.extend(Game.Slots.FreeSpinOutro, Finn.FreeSpinOutro, "Finn.FreeSpinOutro");
Sys.ns("Finn");
Finn.FreeSpinOutroView = {
	MAP_BACKGROUND_IMAGE: "freespinmapOutroBlurredImage",
	MAP_BACKGROUND_IMAGE_POSITION: {
		DESKTOP: {
			x: 640,
			y: 360
		},
		LANDSCAPE: {
			x: 640,
			y: 360
		},
		PORTRAIT: {
			x: 630,
			y: 515
		}
	},
	CONGRATULATION_TEXT: {
		key: Language.Keys.congratulations,
		x: 640,
		y: 220
	},
	COINS_WON_TEXT: {
		key: Language.Keys.coinsWon,
		x: 640,
		y: 280
	},
	COIN_TEXT: {
		x: 640,
		y: 350
	},
	LOCALIZED_STRINGS: {
		congratulations: Language.Keys.congratulations_uc,
		coinsWon: "OCTcoinsWonColon"
	},
	constructor: function() {
		Finn.FreeSpinOutroView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this,
			c = Game.stage.view.animationManager.getLayer("cutScene"),
			b = Game.stage.view.animationManager.getLayer("splashScreensContentOverlay");
		a.backgroundContainer = new PIXI.Container();
		a.particleEffectsContainer = new PIXI.Container();
		a.splashScreenContainer = new PIXI.Container();
		a.splashScreenContainer.pivot = new PIXI.Point(640, 360);
		a.splashScreenContainer.position = new PIXI.Point(640, 360);
		c.addChild(a.backgroundContainer);
		c.addChild(a.particleEffectsContainer);
		b.addChild(a.splashScreenContainer);
		a.outroContainersParent = c.parent;
		a.fadeInAnimation = a.createFadeInAnimation();
		a.fadeOutAnimation = a.createFadeOutAnimation();
		a.setContainersVisibility(false);
		a.createContent()
	},
	setContainersVisibility: function(a) {
		this.particleEffectsContainer.visible = a;
		this.backgroundContainer.visible = a;
		this.splashScreenContainer.visible = a
	},
	createContent: function() {
		var b = this,
			a = new PIXI.Point(0.5, 0);
		b.createBackground(b.backgroundContainer);
		b.congratulationsText = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(b.CONGRATULATION_TEXT.key).toUpperCase(), Game.TextStyles.OUTRO_CONGRATULATIONS, b.splashScreenContainer, new PIXI.Point(b.CONGRATULATION_TEXT.x, b.CONGRATULATION_TEXT.y), a);
		b.coinsWonText = Game.PIXIFactory.createAndAddText(Services.languageManager.getText(b.COINS_WON_TEXT.key), Game.TextStyles.OUTRO_YOU_WON, b.splashScreenContainer, new PIXI.Point(b.COINS_WON_TEXT.x, b.COINS_WON_TEXT.y), a);
		b.coinText = Game.PIXIFactory.createAndAddText("0", Game.TextStyles.OUTRO_COINS, b.splashScreenContainer, new PIXI.Point(b.COIN_TEXT.x, b.COIN_TEXT.y), a)
	},
	createBackground: function(a) {
		var b = this;
		b.backgroundSprite = Game.PIXIFactory.createAndAddSprite(Game.stage.getOrientationSpecificImage(b.MAP_BACKGROUND_IMAGE), a, Environment.getOrientationSpecificConfig(b.MAP_BACKGROUND_IMAGE_POSITION, true), new PIXI.Point(0.5, 0.5))
	},
	createFadeInAnimation: function() {
		var a, b = function() {
			Finn.particles.rainConfettiIn(this.particleEffectsContainer);
			Finn.particles.createBalloonsIn(this.particleEffectsContainer)
		};
		a = new Animation.Holder({
			target: this.outroContainersParent,
			prop: "alpha",
			animate: {
				0: 0,
				750: 1
			},
			onEnd: b.bind(this)
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	createFadeOutAnimation: function() {
		var b = this,
			a;
		a = new Animation.Holder({
			target: b.outroContainersParent,
			onEnd: b.close.bind(b),
			prop: "alpha",
			animate: {
				0: 1,
				750: 0
			}
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	fadeOutAndClose: function() {
		var a = this;
		a.fadeOutAnimation.play()
	},
	resetAnimations: function() {
		this.fadeOutAnimation.stop();
		this.fadeInAnimation.stop();
		this.fadeOutAnimation.restore();
		this.fadeInAnimation.restore();
		this.outroContainersParent.alpha = 1
	},
	show: function() {
		var a = this,
			b = a.model.readData("coinsWon");
		a.congratulationsText.visible = b > 0;
		a.coinText.text = b ? b.toString() : -1;
		a.setContainersVisibility(true);
		a.fadeInAnimation.play()
	},
	close: function() {
		this.resetAnimations();
		this.setContainersVisibility(false);
		this.fireEvent("view:closed")
	},
	refresh: function() {
		var a = this;
		a.backgroundSprite.position = Environment.getOrientationSpecificConfig(a.MAP_BACKGROUND_IMAGE_POSITION, true);
		a.backgroundSprite.texture = Resources.readData("animationImages")[Game.stage.getOrientationSpecificImage(a.MAP_BACKGROUND_IMAGE)]
	}
};
Finn.FreeSpinOutroView = Sys.extend(Game.Slots.FreeSpinOutroView, Finn.FreeSpinOutroView, "Finn.FreeSpinOutroView");
Sys.ns("Finn");
Finn.FreeSpinOutroViewLow = {
	constructor: function() {
		Finn.FreeSpinOutroViewLow.superclass.constructor.apply(this, arguments)
	},
	createContent: function() {
		Finn.FreeSpinOutroViewLow.superclass.createContent.apply(this, arguments)
	}
};
Finn.FreeSpinOutroViewLow = Sys.extend(Finn.FreeSpinOutroView, Finn.FreeSpinOutroViewLow, "Finn.FreeSpinOutroViewLow");
Sys.ns("Finn");
Finn.FreeSpinOutroModel = {
	constructor: function() {
		Finn.FreeSpinOutroModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(c) {
		var a = this,
			b = Sys.isDefined(c.next) ? c.next.rs : "freespin1";
		if (Sys.isDefined(c.freespin)) {
			a.storeData("nextRS", b);
			if (Sys.isDefined(c.freespin.selected)) {
				a.storeData("currentFS", c.freespin.selected)
			}
		}
		Finn.FreeSpinOutroModel.superclass.processServerResponse.apply(this, arguments)
	}
};
Finn.FreeSpinOutroModel = Sys.extend(Game.Slots.FreeSpinOutroModel, Finn.FreeSpinOutroModel, "Finn.FreeSpinOutroModel");
Sys.ns("Finn");
Finn.FreeSpinOutroController = {
	AUTO_CLOSE_TIME: 15000,
	AUTO_CLOSE_TIME_WHEN_AUTO_SPINS_ARE_QUEUED: 10000,
	TIME_BEFORE_USER_CAN_CONTINUE: 5000,
	SOUND: {
		randomwilds: "randomwildsOutro",
		destroy: "destroyOutro",
		symboloverlay: "symboloverlayOutro",
		symboltransform: "symboltransformOutro"
	},
	constructor: function() {
		Finn.FreeSpinOutroController.superclass.constructor.apply(this, arguments)
	},
	close: function() {
		var a = this,
			b = a.model.readData("nextRS");
		a.model.setState("idle");
		clearTimeout(a.autoCloseTimeOut);
		clearTimeout(a.allowUserToAbort);
		this.fireEvent("notify:freeSpinOutro.closed");
		a.fireEvent("notify:mainGameBackgroundAnimations.start");
		a.fireEvent("request:spin.activateReelset", b, "base");
		a.stopListeningToUserInput();
		a.fireEvent("notify:gameModeChanged", "BASIC");
		a.fireEvent("request:enableBasicGamePanel", "freespinSplash");
		a.view.fadeOutAndClose()
	},
	show: function() {
		var c = this,
			d = Services.settingsManager.getSetting("autoPlayNrSpins") > 0,
			b = d ? c.AUTO_CLOSE_TIME_WHEN_AUTO_SPINS_ARE_QUEUED : c.AUTO_CLOSE_TIME,
			a = c.model.readData("currentFS");
		c.model.setState("animating");
		c.view.show();
		c.fireEvent("request:ambienceManager.ambienceStopActive");
		c.playOutroSound();
		if (c.UPDATE_COINS_FIELD_WHEN_START) {
			c.fireEvent("request:coinsField.showNormalWin")
		}
		c.fireEvent("request:playModeManager.removeMode", "freespin");
		c.fireEvent("request:playModeManager.addMode", "basic");
		c.fireEvent("request:closeOpenWindows");
		c.fireEvent("request:freeSpinMap.showBlurredMap");
		if (a) {
			c.fireEvent("request:ambienceManager.ambienceChangeActive", {
				name: c.SOUND[a],
				id: c.SOUND[a],
				loop: false
			})
		}
		c.allowUserToAbort = setTimeout(function() {
			c.startListeningToUserInput()
		}, c.TIME_BEFORE_USER_CAN_CONTINUE);
		c.autoCloseTimeOut = setTimeout(function() {
			c.close.call(c)
		}, b)
	},
	onClosed: function() {
		var a = this;
		a.fireEvent("request:background.restoreImage");
		a.fireEvent("request:ambienceManager.ambienceChangeActive", {
			name: "ambienceGeneral",
			id: "ambienceGeneral",
			loop: true,
			fadeIn: {
				from: 0.01,
				to: 0.5,
				time: 1
			},
			fadeOut: {
				from: 0.5,
				to: 0.01,
				time: 5
			}
		});
		a.fireEvent("notify:freeSpinOutro.closed");
		a.fireEvent("request:freeSpinMap.hideBlurredMap");
		a.fireEvent("request:character.fadeBackAfterFreespin");
		a.fireEvent("notify:keyCounter.show");
		if (!Platform.isDesktopDevice) {
			a.fireEvent("request:spinButton.show")
		}
	},
	onGameSizeChanged: function() {
		this.view.refresh()
	},
	onUserInputEnd: function() {
		this.close.call(this)
	}
};
Finn.FreeSpinOutroController = Sys.extend(Game.Slots.FreeSpinOutroController, Finn.FreeSpinOutroController, "Finn.FreeSpinOutroController");
Sys.ns("Finn");
Finn.FreeSpinCountDown = {
	constructor: function() {
		Finn.FreeSpinCountDown.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation", "serverResponse", "userInput"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.FreeSpinCountDownModel,
			view: Finn.FreeSpinCountDownView,
			controller: Finn.FreeSpinCountDownController
		}
	}
};
Finn.FreeSpinCountDown = Sys.extend(Core.Module, Finn.FreeSpinCountDown, "Finn.FreeSpinCountDown");
Sys.ns("Finn");
Finn.FreeSpinCountDownView = {
	COUNT_DOWN_CONTAINER_POSITION: {
		x: 640,
		y: 360
	},
	COUNT_DOWN_NUMBER_STYLES: {
		randomwilds: "FREESPIN_COUNTER_NUMBER_FS1",
		destroy: "FREESPIN_COUNTER_NUMBER_FS2",
		symboloverlay: "FREESPIN_COUNTER_NUMBER_FS3",
		symboltransform: "FREESPIN_COUNTER_NUMBER_FS4"
	},
	COUNT_DOWN_TEXT_SPACE: 130,
	constructor: function() {
		Finn.FreeSpinCountDownView.superclass.constructor.apply(this, arguments)
	},
	getFreeSpinsLeftTextString: function(a) {
		var b = Language.Keys.freeSpinsLeft;
		if (a === 0) {
			b = Language.Keys.lastFreeSpin
		} else {
			if (a === 1) {
				b = Language.Keys.freeSpinLeft
			}
		}
		return Services.languageManager.getText(b)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.name = "FreeSpinCountDownView";
		b.rootContainer.position = new PIXI.Point(0, 0);
		b.countDownContainer = new PIXI.Container();
		b.countDownContainer.position = b.COUNT_DOWN_CONTAINER_POSITION;
		b.countDownContainer.scale = new PIXI.Point(1, 1);
		b.countDownContainer.visible = false;
		b.createTexts(b.countDownContainer);
		b.rootContainer.addChild(b.countDownContainer);
		b.countDownAnimation = b.createCountDownAnimation();
		var a = Game.stage.view.animationManager.getLayer("freeSpinCountDown");
		a.addChild(b.rootContainer)
	},
	createTexts: function(a) {
		var c = this,
			d = this.getFreeSpinsLeftTextString(),
			b = new PIXI.Point(0.5, 0.5);
		c.freeSpinsTextSprite = Game.PIXIFactory.createAndAddText(d, Game.TextStyles.FREESPIN_COUNTER_TEXT, a, new PIXI.Point(0, (c.COUNT_DOWN_TEXT_SPACE / 2)), b);
		c.freeSpinsNumberSprite = Game.PIXIFactory.createAndAddText("0", Game.TextStyles[c.COUNT_DOWN_NUMBER_STYLES.randomwilds], a, new PIXI.Point(0, -(c.COUNT_DOWN_TEXT_SPACE / 2)), b)
	},
	createCountDownAnimation: function() {
		var c = this,
			b;
		var a = {
			prop: "alpha",
			animate: {
				0: 1,
				1000: 1,
				1200: 0
			}
		};
		var d = {
			prop: "scale",
			animate: {
				0: {
					x: 1,
					y: 1
				},
				1000: {
					x: 1.1,
					y: 1.1
				},
				1200: {
					x: 3,
					y: 3
				}
			}
		};
		b = new Animation.Holder({
			id: "countDownAnimation",
			target: c.countDownContainer,
			prop: "alpha",
			onEnd: c.onCountDownComplete.bind(c),
			children: [a, d]
		});
		Game.stage.view.animationManager.addToAnimationLoop(b);
		return b
	},
	onCountDownComplete: function() {
		var a = this;
		a.countDownContainer.scale = {
			x: 1,
			y: 1
		};
		a.hideCountDown()
	},
	hideCountDown: function() {
		var a = this;
		a.countDownContainer.visible = false;
		a.fireEvent("view:countDownAnimationDone")
	},
	showCountDown: function() {
		var b = this,
			a = b.model.readData("freeSpinsLeft"),
			d = b.model.readData("selectedMode"),
			c = b.COUNT_DOWN_NUMBER_STYLES[d];
		b.freeSpinsTextSprite.text = b.getFreeSpinsLeftTextString(a);
		b.freeSpinsNumberSprite.text = a.toString();
		b.freeSpinsNumberSprite.style = Game.TextStyles[c];
		if (a > 0) {
			b.showNumber()
		} else {
			b.hideNumber()
		}
		b.freeSpinsNumberSprite.updateTransform();
		b.freeSpinsTextSprite.updateTransform();
		b.countDownContainer.visible = true;
		b.countDownAnimation.restore();
		b.countDownAnimation.play();
		b.fireEvent("view:countDownEnd")
	},
	showNumber: function() {
		var a = this;
		a.freeSpinsNumberSprite.visible = true;
		a.freeSpinsTextSprite.position.y = (a.COUNT_DOWN_TEXT_SPACE / 2)
	},
	hideNumber: function() {
		var a = this;
		a.freeSpinsNumberSprite.visible = false;
		a.freeSpinsTextSprite.position.y = 0
	}
};
Finn.FreeSpinCountDownView = Sys.extend(Core.View, Finn.FreeSpinCountDownView, "Finn.FreeSpinCountDownView");
Sys.ns("Finn");
Finn.FreeSpinCountDownModel = {
	constructor: function() {
		Finn.FreeSpinCountDownModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(d) {
		var b = this,
			a = 0,
			c;
		if (Sys.isDefined(d.freespins)) {
			a = Sys.isDefined(d.freespins.left) ? d.freespins.left : d.freespins.initial;
			b.storeData("freeSpinsLeft", a)
		}
		if (Sys.isDefined(d.freespin)) {
			c = d.freespin.selected;
			b.storeData("selectedMode", c)
		}
	}
};
Finn.FreeSpinCountDownModel = Sys.extend(Core.Model, Finn.FreeSpinCountDownModel, "Finn.FreeSpinCountDownModel");
Sys.ns("Finn");
Finn.FreeSpinCountDownController = {
	constructor: function() {
		Finn.FreeSpinCountDownController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		Finn.FreeSpinCountDownController.superclass.setupEvents.apply(this, arguments);
		var a = this;
		a.on({
			"notify:stateHandler.enteringFreeSpinCountDownState": a.onEnteringFreeSpinCountDownState,
			"view:countDownEnd": a.onCountDownEnded,
			"view:countDownAnimationDone": a.onCountDownAnimationDone
		})
	},
	onEnteringFreeSpinCountDownState: function() {
		var a = this;
		a.view.showCountDown();
		a.model.storeData("showing", true);
		a.fireEvent("request:coinsField.showFreeSpinsLeft")
	},
	onCountDownEnded: function() {
		var a = this;
		a.fireEvent("notify:freeSpinCountDown:end");
		a.model.storeData("showing", false)
	},
	onCountDownAnimationDone: function() {
		var a = this;
		a.fireEvent("notify:freeSpinCountDown:animationComplete")
	}
};
Finn.FreeSpinCountDownController = Sys.extend(Core.Controller, Finn.FreeSpinCountDownController, "Finn.FreeSpinCountDownController");
Sys.ns("pixiGenericSlot");
pixiGenericSlot.StandardWinModel = {
	STANDARD_WIN_TYPES: ["smallWin", "mediumWin", "largeWin", "bigWin", "megaWin", "superMegaWin"],
	COUNT_UP_DURATIONS: {
		smallWin: 500,
		mediumWin: 500,
		largeWin: 500,
		bigWin: 1000,
		megaWin: 1000,
		superMegaWin: 1000
	},
	NO_WIN_DISPLAY_DURATION: 0,
	NO_WIN_DISPLAY_DESKTOP_DURATION: 0,
	TOTAL_WIN_DISPLAY_DURATION: 0,
	constructor: function() {
		pixiGenericSlot.StandardWinModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(a) {
		var c = this;
		pixiGenericSlot.StandardWinModel.superclass.processServerResponse.apply(this, arguments);
		var b = a.wins.winType;
		c.storeData("winType", b);
		c.storeData("hasDestroyFeature", Sys.isDefined(a.rf) && a.rf.feature === "destroy");
		c.storeData("countUpDisplay", "winBanner")
	}
};
pixiGenericSlot.StandardWinModel = Sys.extend(Core.Slots.StandardWinModel, pixiGenericSlot.StandardWinModel, "pixiGenericSlot.StandardWinModel");
Sys.ns("Finn");
Finn.StandardWinController = {
	constructor: function() {
		Finn.StandardWinController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:stateHandler.enteringStandardWinPresentationState": a.startPresentation,
			"notify:stateHandler.enteringNoWinPresentationState": a.startNoWinPresentation,
			"notify:winBanner.countUpComplete": a.onShowingTotal,
			"notify:coinsField.countUpComplete": a.onShowingTotal,
			"notify:spinButton.clickedWhileHidden": a.handleUserInput,
			"request:abortPresentation": a.handleUserInput,
			"notify:winSituationsDisplay.showingAllWins": a.waitForWinSituationsDisplay
		})
	},
	startNoWinPresentation: function() {
		var a = this;
		if (a.model.readData("hasDestroyFeature")) {
			a.fireEvent("notify:standardWin.presentationComplete")
		} else {
			a.startEndOfRoundPresentation()
		}
	},
	startPresentation: function() {
		var c = this,
			b = c.model.readData("winClip"),
			a = c.model.readData("winType"),
			d = c.model.readData("countUpDuration"),
			e = c.model.readData("totalWinDisplayDuration");
		c.fireEvent("request:settingsWindow.close");
		c.startListeningToUserInput();
		c.model.setState("countingUp");
		c.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
			showDuration: d + e,
			"standardWin:countUpDuration": d,
			"standardWin:showTotalDuration": e
		});
		if (c.model.readData("countUpDisplay") === "winBanner") {
			c.fireEvent("request:winBanner.setWinType", a);
			c.fireEvent("request:winBanner.setCountUpDuration", d)
		} else {
			c.fireEvent("request:coinsField.countUp", d)
		}
		c.fireEvent("notify:standardWin.startPresentation", b);
		c.fireEvent("notify:spin.switchAmbience")
	},
	startEndOfRoundPresentation: function() {
		var a = this,
			b = a.model.readData("countUpDuration");
		a.fireEvent("request:settingsWindow.close");
		a.fireEvent("request:spin.stopBonusAttention");
		a.fireEvent("request:backgroundOverlay.hideOverlay");
		a.startListeningToUserInput();
		a.model.setState("countingUp");
		if (a.model.readData("countUpDisplay") === "winBanner") {
			a.fireEvent("request:winBanner.endOfRound")
		} else {
			a.fireEvent("request:coinsField.countUp", b)
		}
	},
	handleUserInput: function() {
		var a = this;
		if (a.model.readData("inNoWinPresentation")) {
			a.abortNoWinPresentation()
		} else {
			if (a.model.isState("countingUp")) {
				if (a.model.readData("countUpDisplay") !== "winBanner") {
					a.fireEvent("request:coinsField.showWin")
				}
				a.fireEvent("request:audioPlayer.stop", "winClip");
				a.onShowingTotal();
				a.fireEvent("notify:standardWin.countupAborted");
				a.endPresentation(true)
			} else {
				if (a.model.isState("showingTotal")) {
					a.endPresentation(true)
				}
			}
		}
	}
};
Finn.StandardWinController = Sys.extend(Core.Slots.StandardWinController, Finn.StandardWinController, "Finn.StandardWinController");
Finn.GameRulesController = {
	constructor: function() {
		Finn.GameRulesController.superclass.constructor.apply(this, arguments)
	},
	hide: function() {
		var a = this;
		Finn.GameRulesController.superclass.hide.apply(this, arguments);
		a.fireEvent("request:keyCounter.showMgKeyCounter");
		a.fireEvent("request:winBanner.showMgWinBanner")
	},
	show: function() {
		var a = this;
		Finn.GameRulesController.superclass.show.apply(this, arguments);
		a.fireEvent("request:keyCounter.hideMgKeyCounter");
		a.fireEvent("request:winBanner.hideMgWinBanner")
	}
};
Finn.GameRulesController = Sys.extend(Interface.GameRulesController, Finn.GameRulesController, "Finn.GameRulesController");
Sys.ns("Finn");
Finn.GameRulesDesktopView = {
	constructor: function() {
		Finn.GameRulesDesktopView.superclass.constructor.apply(this, arguments)
	},
	init: function() {
		var b = this,
			c;
		Finn.GameRulesDesktopView.superclass.init.apply(this, arguments);
		b.scrollHolder = new PIXI.Container();
		c = new PIXI.Graphics();
		c.beginFill(1512994, 0.85);
		c.drawRect(0, 0, 1280, 700);
		c.endFill();
		b.scrollHolder.addChild(c);
		var a = Game.stage.view.animationManager.getLayer("blackLayerBackground");
		a.addChild(b.scrollHolder)
	},
	hide: function() {
		var a = this;
		Finn.GameRulesDesktopView.superclass.hide.apply(this, arguments);
		a.scrollHolder.visible = false
	},
	show: function() {
		var a = this;
		Finn.GameRulesDesktopView.superclass.show.apply(this, arguments);
		a.scrollHolder.visible = true
	}
};
Finn.GameRulesDesktopView = Sys.extend(Interface.GameRulesDesktopView, Finn.GameRulesDesktopView, "Finn.GameRulesDesktopView");
Sys.ns("Finn");
Finn.Paytable = {
	constructor: function() {
		Finn.Paytable.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return {
			fallback: ["userInput", "orientation"],
			desktop: ["animation", "userInput", "properties"]
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.PaytableModel,
			controller: Finn.PaytableController,
			view: Finn.PaytableBaseView
		}
	}
};
Finn.Paytable = Sys.extend(Interface.Paytable, Finn.Paytable, "Finn.Paytable");
Sys.ns("Finn");
Finn.PaytableController = {
	constructor: function() {
		Finn.PaytableController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:paytable.forward": a.onForwardRequest,
			"request:paytable.backward": a.onBackwardRequest,
			"notify:responseParser.paytableResponseParsed": a.onPaytableResponse,
			"view:pageSwitch": a.fireEvent.bind(a, "notify:paytable.pageSwitched"),
			"notify:gameModeChanged": a.onGameModeChanged,
			"notify:settingsWindow.open": a.onHideRequest,
			"notify:spinButton.clicked": a.hide,
			"notify:maxBetButton.startedRound": a.hide,
			"notify:stateHandler.enteringFreeSpinTriggerState": a.hideWhenBonusWin,
			"notify:freeSpinTrigger.bonusWinFinished": a.enable,
			"view:hideSpinButton": a.hideSpinButton,
			"view:showSpinButton": a.showSpinButton
		});
		Finn.PaytableController.superclass.setupEvents.apply(a, arguments)
	},
	hideSpinButton: function() {
		this.fireEvent("request:spinButton.hide")
	},
	showSpinButton: function() {
		this.fireEvent("request:spinButton.show")
	},
	onHideRequest: function() {
		var b = this,
			a = b.model.readData("currentContainer");
		b.fireEvent("request:keyCounter.showMgKeyCounter");
		b.fireEvent("request:winBanner.showMgWinBanner");
		if (b.model.readData("showing")) {
			if (Sys.isDefined(a)) {
				b.fireEvent("request:" + a + ".closeChild", b.MODULE_NAME)
			}
			b.fireEvent("notify:" + b.MODULE_NAME + ".hidden");
			b.view.hide()
		}
		b.model.storeData("showing", false);
		Services.storage.storeData(b.MODULE_NAME + ".showing", false)
	},
	hideWhenBonusWin: function() {
		var a = this;
		a.hide();
		a.disable()
	},
	show: function(a) {
		var b = this;
		b.fireEvent("request:keyCounter.hideMgKeyCounter");
		b.fireEvent("request:winBanner.hideMgWinBanner");
		if (!b.model.readData("showing")) {
			b.model.storeData("showing", true);
			Services.storage.storeData(b.MODULE_NAME + ".showing", true);
			b.fireEvent("notify:" + b.MODULE_NAME + ".shown");
			b.view.show(a);
			if (Sys.isTouchDevice) {
				b.startListeningToUserInput()
			}
		}
	}
};
Finn.PaytableController = Sys.extend(Interface.PaytableController, Finn.PaytableController, "Finn.PaytableController");
Sys.ns("Finn");
Finn.PaytableModel = {
	constructor: function() {
		Finn.PaytableModel.superclass.constructor.apply(this, arguments)
	},
	parseGameMode: function(c, a, e) {
		var d = this,
			b = {
				arrayWins: {}
			};
		Sys.iterate(a.comp, function(f, g) {
			d.parsePaytableComponent(f, g, b)
		});
		e[a.id] = b
	},
	parsePaytableComponent: function(b, d, a) {
		var g = d.symbol,
			c = d.type + "Wins",
			f = d.n,
			e;
		if (d.type !== "array") {
			return
		}
		if (!Sys.isDefined(a[c][g])) {
			a[c][g] = {
				array: [],
				freespins: []
			}
		}
		e = a[c][g];
		e.array[f] = d.multi;
		e.freespins[f] = d.freespins
	},
	getCondensedInfo: function(b, c, a, f) {
		var h = this.readData("paytableInfo")[f || "basic"][c || "arrayWins"][b][a || "array"],
			d = 1,
			j = 0,
			g = h[0],
			e = [];
		for (; d < h.length; d++) {
			if (h[d] !== g) {
				e.push({
					from: j,
					to: d - 1,
					value: g
				});
				j = d;
				g = h[d]
			}
		}
		e.push({
			from: j,
			to: d - 1,
			value: g
		});
		return e
	}
};
Finn.PaytableModel = Sys.extend(Interface.PaytableModel, Finn.PaytableModel, "Finn.PaytableModel");
Sys.ns("Finn");
Finn.PaytableBaseView = {
	BASE_CSS: "tab interface-paytable_base",
	PORTRAIT_CSS: "interface-paytable_portrait",
	LANDSCAPE_CSS: "interface-paytable_landscape",
	SECTION_CSS: "interface-paytable_section interface-settingsSection_subSection finn-paytable-section",
	SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
	HEADING_CSS: "finn-paytable-header",
	SECTIONS: ["SymbolValues", "Bonus", "KeyCollecting", "WildGeneration", "FS2SW", "WinSituations", "RandomFeatures", "RF1", "RF2", "RF3", "RF4", "BonusGame", "FS1", "FS2", "FS3", "FS4", "Disclaimer"],
	HIGH_WIN: {
		COLOR: "#eecc33",
		SYMBOLS: ["SYM3", "SYM4"]
	},
	MEDIUM_WIN: {
		COLOR: "#eecc33",
		SYMBOLS: ["SYM5", "SYM6"]
	},
	LOW_WIN: {
		COLOR: "#eecc33",
		SYMBOLS: ["SYM7", "SYM8"]
	},
	DISCLAIMER_STRINGS: [Language.Keys.Disclaimer0, Language.Keys.Disclaimer1, Language.Keys.Disclaimer2, Language.Keys.Disclaimer3, Language.Keys.Disclaimer4],
	constructor: function() {
		Finn.PaytableBaseView.superclass.constructor.apply(this, arguments);
		this.setupContainer();
		this.sectionElements = {}
	},
	appendSymbolContainer: function(a, d, e, b, f, m) {
		var j = this,
			k = Resources.readData("animationImages"),
			p = this.model.readData("symbolHeight"),
			c = a.add(new Sys.Element({
				tag: "td",
				style: "min-height: " + p + "px; text-align: center;"
			})),
			h = j.model.getCondensedInfo(d, b, f, m).sort(function(r, q) {
				return q.from - r.from
			}),
			l = h.length,
			o, n, g;
		if (Sys.isDefined(k[d])) {
			c.el.appendChild(j.chooseImageSource(k[d]))
		}
		o = a.add(new Sys.Element({
			tag: "td",
			style: "min-height: " + p + "px;"
		})).add(new Sys.Element({
			tag: "ul",
			"class": "interface-paytable_symbolValues"
		}));
		for (g = -1; ++g < l;) {
			n = h[g];
			if (Sys.isDefined(n.value)) {
				o.add(new Sys.Element({
					tag: "li",
					textContent: n.from,
					style: "width: 33%; color: " + e + ";"
				}));
				o.add(new Sys.Element({
					tag: "li",
					textContent: n.value,
					style: "width: 66%;"
				}))
			}
		}
	},
	chooseImageSource: function(a) {
		return Sys.isDefined(a.baseTexture) ? a.baseTexture.source : a
	},
	createSymbolValues: function() {
		var a = this,
			b = new Sys.Element({
				tag: "div",
				"class": a.SECTION_CSS
			});
		b.add(new Sys.Element({
			tag: "div",
			textContent: Services.languageManager.getText(Language.Keys.paytable_symbolPayout),
			"class": a.HEADING_CSS
		}));
		if (a.HIGH_WIN.SYMBOLS.length > 0) {
			b.add(a.createSymbolSubSection(a.HIGH_WIN.SYMBOLS, a.HIGH_WIN.COLOR))
		}
		if (a.MEDIUM_WIN.SYMBOLS.length > 0) {
			b.add(a.createSymbolSubSection(a.MEDIUM_WIN.SYMBOLS, a.MEDIUM_WIN.COLOR))
		}
		if (a.LOW_WIN.SYMBOLS.length > 0) {
			b.add(a.createSymbolSubSection(a.LOW_WIN.SYMBOLS, a.LOW_WIN.COLOR))
		}
		a.sectionElements.SymbolValues = b;
		a.container.add(b)
	},
	createWildGeneration: function() {
		var a = this;
		a.createSectionElements("WildGeneration")
	},
	createBonus: function() {
		var a = this;
		a.createSectionElements("Bonus")
	},
	createRandomFeatures: function() {
		var a = this;
		a.createSectionElements("RandomFeatures")
	},
	createRF1: function() {
		var a = this;
		a.createSectionElements("RF1")
	},
	createRF2: function() {
		var a = this;
		a.createSectionElements("RF2")
	},
	createRF3: function() {
		var a = this;
		a.createSectionElements("RF3")
	},
	createRF4: function() {
		var a = this;
		a.createSectionElements("RF4")
	},
	createKeyCollecting: function() {
		var a = this;
		a.createSectionElements("KeyCollecting")
	},
	createBonusGame: function() {
		var a = this;
		a.createSectionElements("BonusGame")
	},
	createFS1: function() {
		var a = this;
		a.createSectionElements("FS1")
	},
	createFS2: function() {
		var a = this;
		a.createSectionElements("FS2")
	},
	createFS2SW: function() {
		var a = this;
		a.createSectionElements("FS2SW")
	},
	createFS3: function() {
		var a = this;
		a.createSectionElements("FS3")
	},
	createFS4: function() {
		var a = this;
		a.createSectionElements("FS4")
	},
	createWinSituations: function() {
		var a = this;
		a.createSectionElements("WinSituations")
	},
	setSectionInfo: function(a, b) {
		switch (a) {
			case "Bonus":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableBonus);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableBonusText0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableBonusText1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableBonusText2);
				b.contentStrings[3] = Services.languageManager.getText(Language.Keys.PaytableBonusText3);
				b.paytableImage = "BONUS";
				break;
			case "KeyCollecting":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableKeyCollecting);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableKeyCollectingText2);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableKeyCollectingText0);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableKeyCollectingText1);
				b.paytableImage = "keyCountFs";
				break;
			case "WildGeneration":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableWild);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableWildText0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableWildText1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableWildText2);
				b.contentStrings[3] = Services.languageManager.getText(Language.Keys.PaytableWildText3);
				b.contentStrings[4] = Services.languageManager.getText(Language.Keys.PaytableWildText4);
				b.contentStrings[5] = Services.languageManager.getText(Language.Keys.PaytableWildText5);
				b.contentStrings[6] = Services.languageManager.getText(Language.Keys.PaytableWildText6);
				b.contentStrings[7] = Services.languageManager.getText(Language.Keys.PaytableWildText7);
				b.contentStrings[8] = Services.languageManager.getText(Language.Keys.PaytableWildText8);
				b.paytableImage = "SYM1";
				break;
			case "FS2SW":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableFS2Text3);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableFS2Text8);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableFS2Text5);
				b.paytableImage = "SYM0";
				break;
			case "RandomFeatures":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableRandomFeatures);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableRandomFeaturesText0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableRandomFeaturesText1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableRandomFeaturesText3);
				break;
			case "RF1":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableRF1);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableRF1Text0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableRF1Text1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableRF1Text2);
				b.contentStrings[3] = Services.languageManager.getText(Language.Keys.PaytableRF1Text3);
				b.contentStrings[4] = Services.languageManager.getText(Language.Keys.PaytableRF1Text5);
				b.paytableImage = "paytableRandomFeatureWilds";
				break;
			case "RF2":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableRF2);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableRF2Text0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableRF2Text1);
				b.paytableImage = "paytableRandomFeatureDestroy";
				break;
			case "RF3":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableRF3);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableRF3Text0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableRF3Text1);
				b.paytableImage = "paytableRandomFeatureOverlay";
				break;
			case "RF4":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableRF4);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableRF4Text0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableRF4Text1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableRF4Text2);
				b.contentStrings[3] = Services.languageManager.getText(Language.Keys.PaytableRF4Text3);
				b.paytableImage = "paytableRandomFeatureTransform";
				break;
			case "BonusGame":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableBonusGame);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableBonusGameText0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableBonusGameText1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableBonusGameText2);
				break;
			case "FS1":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableFS1);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableFS1Text1);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableFS1Text2);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableFS1Text0);
				b.paytableImage = "freespinMapCasino1Unlocked";
				break;
			case "FS2":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableFS2);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableFS2Text6);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableFS2Text7);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableFS2Text4);
				b.paytableImage = "freespinMapCasino2Unlocked";
				break;
			case "FS3":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableFS3);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableFS3Text4);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableFS3Text5);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableFS3Text0);
				b.contentStrings[3] = Services.languageManager.getText(Language.Keys.PaytableFS3Text1);
				b.contentStrings[4] = Services.languageManager.getText(Language.Keys.PaytableFS3Text2);
				b.contentStrings[5] = Services.languageManager.getText(Language.Keys.PaytableFS3Text3);
				b.paytableImage = "freespinMapCasino3Unlocked";
				break;
			case "FS4":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableFS4);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableFS4Text3);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableFS4Text4);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableFS4Text2);
				b.paytableImage = "freespinMapCasino4Unlocked";
				break;
			case "WinSituations":
				b.headerText = Services.languageManager.getText(Language.Keys.PaytableWinSituations);
				b.contentStrings[0] = Services.languageManager.getText(Language.Keys.PaytableWinSituationsText0);
				b.contentStrings[1] = Services.languageManager.getText(Language.Keys.PaytableWinSituationsText1);
				b.contentStrings[2] = Services.languageManager.getText(Language.Keys.PaytableWinSituationsText2);
				b.contentStrings[3] = Services.languageManager.getText(Language.Keys.PaytableWinSituationsText3);
				b.paytableImage = "paytableWinsHorizontal";
				b.paytableImage2 = "paytableWinsVertical";
				break;
			default:
				break
		}
	},
	createSectionElements: function(e) {
		var k = this,
			b, l, d, c, m, g = {
				headerText: "",
				contentStrings: []
			},
			a = new Sys.Element({
				tag: "div",
				textContent: g.headerText,
				"class": k.SECTION_CSS + " " + k.SECTION_SEPARATOR_URI
			});
		k.setSectionInfo(e, g);
		b = new Sys.Element({
			tag: "div",
			textContent: g.headerText,
			"class": k.HEADING_CSS
		});
		a.add(b);
		if (Sys.isDefined(g.paytableImage) && Sys.isDefined(g.paytableImage2)) {
			l = a.add(new Sys.Element({
				tag: "div",
				"class": "finn-paytable-image"
			})).add(new Sys.Element({
				tag: "ul",
				"class": "finn-paytable-multiple-images"
			}));
			var j = new Sys.Element({
				tag: "img",
				src: k.chooseImageSource(Resources.readData("animationImages")[g.paytableImage]).src,
				style: "margin: 0px 40px 0px -20px"
			});
			var h = new Sys.Element({
				tag: "img",
				src: k.chooseImageSource(Resources.readData("animationImages")[g.paytableImage2]).src,
				style: "margin: 0px 40px 0px 20px"
			});
			l.add(j);
			l.add(h);
			a.add(l)
		} else {
			if (Sys.isDefined(g.paytableImage)) {
				l = new Sys.Element({
					tag: "div",
					"class": "finn-paytable-image"
				});
				d = new Sys.Element({
					tag: "img",
					src: k.chooseImageSource(Resources.readData("animationImages")[g.paytableImage]).src
				});
				l.add(d);
				a.add(l)
			}
		}
		m = "";
		for (var f = 0; f < g.contentStrings.length; f++) {
			m += '<p class="finn-paytable-text-paragraph">' + g.contentStrings[f] + "</p>"
		}
		c = new Sys.Element({
			tag: "div",
			innerHTML: m,
			"class": "finn-paytable-text"
		});
		if (e === "RandomFeatures") {
			c = a.add(new Sys.Element({
				tag: "div",
				innerHTML: m,
				"class": "finn-paytable-text-paragraph"
			})).add(new Sys.Element({
				tag: "ul",
				"class": "interface-paytable_image_after_text_random_features"
			}));
			c.add(new Sys.Element({
				tag: "li",
				textContent: Services.languageManager.getText(Language.Keys.PaytableRF1).toUpperCase(),
				style: "width: 50%; color: #D770F1; font-size: 20px;"
			}));
			c.add(new Sys.Element({
				tag: "li",
				textContent: Services.languageManager.getText(Language.Keys.PaytableRF2).toUpperCase(),
				style: "width: 50%; color: #F4691F; font-size: 20px;"
			}));
			c.add(new Sys.Element({
				tag: "li",
				textContent: Services.languageManager.getText(Language.Keys.PaytableRF3).toUpperCase(),
				style: "width: 50%; color: #87FE3E; font-size: 20px;"
			}));
			c.add(new Sys.Element({
				tag: "li",
				textContent: Services.languageManager.getText(Language.Keys.PaytableRF4).toUpperCase(),
				style: "width: 50%; color: #EAE40F; font-size: 20px;"
			}))
		}
		a.add(c);
		k.sectionElements[e] = a;
		k.container.add(a)
	}
};
Finn.PaytableBaseView = Sys.extend(Interface.PaytableBaseView, Finn.PaytableBaseView, "Finn.PaytableBaseView");
Sys.ns("Finn");
Finn.PaytableDesktopView = {
	PAYTABLE_TEXT_STYLE: Game.TextStyles.PAYTABLE_TEXT,
	PAYTABLE_CONTENT_OFFSET: 180,
	PAYTABLE_PARAGRAPH_MARGIN: 80,
	PAYTABLE_PARAGRAPH_LINE_HEIGHT: 10,
	LABEL_HEIGHT: 30,
	LABEL_OFFSET: 30,
	SYMBOL_WIDTH: 130,
	SYMBOL_HEIGHT: 130,
	COLLECTING_HEIGHT: 110,
	CHARACTER_HEIGHT: 304,
	SYMBOL_COLUMN_OFFSET: 170,
	SYMBOL_ROW_OFFSET: 30,
	CASINO_HEIGHT: 250,
	WIN_HEIGHT: 120,
	RANDOM_FEATURE_HEIGHT: 310,
	RANDOM_FEATURE_NAME_HEIGHT: 200,
	PAYOUT_OFFSET_TOP: 10,
	PAYOUT_OFFSET_LEFT: 0,
	WIN_SITUATION_OFFSET: 80,
	CLOSE_BUTTON_POSITION_X: 1235,
	constructor: function() {
		Finn.PaytableDesktopView.superclass.constructor.apply(this, arguments);
		this.textCounter = 0
	},
	setUpContent: function() {
		var a = this;
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	initAnimations: function() {
		var d = this,
			e = Game.stage.view.animationManager.getLayer("userInterface"),
			c = Game.stage.view.animationManager.getLayer("logo");
		d.WILD_GENERATION_TEXT = [Services.languageManager.getText("wildGeneration"), Services.languageManager.getText("wildGeneration2")];
		d.WILD_EXPLOSION_TEXT = [Services.languageManager.getText("wildExplosion")];
		d.BONUS_SYMBOL_TEXT = [Services.languageManager.getText("bonusSymbol")];
		d.RANDOM_WILDS_TEXT = [Services.languageManager.getText("randomWilds"), Services.languageManager.getText("randomWilds2")];
		d.SYMBOL_OVERLAY_TEXT = [Services.languageManager.getText("symbolOverlay")];
		d.SYMBOL_TRANSFORM_TEXT = [Services.languageManager.getText("symbolTransform")];
		d.DESTROY_TEXT = [Services.languageManager.getText("destory")];
		d.button = new Interface.utils.PIXIButton("paytableButtonUp", "paytableButtonDown", "paytableButtonOver", "paytableButtonDisabled");
		d.button.id = "paytableButton";
		d.button.clickCallback = d.onButtonClick.bind(d);
		d.button.moveToPosition(pixiGenericSlot.Positions.PAYTABLE_BUTTON);
		var a = d.button.width / 2;
		d.button.setCustomHitArea(new PIXI.Circle(a, d.button.height / 2, a));
		e.addChild(d.button);
		d.closebutton = new Interface.utils.PIXIButton("paytableButtonClose", "paytableButtonCloseHover", "paytableButtonClosePressed");
		d.closebutton.id = "paytableCloseButton";
		d.closebutton.clickCallback = d.onButtonClick.bind(d);
		d.closebutton.moveToPosition(pixiGenericSlot.Positions.PAYTABLE_CLOSE_BUTTON);
		var b = d.closebutton.width / 2;
		d.closebutton.setCustomHitArea(new PIXI.Circle(b, d.closebutton.height / 2, b));
		d.closebutton.visible = false;
		d.closebutton.position.x = d.CLOSE_BUTTON_POSITION_X;
		c.addChild(d.closebutton);
		d.setupScroller();
		d.animationsReady = true;
		d.fireEvent("view:addToContainer", "settingsWindow", {
			title: "",
			content: d.container
		})
	},
	setupScroller: function() {
		var k = this,
			e, f, d, m, n, b, h, g = k.setupLayer();
		e = k.setupScrollHolder();
		f = new PIXI.Container();
		f.position.x = 185;
		k.setupLayoutValues();
		m = k.setupSymbols(f);
		b = k.setupPayoutInfo();
		n = k.setupLabels();
		h = k.setupTexts(e, f, m, n);
		for (d = 0; d < n.length; ++d) {
			f.addChild(n[d])
		}
		for (d = 0; d < b.length; ++d) {
			f.addChild(b[d].container)
		}
		for (d = 0; d < h.length; ++d) {
			f.addChild(h[d])
		}
		e.addChild(f);
		for (d = 0; d < n.length; ++d) {
			n[d].style = Game.TextStyles.PAYTABLE_LABEL
		}
		for (d = 0; d < h.length; ++d) {
			var l = h[d];
			l.style = l.clonedStyle
		}
		for (d = 0; d < b.length; ++d) {
			var a = b[d].children;
			for (var c = 0; c < a.length; ++c) {
				a[c].label.style = Game.TextStyles.PAYTABLE_PAYOUT_LABEL;
				a[c].value.style = Game.TextStyles.PAYTABLE_PAYOUT_VALUE
			}
		}
		g.addChild(k.scrollHolder);
		k.scrollHolder.visible = false
	},
	setupLayer: function() {
		return Game.stage.view.animationManager.getLayer("paytable")
	},
	getDisclaimerFirst: function() {
		return Services.languageManager.getText(Language.Keys.Disclaimer0) + " " + Services.languageManager.getText(Language.Keys.Disclaimer1)
	},
	getDisclaimerSecond: function() {
		return Services.languageManager.getText(Language.Keys.Disclaimer2) + " " + Services.languageManager.getText(Language.Keys.Disclaimer3) + " " + Services.languageManager.getText(Language.Keys.Disclaimer4)
	},
	setupScrollHolder: function() {
		var d = this,
			a, e;
		d.scrollHolder = new PIXI.Container();
		e = new PIXI.Graphics();
		e.beginFill(1512994, 0);
		e.drawRect(0, 0, 1280, 700);
		e.endFill();
		d.scrollHolder.addChild(e);
		d.blackLayer = new PIXI.Container();
		e = new PIXI.Graphics();
		e.beginFill(1512994, 0.85);
		e.drawRect(0, 0, 1280, 700);
		e.endFill();
		d.blackLayer.addChild(e);
		Game.stage.view.animationManager.getLayer("blackLayerBackground").addChild(d.blackLayer);
		d.blackLayer.visible = false;
		Game.PIXIFactory.createAndAddSprite("paytableDivider", d.scrollHolder, new PIXI.Point(640, 550), new PIXI.Point(0.5, 0.5));
		Game.PIXIFactory.createAndAddText(d.getDisclaimerFirst(), Game.TextStyles.PAYTABLE_VOID_PAYS_FIRST, d.scrollHolder, new PIXI.Point(640, 569), new PIXI.Point(0.5, 0.5));
		Game.PIXIFactory.createAndAddText(d.getDisclaimerSecond(), Game.TextStyles.PAYTABLE_VOID_PAYS, d.scrollHolder, new PIXI.Point(640, 594), new PIXI.Point(0.5, 0.5));
		a = new Interface.utils.PIXIScrollContainer(473);
		a.position.y = 76;
		a.position.x = -5;
		a.setScrollBarSize(11.5);
		a.setScrollBarContentMargin(97);
		a.forceWidth(1180.4);
		a.setBottomPadding(100);
		var c = Game.PIXIFactory.createTexture("paytableScrollBar");
		var b = Game.PIXIFactory.createSprite(c);
		a.useScrollBarSprite(b);
		d.scrollHolder.addChild(a);
		return a
	},
	setupLayoutValues: function() {
		var a = this;
		a.contentWidth = a.scrollHolder.width - 2 * a.PAYTABLE_CONTENT_OFFSET;
		a.columns = [a.PAYTABLE_CONTENT_OFFSET, a.contentWidth / 2];
		a.labels = [];
		a.labels.push(0);
		a.labels.push(a.labels[0] + a.SYMBOL_ROW_OFFSET * 3 + a.SYMBOL_HEIGHT * 4);
		a.labels.push(a.labels[1] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[2] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[3] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[4] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[5] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[6] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[7] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[8] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[9] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[10] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[11] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[12] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[13] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[14] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.labels.push(a.labels[15] + a.LABEL_HEIGHT + a.PAYTABLE_PARAGRAPH_MARGIN);
		a.symbolRows = [a.LABEL_HEIGHT + a.SYMBOL_ROW_OFFSET, a.LABEL_HEIGHT + a.SYMBOL_ROW_OFFSET * 2 + a.SYMBOL_HEIGHT, a.LABEL_HEIGHT + a.SYMBOL_ROW_OFFSET * 3 + a.SYMBOL_HEIGHT * 2, a.LABEL_HEIGHT + a.SYMBOL_ROW_OFFSET * 4 + a.SYMBOL_HEIGHT * 3];
		a.symbolColumns = [a.PAYTABLE_CONTENT_OFFSET, a.PAYTABLE_CONTENT_OFFSET + a.SYMBOL_WIDTH + a.SYMBOL_COLUMN_OFFSET]
	},
	setupSymbols: function(b) {
		var a = this;
		return [{
			symbol: Game.PIXIFactory.createAndAddSprite("SYM3", b, new PIXI.Point(a.symbolColumns[0], a.symbolRows[0])),
			name: "sym3"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM4", b, new PIXI.Point(a.symbolColumns[1], a.symbolRows[0])),
			name: "sym4"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM5", b, new PIXI.Point(a.symbolColumns[0], a.symbolRows[1])),
			name: "sym5"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM6", b, new PIXI.Point(a.symbolColumns[1], a.symbolRows[1])),
			name: "sym6"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM7", b, new PIXI.Point(a.symbolColumns[0], a.symbolRows[2])),
			name: "sym7"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM8", b, new PIXI.Point(a.symbolColumns[1], a.symbolRows[2])),
			name: "sym8"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("BONUS", b, new PIXI.Point(a.columns[0], a.labels[1])),
			name: "bonus"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("keyCountFs", b, new PIXI.Point(a.columns[0], a.labels[2])),
			name: "collecting"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM1", b, new PIXI.Point(a.columns[0], a.labels[3])),
			name: "sym1_g"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("SYM0", b, new PIXI.Point(a.symbolColumns[0], a.labels[4])),
			name: "fs2sw"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("paytableWinsHorizontal", b, new PIXI.Point(a.columns[0], a.labels[5])),
			name: "winSituation"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("paytableWinsVertical", b, new PIXI.Point(a.columns[1], a.labels[5])),
			name: "winSituation2"
		}, {
			symbol: Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.PaytableRF1).toUpperCase(), Game.TextStyles.PAYTABLE_RANDOMD_FEATURES_STARFALL_LABEL, b, new PIXI.Point(a.symbolColumns[0], a.labels[6])),
			name: "rfsw"
		}, {
			symbol: Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.PaytableRF2).toUpperCase(), Game.TextStyles.PAYTABLE_RANDOMD_FEATURES_DRAGON_LABEL, b, new PIXI.Point(a.symbolColumns[1], a.labels[6])),
			name: "rfdd"
		}, {
			symbol: Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.PaytableRF3).toUpperCase(), Game.TextStyles.PAYTABLE_RANDOMD_FEATURES_DRUNKEN_LUCK_LABEL, b, new PIXI.Point(a.columns[0], a.labels[6])),
			name: "rfdl"
		}, {
			symbol: Game.PIXIFactory.createAndAddText(Services.languageManager.getText(Language.Keys.PaytableRF4).toUpperCase(), Game.TextStyles.PAYTABLE_RANDOMD_FEATURES_MAGIC_TRANSFORM_LABEL, b, new PIXI.Point(a.columns[0], a.labels[6])),
			name: "rfmt"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("paytableRandomFeatureWilds", b, new PIXI.Point(a.columns[0], a.labels[7])),
			name: "rf1"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("paytableRandomFeatureDestroy", b, new PIXI.Point(a.columns[0], a.labels[8])),
			name: "rf2"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("paytableRandomFeatureOverlay", b, new PIXI.Point(a.columns[0], a.labels[9])),
			name: "rf3"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("paytableRandomFeatureTransform", b, new PIXI.Point(a.columns[0], a.labels[10])),
			name: "rf4"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("freespinMapCasino1Unlocked", b, new PIXI.Point(a.columns[0], a.labels[11])),
			name: "fs1"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("freespinMapCasino2Unlocked", b, new PIXI.Point(a.columns[0], a.labels[12])),
			name: "fs2"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("freespinMapCasino3Unlocked", b, new PIXI.Point(a.columns[0], a.labels[13])),
			name: "fs3"
		}, {
			symbol: Game.PIXIFactory.createAndAddSprite("freespinMapCasino4Unlocked", b, new PIXI.Point(a.columns[0], a.labels[14])),
			name: "fs4"
		}]
	},
	setupPayoutInfo: function() {
		var a = this;
		return [a.createSymbolPayoutContainer("SYM3", a.symbolColumns[0] + a.SYMBOL_COLUMN_OFFSET, a.symbolRows[0] + a.PAYOUT_OFFSET_TOP), a.createSymbolPayoutContainer("SYM4", a.symbolColumns[1] + a.SYMBOL_COLUMN_OFFSET, a.symbolRows[0] + a.PAYOUT_OFFSET_TOP), a.createSymbolPayoutContainer("SYM5", a.symbolColumns[0] + a.SYMBOL_COLUMN_OFFSET, a.symbolRows[1] + a.PAYOUT_OFFSET_TOP), a.createSymbolPayoutContainer("SYM6", a.symbolColumns[1] + a.SYMBOL_COLUMN_OFFSET, a.symbolRows[1] + a.PAYOUT_OFFSET_TOP), a.createSymbolPayoutContainer("SYM7", a.symbolColumns[0] + a.SYMBOL_COLUMN_OFFSET, a.symbolRows[2] + a.PAYOUT_OFFSET_TOP), a.createSymbolPayoutContainer("SYM8", a.symbolColumns[1] + a.SYMBOL_COLUMN_OFFSET, a.symbolRows[2] + a.PAYOUT_OFFSET_TOP)]
	},
	createSymbolPayoutContainer: function(f, j, g, b) {
		var c = new PIXI.Container(),
			d = [],
			a = this.model.getCondensedInfo(f);
		c.position.x = j;
		c.position.y = g;
		for (var h = a.length - 1; h >= 0; h--) {
			if (Sys.isDefined(a[h].value)) {
				var k = new PIXI.Text(a[h].from.toString());
				var l = new PIXI.Text(a[h].value.toString());
				var e = ((a.length - 1) - h) * 40;
				k.position.y = e;
				l.position.y = e;
				l.anchor.x = 1;
				l.position.x = 85;
				c.addChild(k);
				c.addChild(l);
				d.push({
					label: k,
					value: l
				})
			}
		}
		return {
			container: c,
			children: d,
			name: b
		}
	},
	setupLabels: function() {
		var a = this;
		return [a.createLabel(Services.languageManager.getText(Language.Keys.PaytableSymbols).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[0])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableBonus).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[1])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableKeyCollecting).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[2])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableWild).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[3])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableFS2Text3).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[4])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableWinSituations).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[5])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableRandomFeatures).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[6])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableRF1).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[7])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableRF2).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[8])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableRF3).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[9])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableRF4).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[10])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableBonusGame).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[11])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableFS1).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[12])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableFS2).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[13])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableFS3).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[14])), a.createLabel(Services.languageManager.getText(Language.Keys.PaytableFS4).toUpperCase(), new PIXI.Point(a.PAYTABLE_CONTENT_OFFSET, a.labels[15]))]
	},
	createLabel: function(d, a) {
		var c = this,
			b = new PIXI.Text(d);
		if (Sys.isDefined(a)) {
			b.position = a;
			b.anchor.x = 0.5;
			b.position.x = 640 - c.PAYTABLE_CONTENT_OFFSET
		}
		return b
	},
	setupTexts: function(g, j, p, q) {
		var l = this,
			o = l.PAYTABLE_CONTENT_OFFSET,
			n = l.LABEL_HEIGHT + l.LABEL_OFFSET,
			h = [],
			c, d;
		var b = [{
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableBonusText0), Services.languageManager.getText(Language.Keys.PaytableBonusText1), Services.languageManager.getText(Language.Keys.PaytableBonusText2), Services.languageManager.getText(Language.Keys.PaytableBonusText3)], l.contentWidth / 1.4),
			id: "bonusSymbol"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableKeyCollectingText2), Services.languageManager.getText(Language.Keys.PaytableKeyCollectingText0), Services.languageManager.getText(Language.Keys.PaytableKeyCollectingText1)], l.contentWidth / 1.4),
			id: "collecting"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableWildText0), Services.languageManager.getText(Language.Keys.PaytableWildText1), Services.languageManager.getText(Language.Keys.PaytableWildText2), Services.languageManager.getText(Language.Keys.PaytableWildText3), Services.languageManager.getText(Language.Keys.PaytableWildText4), Services.languageManager.getText(Language.Keys.PaytableWildText5), Services.languageManager.getText(Language.Keys.PaytableWildText6), Services.languageManager.getText(Language.Keys.PaytableWildText7), Services.languageManager.getText(Language.Keys.PaytableWildText8)], l.contentWidth / 1.4),
			id: "wildGeneration"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableFS2Text8), Services.languageManager.getText(Language.Keys.PaytableFS2Text5)], l.contentWidth / 1.4),
			id: "fs2sw"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableWinSituationsText0), Services.languageManager.getText(Language.Keys.PaytableWinSituationsText1), Services.languageManager.getText(Language.Keys.PaytableWinSituationsText2), Services.languageManager.getText(Language.Keys.PaytableWinSituationsText3)], l.contentWidth / 1.4),
			id: "winSituation"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableRandomFeaturesText0), Services.languageManager.getText(Language.Keys.PaytableRandomFeaturesText1), Services.languageManager.getText(Language.Keys.PaytableRandomFeaturesText3), " ", " ", " "], l.contentWidth / 1.4),
			id: "rf"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableRF1Text0), Services.languageManager.getText(Language.Keys.PaytableRF1Text1), Services.languageManager.getText(Language.Keys.PaytableRF1Text2), Services.languageManager.getText(Language.Keys.PaytableRF1Text3), Services.languageManager.getText(Language.Keys.PaytableRF1Text5)], l.contentWidth / 1.4),
			id: "rf1"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableRF2Text0), Services.languageManager.getText(Language.Keys.PaytableRF2Text1)], l.contentWidth / 1.4),
			id: "rf2"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableRF3Text0), Services.languageManager.getText(Language.Keys.PaytableRF3Text1)], l.contentWidth / 1.4),
			id: "rf3"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableRF4Text0), Services.languageManager.getText(Language.Keys.PaytableRF4Text1), Services.languageManager.getText(Language.Keys.PaytableRF4Text2), Services.languageManager.getText(Language.Keys.PaytableRF4Text3)], l.contentWidth / 1.4),
			id: "rf4"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableBonusGameText0), Services.languageManager.getText(Language.Keys.PaytableBonusGameText1), Services.languageManager.getText(Language.Keys.PaytableBonusGameText2)], l.contentWidth / 1.4),
			id: "bonusGame"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableFS1Text1), Services.languageManager.getText(Language.Keys.PaytableFS1Text2), Services.languageManager.getText(Language.Keys.PaytableFS1Text0)], l.contentWidth / 1.4),
			id: "fs1"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableFS2Text6), Services.languageManager.getText(Language.Keys.PaytableFS2Text7), Services.languageManager.getText(Language.Keys.PaytableFS2Text4)], l.contentWidth / 1.4),
			id: "fs2"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableFS3Text4), Services.languageManager.getText(Language.Keys.PaytableFS3Text5), Services.languageManager.getText(Language.Keys.PaytableFS3Text0), Services.languageManager.getText(Language.Keys.PaytableFS3Text1), Services.languageManager.getText(Language.Keys.PaytableFS3Text2), Services.languageManager.getText(Language.Keys.PaytableFS3Text3)], l.contentWidth / 1.4),
			id: "fs3"
		}, {
			textAreas: l.createTextAreas([Services.languageManager.getText(Language.Keys.PaytableFS4Text3), Services.languageManager.getText(Language.Keys.PaytableFS4Text4), Services.languageManager.getText(Language.Keys.PaytableFS4Text2)], l.contentWidth / 1.4),
			id: "fs4"
		}];
		for (d = 0; d < b.length; d++) {
			h = h.concat(b[d].textAreas)
		}
		var e = {
			wildGeneration: l.SYMBOL_HEIGHT + l.PAYOUT_OFFSET_TOP,
			wildExplosion: l.CHARACTER_HEIGHT + l.SYMBOL_ROW_OFFSET,
			bonusSymbol: l.SYMBOL_HEIGHT + l.SYMBOL_ROW_OFFSET + l.PAYOUT_OFFSET_TOP / 2,
			collecting: l.COLLECTING_HEIGHT,
			fs2sw: l.SYMBOL_HEIGHT + l.PAYTABLE_PARAGRAPH_LINE_HEIGHT * 2,
			winSituation: l.WIN_HEIGHT + l.SYMBOL_ROW_OFFSET + l.PAYOUT_OFFSET_TOP,
			rf: 0,
			rf1: l.RANDOM_FEATURE_HEIGHT - l.LABEL_OFFSET,
			rf2: l.RANDOM_FEATURE_HEIGHT + l.SYMBOL_ROW_OFFSET + 2 * l.PAYOUT_OFFSET_TOP,
			rf3: l.RANDOM_FEATURE_HEIGHT + l.SYMBOL_ROW_OFFSET + l.PAYOUT_OFFSET_TOP,
			rf4: l.RANDOM_FEATURE_HEIGHT + l.SYMBOL_ROW_OFFSET,
			fs1: l.CASINO_HEIGHT + l.SYMBOL_ROW_OFFSET + 2 * l.PAYOUT_OFFSET_TOP,
			fs2: l.CASINO_HEIGHT + l.SYMBOL_ROW_OFFSET,
			fs3: l.CASINO_HEIGHT + l.SYMBOL_ROW_OFFSET - l.LABEL_OFFSET / 2,
			fs4: l.CASINO_HEIGHT + l.SYMBOL_ROW_OFFSET - l.PAYOUT_OFFSET_TOP
		};
		var m;
		var k = {};
		for (d = 0; d < b.length; d++) {
			var a = e[b[d].id] || 0;
			m = l.setTextAreaHeights(b[d].textAreas, o, n + l.labels[d + 1] + a);
			k[b[d].id] = n + l.labels[d + 1];
			if (Sys.isDefined(l.labels[d + 1])) {
				l.labels[d + 2] = m + l.PAYTABLE_PARAGRAPH_MARGIN
			}
			if (d === 5) {
				l.textHeightForRandomFeatureTitles = m
			}
		}
		for (d = 0; d < q.length; d++) {
			q[d].position.y = l.labels[d]
		}
		for (d = 0; d < p.length; d++) {
			c = p[d];
			if (c.name === "bonus") {
				c.symbol.position.y = k.bonusSymbol;
				c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
				c.symbol.anchor.x = 0.5
			} else {
				if (c.name === "collecting") {
					c.symbol.position.y = k.collecting;
					c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
					c.symbol.anchor.x = 0.5
				} else {
					if (c.name === "sym1_g") {
						c.symbol.position.y = k.wildGeneration;
						c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
						c.symbol.anchor.x = 0.5
					} else {
						if (c.name === "winSituation") {
							c.symbol.position.y = k.winSituation + l.PAYOUT_OFFSET_TOP;
							c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET - l.WIN_SITUATION_OFFSET;
							c.symbol.anchor.x = 0.5
						} else {
							if (c.name === "winSituation2") {
								c.symbol.position.y = k.winSituation + l.PAYOUT_OFFSET_TOP;
								c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET + l.WIN_SITUATION_OFFSET;
								c.symbol.anchor.x = 0.5
							} else {
								if (c.name === "fs2sw") {
									c.symbol.position.y = k.fs2sw;
									c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
									c.symbol.anchor.x = 0.5
								} else {
									if (c.name === "rf") {
										c.symbol.position.y = k.rf;
										c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
										c.symbol.anchor.x = 0.5
									} else {
										if (c.name === "fs1") {
											c.symbol.position.y = k.fs1;
											c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
											c.symbol.anchor.x = 0.5
										} else {
											if (c.name === "fs2") {
												c.symbol.position.y = k.fs2;
												c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
												c.symbol.anchor.x = 0.5
											} else {
												if (c.name === "fs3") {
													c.symbol.position.y = k.fs3;
													c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
													c.symbol.anchor.x = 0.5
												} else {
													if (c.name === "fs4") {
														c.symbol.position.y = k.fs4;
														c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
														c.symbol.anchor.x = 0.5
													} else {
														if (c.name === "rf1") {
															c.symbol.position.y = k.rf1;
															c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
															c.symbol.anchor.x = 0.5
														} else {
															if (c.name === "rf2") {
																c.symbol.position.y = k.rf2 - l.PAYOUT_OFFSET_TOP * 2;
																c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
																c.symbol.anchor.x = 0.5
															} else {
																if (c.name === "rf3") {
																	c.symbol.position.y = k.rf3 - l.PAYOUT_OFFSET_TOP;
																	c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
																	c.symbol.anchor.x = 0.5
																} else {
																	if (c.name === "rf4") {
																		c.symbol.position.y = k.rf4;
																		c.symbol.position.x = 640 - l.PAYTABLE_CONTENT_OFFSET;
																		c.symbol.anchor.x = 0.5
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		var f = {};
		f[b[5].id] = l.textHeightForRandomFeatureTitles;
		for (d = 0; d < p.length; d++) {
			c = p[d];
			if (c.name === "rfsw") {
				c.symbol.position.y = f.rf - l.WIN_SITUATION_OFFSET;
				c.symbol.position.x = 480 - l.PAYTABLE_CONTENT_OFFSET;
				c.symbol.anchor.x = 0.5
			} else {
				if (c.name === "rfdd") {
					c.symbol.position.y = f.rf - l.WIN_SITUATION_OFFSET;
					c.symbol.position.x = 640;
					c.symbol.anchor.x = 0.5
				} else {
					if (c.name === "rfdl") {
						c.symbol.position.y = f.rf;
						c.symbol.position.x = 480 - l.PAYTABLE_CONTENT_OFFSET;
						c.symbol.anchor.x = 0.5
					} else {
						if (c.name === "rfmt") {
							c.symbol.position.y = f.rf;
							c.symbol.position.x = 640;
							c.symbol.anchor.x = 0.5
						}
					}
				}
			}
		}
		g.updateScrollContainer();
		return h
	},
	createTextAreas: function(d, b) {
		var c = [];
		for (var a = 0; a < d.length; ++a) {
			c.push(this.createTextArea(d[a], b))
		}
		return c
	},
	createTextArea: function(d, b) {
		var a = Sys.clone(this.PAYTABLE_TEXT_STYLE);
		a.wordWrap = true;
		a.wordWrapWidth = b;
		var c = new PIXI.Text(d, a);
		c.id = "paytableText" + this.textCounter;
		c.clonedStyle = a;
		this.textCounter++;
		c.scale = new PIXI.Point(0.6, 0.6);
		return c
	},
	setTextAreaHeights: function(e, b, a) {
		var d = this,
			f = 0,
			c;
		for (c = 0; c < e.length; c++) {
			e[c].position = new PIXI.Point(b, a + f);
			f = e[c].height + f + d.PAYTABLE_PARAGRAPH_LINE_HEIGHT
		}
		return a + f
	},
	show: function(a) {
		var b = this;
		b.scrollHolder.visible = true;
		b.closebutton.visible = true;
		b.blackLayer.visible = true
	},
	hide: function() {
		var a = this;
		if (Sys.isDefined(a.scrollHolder)) {
			a.scrollHolder.visible = false;
			a.closebutton.visible = false
		}
		if (a.blackLayer) {
			a.blackLayer.visible = false
		}
	},
	onButtonClick: function() {
		if (!this.model.readData("showing")) {
			this.fireEvent("view:showRequest")
		} else {
			this.fireEvent("view:hideRequest")
		}
	},
	enableButton: function() {
		if (!this.hidden) {
			this.enable("buttonDisableRequest")
		}
	},
	disableButton: function() {
		if (!this.hidden) {
			this.disable("buttonDisableRequest")
		}
	},
	showButton: function() {
		if (this.animationsReady) {
			this.button.visible = true;
			this.hidden = false
		}
	},
	hideButton: function() {
		if (this.animationsReady) {
			this.button.visible = false;
			this.hidden = true
		}
	},
	onFeatureSplashShowing: function() {
		this.hideButton()
	},
	onFeatureSplashClosed: function() {
		this.showButton()
	},
	enable: function(a) {
		if (this.animationsReady) {
			this.model.removeProperty("buttonDisabled", a);
			var b = this.model.hasProperty("disabled");
			this.button.setEnabled(b === false)
		}
	},
	disable: function(a) {
		if (this.animationsReady) {
			this.model.addProperty("buttonDisabled", a);
			this.button.setEnabled(false)
		}
	}
};
Finn.PaytableDesktopView = Sys.extend(Interface.PaytableDesktopView, Finn.PaytableDesktopView, "Finn.PaytableDesktopView");
Sys.override(Interface.SettingsSectionController, {
	hide: function() {
		var a = this;
		if (a.model.readData("showing")) {
			a.model.storeData("showing", false);
			Services.storage.storeData(a.MODULE_NAME + ".showing", false);
			a.fireEvent("notify:" + a.MODULE_NAME + ".hidden");
			a.stopListeningToUserInput();
			a.view.hide();
			a.fireEvent("request:keyCounter.showMgKeyCounter");
			a.fireEvent("request:winBanner.showMgWinBanner")
		}
	}
});
Sys.ns("pixiGenericSlot");
pixiGenericSlot.ResourceLoaderView = {
	init: function(a) {
		this.model = a.model;
		this.MODULE_NAME = a.name;
		this.setupEvents()
	}
};
pixiGenericSlot.ResourceLoaderView = Sys.extend(Core.ResourceLoaderView, pixiGenericSlot.ResourceLoaderView, "pixiGenericSlot.ResourceLoaderView");
Sys.ns("Finn");
Finn.RandomFeatureView = {
	constructor: function() {
		Finn.RandomFeatureView.superclass.constructor.apply(this, arguments)
	},
	initPortal: function(a) {
		var b = this;
		b.animationName = a;
		b.portalAnimation = b.createPortalAnimation("portal", b.rootContainer);
		b.extraEffect = b.createExtraEffect("portal", b.rootContainer);
		b.scalePortalAnimation = b.initPortalScaleAnimation(b.portalAnimation);
		b.scaleBackPortalAnimation = b.initPortalScaleBackAnimation(b.portalAnimation)
	},
	portalFinished: function() {},
	showIntroPresentation: function() {},
	createExtraEffect: function(b, a) {
		var e, d = this;
		var c = function() {
			Game.PIXIUtils.resetSpineAnimation(e);
			e.visible = false;
			d.fireEvent("view:enableQuickStop");
			d.portalFinished()
		};
		e = Game.PIXIFactory.createAndAddSpineAnimation(b, a);
		e.visible = false;
		e.fire = function(f) {
			Game.PIXIUtils.resetSpineAnimation(e);
			e.state.setAnimation(0, f, false);
			Finn.AnimationUtils.initialize(e, f, false).onAnimationEnd(e, c)
		};
		Game.stage.view.animationManager.addToAnimationLoop(e);
		e.updateTransform();
		return e
	},
	createPortalAnimation: function(a) {
		var b = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(a, b.rootContainer);
		c.visible = false;
		c.fire = function(d) {
			c.state.setAnimation(0, d, true);
			c.visible = true
		};
		return c
	},
	initPortalScaleAnimation: function(c) {
		var b = this;
		var a = {
			prop: "position",
			animate: [{
				time: 0,
				value: {
					x: 1280 / 2,
					y: 720 / 2
				},
				ease: Animation.utils.powerTwoOut
			}, {
				time: 600,
				value: {
					x: 0,
					y: 0
				}
			}]
		};
		var e = {
			prop: "scale",
			animate: [{
				time: 0,
				value: {
					x: 0,
					y: 0
				},
				ease: Animation.utils.powerTwoOut
			}, {
				time: 600,
				value: {
					x: 1,
					y: 1
				}
			}]
		};
		var d = new Animation.Holder({
			id: "full",
			target: c,
			delay: 0,
			onStart: function() {
				b.fireEvent("view:playAudio", {
					id: "randomWildsPortal",
					name: "randomWildsPortal"
				})
			},
			onEnd: function() {
				b.fireEvent("view:playAudio", {
					id: "randomWildsPortalLoop",
					name: "randomWildsPortalLoop",
					loop: true
				});
				b.showIntroPresentation()
			},
			children: [e, a]
		});
		Game.stage.view.animationManager.addToAnimationLoop(d);
		return d
	},
	initPortalScaleBackAnimation: function(c) {
		var b = this;
		var a = {
			prop: "position",
			animate: [{
				time: 0,
				value: {
					x: 0,
					y: 0
				},
				ease: Animation.utils.powerTwoIn
			}, {
				time: 300,
				value: {
					x: 1280 / 2,
					y: 720 / 2
				}
			}]
		};
		var e = {
			prop: "scale",
			animate: [{
				time: 0,
				value: {
					x: 1,
					y: 1
				},
				ease: Animation.utils.powerTwoIn
			}, {
				time: 300,
				value: {
					x: 0,
					y: 0
				}
			}]
		};
		var d = new Animation.Holder({
			id: "full",
			target: c,
			delay: 0,
			onStart: function() {
				b.fireEvent("view:playAudio", {
					id: "randomWildsPortalClose",
					name: "randomWildsPortalClose"
				});
				b.fireEvent("view:stopAudio", "randomWildsPortalLoop")
			},
			onEnd: function() {
				b.extraEffect.fire(b.animationName);
				b.portalAnimation.visible = false;
				Game.PIXIUtils.resetSpineAnimation(b.portalAnimation)
			},
			children: [e, a]
		});
		Game.stage.view.animationManager.addToAnimationLoop(d);
		return d
	}
};
Finn.RandomFeatureView = Sys.extend(Core.View, Finn.RandomFeatureView, "Finn.RandomFeatureView");
Sys.ns("Finn");
Finn.RandomWilds = {
	constructor: function() {
		Finn.RandomWilds.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "waitSequence", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.RandomWildsModel,
			controller: Finn.RandomWildsController,
			view: Finn.RandomWildsView
		}
	}
};
Finn.RandomWilds = Sys.extend(Core.Module, Finn.RandomWilds, "Finn.RandomWilds");
Sys.ns("Finn");
Finn.RandomWildsController = {
	constructor: function() {
		Finn.RandomWildsController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:animationComplete": a.hide,
			"view:replaceSymbol": a.replaceSymbol,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop"),
			"request:randomFeature.restore": a.restore,
			"notify:stateHandler.enteringRandomWildsState": a.show,
			"view:enableQuickStop": a.enableQuickStop
		})
	},
	show: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.stopListeningToUserInput();
		b.model.setState("animating");
		if (a === "basic") {
			b.fireEvent("request:backgroundOverlay.fadeIn", "randomWilds");
			b.fireEvent("request:backgroundOverlay.showBackgroundContentAnimation", "randomWilds");
			b.view.startTrench()
		} else {
			b.showWilds()
		}
	},
	enableQuickStop: function() {
		var a = this;
		a.startListeningToUserInput();
		a.fireEvent("request:quickStopper.enableForRandomFeature")
	},
	onUserInputStart: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			a.abort()
		}
	},
	showWilds: function() {
		var a = this;
		a.view.trenchFinished()
	},
	hide: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.stopListeningToUserInput();
		if (a === "basic") {
			b.fireEvent("request:backgroundOverlay.fadeOut")
		}
		b.model.setState("idle");
		b.fireEvent("notify:randomWilds.presentationFinished")
	},
	abort: function() {
		var a = this;
		if (!this.model.isState("stopped") && !this.model.isState("idle") && a.model.readData("inRandomWildFeature")) {
			a.model.setState("stopped");
			a.view.abort()
		}
	},
	replaceSymbol: function(a) {
		var b = this;
		b.fireEvent("request:spin.replaceSymbols", [{
			0: a
		}, "SYM1"])
	},
	restore: function() {
		var c = this,
			a = c.model.readData("featureTargets");
		if (c.model.readData("inRandomWildFeature")) {
			for (var b = 0; b < a.length; b++) {
				c.replaceSymbol(a[b].pos[1])
			}
		}
	}
};
Finn.RandomWildsController = Sys.extend(Core.Controller, Finn.RandomWildsController, "Finn.RandomWildsController");
Sys.ns("Finn");
Finn.RandomWildsModel = {
	constructor: function() {
		Finn.RandomWildsModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = this;
		a.storeData("inMainGame", !Sys.isDefined(b.freespin));
		if (Sys.isDefined(b.rf) && Sys.isDefined(b.rf.feature)) {
			a.setState("animationRequested");
			a.storeData("featureTargets", b.rf.targets);
			a.storeData("gameState", b.gamestate.current)
		} else {
			a.setState("idle")
		}
		if (Sys.isDefined(b.rf) && Sys.isDefined(b.rf.feature) && b.rf.feature === "randomwilds") {
			a.storeData("inRandomWildFeature", true)
		} else {
			a.storeData("inRandomWildFeature", false)
		}
	}
};
Finn.RandomWildsModel = Sys.extend(Core.Model, Finn.RandomWildsModel, "Finn.RandomWildsModel");
Sys.ns("Finn");
Finn.RandomWildsView = {
	SHOOTOUT_ANIMATIONS: ["wild_shootout_01", "wild_shootout_02", "wild_shootout_03", "wild_shootout_04", "wild_shootout_05"],
	FALLDOWN_ANIMATIONS: ["wild_impact_01", "wild_impact_02", "wild_impact_03", "wild_impact_04", "wild_impact_05", "wild_impact_06", "wild_impact_07", "wild_impact_08", "wild_impact_09", "wild_impact_10", "wild_impact_11", "wild_impact_12", "wild_impact_13", "wild_impact_14", "wild_impact_15", "wild_impact_16", "wild_impact_17", "wild_impact_18", "wild_impact_19", "wild_impact_20", "wild_impact_21", "wild_impact_22", "wild_impact_23", "wild_impact_24", "wild_impact_25"],
	SHOOTOUT_SOUND: ["randomWildsShootOut01", "randomWildsShootOut02", "randomWildsShootOut03", "randomWildsShootOut04", "randomWildsShootOut05", "randomWildsShootOut06", "randomWildsShootOut07", "randomWildsShootOut08", "randomWildsShootOut09", "randomWildsShootOut10"],
	FALLDOWN_SOUND: ["randomWildsFallDown01", "randomWildsFallDown02", "randomWildsFallDown03", "randomWildsFallDown04", "randomWildsFallDown05", "randomWildsFallDown06", "randomWildsFallDown07", "randomWildsFallDown08", "randomWildsFallDown09", "randomWildsFallDown10"],
	constructor: function() {
		Finn.RandomWildsView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.symbols = [];
		a.symbolAnimations = [];
		a.config = Resources.readData("config");
		a.reelLayout = a.config.reelGroups["default"].reelLayout;
		a.numberOfOutcomeSymbols = a.reelLayout.standard.numberOfOutcomeSymbols;
		a.symbolWidths = a.reelLayout.standard.symbolWidths;
		a.symbolHeights = a.reelLayout.standard.symbolHeights;
		a.rootContainer = new PIXI.Container();
		a.randomizer = new Finn.Randomizer();
		a.myTimeout = null;
		a.initPortal("init_Blast_RandomWild");
		a.symbolContainer = new PIXI.Container();
		a.symbolContainer.position = new PIXI.Point(a.reelLayout[0].left, a.reelLayout[0].top);
		a.rootContainer.addChild(a.symbolContainer);
		a.createSymbolAnimations();
		a.createTrenchAnimation();
		Game.stage.view.animationManager.getLayer("randomFeaturePresentations").addChild(a.rootContainer)
	},
	createSymbolAnimations: function() {
		var a = this;
		a.shootOutAnimation = Game.PIXIFactory.createAndAddSpineAnimation("randomFeatureWilds", a.rootContainer);
		a.shootOutAnimation.fire = function(b) {
			a.shootOutAnimation.state.setAnimation(0, b, false);
			a.shootOutAnimation.visible = true
		};
		a.shootOutAnimation.state.addListener({
			complete: a.onShootoutComplete.bind(a)
		});
		Game.stage.view.animationManager.addToAnimationLoop(a.shootOutAnimation);
		a.shootOutAnimation.visible = false
	},
	onShootoutComplete: function() {
		var b = this,
			c, d;
		Game.PIXIUtils.resetSpineAnimation(b.shootOutAnimation);
		b.shootOutAnimation.visible = false;
		if (b.model.getState() === "stopped") {
			return
		}
		if (b.model.getState() === "fallDown") {
			b.fireEvent("view:replaceSymbol", b.model.readData("featureTargets")[b.shootoutCompleted].pos[1])
		}
		b.shootoutCompleted++;
		if (b.shootoutCompleted === b.numberOfShootOuts && b.model.getState() === "shootOut") {
			b.model.setState("fallDown");
			b.shootoutCompleted = 0
		} else {
			if (b.shootoutCompleted >= b.numberOfShootOuts) {
				b.stop();
				return
			}
		}
		var a = 0;
		if (b.model.getState() === "shootOut") {
			c = b.SHOOTOUT_ANIMATIONS[b.randomizer.draw()];
			d = b.SHOOTOUT_SOUND[b.shootoutCompleted];
			if (b.shootoutCompleted + 1 === b.numberOfShootOuts) {
				d = "randomWildsShootOutFinal"
			}
			a = 0
		} else {
			c = b.FALLDOWN_ANIMATIONS[b.model.readData("featureTargets")[b.shootoutCompleted].pos[1]];
			d = b.FALLDOWN_SOUND[b.shootoutCompleted];
			if (b.shootoutCompleted + 1 === b.numberOfShootOuts) {
				d = "randomWildsFallDownFinal"
			}
			switch (b.shootoutCompleted) {
				case 0:
					a = 600;
					break;
				case 1:
					a = 100;
					break;
				default:
					a = b.shootoutCompleted * 300;
					break
			}
		}
		if (b.shootoutCompleted === 0 && b.model.getState() === "fallDown") {
			b.scaleBackPortalAnimation.play()
		}
		clearTimeout(b.myTimeout);
		b.myTimeout = setTimeout(function() {
			b.shootOutAnimation.fire(c);
			b.fireEvent("view:playAudio", {
				id: d,
				name: d
			})
		}, a)
	},
	trenchFinished: function() {
		var a = this;
		a.fireEvent("view:trenchComplete");
		a.portalAnimation.fire("portal_RandomWilds");
		a.scalePortalAnimation.play()
	},
	startTrench: function() {
		var a = this;
		if (a.model.readData("inMainGame")) {
			a.fireEvent("view:playAudio", {
				id: "randomWildsTrench",
				name: "randomWildsTrench"
			});
			a.trench.setCallback(a.trenchFinished.bind(a));
			a.trench.start(0, 23, 0)
		}
	},
	showIntroPresentation: function() {
		var a = this;
		a.startShootout()
	},
	startShootout: function() {
		var a = this;
		a.shootoutCompleted = 0;
		a.numberOfShootOuts = a.model.readData("featureTargets").length;
		a.model.setState("shootOut");
		a.randomizer.initiate([0, 1, 2, 3, 4]);
		var b = a.SHOOTOUT_ANIMATIONS[a.randomizer.draw()];
		a.shootOutAnimation.fire(b);
		a.fireEvent("view:playAudio", {
			id: a.SHOOTOUT_SOUND[0],
			name: a.SHOOTOUT_SOUND[0]
		})
	},
	hideSpineAnimation: function(a) {
		a.visible = false
	},
	stop: function() {
		var a = this;
		a.trench.fadeOut();
		a.fireEvent("view:animationComplete")
	},
	abort: function() {
		var c = this,
			a = c.model.readData("featureTargets");
		Game.PIXIUtils.resetSpineAnimation(c.shootOutAnimation);
		c.shootOutAnimation.visible = false;
		clearTimeout(c.myTimeout);
		for (var b = 0; b < a.length; b++) {
			c.fireEvent("view:replaceSymbol", a[b].pos[1])
		}
		c.stop()
	},
	createTrenchAnimation: function() {
		var a = this;
		a.trenchContainer = new PIXI.Container();
		a.trench = new Finn.TrenchMasker(Game.stage.view.animationManager.getLayer("reelBackground"), "trench_RandomWilds");
		a.trench.setSpeed(30)
	}
};
Finn.RandomWildsView = Sys.extend(Finn.RandomFeatureView, Finn.RandomWildsView, "Finn.RandomWildsView");
Sys.ns("Finn");
Finn.RandomWildsViewLow = {
	startTrench: function() {
		var a = this;
		a.trenchFinished()
	}
};
Finn.RandomWildsViewLow = Sys.extend(Finn.RandomWildsView, Finn.RandomWildsViewLow, "Finn.RandomWildsViewLow");
Sys.ns("Finn");
(function() {
	Finn.particles.createSparklesIn = function(b) {
		var e = Finn.particles.getNewParticlePrototype(),
			g = Platform.PlatformManager.getDevicePerformance(),
			f, c;
		switch (g) {
			case Platform.PlatformManager.LOW_END_DEVICE:
				f = Platform.isAndroidMajorVersion < 6 ? 0 : 25;
				c = [Finn.particles.NO_TINT_COLOUR];
				break;
			case Platform.PlatformManager.MEDIUM_DEVICE:
				f = Platform.isAndroidMajorVersion < 6 ? 0 : 100;
				c = [Finn.particles.NO_TINT_COLOUR];
				break;
			case Platform.PlatformManager.HIGH_END_DEVICE:
				f = 250;
				c = [Finn.particles.NO_TINT_COLOUR, 16774847, 16772028, 15859621, 16579200];
				break;
			default:
				f = 0;
				break
		}

		function a() {
			var h = pixiGenericSlot.Positions.createCurrentCanvasRectangle();
			h.y = -h.height;
			return h
		}
		var d = {
			particleCount: f,
			minDelayBeforeStart: 3000,
			maxDelayBeforeStart: 8000,
			minWidthScale: 0.8,
			maxWidthScale: 1.2,
			minHeightScale: 1,
			maxHeightScale: 1,
			minOverallScale: 0.5,
			maxOverallScale: 0.8,
			minOpacity: (Math.random() * 0.2),
			maxOpacity: 3,
			minMoveSpeed: 8,
			maxMoveSpeed: 12,
			minRotatingSpeed: 0,
			maxRotatingSpeed: 0,
			coloursArray: c,
			minUpdateSpeed: 1,
			maxUpdateSpeed: 1,
			frameCount: 1,
			boundsRectangle: pixiGenericSlot.Positions.createCurrentCanvasRectangle(),
			spawnRectangle: a(),
			ParticlePrototype: e,
			imageURL: "transformTwinkle"
		};
		e.init = function() {
			var l = (Math.random() / 30) + 0.05,
				k = this.height - (this.height * 0.45),
				h = this.height + (this.height * 0.45),
				j = 3;
			this.addPropertyToggle("alpha", this.minOpacity, this.maxOpacity, l);
			this.addPropertyToggle("height", k, h, j)
		};
		e.tickParticle = function() {
			this.y += this.movingSpeed
		};
		Finn.particles.createIn(b, d)
	}
}());
Sys.ns("Finn");
Finn.SymbolTransform = {
	constructor: function() {
		Finn.SymbolTransform.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "waitSequence", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.SymbolTransformModel,
			controller: Finn.SymbolTransformController,
			view: Finn.SymbolTransformView
		}
	}
};
Finn.SymbolTransform = Sys.extend(Core.Module, Finn.SymbolTransform, "Finn.SymbolTransform");
Sys.ns("Finn");
Finn.SymbolTransformController = {
	constructor: function() {
		Finn.SymbolTransformController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:animationComplete": a.hide,
			"view:hideSymbols": a.hideSymbols,
			"view:replaceSymbols": a.replaceSymbols,
			"view:enableQuickStop": a.enableQuickStop,
			"request:randomFeature.restore": a.restore,
			"notify:stateHandler.enteringSymbolTransformState": a.show,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop")
		})
	},
	enableQuickStop: function() {
		var a = this;
		a.startListeningToUserInput();
		a.fireEvent("request:quickStopper.enableForRandomFeature")
	},
	onUserInputStart: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			a.abort()
		}
	},
	abort: function() {
		var a = this;
		if (this.model.isState("animating")) {
			a.model.setState("idle");
			a.view.abort()
		}
	},
	show: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.stopListeningToUserInput();
		b.model.setState("animating");
		if (a === "basic") {
			b.view.startTrench();
			b.fireEvent("request:backgroundOverlay.fadeIn", "symbolTransform")
		} else {
			b.view.trenchFinished()
		}
		b.view.showSparkleParticles()
	},
	hide: function() {
		var a = this;
		a.view.cutAudio();
		a.stopListeningToUserInput();
		a.model.setState("idle");
		a.fireEvent("notify:symbolTransform.presentationFinished");
		if (a.model.readData("gameState") === "basic") {
			a.fireEvent("request:backgroundOverlay.fadeOut")
		}
	},
	hideSymbols: function(a) {
		var c = this,
			b = c.model.readData(a);
		Sys.each(b, function(d) {
			c.fireEvent("request:spin.hideSymbols", {
				0: d.pos[1]
			})
		})
	},
	replaceSymbols: function(b) {
		var c = this,
			a = c.model.readData(b);
		Sys.each(a, function(d) {
			c.fireEvent("request:spin.replaceSymbols", [{
				0: d.pos[1]
			}, d.to])
		})
	},
	restore: function() {
		var b = this,
			a = b.model.readData("featureTargets");
		Sys.each(a, function(c) {
			b.fireEvent("request:spin.replaceSymbols", [{
				0: c.pos[1]
			}, c.to])
		})
	}
};
Finn.SymbolTransformController = Sys.extend(Core.Controller, Finn.SymbolTransformController, "Finn.SymbolTransformController");
Sys.ns("Finn");
Finn.SymbolTransformModel = {
	constructor: function() {
		Finn.SymbolTransformModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = this;
		a.storeData("inMainGame", !Sys.isDefined(b.freespin));
		if (Sys.isDefined(b.rf) && Sys.isDefined(b.rf.feature) && b.rf.feature === "symboltransform") {
			a.storeData("gameState", b.gamestate.current);
			a.setState("animationRequested");
			a.storeData("featureTargets", b.rf.targets);
			if (b.rf.targets) {
				a.splitTargetSymbols(b.rf.targets)
			}
		} else {
			a.setState("idle")
		}
	},
	splitTargetSymbols: function(b) {
		var e = this,
			d = [],
			a = [];
		for (var c = 0; c < b.length; c++) {
			if (b[c].from === "SYM7") {
				d.push(b[c])
			} else {
				a.push(b[c])
			}
		}
		e.storeData("sym7", d);
		e.storeData("sym8", a)
	}
};
Finn.SymbolTransformModel = Sys.extend(Core.Model, Finn.SymbolTransformModel, "Finn.SymbolTransformModel");
Sys.ns("Finn");
Finn.SymbolTransformView = {
	SPARKLE_OFFSET: 20,
	BLINK_AUDIO: ["transformBlink1", "transformBlink2", "transformBlink3", "transformBlink4", "transformBlink5", "transformBlink6", "transformBlink7"],
	NUMBER_OF_BLINKS: 7,
	BLINK_ANIMATIONS: {
		SYM3: {
			animation: "sym3_tease",
			result: "sym3_result",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM4: {
			animation: "sym4_tease",
			result: "sym4_result",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM5: {
			animation: "sym5_tease",
			result: "sym5_result",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM6: {
			animation: "sym6_tease",
			result: "sym6_result",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM7: {
			animation: "sym7_tease",
			result: "sym7_result",
			offset: {
				x: -36,
				y: -36
			}
		},
		SYM8: {
			animation: "sym8_tease",
			result: "sym8_result",
			offset: {
				x: -36,
				y: -36
			}
		}
	},
	constructor: function() {
		Finn.SymbolTransformView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.config = Resources.readData("config");
		a.reelLayout = a.config.reelGroups["default"].reelLayout;
		a.numberOfOutcomeSymbols = a.reelLayout.standard.numberOfOutcomeSymbols;
		a.symbolWidths = a.reelLayout.standard.symbolWidths;
		a.symbolHeights = a.reelLayout.standard.symbolHeights;
		a.rootContainer = new PIXI.Container();
		a.symbolContainer = new PIXI.Container();
		a.symbolContainer.position = new PIXI.Point(a.reelLayout[0].left, a.reelLayout[0].top);
		a.createTrenchAnimation();
		a.initPortal("init_Blast_MagicTransform");
		a.randomizer = new Finn.Randomizer();
		a.randomizer.initiate(["SYM3", "SYM4", "SYM5", "SYM6"]);
		a.blinkAnimations = [];
		a.sparkleAnimations = [];
		a.createBlinkAnimations();
		a.createSparkleAnimations();
		a.introPresentation = a.createSpineAnimation("symbolTransform");
		Game.stage.view.animationManager.getLayer("randomFeaturePresentations").addChild(a.rootContainer);
		Game.stage.view.animationManager.getLayer("winPresentationAboveSymbols").addChild(a.symbolContainer)
	},
	portalFinished: function() {
		var a = this;
		a.waveCount = 0;
		a.currentSymbolChange = "sym7";
		a.startBlink()
	},
	createTrenchAnimation: function() {
		var a = this;
		a.trenchContainer = new PIXI.Container();
		a.trench = new Finn.TrenchMasker(Game.stage.view.animationManager.getLayer("reelBackground"), "trench_MagicTransform");
		a.trench.setSpeed(30)
	},
	startTrench: function() {
		var a = this;
		if (a.model.readData("inMainGame")) {
			a.fireEvent("view:playAudio", {
				id: "transformTrench",
				name: "transformTrench"
			});
			a.trench.setCallback(a.trenchFinished.bind(a));
			a.trench.start(0, 23, 0)
		}
	},
	trenchFinished: function() {
		var a = this;
		a.fireEvent("view:trenchComplete");
		a.portalAnimation.fire("portal_MagicTransform");
		a.scalePortalAnimation.play()
	},
	createSpineAnimation: function(a) {
		var b = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(a, b.rootContainer);
		c.visible = false;
		c.fire = function(e, d) {
			Finn.AnimationUtils.initialize(c, e).onAnimationEnd(b, function() {
				b.scaleBackPortalAnimation.play()
			}, this, d)
		};
		return c
	},
	createBlinkAnimation: function(a) {
		var b = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(a, b.symbolContainer);
		c.visible = false;
		c.fire = function(h, g, e) {
			var f = h.animation,
				d = b.reelLayout.symbolPositions[e];
			c.position.x = d.x * b.symbolWidths.standard + h.offset.x;
			c.position.y = d.y * b.symbolHeights.standard + h.offset.y;
			if (b.waveCount === b.NUMBER_OF_BLINKS - 1) {
				f = h.result
			}
			Finn.AnimationUtils.initialize(c, f).onAnimationEnd(b, function() {
				b.hideAndResetSpineAnimation(c);
				if (b.model.isState("animating")) {
					b.completedMissileAnimations++;
					if (b.completedMissileAnimations === b.symbolsToAnimate.length) {
						b.waveCount++;
						if (b.waveCount === b.NUMBER_OF_BLINKS && b.currentSymbolChange === "sym8") {
							b.fireEvent("view:replaceSymbols", b.currentSymbolChange);
							b.fireEvent("view:animationComplete");
							b.hideSymbols()
						} else {
							if (b.waveCount === b.NUMBER_OF_BLINKS) {
								b.fireEvent("view:replaceSymbols", b.currentSymbolChange);
								b.currentSymbolChange = "sym8";
								b.waveCount = 0;
								b.startBlink()
							} else {
								b.startBlink()
							}
						}
					}
				}
			}, this, g);
			c.updateTransform();
			c.visible = true
		};
		return c
	},
	createBlinkAnimations: function() {
		var b = this;
		for (var a = 0; a < b.numberOfOutcomeSymbols; a++) {
			b.blinkAnimations[a] = b.createBlinkAnimation("symbolTransformChange")
		}
	},
	createSparkleAnimation: function(b) {
		var c = this,
			d, a = c.reelLayout.symbolPositions[b];
		d = Game.PIXIFactory.createAndAddSpineAnimation("symbolTransformStickySparkles", c.symbolContainer);
		d.visible = false;
		d.fire = function() {
			d.state.setAnimation(0, "animation", true);
			d.updateTransform();
			d.visible = true
		};
		d.position.x = c.SPARKLE_OFFSET + a.x * c.symbolWidths.standard;
		d.position.y = c.SPARKLE_OFFSET + a.y * c.symbolHeights.standard;
		return d
	},
	createSparkleAnimations: function() {
		var b = this;
		for (var a = 0; a < b.numberOfOutcomeSymbols; a++) {
			b.sparkleAnimations[a] = b.createSparkleAnimation(a)
		}
	},
	showIntroPresentation: function() {
		var a = this,
			b = "randomFeatureCauldron";
		if (!a.model.readData("inMainGame")) {
			b = "randomFeatureCauldronSmall"
		}
		a.symbolContainer.visible = true;
		if (a.model.isState("animating")) {
			a.introPresentation.fire("animation", "intro");
			a.fireEvent("view:playAudio", {
				id: b,
				name: b
			})
		}
		a.startStickySparkle()
	},
	startStickySparkle: function() {
		var c = this,
			a, d = c.model.readData("featureTargets");
		for (var b = 0; b < d.length; b++) {
			a = d[b].pos[1];
			c.sparkleAnimations[a].fire()
		}
	},
	showSparkleParticles: function() {
		var a = Game.stage.view.animationManager.getLayer("splashScreensContentOverlay");
		Finn.particles.createSparklesIn(a)
	},
	startBlink: function() {
		var a = this;
		a.symbolsToAnimate = a.model.readData(a.currentSymbolChange);
		if (!a.symbolsToAnimate.length && a.currentSymbolChange === "sym7") {
			a.currentSymbolChange = "sym8";
			a.symbolsToAnimate = a.model.readData(a.currentSymbolChange)
		}
		if (!a.symbolsToAnimate.length && a.currentSymbolChange === "sym8") {
			a.hideSymbols();
			a.fireEvent("view:animationComplete");
			return
		}
		a.completedMissileAnimations = 0;
		if (a.waveCount === 0) {
			a.fireEvent("view:hideSymbols", a.currentSymbolChange);
			a.currentBlink = a.symbolsToAnimate[0].from
		} else {
			if (a.waveCount === a.NUMBER_OF_BLINKS - 1) {
				a.currentBlink = a.symbolsToAnimate[0].to
			} else {
				a.currentBlink = a.randomizer.draw()
			}
		}
		a.triggerSound();
		a.doBlink(0)
	},
	triggerSound: function() {
		var a = this;
		a.fireEvent("view:playAudio", {
			id: a.BLINK_AUDIO[a.waveCount],
			name: a.BLINK_AUDIO[a.waveCount]
		})
	},
	doBlink: function(b) {
		var c = this,
			a;
		if (c.model.isState("animating") && b < c.symbolsToAnimate.length) {
			a = c.symbolsToAnimate[b].pos[1];
			if (c.waveCount === c.NUMBER_OF_BLINKS - 1) {
				c.blinkAnimations[a].state.timeScale = 1
			} else {
				c.blinkAnimations[a].state.timeScale = 1 / (1 + (c.waveCount / 3))
			}
			c.blinkAnimations[a].visible = true;
			c.blinkAnimations[a].fire(c.BLINK_ANIMATIONS[c.currentBlink], "missile", c.symbolsToAnimate[b].pos[1]);
			c.doBlink(b + 1)
		}
	},
	hideAndResetSpineAnimation: function(a) {
		a.visible = false;
		Game.PIXIUtils.resetSpineAnimation(a)
	},
	hideSymbols: function() {
		var a = this;
		a.symbolContainer.visible = false;
		if (a.model.readData("inMainGame")) {
			a.trench.fadeOut()
		}
		Sys.each(a.sparkleAnimations, function(b) {
			a.hideAndResetSpineAnimation(b)
		})
	},
	abort: function() {
		var a = this;
		a.fireEvent("view:replaceSymbols", "sym7");
		a.fireEvent("view:replaceSymbols", "sym8");
		a.stop()
	},
	stop: function() {
		var a = this;
		a.hideSymbols();
		a.hideAndResetSpineAnimation(a.introPresentation);
		a.cutAudio();
		Sys.each(a.blinkAnimations, function(b) {
			a.hideAndResetSpineAnimation(b)
		});
		a.fireEvent("view:animationComplete")
	},
	cutAudio: function() {
		var a = this;
		a.fireEvent("view:stopAudio", "randomFeatureCauldronSmall");
		a.fireEvent("view:stopAudio", "randomFeatureCauldron")
	}
};
Finn.SymbolTransformView = Sys.extend(Finn.RandomFeatureView, Finn.SymbolTransformView, "Finn.SymbolTransformView");
Sys.ns("Finn");
Finn.SymbolTransformViewLow = {
	startTrench: function() {
		var a = this;
		a.trenchFinished()
	}
};
Finn.SymbolTransformViewLow = Sys.extend(Finn.SymbolTransformView, Finn.SymbolTransformViewLow, "Finn.SymbolTransformViewLow");
Sys.ns("Finn");
Finn.SymbolOverlay = {
	constructor: function() {
		Finn.SymbolOverlay.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		var a = this.model
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "waitSequence", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.CloneModel,
			controller: Finn.CloneController,
			view: Finn.CloneView
		}
	}
};
Finn.SymbolOverlay = Sys.extend(Core.Module, Finn.SymbolOverlay, "Finn.SymbolOverlay");
Sys.ns("Finn");
Finn.SymbolOverlayController = {
	constructor: function() {
		Finn.SymbolOverlayController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:animationComplete": a.hide,
			"view:enableQuickStop": a.enableQuickStop,
			"notify:stateHandler.enteringSymbolOverlayState": a.show,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop"),
			"view:prepareSymbols": a.prepareSymbols
		})
	},
	enableQuickStop: function() {
		var a = this;
		a.startListeningToUserInput();
		a.fireEvent("request:quickStopper.enableForRandomFeature")
	},
	onUserInputStart: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			a.abort()
		}
	},
	abort: function() {
		var a = this;
		if (this.model.isState("animating")) {
			a.model.setState("idle");
			a.view.abort()
		}
	},
	show: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.stopListeningToUserInput();
		b.fireEvent("request:quickStopper.disableForRandomFeature");
		b.model.setState("animating");
		if (a === "basic") {
			setTimeout(function() {
				b.view.startTrench();
				b.fireEvent("request:backgroundOverlay.fadeIn", "symbolOverlay")
			}, 2500)
		} else {
			b.view.trenchFinished()
		}
	},
	prepareSymbols: function() {
		var b = this,
			a = b.model.readData("featureTargets");
		Sys.each(a, function(c) {
			b.fireEvent("request:spin.hideSymbols", {
				0: c.pos[1]
			})
		});
		b.view.showOldSymbols()
	},
	hide: function() {
		var b = this,
			a = b.model.readData("featureTargets");
		b.stopListeningToUserInput();
		Sys.each(a, function(c) {
			b.fireEvent("request:spin.replaceSymbols", [{
				0: c.pos[1]
			}, c.to])
		});
		b.model.setState("idle");
		b.fireEvent("notify:symbolOverlay.presentationFinished");
		if (b.model.readData("gameState") === "basic") {
			b.fireEvent("request:backgroundOverlay.fadeOut")
		}
	}
};
Finn.SymbolOverlayController = Sys.extend(Core.Controller, Finn.SymbolOverlayController, "Finn.SymbolOverlayController");
Sys.ns("Finn");
Finn.SymbolOverlayModel = {
	constructor: function() {
		Finn.SymbolOverlayModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = this;
		a.storeData("inMainGame", !Sys.isDefined(b.freespin));
		if (Sys.isDefined(b.rf) && Sys.isDefined(b.rf.feature)) {
			a.storeData("gameState", b.gamestate.current);
			a.setState("animationRequested");
			a.storeData("featureTargets", b.rf.targets)
		} else {
			a.setState("idle")
		}
	}
};
Finn.SymbolOverlayModel = Sys.extend(Core.Model, Finn.SymbolOverlayModel, "Finn.SymbolOverlayModel");
Sys.ns("Finn");
Finn.SymbolOverlayView = {
	OLD_SYM: "old",
	NEW_SYM: "new",
	FALLDOWN_AUDIO: ["luckyMugFallDown1", "luckyMugFallDown2", "luckyMugFallDown3", "luckyMugFallDown4", "luckyMugFallDown5"],
	constructor: function() {
		Finn.SymbolOverlayView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this,
			a = Game.stage.view.animationManager.getLayer("randomFeaturePresentations");
		b.oldSymbolSprites = [];
		b.newSymbolSprites = [];
		b.oldSymbolAnimations = [];
		b.newSymbolAnimations = [];
		b.symbolSpines = [];
		b.config = Resources.readData("config");
		b.reelLayout = b.config.reelGroups["default"].reelLayout;
		b.numberOfOutcomeSymbols = b.reelLayout.standard.numberOfOutcomeSymbols;
		b.symbolWidths = b.reelLayout.standard.symbolWidths;
		b.symbolHeights = b.reelLayout.standard.symbolHeights;
		b.rootContainer = new PIXI.Container();
		b.symbolContainer = new PIXI.Container();
		b.symbolContainer.position = new PIXI.Point(b.reelLayout[0].left, b.reelLayout[0].top);
		b.rootContainer.addChild(b.symbolContainer);
		b.createTrenchAnimation();
		b.initPortal("init_Blast_DrunkenLuck");
		b.introPresentation = b.createSpineAnimation("symbolOverlay");
		b.createBeerSplashAnimationContainers();
		b.createSymbolAnimationContainers(b.oldSymbolAnimations, b.oldSymbolSprites, b.OLD_SYM);
		b.createSymbolAnimationContainers(b.newSymbolAnimations, b.newSymbolSprites, b.NEW_SYM);
		Game.stage.view.animationManager.getLayer("randomFeaturePresentations").addChild(b.rootContainer);
		Game.stage.view.animationManager.getLayer("winPresentationBelowSymbols").addChild(b.trenchContainer)
	},
	createBeerSplashAnimationContainers: function() {
		var d = this;
		for (var c = 0; c < d.numberOfOutcomeSymbols; c++) {
			var a = d.reelLayout.symbolPositions[c];
			var b = new PIXI.Container();
			b.position.x = a.x * d.symbolWidths.standard;
			b.position.y = a.y * d.symbolHeights.standard;
			d.symbolSpines.push(d.createBeerSplash(b.position.x, b.position.y));
			d.symbolContainer.addChild(b)
		}
	},
	createBeerSplash: function(a, d) {
		var b = this,
			c = Game.PIXIFactory.createAndAddSpineAnimation("beerSplash", b.symbolContainer);
		c.visible = false;
		c.position.x = a - 120;
		c.position.y = d - 80;
		c.fire = function(f) {
			var e = function() {
				Game.PIXIUtils.resetSpineAnimation(c);
				c.visible = false
			};
			c.visible = true;
			Game.PIXIUtils.resetSpineAnimation(c);
			Finn.AnimationUtils.initialize(c, f, false).onAnimationEnd(c, e);
			c.updateTransform()
		};
		c.visible = false;
		Game.stage.view.animationManager.addToAnimationLoop(c);
		return c
	},
	portalFinished: function() {
		var a = this;
		a.removeOldSymbols()
	},
	createTrenchAnimation: function() {
		var a = this;
		a.trenchContainer = new PIXI.Container();
		a.trench = new Finn.TrenchMasker(Game.stage.view.animationManager.getLayer("reelBackground"), "trench_DrunkenLuck");
		a.trench.setSpeed(30)
	},
	startTrench: function() {
		var a = this;
		if (a.model.readData("inMainGame")) {
			a.fireEvent("view:playAudio", {
				id: "overlayTrench",
				name: "overlayTrench"
			});
			a.trench.setCallback(a.trenchFinished.bind(a));
			a.trench.start(0, 23, 0)
		}
	},
	trenchFinished: function() {
		var a = this;
		setTimeout(function() {
			a.fireEvent("view:trenchComplete");
			a.portalAnimation.fire("portal_DrunkenLuck");
			a.scalePortalAnimation.play()
		}, 500)
	},
	createSpineAnimation: function(a) {
		var b = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(a, b.rootContainer);
		c.visible = false;
		c.fire = function(d) {
			Finn.AnimationUtils.initialize(c, d).onAnimationEnd(b, b.onComplete)
		};
		return c
	},
	createSymbolAnimationContainers: function(h, g, e) {
		var d = this,
			f;
		for (var c = 0; c < d.numberOfOutcomeSymbols; c++) {
			var a = d.reelLayout.symbolPositions[c];
			var b = new PIXI.Container();
			b.position.x = a.x * d.symbolWidths.standard + d.symbolWidths.standard * 0.5 - 0.5;
			b.position.y = a.y * d.symbolHeights.standard + d.symbolHeights.standard * 0.5 - 0.5;
			f = Game.PIXIFactory.createAndAddSprite("symbolOverlayAnimation", b, {
				x: 0,
				y: 0
			});
			f.visible = false;
			f.anchor = new PIXI.Point(0.5, 0.5);
			g.push(f);
			if (e === d.OLD_SYM) {
				h[c] = d.initOldSymbolAnimation(f)
			} else {
				if (e === d.NEW_SYM) {
					h[c] = d.initNewSymbolAnimation(f)
				}
			}
			d.symbolContainer.addChild(b)
		}
	},
	initOldSymbolAnimation: function(c) {
		var b = this;
		var e = {
			prop: "scale",
			animate: {
				0: {
					x: 1,
					y: 1
				},
				750: {
					x: 0,
					y: 0
				}
			}
		};
		var a = {
			prop: "rotation",
			animate: {
				0: 0,
				750: 2 * Math.PI
			}
		};
		var d = new Animation.Holder({
			id: "full",
			target: c,
			delay: 0,
			onEnd: function() {
				b.completedOldAnimationCounter++;
				if (b.completedOldAnimationCounter === b.symbolsToAnimate.length && b.model.isState("animating")) {
					b.showNewSymbols()
				}
			},
			children: [e, a]
		});
		Game.stage.view.animationManager.addToAnimationLoop(d);
		return d
	},
	initNewSymbolAnimation: function(d) {
		var c = this;
		var e = {
			prop: "scale",
			animate: {
				0: {
					x: 1.5,
					y: 1.5
				},
				350: {
					x: 1,
					y: 1
				}
			}
		};
		var b = {
			prop: "alpha",
			animate: {
				0: 0,
				350: 1
			}
		};
		var a = new Animation.Holder({
			id: "full",
			target: d,
			delay: 0,
			onEnd: function() {
				c.fireEvent("view:playAudio", {
					id: c.FALLDOWN_AUDIO[c.completedNewAnimationCounter],
					name: c.FALLDOWN_AUDIO[c.completedNewAnimationCounter]
				});
				c.showBeerSplash();
				c.completedNewAnimationCounter++;
				if (c.completedNewAnimationCounter === c.symbolsToAnimate.length) {
					setTimeout(function() {
						c.fireEvent("view:animationComplete");
						c.hideSymbols()
					}, 500)
				} else {
					c.showNewSymbol()
				}
			},
			children: [e, b]
		});
		Game.stage.view.animationManager.addToAnimationLoop(a);
		return a
	},
	showIntroPresentation: function() {
		var a = this,
			b = "randomFeatureBeerMugs";
		if (!a.model.readData("inMainGame")) {
			b = "randomFeatureBeerMugsSmall"
		}
		if (a.model.isState("animating")) {
			a.introPresentation.fire("animation");
			a.fireEvent("view:playAudio", {
				id: b,
				name: b
			})
		}
	},
	onComplete: function() {
		var a = this;
		a.scaleBackPortalAnimation.play();
		a.hideIntroPresentation();
		Game.PIXIUtils.resetSpineAnimation(a.introPresentation);
		if (a.model.readData("inMainGame")) {
			a.trench.fadeOut()
		}
	},
	hideIntroPresentation: function() {
		var a = this;
		a.introPresentation.visible = false;
		if (a.model.readData("inMainGame")) {
			a.trench.fadeOut()
		}
	},
	showOldSymbols: function() {
		var c = this,
			a, d;
		if (c.model.isState("animating")) {
			c.symbolContainer.visible = true;
			c.symbolsToAnimate = c.model.readData("featureTargets");
			for (var b = 0; b < c.symbolsToAnimate.length; b++) {
				a = c.symbolsToAnimate[b].pos[1];
				d = c.symbolsToAnimate[b].from;
				c.oldSymbolSprites[a].texture = Resources.readData("animationImages")[d];
				c.oldSymbolSprites[a].scale = {
					x: 1,
					y: 1
				};
				c.oldSymbolSprites[a].visible = true
			}
		}
	},
	removeOldSymbols: function() {
		var c = this,
			a;
		if (c.model.isState("animating")) {
			c.fireEvent("view:prepareSymbols");
			c.completedOldAnimationCounter = 0;
			c.symbolsToAnimate = c.model.readData("featureTargets");
			c.fireEvent("view:playAudio", {
				id: "luckyMugSpinOut",
				name: "luckyMugSpinOut"
			});
			for (var b = 0; b < c.symbolsToAnimate.length; b++) {
				a = c.symbolsToAnimate[b].pos[1];
				c.removeOldSymbol(a)
			}
		}
	},
	removeOldSymbol: function(a) {
		var b = this;
		b.oldSymbolSprites[a].visible = true;
		b.oldSymbolAnimations[a].play()
	},
	showNewSymbols: function() {
		var a = this;
		a.completedNewAnimationCounter = 0;
		a.symbolsToAnimate = a.model.readData("featureTargets");
		a.showNewSymbol()
	},
	showNewSymbol: function() {
		var b = this,
			c, a = b.getOrderedIndex();
		c = b.symbolsToAnimate[0].to;
		b.newSymbolSprites[a].texture = Resources.readData("animationImages")[c];
		b.newSymbolSprites[a].visible = true;
		b.newSymbolAnimations[a].play()
	},
	showBeerSplash: function() {
		var a = this;
		a.symbolSpines[a.getOrderedIndex()].fire("animation")
	},
	getOrderedIndex: function() {
		var c = this,
			d = "x",
			a = 0;
		if (c.reelLayout.symbolPositions[c.symbolsToAnimate[0].pos[1]].x === c.reelLayout.symbolPositions[c.symbolsToAnimate[1].pos[1]].x) {
			d = "y"
		}
		for (var b = 0; b < c.symbolsToAnimate.length; b++) {
			if (c.reelLayout.symbolPositions[c.symbolsToAnimate[b].pos[1]][d] === c.completedNewAnimationCounter) {
				a = c.symbolsToAnimate[b].pos[1]
			}
		}
		return a
	},
	hideSymbols: function() {
		var a = this;
		a.symbolContainer.visible = false;
		Sys.each(a.oldSymbolSprites, function(c, b) {
			a.resetSymbol(c, 1);
			a.oldSymbolAnimations[b].stop()
		});
		Sys.each(a.newSymbolSprites, function(c, b) {
			a.resetSymbol(c, 0);
			a.newSymbolAnimations[b].stop()
		})
	},
	resetSymbol: function(a, b) {
		a.scale = {
			x: b,
			y: b
		};
		a.rotation = 0;
		a.visible = false
	},
	abort: function() {
		var a = this;
		a.stop()
	},
	stop: function() {
		var a = this;
		a.fireEvent("view:stopAudio", "randomFeatureBeerMugs");
		a.fireEvent("view:stopAudio", "randomFeatureBeerMugsSmall");
		a.hideSymbols();
		a.hideIntroPresentation();
		Game.PIXIUtils.resetSpineAnimation(a.introPresentation);
		a.fireEvent("view:animationComplete")
	}
};
Finn.SymbolOverlayView = Sys.extend(Finn.RandomFeatureView, Finn.SymbolOverlayView, "Finn.SymbolOverlayView");
Sys.ns("Finn");
Finn.SymbolOverlayViewLow = {
	startTrench: function() {
		var a = this;
		a.trenchFinished()
	}
};
Finn.SymbolOverlayViewLow = Sys.extend(Finn.SymbolOverlayView, Finn.SymbolOverlayViewLow, "Finn.SymbolOverlayViewLow");
Sys.ns("Finn");
Finn.Destroy = {
	constructor: function() {
		Finn.Destroy.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput", "waitSequence", "trigger"]
	},
	getDefaultMVCClasses: function() {
		return {
			model: Finn.DestroyModel,
			controller: Finn.DestroyController,
			view: Finn.DestroyView
		}
	}
};
Finn.Destroy = Sys.extend(Core.Module, Finn.Destroy, "Finn.Destroy");
Sys.ns("Finn");
Finn.DestroyController = {
	constructor: function() {
		Finn.DestroyController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"view:animationComplete": a.hide,
			"view:hideSymbols": a.hideSymbols,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
			"view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop"),
			"request:randomFeature.restore": a.hideSymbols,
			"notify:stateHandler.enteringDestroyState": a.show,
			"view:enableQuickStop": a.enableQuickStop
		})
	},
	enableQuickStop: function() {
		var a = this;
		a.startListeningToUserInput();
		a.fireEvent("request:quickStopper.enableForRandomFeature")
	},
	onUserInputStart: function(b) {
		var a = this;
		if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
			a.abort()
		}
	},
	show: function() {
		var b = this,
			a = b.model.readData("gameState");
		b.stopListeningToUserInput();
		b.model.setState("animating");
		b.fireEvent("request:quickStopper.disableForRandomFeature");
		if (a === "basic") {
			b.fireEvent("request:backgroundOverlay.fadeIn", "destroy");
			b.view.startBlink()
		} else {
			b.view.trenchFinished()
		}
	},
	showIntro: function() {
		var a = this;
		a.view.showIntroPresentation()
	},
	hide: function() {
		var c = this,
			a = c.model.readData("featureTargets"),
			b = c.model.readData("gameState");
		if (b === "basic") {
			c.fireEvent("request:backgroundOverlay.fadeOut")
		}
		Sys.each(a, function(d) {
			c.fireEvent("request:spin.hideSymbols", {
				0: d.pos[1]
			})
		});
		c.model.setState("idle");
		c.fireEvent("notify:destroy.presentationFinished")
	},
	hideSymbols: function() {
		var b = this,
			a = b.model.readData("featureTargets");
		if (b.model.readData("inDestroyFeature")) {
			Sys.each(a, function(c) {
				b.fireEvent("request:spin.hideSymbols", {
					0: c.pos[1]
				})
			})
		}
	},
	abort: function() {
		var a = this;
		if (this.model.isState("animating")) {
			a.model.setState("idle");
			a.view.abort()
		}
	}
};
Finn.DestroyController = Sys.extend(Core.Controller, Finn.DestroyController, "Finn.DestroyController");
Sys.ns("Finn");
Finn.DestroyModel = {
	constructor: function() {
		Finn.DestroyModel.superclass.constructor.apply(this, arguments)
	},
	processServerResponse: function(b) {
		var a = this;
		a.storeData("inMainGame", !Sys.isDefined(b.freespin));
		if (Sys.isDefined(b.rf) && Sys.isDefined(b.rf.feature)) {
			a.setState("animationRequested");
			a.storeData("featureTargets", b.rf.targets);
			a.storeData("gameState", b.gamestate.current);
			a.storeData("syms", b.rs.i0.r.i0.beforefeaturesyms)
		} else {
			a.setState("idle")
		}
		if (Sys.isDefined(b.rf) && Sys.isDefined(b.rf.feature) && b.rf.feature === "destroy") {
			a.storeData("inDestroyFeature", true)
		} else {
			a.storeData("inDestroyFeature", false)
		}
	}
};
Finn.DestroyModel = Sys.extend(Core.Model, Finn.DestroyModel, "Finn.DestroyModel");
Sys.ns("Finn");
Finn.DestroyView = {
	BLEND_MODE: 1,
	ORANGE_TINT: 16505750,
	EXPLOSION_OFFSET: {
		x: -100,
		y: -100
	},
	FADE_TO_GOLD_ANIMATIONS: {
		SYM3: {
			animation: "sym3_init_EXPORT",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM4: {
			animation: "sym4_init_EXPORT",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM5: {
			animation: "sym5_init_EXPORT",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM6: {
			animation: "sym6_init_EXPORT",
			offset: {
				x: -86,
				y: -86
			}
		},
		SYM7: {
			animation: "sym7_init_EXPORT",
			offset: {
				x: -36,
				y: -36
			}
		},
		SYM8: {
			animation: "sym8_init_EXPORT",
			offset: {
				x: -36,
				y: -36
			}
		}
	},
	constructor: function() {
		Finn.DestroyView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var a = this;
		a.symbolSpines = [];
		a.symbolFadeToGold = [];
		a.symbolBlink;
		a.explosions = [];
		a.config = Resources.readData("config");
		a.randomizer = new Finn.Randomizer();
		a.reelLayout = a.config.reelGroups["default"].reelLayout;
		a.numberOfOutcomeSymbols = a.reelLayout.standard.numberOfOutcomeSymbols;
		a.symbolWidths = a.reelLayout.standard.symbolWidths;
		a.symbolHeights = a.reelLayout.standard.symbolHeights;
		a.rootContainer = new PIXI.Container();
		a.symbolContainer = new PIXI.Container();
		a.symbolContainer.position = new PIXI.Point(a.reelLayout[0].left, a.reelLayout[0].top);
		a.initPortal("init_Blast_Destroy");
		a.introPresentation = a.createSpineAnimation("destroy");
		a.createSymbolAnimationContainers();
		a.createDisplacement();
		a.createTrenchAnimation();
		a.symbolBlink = a.createBlink();
		Game.stage.view.animationManager.getGroupLayer(0).filters = null;
		Game.stage.view.animationManager.getLayer("randomFeaturePresentations").addChild(a.rootContainer);
		Game.stage.view.animationManager.getLayer("winPresentationBelowSymbols").addChild(a.trenchContainer);
		Game.stage.view.animationManager.getLayer("winPresentationAboveSymbols").addChild(a.symbolContainer)
	},
	portalFinished: function() {
		var a = this;
		a.randomFlickering()
	},
	createSpineAnimation: function(a) {
		var b = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(a, b.rootContainer);
		c.visible = false;
		c.fire = function(d) {
			c.state.setAnimation(0, d, false);
			c.state.addListener({
				complete: b.onComplete.bind(b)
			});
			c.visible = true
		};
		return c
	},
	createDisplacement: function() {
		var b = this,
			a;
		a = PIXI.Texture.fromImage("multimedia/images/1280x720/fx/flames.png");
		b.displacementSprite = new PIXI.Sprite(a);
		b.displacementSprite.anchor.set(0.5);
		b.displacementSprite.scale.y = 10;
		b.displacementSprite.scale.x = 10;
		b.displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
		Game.stage.view.animationManager.addToAnimationLoop(b.displacementSprite);
		Game.stage.view.animationManager.getRootLayer().addChild(b.displacementSprite);
		b.displacementSprite.visible = false;
		b.displacementFilter = new PIXI.filters.DisplacementFilter(b.displacementSprite)
	},
	createTrenchAnimation: function() {
		var a = this;
		a.trenchContainer = new PIXI.Container();
		a.trench = new Finn.TrenchMasker(Game.stage.view.animationManager.getLayer("reelBackground"), "trench_Destroy");
		a.trench.setSpeed(30)
	},
	startNextAnimation: function() {
		var a = this,
			b = "randomFeatureDragonHead";
		a.introPresentation.fire("animation");
		if (!a.model.readData("inMainGame")) {
			b = "randomFeatureDragonHeadSmall"
		}
		a.fireEvent("view:playAudio", {
			id: b,
			name: b
		})
	},
	createSymbolAnimationContainers: function() {
		var d = this;
		for (var c = 0; c < d.numberOfOutcomeSymbols; c++) {
			d.symbolFadeToGold.push(d.createFadeToGold());
			d.explosions.push(d.createExplosion());
			d.explosions[c].position.x = (d.reelLayout.symbolPositions[c].x) * d.symbolWidths.standard + d.EXPLOSION_OFFSET.x;
			d.explosions[c].position.y = (d.reelLayout.symbolPositions[c].y) * d.symbolHeights.standard + d.EXPLOSION_OFFSET.y;
			d.explosions[c].updateTransform()
		}
		for (c = 0; c < d.numberOfOutcomeSymbols; c++) {
			var a = d.reelLayout.symbolPositions[c];
			var b = new PIXI.Container();
			b.position.x = a.x * d.symbolWidths.standard;
			b.position.y = a.y * d.symbolHeights.standard;
			d.symbolSpines.push(d.createFirePuff(b.position.x, b.position.y));
			d.symbolContainer.addChild(b)
		}
	},
	createExplosion: function() {
		var b = this,
			c = Game.PIXIFactory.createAndAddSpineAnimation("winExplosion", b.symbolContainer);
		c.visible = false;
		c.fire = function() {
			var d = function() {
				Game.PIXIUtils.resetSpineAnimation(c);
				c.visible = false
			};
			Game.PIXIUtils.resetSpineAnimation(c);
			Finn.AnimationUtils.initialize(c, "animation", false).onAnimationEnd(c, d);
			c.visible = true;
			c.updateTransform()
		};
		c.tint = b.ORANGE_TINT;
		for (var a = 0; a < c.spineData.slots.length; a++) {
			c.spineData.slots[a].blendMode = b.BLEND_MODE
		}
		b.symbolContainer.addChild(c);
		return c
	},
	createBlink: function() {
		var a = this,
			b = Game.PIXIFactory.createAndAddSpineAnimation("destroyBlink", a.symbolContainer);
		b.visible = false;
		b.fire = function(e, c) {
			var d = function() {
				Game.PIXIUtils.resetSpineAnimation(b);
				b.visible = false;
				a.blinkComplete()
			};
			Finn.AnimationUtils.initialize(b, e.animation, false).onAnimationEnd(b, d);
			b.position.x = e.offset.x + a.reelLayout.symbolPositions[c].x * a.symbolWidths.standard;
			b.position.y = e.offset.y + a.reelLayout.symbolPositions[c].y * a.symbolHeights.standard;
			b.visible = true;
			b.updateTransform()
		};
		return b
	},
	createFadeToGold: function() {
		var a = this,
			b = Game.PIXIFactory.createAndAddSpineAnimation("fadeToGold", a.symbolContainer);
		b.visible = false;
		b.fire = function(e, c) {
			var d = function() {
				Game.PIXIUtils.resetSpineAnimation(b);
				b.visible = false
			};
			Game.PIXIUtils.resetSpineAnimation(b);
			Finn.AnimationUtils.initialize(b, e.animation, false).onAnimationEnd(b, d);
			b.position.x = e.offset.x + a.reelLayout.symbolPositions[c].x * a.symbolWidths.standard;
			b.position.y = e.offset.y + a.reelLayout.symbolPositions[c].y * a.symbolHeights.standard;
			b.visible = true;
			b.updateTransform()
		};
		return b
	},
	createFirePuff: function(a, d) {
		var b = this,
			c = Game.PIXIFactory.createAndAddSpineAnimation("destroyFire", b.symbolContainer);
		c.visible = false;
		c.position.x = a - 140;
		c.position.y = d - 170;
		c.fire = function(f) {
			var e = function() {
				Game.PIXIUtils.resetSpineAnimation(c);
				c.visible = false;
				b.puffComplete()
			};
			Game.PIXIUtils.resetSpineAnimation(c);
			Finn.AnimationUtils.initialize(c, f, false).onAnimationEnd(c, e);
			c.visible = true;
			c.updateTransform()
		};
		Game.stage.view.animationManager.addToAnimationLoop(c);
		return c
	},
	showIntroPresentation: function() {
		var b = this;
		b.symbolContainer.visible = true;
		b.randomizer.initiate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);
		b.puffsCompleted = 0;
		b.startNextAnimation();

		function a() {
			b.displacementSprite.x += 10;
			b.displacementSprite.y += 10;
			if (b.model.isState("animating")) {
				requestAnimationFrame(a)
			}
		}
		b.displacementSprite.x = 0;
		b.displacementSprite.y = 0;
		b.displacementSprite.visible = true;
		Game.stage.view.animationManager.getGroupLayer(0).filters = [b.displacementFilter];
		requestAnimationFrame(a);
		b.startFadeToGold()
	},
	onComplete: function() {
		var a = this;
		a.hideIntroPresentation();
		Game.PIXIUtils.resetSpineAnimation(a.introPresentation);
		if (a.model.readData("inMainGame")) {
			a.trench.fadeOut()
		}
		if (a.model.isState("animating")) {
			a.scaleBackPortalAnimation.play()
		}
	},
	hideIntroPresentation: function() {
		var a = this;
		a.displacementSprite.visible = false;
		Game.stage.view.animationManager.getGroupLayer(0).filters = null;
		a.introPresentation.visible = false;
		if (a.model.readData("inMainGame")) {
			a.trench.fadeOut()
		}
	},
	killThemAll: function() {
		var c = this;
		clearTimeout(c.killFadeToGoldTimer);
		c.fireEvent("view:hideSymbols");
		c.fireEvent("view:playAudio", {
			id: "dragonFeatureEnd",
			name: "dragonFeatureEnd"
		});
		for (var b = 0; b < c.symbolsToAnimate.length; b++) {
			var a = c.symbolsToAnimate[b].pos[1];
			c.explosions[a].fire();
			c.symbolFadeToGold[a].visible = false
		}
	},
	puffComplete: function() {
		var a = this;
		a.puffsCompleted++;
		if (a.puffsCompleted < 6) {
			a.symbolSpines[a.randomizer.draw()].fire("firePuff")
		} else {
			if (a.puffsCompleted === 6) {
				a.destroySymbols();
				a.killFadeToGoldTimer = setTimeout(function() {
					a.killThemAll()
				}, 850)
			} else {
				if (a.puffsCompleted === 7) {
					a.hideSymbols();
					a.closeView()
				}
			}
		}
	},
	randomFlickering: function() {
		var a = this;
		a.fireEvent("view:playAudio", {
			id: "randomFeatureDragonStartFirepuffs",
			name: "randomFeatureDragonStartFirepuffs"
		});
		a.puffComplete()
	},
	destroySymbols: function() {
		var c = this,
			a;
		for (var b = 0; b < c.symbolsToAnimate.length; b++) {
			a = c.symbolsToAnimate[b].pos[1];
			c.destroySymbol(a)
		}
	},
	destroySymbol: function(a) {
		var b = this;
		b.symbolSpines[a].fire("firePuff_burn")
	},
	hideSymbols: function() {
		var b = this;
		b.fireEvent("view:hideSymbols");
		for (var a = 0; a < b.symbolSpines.length; a++) {
			Game.PIXIUtils.resetSpineAnimation(b.symbolSpines[a]);
			b.symbolSpines[a].visible = false
		}
	},
	stop: function() {
		var a = this;
		a.hideIntroPresentation();
		Game.PIXIUtils.resetSpineAnimation(a.introPresentation);
		a.prolongedComplete()
	},
	abort: function() {
		var b = this;
		b.killThemAll();
		for (var a = 0; a < b.symbolFadeToGold.length; a++) {
			Game.PIXIUtils.resetSpineAnimation(b.symbolFadeToGold[a]);
			b.symbolFadeToGold[a].visible = false
		}
		b.closeView()
	},
	trenchFinished: function() {
		var a = this;
		a.symbolsToAnimate = a.model.readData("featureTargets");
		a.portalAnimation.fire("portal_Destroy");
		a.scalePortalAnimation.play()
	},
	startBlink: function() {
		var a = this;
		a.numberOfblinks = 0;
		a.symbolContainer.visible = true;
		a.randomizer.initiate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);
		setTimeout(function() {
			a.fireEvent("view:playAudio", {
				id: "randomFeatureDragonSymbolBlink",
				name: "randomFeatureDragonSymbolBlink"
			});
			a.fireRandomBlink()
		}, 2000)
	},
	blinkComplete: function() {
		var a = this;
		a.numberOfblinks++;
		if (a.numberOfblinks === 8) {
			a.startTrench()
		} else {
			a.fireRandomBlink()
		}
	},
	fireRandomBlink: function() {
		var c = this,
			b = c.model.readData("syms"),
			a = c.randomizer.draw();
		while (!c.FADE_TO_GOLD_ANIMATIONS[b[a]]) {
			a = c.randomizer.draw()
		}
		Game.PIXIUtils.resetSpineAnimation(c.symbolBlink);
		c.symbolBlink.fire(c.FADE_TO_GOLD_ANIMATIONS[c.model.readData("syms")[a]], a)
	},
	startTrench: function() {
		var a = this;
		if (a.model.readData("inMainGame")) {
			a.fireEvent("view:playAudio", {
				id: "randomWildsTrench",
				name: "randomWildsTrench"
			});
			a.trench.setCallback(a.trenchFinished.bind(a));
			a.trench.start(0, 23, 0)
		}
	},
	closeView: function() {
		var a = this;
		a.portalAnimation.visible = false;
		a.fireEvent("view:stopAudio", "randomFeatureDragonHead");
		a.fireEvent("view:stopAudio", "randomFeatureDragonHeadSmall");
		a.fireEvent("view:stopAudio", "randomFeatureDragonStartFirepuffs");
		Game.PIXIUtils.resetSpineAnimation(a.portalAnimation);
		a.prolongedComplete();
		a.hideSymbols();
		Game.PIXIUtils.resetSpineAnimation(a.introPresentation)
	},
	prolongedComplete: function() {
		var a = this;
		setTimeout(function() {
			a.fireEvent("view:animationComplete")
		}, 250)
	},
	startFadeToGold: function() {
		var c = this,
			a = c.model.readData("syms");
		for (var b = 0; b < a.length; b++) {
			if (c.FADE_TO_GOLD_ANIMATIONS[a[b]]) {
				c.symbolFadeToGold[b].fire(c.FADE_TO_GOLD_ANIMATIONS[a[b]], b)
			}
		}
	}
};
Finn.DestroyView = Sys.extend(Finn.RandomFeatureView, Finn.DestroyView, "Finn.DestroyView");
Sys.ns("Finn");
Finn.DestroyViewLow = {
	constructor: function() {
		Finn.DestroyViewLow.superclass.constructor.apply(this, arguments)
	},
	createDisplacement: function() {},
	showIntroPresentation: function() {
		var a = this;
		a.symbolContainer.visible = true;
		a.randomizer.initiate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);
		a.puffsCompleted = 0;
		a.startNextAnimation();
		a.startFadeToGold()
	},
	startTrench: function() {
		var a = this;
		a.trenchFinished()
	},
	hideIntroPresentation: function() {
		var a = this;
		a.introPresentation.visible = false
	}
};
Finn.DestroyViewLow = Sys.extend(Finn.DestroyView, Finn.DestroyViewLow, "Finn.DestroyViewLow");
Sys.ns("Finn");
Finn.Character = {
	constructor: function() {
		Finn.Character.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["serverResponse", "animation", "userInput"]
	}
};
Finn.Character = Sys.extend(Core.Module, Finn.Character, "Finn.Character");
Sys.ns("Finn");
Finn.CharacterController = {
	constructor: function() {
		Finn.CharacterController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"request:character.randomFeatureStart.randomwilds": a.setRandomFeatureStartWilds,
			"request:character.randomFeatureStart.symboltransform": a.setRandomFeatureStartTransform,
			"notify:stateHandler.enteringDestroyState": a.setRandomFeatureStartDestroy,
			"notify:stateHandler.enteringSymbolOverlayState": a.setRandomFeatureStartOverlay,
			"view:animationComplete": a.animationComplete,
			"request:character.hide": a.hide,
			"request:character.show": a.show,
			"notify:winPresentation.showWinEffect": a.setWin,
			"request:character.setProgressiveIdle": a.setWin,
			"notify:quickStopper.quickStop": a.abort,
			"notify:stateHandler.enteringBeforeLoaderCloseState": a.show,
			"notify:stateHandler.enteringSpinningState": a.resetIdleOnNewMainGameRound,
			"notify:stateHandler.leavingRandomWildsState": a.setRandomFeatureEnd,
			"notify:stateHandler.leavingDestroyState": a.setRandomFeatureEnd,
			"notify:stateHandler.leavingSymbolOverlayState": a.setRandomFeatureEnd,
			"notify:stateHandler.leavingSymbolTransformState": a.setRandomFeatureEnd,
			"request:character.fadeBackAfterFreespin": a.fadeBackAfterFreespin,
			"view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play")
		})
	},
	fadeBackAfterFreespin: function() {
		var a = this;
		a.model.storeData("currentAnimation", "");
		a.model.storeData("isBigWin", false);
		a.model.storeData("stillBigWin", false);
		a.model.storeData("gameOver", true);
		a.model.setState("idle");
		a.view.show();
		a.view.setRandomFeatureEnd()
	},
	hide: function() {
		var a = this;
		a.view.hide()
	},
	show: function() {
		var b = this,
			c = b.model.readData("inMainGame"),
			a = b.model.readData("gameOver");
		if (c || a) {
			b.resetIdleOnNewMainGameRound();
			b.view.show()
		}
	},
	resetIdleOnNewMainGameRound: function() {
		var b = this,
			a = b.model.readData("newMainGameRound");
		if ((b.model.readData("currentAnimation") === "transIn" || b.model.readData("currentAnimation") === "default") && b.model.readData("gameOver")) {
			b.view.setCountUp("transOut");
			b.model.storeData("currentAnimation", "")
		} else {
			if (!b.model.isState("idle") && a && b.model.readData("gameOver")) {
				b.model.setState("idle");
				b.view.setIdle();
				b.model.storeData("currentAnimation", "")
			}
		}
	},
	setProgressiveIdle: function() {
		var b = this,
			c = b.model.readData("inMainGame"),
			a = b.model.readData("isBigWin");
		if (c && !b.model.isState("animating")) {
			if (!b.model.isState("bigWinIdle") && a) {
				b.model.setState("bigWinIdle");
				b.view.setBigWinIdle()
			} else {
				if (!b.model.isState("idle") && !a) {
					b.model.setState("idle");
					b.view.setIdle()
				}
			}
		} else {
			if (b.model.readData("gameState") === "bonus") {
				if (b.model.readData("stillBigWin")) {
					b.view.setBigWinIdle()
				} else {
					b.view.setIdle()
				}
			}
		}
	},
	setWin: function(a) {
		var b = this,
			c = b.model.readData("inMainGame");
		a = b.model.readData("winType");
		if (Sys.isDefined(a) && c) {
			b.view.setCountUp(a)
		}
		b.model.storeData("currentAnimation", a)
	},
	setRandomFeatureStart: function(a) {
		var b = this,
			c = b.model.readData("inMainGame");
		if (c) {
			b.model.setOngoingRandomFeature(true);
			b.model.setState("animating");
			b.view.setRandomFeatureStart(a)
		}
	},
	setRandomFeatureStartDestroy: function() {
		var a = this;
		a.setRandomFeatureStart("randomFeatureStart1")
	},
	setRandomFeatureStartWilds: function() {
		var a = this;
		a.setRandomFeatureStart("randomFeatureStart")
	},
	setRandomFeatureStartOverlay: function() {
		var a = this;
		a.setRandomFeatureStart("randomFeatureStart2")
	},
	setRandomFeatureStartTransform: function() {
		var a = this;
		a.setRandomFeatureStart("randomFeatureStart3")
	},
	setRandomFeatureEnd: function() {
		var a = this,
			b = a.model.readData("inMainGame");
		if (b) {
			a.model.setState("animating");
			a.view.setRandomFeatureEnd();
			a.model.setOngoingRandomFeature(false)
		}
	},
	animationComplete: function() {
		var a = this;
		a.model.setState("animationComplete");
		if (!a.model.getOngoingRandomFeature()) {
			if (a.model.readData("currentAnimation") === "transIn") {
				a.model.storeData("isBigWin", true);
				a.model.storeData("winType", "default")
			}
			a.setProgressiveIdle()
		} else {
			a.view.disintegrate()
		}
	},
	abort: function() {
		var a = this;
		if (a.model.getOngoingRandomFeature()) {
			a.model.setState("animationComplete");
			a.model.setOngoingRandomFeature(false);
			a.setProgressiveIdle()
		} else {
			if (a.model.readData("currentAnimation") === "transIn" || a.model.readData("currentAnimation") === "default") {
				a.model.storeData("isBigWin", true);
				a.model.storeData("winType", "default")
			}
		}
	}
};
Finn.CharacterController = Sys.extend(Core.Controller, Finn.CharacterController, "Finn.CharacterController");
Sys.ns("Finn");
Finn.CharacterView = {
	TWINKLE_ANIMATIONS: {
		randomFeatureStart: "twinkleMagicReelsRandom",
		randomFeatureStart1: "twinkleMagicReelsDestroy",
		randomFeatureStart2: "twinkleMagicReelsDrunkenLuck",
		randomFeatureStart3: "twinkleMagicReelsTransform"
	},
	TWINKLE_REEL_ANIMATIONS: {
		randomFeatureStart: "twinkleMagicReelsRandom",
		randomFeatureStart1: "twinkleMagicReelsDestroy",
		randomFeatureStart2: "twinkleMagicReelsDrunken",
		randomFeatureStart3: "twinkleMagicReelsMagicTransform"
	},
	CHARACTER_ANIMATIONS: {
		source: "character",
		position: new PIXI.Point(140, 630),
		animations: {
			idle: "Idle",
			transIn1: "BigWinTrans",
			transIn2: "BigWinTrans",
			transOut1: "BigWinTrans2",
			transOut2: "BigWinTrans2",
			default1: "DefaultWin",
			default2: "DefaultWin",
			smallWin1: "SmallWinv1",
			smallWin2: "SmallWinv2",
			mediumWin1: "MediumWin",
			mediumWin2: "MediumWin",
			largeWin1: "LargeWinv1",
			largeWin2: "LargeWinv2",
			bigWin1: "LargeWinv1",
			bigWin2: "LargeWinv2",
			bigWinIdle: "BigWinLoop",
			randomFeatureStart: "RandomFeature",
			randomFeatureEnd: "MediumWin"
		}
	},
	constructor: function() {
		Finn.CharacterView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.name = "CharacterView";
		b.rootContainer.visible = true;
		b.initCharacter();
		var a = Game.stage.view.animationManager.getLayer("character");
		a.addChild(b.rootContainer);
		b.twinkleAnimation = b.createTwinkleSpine();
		b.smallTwinkleAnimation = b.createSmallTwinkleSpine();
		b.disintegrateAnimation = b.createDisintegrateSpine();
		b.smallTwinkleAnimation.updateTransform();
		b.fadeInAnimation = b.createFadeInAnimation(b.characterAnimation)
	},
	createDisintegrateSpine: function() {
		var b = this,
			c = Game.PIXIFactory.createAndAddSpineAnimation("disintegrate", b.rootContainer),
			a = function() {
				c.visible = false;
				Game.PIXIUtils.resetSpineAnimation(c)
			};
		c.position.y = 0;
		c.position.x = 0;
		c.fire = function(d) {
			Finn.AnimationUtils.initialize(c, d).onAnimationEnd(b, a)
		};
		c.visible = false;
		return c
	},
	createTwinkleSpine: function() {
		var d = this,
			b = Game.stage.view.animationManager.getLayer("winSymbols"),
			a = Game.PIXIFactory.createAndAddSpineAnimation("twinkle", b),
			c = function() {
				a.visible = false;
				Game.PIXIUtils.resetSpineAnimation(a)
			};
		a.fire = function(e) {
			Finn.AnimationUtils.initialize(a, e).onAnimationEnd(d, c);
			a.visible = true
		};
		return a
	},
	createSmallTwinkleSpine: function() {
		var c = this,
			a = Game.PIXIFactory.createAndAddSpineAnimation("smallTwinkle", c.rootContainer),
			b = function() {
				a.visible = false;
				Game.PIXIUtils.resetSpineAnimation(a)
			};
		a.position.y = 0;
		a.position.x = 0;
		a.fire = function(d) {
			Finn.AnimationUtils.initialize(a, d).onAnimationEnd(c, b)
		};
		return a
	},
	initCharacter: function() {
		var a = this;
		a.characterAnimation = a.createSpineAnimation(a.CHARACTER_ANIMATIONS, true);
		a.setLoopingAnimation(a.characterAnimation);
		a.characterAnimation.fire(a.CHARACTER_ANIMATIONS.animations.idle);
		a.characterAnimation.alpha = 0
	},
	createSpineAnimation: function(b) {
		var a = this,
			c;
		c = Game.PIXIFactory.createAndAddSpineAnimation(b.source, a.rootContainer);
		c.visible = false;
		c.position = b.position;
		return c
	},
	setLoopingAnimation: function(a) {
		a.fire = function(b) {
			a.state.setAnimation(0, b, true);
			a.visible = true
		}
	},
	setNotLoopingAnimation: function(b) {
		var a = this;
		b.fire = function(c) {
			Finn.AnimationUtils.initialize(b, c).onAnimationEnd(a, a.onComplete)
		}
	},
	onComplete: function() {
		var a = this;
		a.fireEvent("view:animationComplete")
	},
	hide: function() {
		var a = this;
		a.stop();
		a.characterAnimation.fire(a.CHARACTER_ANIMATIONS.animations.idle)
	},
	show: function() {
		var a = this;
		a.characterAnimation.alpha = 1
	},
	setCharacterMode: function(c, a) {
		var b = this;
		if (a) {
			b.setLoopingAnimation(b.characterAnimation)
		} else {
			b.setNotLoopingAnimation(b.characterAnimation)
		}
		b.characterAnimation.fire(c);
		if ((c === "SmallWinv1" || c === "SmallWinv2") && Math.random() > 0.5) {
			c = "SmallWinv3"
		}
		b.fireEvent("view:playAudio", {
			id: "character" + c,
			name: "character" + c
		})
	},
	setIdle: function() {
		var a = this;
		Game.PIXIUtils.resetSpineAnimation(a.characterAnimation);
		a.setCharacterMode(a.CHARACTER_ANIMATIONS.animations.idle, true)
	},
	setBigWinIdle: function() {
		var a = this;
		a.setCharacterMode(a.CHARACTER_ANIMATIONS.animations.bigWinIdle, true)
	},
	setCountUp: function(a) {
		var d = this,
			c = Finn.AnimationUtils.randomIntFromInterval(1, 2),
			b = a + c;
		if (Sys.isDefined(d.CHARACTER_ANIMATIONS.animations[b])) {
			d.setCharacterMode(d.CHARACTER_ANIMATIONS.animations[b], false)
		}
	},
	setRandomFeatureStart: function(a) {
		var b = this;
		b.setCharacterMode(b.CHARACTER_ANIMATIONS.animations.randomFeatureStart, false);
		b.twinkleAnimation.fire(b.TWINKLE_REEL_ANIMATIONS[a]);
		b.smallTwinkleAnimation.fire(b.TWINKLE_ANIMATIONS[a])
	},
	setRandomFeatureEnd: function() {
		var a = this;
		a.setIdle();
		a.fadeInAnimation.play()
	},
	stop: function() {
		var a = this;
		a.characterAnimation.alpha = 0;
		Game.PIXIUtils.resetSpineAnimation(a.characterAnimation)
	},
	disintegrate: function() {
		var a = this;
		a.stop();
		a.disintegrateAnimation.fire("animation")
	},
	createFadeInAnimation: function(c) {
		var a = {
			prop: "alpha",
			animate: {
				0: 0,
				625: 1
			}
		};
		var b = new Animation.Holder({
			id: "full",
			target: c,
			delay: 0,
			onEnd: function() {},
			children: [a]
		});
		Game.stage.view.animationManager.addToAnimationLoop(b);
		return b
	}
};
Finn.CharacterView = Sys.extend(Core.View, Finn.CharacterView, "Finn.CharacterView");
Sys.ns("Finn");
Finn.CharacterViewLow = {
	CHARACTER_IMAGES: {
		idle: {
			image: "characterIdle",
			position: new PIXI.Point(20, 350)
		},
		smallWin: {
			image: "characterSmallWinCountUp",
			position: new PIXI.Point(20, 365)
		},
		mediumWin: {
			image: "characterMediumWinCountUp",
			position: new PIXI.Point(10, 350)
		},
		largeWin: {
			image: "characterLargeWinCountUp",
			position: new PIXI.Point(0, 310)
		},
		bigWin: {
			image: "characterBigWinCountUp",
			position: new PIXI.Point(0, 150)
		},
		bigWinIdle: {
			image: "characterBigWinIdle",
			position: new PIXI.Point(0, 150)
		}
	},
	constructor: function() {
		Finn.CharacterView.superclass.constructor.apply(this, arguments)
	},
	initCharacter: function() {
		var a = this;
		a.characterSprite = Game.PIXIFactory.createAndAddSprite(a.CHARACTER_IMAGES.idle.image, a.rootContainer, a.CHARACTER_IMAGES.idle.position, new PIXI.Point(0, 0))
	},
	hide: function() {
		var a = this;
		a.rootContainer.visible = false
	},
	show: function() {
		var a = this;
		a.rootContainer.visible = true
	},
	setCharacterImage: function(a) {
		var b = this;
		b.characterSprite.texture = Resources.readData("animationImages")[a.image];
		b.characterSprite.position = a.position
	},
	setIdle: function() {
		var a = this;
		a.setCharacterImage(a.CHARACTER_IMAGES.idle)
	},
	setBigWinIdle: function() {
		var a = this;
		a.setCharacterImage(a.CHARACTER_IMAGES.bigWinIdle)
	},
	setCountUp: function(a) {
		var b = this;
		b.setCharacterImage(b.CHARACTER_IMAGES[a]);
		setTimeout(function() {
			b.fireEvent("view:animationComplete")
		}, 1000)
	},
	setRandomFeatureStart: function() {
		var a = this;
		a.characterSprite.visible = false;
		a.fireEvent("view:playAudio", {
			id: "characterRandomFeature",
			name: "characterRandomFeature"
		})
	},
	setRandomFeatureEnd: function() {
		var a = this;
		a.characterSprite.visible = true
	},
	stop: function() {
		var a = this;
		a.show()
	}
};
Finn.CharacterViewLow = Sys.extend(Finn.CharacterView, Finn.CharacterViewLow, "Finn.CharacterViewLow");
Sys.ns("Finn");
Finn.CharacterModel = {
	constructor: function() {
		var a = this;
		Finn.CharacterModel.superclass.constructor.apply(this, arguments);
		a.winTypes = Resources.readData("config").winTypes
	},
	setupData: function() {
		var a = this;
		a.ongoingRandomFeature = false;
		a.storeData("inMainGame", true)
	},
	processServerResponse: function(g) {
		var h = this,
			f = !Sys.isDefined(g.freespin),
			c = g.nextaction === "spin",
			j = g.gameover,
			e, d, b = g.gamestate.current,
			a = Services.moneyManager.getBetCoins();
		if (g.wins) {
			d = g.wins.winType;
			e = d === "bigWin" || d === "megaWin" || d === "superMegaWin";
			if (g.wins.coins) {
				var k = g.wins.coins;
				if (k >= a * h.winTypes.largeWin.from) {
					d = "largeWin"
				} else {
					if (k >= a * h.winTypes.mediumWin.from) {
						d = "mediumWin"
					} else {
						d = "smallWin"
					}
				}
			}
			if (!e) {
				h.storeData("isBigWin", false)
			}
			if (e && !h.readData("isBigWin")) {
				d = "transIn"
			} else {
				if (e) {
					d = "default"
				}
			}
		}
		if (f) {
			h.storeData("winType", d)
		}
		h.storeData("stillBigWin", g.totalwin.coins >= a * h.winTypes.bigWin.from);
		h.storeData("gameState", b);
		h.storeData("inMainGame", f);
		h.storeData("gameOver", j);
		h.storeData("newMainGameRound", c)
	},
	setOngoingRandomFeature: function(b) {
		var a = this;
		a.ongoingRandomFeature = b
	},
	getOngoingRandomFeature: function() {
		var a = this;
		return a.ongoingRandomFeature
	}
};
Finn.CharacterModel = Sys.extend(Core.Model, Finn.CharacterModel, "Finn.CharacterModel");
Sys.ns("Finn");
Finn.CoinsFieldController = {
	TOGGLE_SEQUENCE: [{
		action: "showBalanceAndBet",
		displayDuration: 3000
	}],
	constructor: function() {
		Finn.CoinsFieldController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		Finn.CoinsFieldController.superclass.setupEvents.apply(this, arguments);
		var a = this;
		a.on({
			"notify:responseParser.bonusActionResponseParsed": a.onBonusActionResponseParsed,
			"request:coinsField.showWin": a.onShowWinRequest,
			"request:coinsField.showFreeSpinsLeft": a.showFreeSpinsLeft,
			"request:coinsField.hide": a.view.hideCoinsField,
			"request:coinsField.show": a.view.showCoinsField
		})
	},
	onBonusActionResponseParsed: function(b) {
		var a = this;
		a.model.processServerResponse(b);
		a.showFreeSpinsLeft()
	},
	onShowWinRequest: function() {
		this.showBalanceAndBet();
		Finn.CoinsFieldController.superclass.onShowWinRequest.apply(this, arguments)
	}
};
Finn.CoinsFieldController = Sys.extend(Interface.Slots.CoinsFieldController, Finn.CoinsFieldController, "Finn.CoinsFieldController");
Sys.ns("Core");
Core.FullscreenViewIOS = {
	init: function(b) {
		var c = this,
			a;
		c._device = Resources.readData("screenSpecification");
		c.isIphone6PlusStandardMode = c._device && c._device[7] === "iPhone 6+";
		c.setupScrollOverlay();
		c.model = b.model;
		c.model.storeData("overlayVisible", false);
		if (c.isIphone6PlusStandardMode) {
			window.addEventListener("scroll", c.toggleOverlay.bind(c), false)
		}
		if (Sys.isGcmEnabled) {
			a = document.querySelector("iframe[name='commonUIIFrame']");
			if (a !== null) {
				a.style.position = "fixed"
			}
		}
	},
	toggleOverlay: function() {
		document.documentElement.style.paddingBottom = "79px";
		if (Services.orientation.isLandscape() && this.isIphone6PlusStandardMode) {
			document.documentElement.style.paddingBottom = ""
		}
		if (this.isFullscreen()) {
			this.removeOverlay()
		} else {
			this.showOverlay()
		}
	},
	onUserInputEnded: function() {
		this.toggleOverlay();
		if (!this.isFullscreen()) {
			this.resetGamePosition()
		}
	},
	onOrientationChange: function() {
		this.toggleOverlay();
		if (!this.isFullscreen()) {
			this.resetGamePosition()
		}
	},
	onViewportScaled: function() {
		this.toggleOverlay()
	},
	showOverlay: function() {
		if (!this.model.readData("overlayVisible")) {
			this.fireEvent("view:allowPropagation");
			this.scrollOverlay.style.display = "block";
			this.animationContainer.style.visibility = "visible";
			this.model.storeData("overlayVisible", true)
		}
	},
	resetGamePosition: function() {
		window.clearTimeout(this.removeOverlayTimeout);
		this.removeOverlayTimeout = window.setTimeout(function() {
			window.scrollTo(0, 0);
			document.getElementById("scrollup").scrollTo(0, 0)
		}, 300)
	},
	removeOverlay: function() {
		this.resetGamePosition();
		if (this.model.readData("overlayVisible")) {
			this.fireEvent("view:disallowPropagation");
			this.scrollOverlay.style.display = "none";
			this.animationContainer.style.visibility = "hidden";
			this.model.storeData("overlayVisible", false);
			if (Services.orientation.isLandscape() && !Sys.isIphone5Or5sOr5c) {
				document.documentElement.style.paddingBottom = ""
			}
		}
	},
	isFullscreen: function() {
		var a = Environment.getRealScreenSize();
		return a.height === window.innerHeight || window.innerHeight / a.height >= 0.9
	},
	setupScrollOverlay: function() {
		this.scrollOverlay = document.createElement("div");
		this.scrollOverlay.className = "scrollup";
		this.scrollOverlay.setAttribute("id", "scrollup");
		this.scrollOverlay.style.height = "1000000px";
		this.scrollOverlay.style.display = "none";
		this.animationContainer = document.createElement("div");
		if (this.isIphone6PlusStandardMode && Services.orientation.isLandscape()) {
			this.animationContainer.style.position = "absolute"
		}
		this.animationContainer.className = "scrollAnimationContainer iOS_scrollup_uri";
		this.animationContainer.style.visibility = "hidden";
		document.body.appendChild(this.animationContainer);
		document.body.appendChild(this.scrollOverlay)
	}
};
Core.FullscreenViewIOS = Sys.extend(Core.FullscreenView, Core.FullscreenViewIOS, "Core.FullscreenViewIOS");
Sys.override(Core.CountUpView, {
	refresh: function() {}
});
Sys.override(Game.StageView, {
	setupAnimationManager: function() {
		var b = this,
			a = Environment.getResolution();
		b.animationManager = new Animation.PixiAnimationManager({
			parent: document.getElementById("gameElements"),
			images: b.model.readData("images"),
			sprites: b.model.readData("sprites"),
			top: "0px",
			left: "0px",
			height: a.height,
			width: a.width,
			scenes: b.model.readData("scenes"),
			layers: b.model.readData("layers"),
			layeredLayers: b.model.readData("layeredLayers")
		})
	},
	getOrientationSpecificImage: function(c) {
		var b = Environment.getViewportOrientation(),
			a = c + "_" + b.toLowerCase(),
			d = this.animationManager.images[a];
		if (Environment.allowsCustomCanvasSize() && Sys.isDefined(d)) {
			return a
		}
		return c
	}
});
Sys.override(Game.StageModel, {
	setupData: function() {
		var b = this,
			a = Resources.readData("config");
		b.storeData("images", Resources.readData("images"));
		b.storeData("sprites", a.sprites);
		b.storeData("reelConfig", a.reel);
		b.storeData("reelGroups", a.reelGroups);
		b.storeData("scenes", a.scenes);
		b.storeData("layers", a.layers);
		b.storeData("layeredLayers", a.layeredLayers);
		b.switchScenes("base")
	}
});
Sys.ns("Finn");
Finn.TrenchMasker = {
	TRENCH_X_OFFSET: 311,
	TRENCH_Y_OFFSET: 0,
	SYMBOL_HEIGHT: 128,
	SYMBOL_WIDTH: 128,
	constructor: function(a, c) {
		var b = this;
		Sys.Observable.prototype.constructor.apply(this, arguments);
		b.trenchConfig = Resources.readData("config").trench;
		b.initTrench(a, c);
		b.trenchTypeString = c;
		b.trenchSparkle = Finn.trenchSparkle.addToTrench(b);
		b.fadeOutAnimation = new Animation.Holder({
			target: b.trenchFillAnimation,
			onEnd: function() {
				b.clear();
				b.trenchFillAnimation.alpha = 1
			},
			animate: {
				0: {
					alpha: 1
				},
				750: {
					alpha: 0
				}
			}
		});
		Game.stage.view.animationManager.addToAnimationLoop(b.fadeOutAnimation)
	},
	setCallback: function(b) {
		var a = this;
		a.callback = b
	},
	setSpeed: function(b) {
		var a = this;
		a.animationSpeed = b
	},
	setTint: function(b) {
		var a = this;
		a.trenchFillAnimation.tint = b
	},
	clear: function() {
		var a = this;
		a.trenchAnimation.stop();
		a.reelMaskGraphics.clear();
		a.trenchContainer.visible = false;
		a.trenchSparkle.clear()
	},
	fadeOut: function() {
		var a = this;
		a.fadeOutAnimation.play()
	},
	start: function(d, c, a) {
		var b = this;
		b.animatedPositions = d;
		b.goToPosition = c;
		b.trenchAnimation.delay = a;
		b.trenchAnimation.play()
	},
	initTrench: function(a, c) {
		var b = this;
		b.trenchContainer = new PIXI.Container();
		b.trenchContainer.visible = false;
		a.addChild(b.trenchContainer);
		b.addTrenchFillAnimation(c);
		b.dummy = Game.PIXIFactory.createAndAddSprite("dummy", b.trenchContainer, new PIXI.Point(0, 0), new PIXI.Point(0, 0));
		b.trenchAnimation = new Animation.Holder({
			id: "dummy",
			target: b.dummy,
			loop: true,
			prop: "position",
			addToAnimationLoop: true,
			onStart: function() {
				b.dummy.position.x = 0;
				b.previous = 0;
				b.drawn = 0;
				b.cleared = false;
				b.trenchAnimation.animation.keyFrames[1].time = b.animationSpeed
			},
			onUpdate: function() {
				if (!b.cleared) {
					b.reelMaskGraphics.clear();
					b.cleared = true
				}
				b.current = Math.round(b.dummy.position.x);
				if (b.current < b.previous) {
					b.drawOneTrenchSegment(b.animatedPositions, b.previous);
					b.animatedPositions++
				} else {
					b.drawOneTrenchSegment(b.animatedPositions, b.previous)
				}
				for (var d = b.drawn; d < b.animatedPositions; d++) {
					b.drawOneTrenchSegment(d, 100)
				}
				b.drawn = b.animatedPositions;
				if (b.animatedPositions > b.goToPosition) {
					b.animatedPositions++;
					b.trenchAnimation.stop()
				} else {
					b.drawOneTrenchSegment(b.animatedPositions, b.current);
					b.previous = b.current
				}
			},
			onEnd: function() {
				if (b.callback) {
					b.callback()
				}
			},
			animate: {
				0: {
					x: 0,
					y: 0
				},
				500: {
					x: 100,
					y: 100
				}
			}
		});
		b.reelMaskGraphics = new PIXI.Graphics();
		b.trenchContainer.addChild(b.reelMaskGraphics);
		b.trenchContainer.mask = b.reelMaskGraphics
	},
	addTrenchFillAnimation: function(b) {
		var a = this;
		a.trenchFillAnimation = Game.PIXIFactory.createAndAddSpineAnimation("trenchFill", a.trenchContainer);
		a.trenchFillAnimation.position = new PIXI.Point(0, 0);
		a.trenchFillAnimation.fire = function() {
			a.trenchFillAnimation.state.setAnimation(0, b, true);
			a.trenchFillAnimation.visible = true;
			a.trenchFillAnimation.updateTransform()
		};
		a.trenchFillAnimation.fire()
	},
	drawOneTrenchSegment: function(c, b) {
		var e = this,
			d = e.trenchConfig[c].type,
			h = e.trenchConfig[c].fromArc * Math.PI,
			a = e.trenchConfig[c].toArc * Math.PI,
			g = (100 - b) / 100,
			f;
		f = e.getTrenchPosition(e.trenchConfig[c], g);
		f.atSymbolNumber = c;
		e.trenchSparkle.doUpdate(c - 1, c, b / 100, e.trenchTypeString);
		if (c >= e.trenchConfig.length) {
			return
		}
		e.trenchContainer.visible = true;
		e.reelMaskGraphics.beginFill(16711680, 0.5);
		if (e.trenchConfig[c].type === "RECT") {
			e.drawOneTrenchRectSegment(e.trenchConfig[c], e.SYMBOL_WIDTH, e.SYMBOL_HEIGHT, g)
		} else {
			if (d === "ARC") {
				e.drawOneTrenchArcSegment(e.trenchConfig[c], h, a, g)
			}
		}
		e.reelMaskGraphics.endFill()
	},
	getTrenchPosition: function(a, e) {
		var d = this,
			b = a.animateX * (d.SYMBOL_WIDTH - (d.SYMBOL_WIDTH * (1 - e))),
			g = a.animateY * (d.SYMBOL_HEIGHT - (d.SYMBOL_HEIGHT * (1 - e))),
			f = a.x * d.SYMBOL_WIDTH + d.TRENCH_X_OFFSET + b,
			c = a.y * d.SYMBOL_HEIGHT + d.TRENCH_Y_OFFSET + g;
		return {
			x: f,
			y: c,
			trenchWidth: d.SYMBOL_WIDTH
		}
	},
	drawOneTrenchRectSegment: function(b, c, a, d) {
		var e = this.getTrenchPosition(b, d);
		this.reelMaskGraphics.drawRect(e.x, e.y, c - (b.animateW * c * d), a - (b.animateH * a * d))
	},
	drawOneTrenchArcSegment: function(b, e, a, d) {
		var c = this;
		c.reelMaskGraphics.moveTo(b.x * c.SYMBOL_WIDTH + c.TRENCH_X_OFFSET, b.y * c.SYMBOL_HEIGHT);
		c.reelMaskGraphics.arc(b.x * c.SYMBOL_WIDTH + c.TRENCH_X_OFFSET, b.y * c.SYMBOL_HEIGHT, c.SYMBOL_WIDTH, e, a - (a - e) * d);
		c.reelMaskGraphics.lineTo(b.x * c.SYMBOL_WIDTH + c.TRENCH_X_OFFSET, b.y * c.SYMBOL_HEIGHT)
	},
	quickDrawTrench: function() {
		var b = this;
		b.trenchAnimation.stop();
		b.reelMaskGraphics.clear();
		for (var a = 0; a < b.goToPosition + 1; a++) {
			b.drawOneTrenchSegment(a, 100)
		}
	}
};
Finn.TrenchMasker = Sys.extend(Sys.Observable, Finn.TrenchMasker, "Finn.TrenchMasker");
(function() {
	Sys.ns("Finn");
	var g = {
			"-1": {
				x: 440,
				y: 704
			},
			"0": {
				x: 440,
				y: 576
			},
			"1": {
				x: 435,
				y: 448
			},
			"2": {
				x: 437,
				y: 320
			},
			"3": {
				x: 436,
				y: 192
			},
			"4": {
				x: 441,
				y: 131
			},
			"5": {
				x: 495,
				y: 110
			},
			"6": {
				x: 631,
				y: 121.6
			},
			"7": {
				x: 753,
				y: 116
			},
			"8": {
				x: 820,
				y: 125
			},
			"9": {
				x: 823,
				y: 192
			},
			"10": {
				x: 816.6,
				y: 313.6
			},
			"11": {
				x: 823,
				y: 448
			},
			"12": {
				x: 814,
				y: 504
			},
			"13": {
				x: 757,
				y: 512
			},
			"14": {
				x: 631,
				y: 512
			},
			"15": {
				x: 564,
				y: 512
			},
			"16": {
				x: 567,
				y: 448
			},
			"17": {
				x: 565,
				y: 320
			},
			"18": {
				x: 560.6,
				y: 249.6
			},
			"19": {
				x: 624.6,
				y: 246.39999999999998
			},
			"20": {
				x: 688,
				y: 252
			},
			"21": {
				x: 688.6,
				y: 320
			},
			"22": {
				x: 688,
				y: 380
			},
			"23": {
				x: 688,
				y: 380
			},
			"24": {
				x: 688,
				y: 380
			}
		},
		a = function() {
			this.animation.position.x = 0;
			this.animation.position.y = 0;
			this.animation.visible = false
		},
		c = function(k) {
			var h = k.replace("trench", "sparkle").replace("_Game", ""),
				j = h.match(/_[A-Z]/) ? h.match(/_[A-Z]/)[0] : null;
			if (j) {
				h = h.replace(j, j.toLowerCase())
			}
			return h
		},
		f = function(h) {
			this.state.setAnimation(0, c(h), true)
		},
		b = function(o, n, l) {
			var k = g[o],
				m = g[n],
				j = k.x + (m.x - k.x) * (l),
				h = k.y + (m.y - k.y) * (l);
			return {
				x: j,
				y: h
			}
		},
		e = function(m, l, h) {
			var k = b(m, l, h),
				j = l >= 22 && h >= 1;
			this.animation.visible = (!j);
			this.animation.position = k
		},
		d = function() {
			if (this.animation.visible) {
				if (this.opacityIsDimming) {
					this.animation.alpha -= Finn.trenchSparkle.OPACITY_CHANGE_SPEED
				} else {
					this.animation.alpha += Finn.trenchSparkle.OPACITY_CHANGE_SPEED
				}
				if (this.animation.alpha <= Finn.trenchSparkle.OPACITY_MIN) {
					this.opacityIsDimming = false
				} else {
					if (this.animation.alpha >= Finn.trenchSparkle.OPACITY_MAX) {
						this.opacityIsDimming = true
					}
				}
			}
		};
	Finn.trenchSparkle = {
		addToTrench: function(j) {
			var h = j.trenchContainer.parent,
				l = this.SPARKLE_CONFIG_NAME,
				k = {
					container: h,
					animation: Game.PIXIFactory.createAndAddSpineAnimation(l, h),
					sparkleMoveSpeed: Finn.trenchSparkle.DEFAULT_SPARKLE_SPEED,
					opacityIsDimming: true,
					trenchTypeString: j.trenchTypeString,
					clear: a,
					doUpdate: function(p, o, n, m) {
						e.call(this, p, o, n, m)
					}
				};
			k.animation.pivot.x = (0.5 * k.animation.width);
			k.animation.pivot.y = (0.5 * k.animation.height);
			k.animation.position.x = 0;
			k.animation.position.y = 0;
			k.animation.visible = false;
			k.animation.alpha = this.OPACITY_MAX;
			f.call(k.animation, k.trenchTypeString);
			PIXI.ticker.shared.add(d, k);
			return k
		}
	};
	Object.defineProperty(Finn.trenchSparkle, "SPARKLE_CONFIG_NAME", {
		value: "trenchSparkle",
		writable: false
	});
	Object.defineProperty(Finn.trenchSparkle, "OPACITY_CHANGE_SPEED", {
		value: 0.001,
		writable: false
	});
	Object.defineProperty(Finn.trenchSparkle, "OPACITY_MAX", {
		value: Platform.isIEBrowser ? 1 : 0.7,
		writable: false
	});
	Object.defineProperty(Finn.trenchSparkle, "OPACITY_MIN", {
		value: Platform.isIEBrowser ? 0.8 : 0.55,
		writable: false
	})
}());
Sys.ns("Finn");
(function() {
	var a = 0;
	Finn.AnimationUtils = {
		setTime: function(b, c, d) {
			if (!Sys.isDefined(d)) {
				d = 0
			}
			b.state.tracks[d].trackTime = (c / 1000);
			b.state.update(d)
		},
		getDuration: function(c, b) {
			var d = 0;
			Sys.each(c.skeleton.data.animations, function(e) {
				if (e.name === b) {
					d = e.duration
				}
			});
			return d * 1000
		},
		initialize: function(e, c, d, b) {
			var f = e.state;
			b = b ? b : 0;
			c = c ? c : "unnamed-animation-no-" + (++a);
			d = d !== undefined ? d : false;
			e.state.setAnimation(b, c, d);
			e.visible = true;
			return {
				onAnimationEnd: function() {
					var j = Array.prototype.shift.call(arguments),
						g = Array.prototype.shift.call(arguments),
						k = arguments,
						h = function() {
							f.clearListeners();
							g.apply(j, k)
						};
					f.addListener({
						complete: h
					});
					if (!j instanceof Object) {
						throw "- The first argument supplied to .onAnimationEnd() should be an Object that represents the calling context for the callback function."
					}
					if (!g instanceof Function) {
						throw "- The second argument supplied to .onAnimationEnd() should be a Function that represents the callback function to call once the animation is complete."
					}
				}
			}
		},
		setCurrentTime: function(c, b) {
			var e, d;
			e = this.getDuration(c, b);
			d = new Date().getTime() % (e);
			this.setTime(c, d)
		},
		randomIntFromInterval: function(c, b) {
			return Math.floor(Math.random() * (b - c + 1) + c)
		}
	}
}());
Sys.ns("Finn");
Finn.Randomizer = {
	constructor: function() {
		var a = this;
		Sys.Observable.prototype.constructor.apply(this, arguments);
		a.initial = [];
		a.left = []
	},
	initiate: function(b) {
		var a = this;
		a.initial = Sys.clone(b);
		a.left = Sys.clone(b)
	},
	draw: function() {
		var a = this;
		if (!a.left.length) {
			a.left = Sys.clone(a.initial)
		}
		return a.left.splice(Math.floor((Math.random() * (a.left.length - 1))), 1)[0]
	}
};
Finn.Randomizer = Sys.extend(Sys.Observable, Finn.Randomizer, "Finn.Randomizer");
Sys.ns("Finn");
Finn.BlackLayer = {
	constructor: function() {
		Finn.BlackLayer.superclass.constructor.apply(this, arguments)
	},
	getMixinDependencies: function() {
		return ["animation"]
	}
};
Finn.BlackLayer = Sys.extend(Core.Module, Finn.BlackLayer, "Finn.BlackLayer");
Sys.ns("Finn");
Finn.BlackLayerController = {
	constructor: function() {
		Finn.BlackLayerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:settingsMenu.open": a.onSettingsMenuOpened,
			"notify:settingsMenu.closed": a.onSettingsMenuClosed
		})
	},
	onSettingsMenuOpened: function() {
		this.view.show()
	},
	onSettingsMenuClosed: function() {
		this.view.hide()
	}
};
Finn.BlackLayerController = Sys.extend(Core.Controller, Finn.BlackLayerController, "Finn.BlackLayerController");
Sys.ns("Finn");
Finn.BlackLayerView = {
	constructor: function() {
		Finn.BlackLayerView.superclass.constructor.apply(this, arguments)
	},
	initAnimations: function() {
		var b = this;
		b.rootContainer = new PIXI.Container();
		b.rootContainer.name = "BlackLayer";
		b.rectGraphics = new PIXI.Graphics();
		b.rootContainer.addChild(b.rectGraphics);
		b.rectGraphics.beginFill(1250067, 1);
		b.rectGraphics.drawRect(0, 0, 1280, 1280);
		b.rectGraphics.endFill();
		var a = Game.stage.view.animationManager.getLayer("blackLayer");
		a.addChild(b.rootContainer);
		b.rootContainer.visible = false
	},
	show: function() {
		var a = this;
		a.rootContainer.visible = true
	},
	hide: function() {
		var a = this;
		a.rootContainer.visible = false
	}
};
Finn.BlackLayerView = Sys.extend(Core.View, Finn.BlackLayerView, "Finn.BlackLayerView");
Sys.ns("Finn");
Finn.AudioPlayer = {
	constructor: function() {
		Finn.AudioPlayer.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		if (Platform.hasWebAudioContext) {
			return {
				model: Core.Audio.AudioPlayerModel,
				view: Finn.AudioPlayerView,
				controller: Finn.AudioPlayerController
			}
		} else {
			return {
				model: Core.Audio.AudioPlayerModel,
				view: Core.Audio.Legacy.LegacyAudioPlayerView,
				controller: Core.Audio.AudioPlayerController
			}
		}
	}
};
Finn.AudioPlayer = Sys.extend(Core.Audio.AudioPlayer, Finn.AudioPlayer, "Finn.AudioPlayer");
Sys.ns("Finn");
Finn.AudioPlayerController = {
	init: function() {
		var a = this;
		Core.Audio.AudioPlayerController.superclass.init.apply(a, arguments);
		a.soundsToLoadOnEnable = ["main", "additional", "freespin"];
		if (Sys.isDefined(Resources.readData("preloadedAudio"))) {
			a.model.storeData("hasPreloadedAudio", true);
			a.view.decodePreloadedAudio()
		} else {
			a.model.storeData("hasPreloadedAudio", false);
			window.setTimeout(function() {
				a.fireEvent("notify:audioPlayer.ready");
				a.fireEvent("canplaythrough");
			}, 0)
		}
	},
	play: function(c) {
		var b = this,
			a = {
				randomWildsShootOut01: "additional",
				randomWildsShootOut02: "additional",
				randomWildsShootOut03: "additional",
				randomWildsShootOut04: "additional",
				randomWildsShootOut05: "additional",
				randomWildsShootOut06: "additional",
				randomWildsShootOut07: "additional",
				randomWildsShootOut08: "additional",
				randomWildsShootOut09: "additional",
				randomWildsShootOut10: "additional",
				randomWildsShootOutFinal: "additional",
				randomWildsFallDown01: "additional",
				randomWildsFallDown02: "additional",
				randomWildsFallDown03: "additional",
				randomWildsFallDown04: "additional",
				randomWildsFallDown05: "additional",
				randomWildsFallDown06: "additional",
				randomWildsFallDown07: "additional",
				randomWildsFallDown08: "additional",
				randomWildsFallDown09: "additional",
				randomWildsFallDown10: "additional",
				randomWildsFallDownFinal: "additional",
				winAttention1: "additional",
				winAttention2: "additional",
				winAttention3: "additional",
				winAttention4: "additional",
				winAttention5: "additional",
				explosion1: "additional",
				explosion2: "additional",
				explosion3: "additional",
				explosion4: "additional",
				wildSpoiler: "additional",
				wildExplode: "additional",
				wildSpawn: "additional",
				returnToBase: "additional",
				starAmbience: "freespin",
				dragonAmbience: "freespin",
				luckyAmbience: "freespin",
				goldenAmbience: "freespin"
			};
		if (!Platform.isDesktopDevice && a[c.name]) {
			Sys.applyProperties(c, {
				buffer: a[c.name]
			})
		}
		if (!b.model.isState("audioEnabled") && Sys.isDefined(c) && Sys.isDefined(c.callback)) {
			c.callback();
			delete c.callback
		}
		b.view.play(c);
		b.fireEvent("notify:audioPlayer.playing", c)
	},
	handleLoadError: function(b, a) {}
};
Finn.AudioPlayerController = Sys.extend(Core.Audio.AudioPlayerController, Finn.AudioPlayerController, "Finn.AudioPlayerController");
Sys.ns("Finn");
Finn.AudioPlayerView = {
	constructor: function() {
		Finn.AudioPlayerView.superclass.constructor.apply(this, arguments)
	},
	checkAPICompability: function(a) {
		var h = this,
			b = h.model.readData("clips"),
			j = a,
			f, d, k = true;
		if (Sys.isDefined(b[a])) {
			var c = Object.keys(b[a]);
			j = c[c.length - 1];
			d = a
		}
		f = h.setUpSource({
			name: j,
			volume: 0,
			buffer: d
		});
		try {
			f.source.start(0, 0);
			f.source.stop(h.context.currentTime)
		} catch (g) {
			k = false
		}
		h.canPlayWithoutDuration = k
	},
	setUpSourceParams: function(f) {
		var j = this,
			a, e, h, k = 1,
			g, b, c, d;
		if (!Sys.isDefined(f.name)) {
			return undefined
		}
		a = Sys.isDefined(f.buffer) ? f.buffer : "main";
		e = j.model.readData("clips")[a][f.name];
		h = j.audioBuffers[a];
		if (!Sys.isDefined(e)) {
			return undefined
		}
		if (!Sys.isDefined(h)) {
			return undefined
		}
		if (!Sys.isAudioBuffer(h)) {
			if (Sys.isAudioBuffer(h[f.name])) {
				h = h[f.name]
			} else {
				return undefined
			}
		}
		if (Sys.isDefined(f.volume)) {
			k = f.volume
		} else {
			if (Sys.isDefined(e.volume)) {
				k = e.volume
			}
		}
		g = Sys.isDefined(e.start) ? e.start : 0;
		b = g;
		if (Sys.isDefined(f.offset)) {
			b += f.offset
		}
		c = h.duration - b;
		if (Sys.isDefined(f.duration)) {
			c = Math.min(c, f.duration)
		} else {
			if (Sys.isDefined(e.duration)) {
				c = Math.min(c, e.duration)
			}
		}
		d = {
			sourceBuffer: h,
			delay: Sys.isDefined(f.delay) ? f.delay : 0,
			start: b,
			duration: c,
			clipOffsetFromFileStart: g,
			gain: k,
			loop: f.loop === true,
			fadeIn: Sys.isDefined(f.fadeIn) ? f.fadeIn : false,
			fadeOut: Sys.isDefined(f.fadeOut) ? f.fadeOut : Sys.isDefined(e.fadeOut) ? e.fadeOut : false,
			filter: f.filter,
			ducking: e.duck
		};
		return d
	}
};
Finn.AudioPlayerView = Sys.extend(Core.Audio.AudioPlayerView, Finn.AudioPlayerView, "Finn.AudioPlayerView");
Sys.ns("Finn");
Finn.FreeRounds = {
	constructor: function() {
		Finn.FreeRounds.superclass.constructor.apply(this, arguments)
	},
	getStateChanges: function() {
		return {
			freeRoundsDialog: {
				state: {
					name: "FreeRoundsDialog",
					execute: function() {},
					waitEvents: {}
				}
			}
		}
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Slots.FreeRoundsModel,
			controller: Core.Slots.FreeRoundsController
		}
	}
};
Finn.FreeRounds = Sys.extend(Core.Slots.FreeRounds, Finn.FreeRounds, "Finn.FreeRounds");
Sys.override(Interface.SettingsMenuBaseView, {
	determineChildSize: function() {
		var c = this,
			e = c.childElements.getChildren(),
			d = e.length,
			a, b;
		if (d === 0) {
			return
		}
		b = Math.ceil(Math.ceil(e[0].getBoundingClientRect().width) * (1 / Environment.scale));
		a = b * d;
		if (c.totalChildWidth !== a) {
			c.childElements.el.style.width = a + "px"
		}
		c.totalChildWidth = a;
		c.childWidth = b
	}
});
Sys.ns("Finn");
Finn.SoundSettingsController = {
	constructor: function() {
		Finn.SoundSettingsController.superclass.constructor.apply(this, arguments)
	},
	onUserAction: function(a, b) {
		switch (a) {
			case "audioOn":
				Services.settingsManager.storeSetting("volume", b ? this.model.getPreviousVolume() : 0, true);
				break;
			case "volume":
				Services.settingsManager.storeSetting("volume", b, true);
				break;
			case "vibrationOn":
				Services.settingsManager.storeSetting("vibration", b, true);
				break;
			case "splashOn":
				Services.settingsManager.storeSetting("showFeatureSplash", b, true);
				break;
			default:
		}
	},
	onSettingChanged: function(a, b) {
		if (a === "volume") {
			this.view.update(b);
			if (b > 0) {
				this.model.storeData("previousVolume", b)
			}
		} else {
			if (a === "vibration") {
				this.view.updateVibration(b)
			} else {
				if (a === "showFeatureSplash") {
					this.view.updateSplash(b)
				}
			}
		}
	}
};
Finn.SoundSettingsController = Sys.extend(Interface.SoundSettingsController, Finn.SoundSettingsController, "Finn.SoundSettingsController");
Sys.ns("Finn");
Finn.SoundSettingsModel = {
	constructor: function() {
		Finn.SoundSettingsModel.superclass.constructor.apply(this, arguments)
	},
	setupData: function() {
		var a = this;
		a.initData({
			key: "volume",
			defaultValue: Platform.resourceBundle.preloadAudio ? 1 : 0,
			settingsManager: true,
			localStorage: Platform.resourceBundle.preloadAudio
		});
		a.initData({
			key: "vibration",
			defaultValue: false,
			settingsManager: true,
			localStorage: true
		});
		a.storeData("previousVolume", 1);
		a.initData({
			key: "showFeatureSplash",
			defaultValue: true,
			settingsManager: true,
			localStorage: true
		})
	}
};
Finn.SoundSettingsModel = Sys.extend(Interface.SoundSettingsModel, Finn.SoundSettingsModel, "Finn.SoundSettingsModel");
Sys.ns("Finn");
Finn.SoundSettingsBaseView = {
	constructor: function() {
		Finn.SoundSettingsBaseView.superclass.constructor.apply(this, arguments)
	},
	setUpContent: function() {
		var a = this;
		a.container = new Sys.Element({
			id: "userSettings",
			tag: "div",
			cls: a.BASE_CSS
		});
		a.audioOnOffContainer = a.container.add(new Sys.Element({
			id: "soundSettings_soundSettings",
			tag: "div",
			cls: a.SECTION_CSS
		}));
		a.audioOnOff = new Interface.utils.ToggleSwitch({
			id: "audioOnOff",
			title: Services.languageManager.getText(Language.Keys.setting_gameSound),
			callback: a.onSettingsControllerChanged.bind(a, "audioOn")
		});
		a.audioOnOffContainer.add(a.audioOnOff.getContainer());
		a.fireEvent("view:addToContainer", "settingsWindow", {
			title: Services.languageManager.getText(Language.Keys.gameSettingsPanelLabel),
			content: a.container
		});
		a.fireEvent("view:addToNavigator", "settingsMenu", {
			order: 1
		});
		a.subComponents = [a.audioOnOff];
		a.addSplashToggle();
		a.addScrolling();
		if (!a.model.readData("disabled")) {
			a.enable()
		}
		a.hide()
	},
	addVibrationToggle: function() {
		var a = this;
		a.vibrationOnOffContainer = a.container.add(new Sys.Element({
			id: "soundSettings_soundSettings",
			tag: "div",
			cls: a.SECTION_CSS
		}));
		a.vibrationOnOff = new Interface.utils.ToggleSwitch({
			id: "vibrationOnOff",
			title: Services.languageManager.getText(Language.Keys.setting_gameVibration),
			callback: a.onSettingsControllerChanged.bind(a, "vibrationOn")
		});
		a.vibrationOnOffContainer.add(a.vibrationOnOff.getContainer());
		a.subComponents.push(a.vibrationOnOff);
		a.vibrationOnOff.enable();
		a.updateVibration(Services.settingsManager.getSetting("vibration"));
		if (Services.settingsManager.getSetting("vibration")) {
			a.fireEvent("view:userAction", "vibrationOn", false);
			a.fireEvent("view:userAction", "vibrationOn", true)
		}
	},
	addSplashToggle: function() {
		var a = this;
		a.splashOnOffContainer = a.container.add(new Sys.Element({
			id: "soundSettings_soundSettings",
			tag: "div",
			cls: a.SECTION_CSS
		}));
		a.splashOnOff = new Interface.utils.ToggleSwitch({
			id: "splashOnOff",
			title: Services.languageManager.getText(Language.Keys.setting_introScreeGame),
			callback: a.onSettingsControllerChanged.bind(a, "splashOn")
		});
		a.splashOnOffContainer.add(a.splashOnOff.getContainer());
		a.subComponents.push(a.splashOnOff);
		a.splashOnOff.enable();
		a.updateSplash(Services.settingsManager.getSetting("showFeatureSplash"))
	},
	updateSplash: function(a) {
		this.splashOnOff.toggle(a)
	}
};
Finn.SoundSettingsBaseView = Sys.extend(Interface.SoundSettingsBaseView, Finn.SoundSettingsBaseView, "Finn.SoundSettingsBaseView");
Sys.ns("Finn");
Finn.BalanceDisplayBaseView = {
	constructor: function() {
		Finn.BalanceDisplayBaseView.superclass.constructor.apply(this, arguments)
	},
	addClass: function(a) {
		if (a !== "ticker") {
			this.container.addCls(a)
		}
	}
};
Finn.BalanceDisplayBaseView = Sys.extend(Interface.BalanceDisplayBaseView, Finn.BalanceDisplayBaseView, "Finn.BalanceDisplayBaseView");
Sys.ns("Finn");
Finn.BalanceDisplayMobileView = {
	constructor: function() {
		Finn.BalanceDisplayMobileView.superclass.constructor.apply(this, arguments)
	},
	addClass: function(a) {
		if (a !== "ticker") {
			this.container.addCls(a)
		}
	}
};
Finn.BalanceDisplayMobileView = Sys.extend(Interface.BalanceDisplayMobileView, Finn.BalanceDisplayMobileView, "Finn.BalanceDisplayMobileView");
Sys.ns("Finn");
Finn.TickerController = {
	constructor: function() {
		Finn.TickerController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		Finn.TickerController.superclass.setupEvents.apply(this, arguments);
		a.on({
			"notify:stateHandler.enteringIdleState": a.enableReady,
			"notify:stateHandler.enteringFreeSpinMapState": a.enableReady,
			"notify:stateHandler.enteringSpinningState": a.enableReady,
			"notify:stateHandler.enteringStoppingState": a.enableReady
		})
	},
	enable: function(c, a) {
		var b = this;
		b.addProperty("enabled", c);
		b.model.storeData("animate", a === true);
		b.model.storeData("shouldEnable", true);
		b.tryEnable()
	},
	enableReady: function() {
		var a = this;
		a.model.storeData("idleEntered", true);
		a.tryEnable()
	},
	tryEnable: function() {
		var a = this;
		if (a.model.hasProperty("enabled") && a.model.readData("shouldEnable") && a.model.readData("idleEntered")) {
			a.view.enable();
			a.model.storeData("shouldEnable", false)
		}
	}
};
Finn.TickerController = Sys.extend(Interface.TickerController, Finn.TickerController, "Finn.TickerController");
Sys.ns("Finn");
Finn.PluginMenuController = {
	constructor: function() {
		Finn.PluginMenuController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		Finn.PluginMenuController.superclass.setupEvents.apply(this, arguments);
		var b = this,
			a = {
				"notify:stateHandler.enteringFeatureSplashState": b.view.hideButton.bind(b.view),
				"notify:stateHandler.leavingFeatureSplashState": b.view.showButton.bind(b.view)
			};
		b.on(a)
	}
};
Finn.PluginMenuController = Sys.extend(Integration.PluginMenuController, Finn.PluginMenuController, "Finn.PluginMenuController");
Sys.ns("Core");
Core.Vibration = {
	constructor: function(a) {
		Core.Vibration.superclass.constructor.apply(this, arguments)
	},
	getDefaultMVCClasses: function() {
		return {
			model: Core.Model,
			controller: Core.VibrationController
		}
	}
};
Core.Vibration = Sys.extend(Core.Module, Core.Vibration, "Core.Vibration");
Sys.ns("Core");
Core.VibrationController = {
	BASIC_CONFIG: [200],
	constructor: function(a) {
		Core.VibrationController.superclass.constructor.apply(this, arguments)
	},
	setupEvents: function() {
		var a = this;
		a.on({
			"notify:moduleLoader.finishedLoadingModules": a.onAllModulesFinishedLoading,
			"notify:settingsManager.settingChanged": a.onSettingsChanged,
			"request:vibration.vibrate": a.onVibrationRequest,
			"request:vibration.vibrateAbort": a.onVibrationAbort
		})
	},
	onAllModulesFinishedLoading: function() {
		this.setUpVibration()
	},
	setUpVibration: function() {
		if (Platform.isVibrationAPISupported) {
			this.fireEvent("request:soundSettings.enableVibrationSetting");
			this.vibrateFunc = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate
		}
	},
	onSettingsChanged: function(a, b) {
		if (a === "vibration") {
			this.model.storeData("isActive", b)
		}
	},
	onVibrationRequest: function(b) {
		var a;
		if (this.model.readData("isActive")) {
			a = this.getConfig(b);
			this.vibrateFunc.call(navigator, a)
		}
	},
	getConfig: function(a) {
		if (!Sys.isDefined(a) || !Sys.isArray(a) || a.filter(Sys.isNumber).length !== a.length) {
			return this.BASIC_CONFIG
		}
		return a
	},
	onVibrationAbort: function() {
		if (this.model.readData("isActive")) {
			this.vibrateFunc.call(navigator, 0)
		}
	}
};
Core.VibrationController = Sys.extend(Core.Controller, Core.VibrationController, "Core.VibrationController");
Sys.applyProperties(Core.Scaling.prototype, {
	scale: function() {
		var b = this,
			a = Environment.getViewportOrientation(),
			c = b.calculateScale();
		if (Environment.orientation() === "LANDSCAPE" && Environment.os === "ios" && c < 1) {
			setTimeout(function() {
				for (var d = 0; d < 3; d++) {
					b.reScale()
				}
			}, 200)
		}
		Environment.setScale(c);
		b.setDocumentSize();
		b.scaleGame(c);
		b.fireEvent("notify:viewport.scaled");
		b.fireEvent("notify:scaling.updated");
		b.fireEvent("notify:viewport." + a)
	},
	reScale: function() {
		var b = this,
			a = Environment.getViewportOrientation(),
			c = b.calculateScale();
		Environment.setScale(c);
		b.setDocumentSize();
		b.scaleGame(c);
		b.fireEvent("notify:viewport.scaled");
		b.fireEvent("notify:scaling.updated");
		b.fireEvent("notify:viewport." + a)
	}
});
Sys.ns("Integration.OpenBet");
Integration.OpenBet.ResponseParserControllerOverride = {
	doIntegrationSpecificResponseHandling: function(c) {
		var b, a;
		if (!Sys.isDefined(c) || (c.clientaction === "rcinfo" || c.clientaction === "rcreset")) {
			return c
		}
		b = c.credit + c.openbet.freebets;
		a = c.openbet.rgitoken;
		if (!isNaN(b)) {
			c.credit = b
		}
		if (Sys.isDefined(a)) {
			Resources.readData("extraParams")["openbet.rgitoken"] = encodeURIComponent(a)
		}
		return c
	}
};
Integration.OpenBet.ServerManagerModelOverride = {
	doIntegrationSpecificRequestUrlUpdates: function(a) {
		var c = Resources.readData("extraParams"),
			b = a;
		Sys.iterate(c, function(e, d) {
			if (e.match(/openbet\.\w+/)) {
				b += "&" + e + "=" + d
			}
		});
		return b
	}
};
Integration.OpenBet.ErrorManagerControllerOverride = {
	handleIntegrationSpecificErrors: function(b) {
		var c = this,
			d = Sys.utils.getErrorCode(b),
			a = Sys.utils.getResponseParameter("errordata", b);
		if (!Sys.isDefined(d) || d < 997 || d > 1000) {
			return false
		}
		if (Sys.isDefined(a)) {
			a = decodeURIComponent(a);
			a = a.replace(/\+/g, " ")
		}
		return {
			title: "Error (" + d + ")",
			text: a,
			buttons: c.getButtons([{
				type: "casino",
				reason: 3
			}]),
			fatal: true
		}
	}
};
Integration.OpenBet.GameHistoryOverride = function() {
	var a = Game.getHistoryTab;
	Game.getHistoryTab = function(c, d, b) {
		if (b) {
			a(c, d, b)
		}
	}
};
Integration.OpenBet.applyOverrides = function() {
	var a;
	Sys.override(Core.ResponseParserController, Integration.OpenBet.ResponseParserControllerOverride);
	Sys.override(Core.ServerManagerModel, Integration.OpenBet.ServerManagerModelOverride);
	Sys.override(Core.ErrorManagerController, Integration.OpenBet.ErrorManagerControllerOverride);
	a = Integration.OpenBet.GameHistoryOverride;
	a()
};
if (Sys.openBetMode) {
	Integration.OpenBet.applyOverrides()
}
Sys.ns("Integration.GCM");
Integration.GCM.ErrorManagerModel = {
	setupDialogConfig: function() {
		var a = {},
			b;
		Sys.each([11, 13], function(c) {
			b = Services.languageManager.getText(String(c));
			a[c] = {
				category: "RECOVERABLE_ERROR",
				severity: "INFO",
				errorCode: "LIMIT_EXCEEDED",
				message: b,
				extraParameters: {
					originalError: c,
					originalTitle: Services.languageManager.getText(Language.Keys.playLimit),
					originalMessage: b
				},
				revert: true
			}
		});
		b = Services.languageManager.getText(Language.Keys.freeRounds_expired);
		a[12] = {
			category: "RECOVERABLE_ERROR",
			severity: "INFO",
			errorCode: "FREEROUNDS_EXPIRED",
			message: b,
			extraParameters: {
				originalError: 12,
				originalTitle: Services.languageManager.getText(Language.Keys.freeRounds_expired)
			},
			revert: false
		};
		b = Services.languageManager.getText(Language.Keys.returnToLobby);
		a[20] = {
			category: "CONNECTION_ERROR",
			severity: "ERROR",
			errorCode: "SESSION_TIMEOUT",
			message: b,
			extraParameters: {
				originalError: 20,
				originalTitle: Services.languageManager.getText(Language.Keys.btn_sessionTimeOut),
				originalMessage: b,
				reason: 3
			},
			revert: false
		};
		Sys.each([10, 15, 51, 100, 101, 102], function(c) {
			b = Services.languageManager.getText(Language.Keys.deposit);
			a[c] = {
				category: "INSUFFICIENT_FUNDS",
				severity: "INFO",
				errorCode: "CLIENT_INSUFFICIENT_FUNDS",
				message: b,
				extraParameters: {
					originalError: c,
					originalTitle: Services.languageManager.getText(Language.Keys.outOfMoney),
					originalMessage: b,
					reason: 5
				},
				revert: true
			}
		});
		Sys.each([0, 53, 56, 58], function(c) {
			b = Services.languageManager.getText(Language.Keys.gameUnavailable);
			a[c] = {
				category: "CONNECTION_ERROR",
				severity: "ERROR",
				errorCode: "CANNOT_CONNECT_TO_SERVER",
				message: b,
				extraParameters: {
					originalError: c,
					originalTitle: Services.languageManager.getText(Language.Keys.gameUnavailable),
					reason: 9
				},
				revert: false
			}
		});
		b = Services.languageManager.getText(Language.Keys.accountUnavailable);
		a[70] = {
			category: "LOGIN_ERROR",
			severity: "ERROR",
			errorCode: "ACCOUNT_UNAVAILABLE",
			message: b,
			extraParameters: {
				originalError: 70,
				originalTitle: Services.languageManager.getText(Language.Keys.accountUnavailable)
			},
			revert: false
		};
		b = Services.languageManager.getText(Language.Keys.reload);
		a.http = {
			category: "CONNECTION_ERROR",
			severity: "ERROR",
			errorCode: "CANNOT_CONNECT_TO_SERVER",
			message: b,
			extraParameters: {
				originalError: "httpError",
				originalTitle: Services.languageManager.getText(Language.Keys.connectionLost),
				originalMessage: b,
				reason: 9
			},
			revert: false
		};
		b = Services.languageManager.getText(Language.Keys.deposit);
		a.clientOutOfMoney = {
			category: "INSUFFICIENT_FUNDS",
			severity: "INFO",
			errorCode: "CLIENT_INSUFFICIENT_FUNDS",
			message: b,
			extraParameters: {
				originalError: "clientOutOfMoney",
				originalTitle: Services.languageManager.getText(Language.Keys.outOfMoney),
				reason: 9
			},
			revert: false
		};
		b = Services.languageManager.getText(Language.Keys.returnToLobby);
		a.generic = {
			category: "NON_RECOVERABLE_ERROR",
			severity: "ERROR",
			errorCode: "CLIENTERROR",
			message: b,
			extraParameters: {
				originalError: "generic",
				originalTitle: Services.languageManager.getText(Language.Keys.error),
				originalMessage: b,
				reason: 9
			},
			revert: false
		};
		return a
	}
};
Integration.GCM.ErrorManagerDesktopModel = {
	setupDialogConfig: function() {
		return Core.ErrorManagerDesktopModel.superclass.setupDialogConfig.apply(this, arguments)
	}
};
Integration.GCM.ErrorManagerController = {
	showDialog: function(a) {
		var b = (a.errorCode === "http") ? 0 : a.errorCode;
		this.fireEvent("notify:errorManager.error", b, Services.languageManager.getText(b));
		this.fireEvent("request:gcmProxy.handleError", a)
	},
	handleIntegrationSpecificErrors: function(b) {
		var a = Sys.utils.getResponseParameter("openbet.error.xml", b),
			c;
		if (Sys.isDefined(a)) {
			c = {
				RGIError: true,
				RGIXML: a.replace(/\+/g, " ")
			}
		}
		return c
	},
	getDialogConfig: function(a) {
		return this.model.getDialogConfig(a)
	},
	handleClientOutOfMoneyError: function() {
		this.showDialogForErrorCode("clientOutOfMoney")
	}
};
Integration.GCM.DialogWindowController = {
	onShowDialogRequest: function(b) {
		var c = this,
			e = b.severity === "stopped",
			d = {
				category: "MULTI_CHOICE_DIALOG",
				severity: e ? "ERROR" : "INFO",
				message: Sys.isDefined(b.text) ? b.text : b.title,
				errorCode: "ERROR",
				actions: [],
				revert: false,
				extraParameters: {}
			},
			a = [];
		Sys.each(b.buttons, function(f) {
			a.push(f.text);
			d.actions.push(f.action)
		});
		d.extraParameters.options = a;
		c.fireEvent("request:gcmProxy.handleError", d);
		c.model.storeData("currentDialogConfig", b);
		c.model.setState("showing")
	}
};
Integration.GCM.SlowRequestAnimationController = {
	onShowDialog: function() {}
};
(function() {
	if (Sys.isGcmEnabled) {
		Sys.override(Core.ErrorManagerModel, Integration.GCM.ErrorManagerModel);
		Sys.override(Core.ErrorManagerController, Integration.GCM.ErrorManagerController);
		Sys.override(Core.DialogWindowController, Integration.GCM.DialogWindowController);
		Sys.override(Core.SlowRequestAnimationController, Integration.GCM.SlowRequestAnimationController);
		if (Sys.isDefined(Core.ErrorManagerDesktopModel)) {
			Sys.override(Core.ErrorManagerDesktopModel, Integration.GCM.ErrorManagerDesktopModel)
		}
	}
}());
Sys.ns("Game");
if (Sys.isDefined(window.injectWeinre)) {
	injectWeinre()
}(function() {
	var b = document.createElement("style"),
		e = ["bg", "cn", "cs", "el", "et", "hr", "pl", "ro", "ru"],
		c = document.documentElement.lang;
	if (e.indexOf(c) < 0) {
		b.appendChild(document.createTextNode("            @font-face {\n                font-family: 'FuturaCom-MediumCondensed';\n                src: url('multimedia/fonts/FuturaCom-MediumCondensed.woff');\n            }\n            \n            @font-face {\n                font-family: 'FuturaCom-ExtraBoldCond';\n                src: url('multimedia/fonts/FuturaCom-ExtraBoldCond.woff');\n            }\n            \n            @font-face {\n                font-family: 'riffic-bold';\n                src: url('multimedia/fonts/riffic-bold.woff');\n            }\n            \n            @font-face {\n                font-family: 'riffic-semibold';\n                src: url('multimedia/fonts/riffic-semibold.woff');\n            }\n            \n            @font-face {\n                font-family: 'OpenSans-Regular';\n                src: url('multimedia/fonts/OpenSans-Regular.woff');\n            }\n        "))
	} else {
		b.appendChild(document.createTextNode("            @font-face {\n                font-family: 'FuturaCom-MediumCondensed';\n                src: local('Arial');\n                font-style: normal;\n            }\n            \n            @font-face {\n                font-family: 'FuturaCom-ExtraBoldCond';\n                src: local('Arial');\n                font-weight: bold;\n                font-style: normal;\n            }\n            \n            @font-face {\n                font-family: 'riffic-bold';\n                src: url('Arial');\n                font-weight: bold;\n                font-style: normal;\n            }\n            \n            @font-face {\n                font-family: 'riffic-semibold';\n                src: url('Arial');\n                font-weight: bold;\n                font-style: normal;\n            }\n            \n            @font-face {\n                font-family: 'OpenSans-Regular';\n                src: url('Arial');\n                font-style: normal;\n            }\n        "))
	}
	b.setAttribute("type", "text/css");
	document.head.appendChild(b);
	var d = new Core.StateHandler();
	Game.moduleLoader = new Core.Slots.ModuleLoader({
		stateHandler: d
	});
	var a = new Core.Heart();
	d.initStateHandler();
	if (Sys.isDefined(Integration) && Sys.isDefined(Integration.GCM)) {
		Integration.GCM.availableOptions = ["MUTE", "GAME_PREFERENCES", "PAYTABLE", "ABOUT", "TURBO"]
	}
}());